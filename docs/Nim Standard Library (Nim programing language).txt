Nim Standard Library




Author:
Andreas Rumpf
Version:
2.2.0
Nim's library is divided into pure libraries, impure libraries, and wrappers.
Pure libraries do not depend on any external *.dll or lib*.so binary while impure libraries do. A wrapper is an impure library that is a very low-level interface to a C library.
Read this document for a quick overview of the API design.
Nimble
Nim's standard library only covers the basics, check out https://nimble.directory/ for a list of 3rd party packages.
Pure libraries
Automatic imports
system Basic procs and operators that every program needs. It also provides IO facilities for reading and writing text and binary files. It is imported implicitly by the compiler. Do not import it directly. It relies on compiler magic to work.
Core
atomics Types and operations for atomic operations and lockless algorithms.
bitops Provides a series of low-level methods for bit manipulation.
compilesettings Querying the compiler about diverse configuration settings from code.
cpuinfo Procs to determine the number of CPUs / cores.
effecttraits Access to the inferred .raises effects for Nim's macro system.
endians Helpers that deal with different byte orders.
locks Locks and condition variables for Nim.
macrocache Provides an API for macros to collect compile-time information across modules.
macros Contains the AST API and documentation of Nim for writing macros.
rlocks Reentrant locks for Nim.
typeinfo Provides (unsafe) access to Nim's run-time type information.
typetraits Compile-time reflection procs for working with types.
volatile Code for generating volatile loads and stores, which are useful in embedded and systems programming.
Algorithms
algorithm Some common generic algorithms like sort or binary search.
enumutils Additional functionality for the built-in enum type.
sequtils Operations for the built-in seq type which were inspired by functional programming languages.
setutils Additional functionality for the built-in set type.
Collections
critbits A crit bit tree which is an efficient container for a sorted set of strings, or a sorted mapping of strings.
deques Implementation of a double-ended queue. The underlying implementation uses a seq.
heapqueue Implementation of a binary heap data structure that can be used as a priority queue.
intsets Efficient implementation of a set of ints as a sparse bit set.
lists Nim linked list support. Contains singly and doubly linked lists and circular lists ("rings").
options The option type encapsulates an optional value.
packedsets Efficient implementation of a set of ordinals as a sparse bit set.
ropes A rope data type. Ropes can represent very long strings efficiently; in particular, concatenation is done in O(1) instead of O(n).
sets Nim hash set support.
strtabs The strtabs module implements an efficient hash table that is a mapping from strings to strings. Supports a case-sensitive, case-insensitive and style-insensitive modes.
tables Nim hash table support. Contains tables, ordered tables, and count tables.
String handling
cstrutils Utilities for cstring handling.
editdistance An algorithm to compute the edit distance between two Unicode strings.
encodings Converts between different character encodings. On UNIX, this uses the iconv library, on Windows the Windows API.
formatfloat Formatting floats as strings.
objectdollar A generic $ operator to convert objects to strings.
punycode Implements a representation of Unicode with the limited ASCII character subset.
strbasics Some high performance string operations.
strformat Macro based standard string interpolation/formatting. Inspired by Python's f-strings. Note: if you need templating, consider using Nim Source Code Filters (SCF).
strmisc Uncommon string handling operations that do not fit with the commonly used operations in strutils.
strscans A scanf macro for convenient parsing of mini languages.
strutils Common string handling operations like changing case of a string, splitting a string into substrings, searching for substrings, replacing substrings.
unicode Support for handling the Unicode UTF-8 encoding.
unidecode It provides a single proc that does Unicode to ASCII transliterations. Based on Python's Unidecode module.
widestrs Nim support for C/C++'s wide strings.
wordwrap An algorithm for word-wrapping Unicode strings.
Time handling
monotimes The monotimes module implements monotonic timestamps.
times The times module contains support for working with time.
Generic Operating System Services
appdirs Helpers for determining special directories used by apps.
cmdline System facilities for reading command line parameters.
dirs Directory handling.
distros Basics for OS distribution ("distro") detection and the OS's native package manager. Its primary purpose is to produce output for Nimble packages, but it also contains the widely used Distribution enum that is useful for writing platform-specific code. See packaging for hints on distributing Nim using OS packages.
dynlib Accessing symbols from shared libraries.
envvars Environment variable handling.
exitprocs Adding hooks to program exit.
files File handling.
memfiles Support for memory-mapped files (Posix's mmap) on the different operating systems.
os Basic operating system facilities like retrieving environment variables, reading command line arguments, working with directories, running shell commands, etc.
oserrors OS error reporting.
osproc Module for process communication beyond os.execShellCmd.
paths Path handling.
reservedmem Utilities for reserving portions of the address space of a program without consuming physical memory.
streams A stream interface and two implementations thereof: the FileStream and the StringStream which implement the stream interface for Nim file objects (File) and strings. Other modules may provide other implementations for this standard stream interface.
symlinks Symlink handling.
syncio Various synchronized I/O operations.
terminal A module to control the terminal output (also called console).
tempfiles Some utilities for generating temporary path names and creating temporary files and directories.
Math libraries
complex Complex numbers and relevant mathematical operations.
fenv Floating-point environment. Handling of floating-point rounding and exceptions (overflow, zero-divide, etc.).
lenientops Binary operators for mixed integer/float expressions for convenience.
math Mathematical operations like cosine, square root.
random Fast and tiny random number generator.
rationals Rational numbers and relevant mathematical operations.
stats Statistical analysis.
sysrand Cryptographically secure pseudorandom number generator.
Internet Protocols and Support
async Exports asyncmacro and asyncfutures for native backends, and asyncjs on the JS backend.
asyncdispatch An asynchronous dispatcher for IO operations.
asyncfile An asynchronous file reading and writing using asyncdispatch.
asyncftpclient An asynchronous FTP client using the asyncnet module.
asynchttpserver An asynchronous HTTP server using the asyncnet module.
asyncmacro async and multisync macros for asyncdispatch.
asyncnet Asynchronous sockets based on the asyncdispatch module.
asyncstreams FutureStream - a future that acts as a queue.
cgi Helpers for CGI applications.
cookies Helper procs for parsing and generating cookies.
httpclient A simple HTTP client with support for both synchronous and asynchronous retrieval of web pages.
mimetypes A mimetypes database.
nativesockets A low-level sockets API.
net A high-level sockets API.
selectors A selector API with backends specific to each OS. Supported OS primitives: epoll, kqueue, poll, and select on Windows.
smtp A simple SMTP client with support for both synchronous and asynchronous operation.
socketstreams An implementation of the streams interface for sockets.
uri Functions for working with URIs and URLs.
Threading
isolation The Isolated[T] type for safe construction of isolated subgraphs that can be passed efficiently to different channels and threads.
tasks Basic primitives for creating parallel programs.
threadpool Implements Nim's spawn.
typedthreads Basic Nim thread support.
Parsers
htmlparser HTML document parser that creates a XML tree representation.
json High-performance JSON parser.
lexbase A low-level module that implements an extremely efficient buffering scheme for lexers and parsers. This is used by the diverse parsing modules.
parsecfg The parsecfg module implements a high-performance configuration file parser. The configuration file's syntax is similar to the Windows .ini format, but much more powerful, as it is not a line based parser. String literals, raw string literals, and triple quote string literals are supported as in the Nim programming language.
parsecsv The parsecsv module implements a simple high-performance CSV parser.
parsejson A JSON parser. It is used and exported by the json module, but can also be used in its own right.
parseopt The parseopt module implements a command line option parser.
parsesql The parsesql module implements a simple high-performance SQL parser.
parseutils Helpers for parsing tokens, numbers, identifiers, etc.
parsexml The parsexml module implements a simple high performance XML/HTML parser. The only encoding that is supported is UTF-8. The parser has been designed to be somewhat error-correcting, so that even some "wild HTML" found on the web can be parsed with it.
pegs Procedures and operators for handling PEGs.
Docutils
packages/docutils/highlite Source highlighter for programming or markup languages. Currently, only a few languages are supported, other languages may be added. The interface supports one language nested in another.
packages/docutils/rst A reStructuredText parser. A large subset is implemented. Some features of the markdown wiki syntax are also supported.
packages/docutils/rstast An AST for the reStructuredText parser.
packages/docutils/rstgen A generator of HTML/Latex from reStructuredText.
XML Processing
xmltree A simple XML tree. More efficient and simpler than the DOM. It also contains a macro for XML/HTML code generation.
xmlparser XML document parser that creates a XML tree representation.
Generators
genasts AST generation using captured variables for macros.
htmlgen A simple XML and HTML code generator. Each commonly used HTML tag has a corresponding macro that generates a string with its HTML representation.
Hashing
base64 A Base64 encoder and decoder.
hashes Efficient computations of hash values for diverse Nim types.
md5 The MD5 checksum algorithm.
oids An OID is a global ID that consists of a timestamp, a unique counter, and a random value. This combination should suffice to produce a globally distributed unique ID.
sha1 The SHA-1 checksum algorithm.
Serialization
jsonutils Hookable (de)serialization for arbitrary types using JSON.
marshal Contains procs for serialization and deserialization of arbitrary Nim data structures.
Miscellaneous
assertions Assertion handling.
browsers Procs for opening URLs with the user's default browser.
colors Color handling.
coro Experimental coroutines in Nim.
decls Syntax sugar for some declarations.
enumerate enumerate syntactic sugar based on Nim's macro system.
importutils Utilities related to import and symbol resolution.
logging A simple logger.
segfaults Turns access violations or segfaults into a NilAccessDefect exception.
sugar Nice syntactic sugar based on Nim's macro system.
unittest Implements a Unit testing DSL.
varints Decode variable-length integers that are compatible with SQLite.
with The with macro for easy function chaining.
wrapnils Allows evaluating expressions safely against nil dereferences.
Modules for the JavaScript backend
asyncjs Types and macros for writing asynchronous procedures in JavaScript.
dom Declaration of the Document Object Model for the JS backend.
jsbigints Arbitrary precision integers.
jsconsole Wrapper for the console object.
jscore The wrapper of core JavaScript functions. For most purposes, you should be using the math, json, and times stdlib modules instead of this module.
jsfetch Wrapper for fetch.
jsffi Types and macros for easier interaction with JavaScript.
jsre Regular Expressions for the JavaScript target.
Impure libraries
Regular expressions
re Procedures and operators for handling regular expressions. The current implementation uses PCRE.
nre Many help functions for handling regular expressions. The current implementation uses PCRE.
Database support
db_mysql A higher level MySQL database wrapper. The same interface is implemented for other databases too.
db_odbc A higher level ODBC database wrapper. The same interface is implemented for other databases too.
db_postgres A higher level PostgreSQL database wrapper. The same interface is implemented for other databases too.
db_sqlite A higher level SQLite database wrapper. The same interface is implemented for other databases too.
Generic Operating System Services
rdstdin Code for reading user input from stdin.
Wrappers
The generated HTML for some of these wrappers is so huge that it is not contained in the distribution. You can then find them on the website.
Windows-specific
winlean Wrapper for a small subset of the Win32 API.
registry Windows registry support.
UNIX specific
posix Wrapper for the POSIX standard.
posix_utils Contains helpers for the POSIX standard or specialized for Linux and BSDs.
Regular expressions
pcre Wrapper for the PCRE library.
Database support
mysql Wrapper for the mySQL API.
odbcsql interface to the ODBC driver.
postgres Wrapper for the PostgreSQL API.
sqlite3 Wrapper for the SQLite 3 API.
Network Programming and Internet Protocols
openssl Wrapper for OpenSSL.

Pure libraries

Automatic imports
System


system
Source   Edit  

The compiler depends on the System module to work properly and the System module depends on the compiler. Most of the routines listed here use special compiler magic.

Each module implicitly imports the System module; it must not be listed explicitly. Because of this there cannot be a user-defined module named system.
System module

The System module imports several separate modules, and their documentation is in separate files:

	iterators
	exceptions
	assertions
	dollars
	ctypes

Here is a short overview of the most commonly used functions from the system module. Function names in the tables below are clickable and will take you to the full documentation of the function.

There are many more functions available than the ones listed in this overview. Use the table of contents on the left-hand side and/or Ctrl+F to navigate through this module.
Strings and characters
Proc	Usage
len(s)	Return the length of a string
chr(i)	Convert an int in the range 0..255 to a character
ord(c)	Return int value of a character
a & b	Concatenate two strings
s.add(c)	Add character to the string
$	Convert various types to string

See also:

	strutils module for common string functions
	strformat module for string interpolation and formatting
	unicode module for Unicode UTF-8 handling
	strscans for scanf and scanp macros, which offer easier substring extraction than regular expressions
	strtabs module for efficient hash tables (dictionaries, in some programming languages) mapping from strings to strings

Seqs
Proc	Usage
newSeq	Create a new sequence of a given length
newSeqOfCap	Create a new sequence with zero length and a given capacity
setLen	Set the length of a sequence
len	Return the length of a sequence
@	Turn an array into a sequence
add	Add an item to the sequence
insert	Insert an item at a specific position
delete	Delete an item while preserving the order of elements (O(n) operation)
del	O(1) removal, doesn't preserve the order
pop	Remove and return last item of a sequence
x & y	Concatenate two sequences
x[a .. b]	Slice of a sequence (both ends included)
x[a .. ^b]	Slice of a sequence but b is a reversed index (both ends included)
x[a ..< b]	Slice of a sequence (excluded upper bound)

See also:

	sequtils module for operations on container types (including strings)
	json module for a structure which allows heterogeneous members
	lists module for linked lists

Sets

Built-in bit sets.
Proc	Usage
incl	Include element y in the set x
excl	Exclude element y from the set x
card	Return the cardinality of the set, i.e. the number of elements
a * b	Intersection
a + b	Union
a - b	Difference
contains	Check if an element is in the set
a < b	Check if a is a subset of b

See also:

	setutils module for bit set convenience functions
	sets module for hash sets
	intsets module for efficient int sets

Numbers
Proc	Usage 	Also known as (in other languages)
div	Integer division	//
mod	Integer modulo (remainder)	%
shl	Shift left	<<
shr	Shift right	>>
ashr	Arithmetic shift right    
and	Bitwise and	&
or	Bitwise or	|
xor	Bitwise xor	^
not	Bitwise not (complement)	~
toInt	Convert floating-point number into an int    
toFloat	Convert an integer into a float    

See also:

	math module for mathematical operations like trigonometric functions, logarithms, square and cubic roots, etc.
	complex module for operations on complex numbers
	rationals module for rational numbers

Ordinals

Ordinal type includes integer, bool, character, and enumeration types, as well as their subtypes.
Proc	Usage
succ	Successor of the value
pred	Predecessor of the value
inc	Increment the ordinal
dec	Decrement the ordinal
high	Return the highest possible value
low	Return the lowest possible value
ord	Return int value of an ordinal value
Misc
Proc	Usage
is	Check if two arguments are of the same type
isnot	Negated version of is
!=	Not equals
addr	Take the address of a memory location
T and F	Boolean and
T or F	Boolean or
T xor F	Boolean xor (exclusive or)
not T	Boolean not
a[^x]	Take the element at the reversed index x
a .. b	Binary slice that constructs an interval [a, b]
a ..^ b	Interval [a, b] but b as reversed index
a ..< b	Interval [a, b) (excluded upper bound)
runnableExamples	Create testable documentation

Channel support for threads.

Note: This is part of the system module. Do not import it directly. To activate thread support compile with the --threads:on command line switch.

Note: Channels are designed for the Thread type. They are unstable when used with spawn

Note: The current implementation of message passing does not work with cyclic data structures.

Note: Channels cannot be passed between threads. Use globals or pass them by ptr.
Example

The following is a simple example of two different ways to use channels: blocking and non-blocking.

# Be sure to compile with --threads:on.
# The channels and threads modules are part of system and should not be
# imported.
import std/os

# Channels can either be:
#  - declared at the module level, or
#  - passed to procedures by ptr (raw pointer) -- see note on safety.
#
# For simplicity, in this example a channel is declared at module scope.
# Channels are generic, and they include support for passing objects between
# threads.
# Note that objects passed through channels will be deeply copied.
var chan: Channel[string]

# This proc will be run in another thread using the threads module.
proc firstWorker() =
  chan.send("Hello World!")

# This is another proc to run in a background thread. This proc takes a while
# to send the message since it sleeps for 2 seconds (or 2000 milliseconds).
proc secondWorker() =
  sleep(2000)
  chan.send("Another message")

# Initialize the channel.
chan.open()

# Launch the worker.
var worker1: Thread[void]
createThread(worker1, firstWorker)

# Block until the message arrives, then print it out.
echo chan.recv() # "Hello World!"

# Wait for the thread to exit before moving on to the next example.
worker1.joinThread()

# Launch the other worker.
var worker2: Thread[void]
createThread(worker2, secondWorker)
# This time, use a non-blocking approach with tryRecv.
# Since the main thread is not blocked, it could be used to perform other
# useful work while it waits for data to arrive on the channel.
while true:
  let tried = chan.tryRecv()
  if tried.dataAvailable:
	echo tried.msg # "Another message"
	break
 
  echo "Pretend I'm doing useful work..."
  # For this example, sleep in order not to flood stdout with the above
  # message.
  sleep(400)

# Wait for the second thread to exit before cleaning up the channel.
worker2.joinThread()

# Clean up the channel.
chan.close()

Sample output

The program should output something similar to this, but keep in mind that exact results may vary in the real world:

Hello World!
Pretend I'm doing useful work...
Pretend I'm doing useful work...
Pretend I'm doing useful work...
Pretend I'm doing useful work...
Pretend I'm doing useful work...
Another message

Passing Channels Safely

Note that when passing objects to procedures on another thread by pointer (for example through a thread's argument), objects created using the default allocator will use thread-local, GC-managed memory. Thus it is generally safer to store channel objects in global variables (as in the above example), in which case they will use a process-wide (thread-safe) shared heap.

However, it is possible to manually allocate shared memory for channels using e.g. system.allocShared0 and pass these pointers through thread arguments:

proc worker(channel: ptr Channel[string]) =
  let greeting = channel[].recv()
  echo greeting

proc localChannelExample() =
  # Use allocShared0 to allocate some shared-heap memory and zero it.
  # The usual warnings about dealing with raw pointers apply. Exercise caution.
  var channel = cast[ptr Channel[string]](
	allocShared0(sizeof(Channel[string]))
  )
  channel[].open()
  # Create a thread which will receive the channel as an argument.
  var thread: Thread[ptr Channel[string]]
  createThread(thread, worker, channel)
  channel[].send("Hello from the main thread!")
  # Clean up resources.
  thread.joinThread()
  channel[].close()
  deallocShared(channel)

localChannelExample() # "Hello from the main thread!"

Imports

exceptions, since, ctypes, ctypes, sysatomics, ansi_c, memory, syslocks, threadtypes, assertions, iterators, coro_detection, dollars, typedthreads, miscdollars, stacktraces, countbits_impl, syslocks, sysatomics, sharedlist, digitsutils, syslocks, digitsutils, widestrs, syncio

Types

AllocStats = object

	Source   Edit   

any {.....} = distinct auto

	Deprecated: Deprecated since v1.5; Use auto instead.
	Deprecated; Use auto instead. See https://github.com/nim-lang/RFCs/issues/281 Source   Edit   

array[I; T] {.magic: "Array".}

	Generic type to construct fixed-length arrays. Source   Edit   

auto {.magic: Expr.}

	Meta type for automatic type determination. Source   Edit   

BackwardsIndex = distinct int

	Type that is constructed by ^ for reversed array accesses. (See ^ template) Source   Edit   

bool {.magic: "Bool".} = enum
  false = 0, true = 1

	Built-in boolean type. Source   Edit   

byte = uint8

	This is an alias for uint8, that is an unsigned integer, 8 bits wide. Source   Edit   

CatchableError = object of Exception

	Abstract class for all exceptions that are catchable. Source   Edit   

Channel[TMsg] {.....} = RawChannel

	a channel for thread communication Source   Edit   

char {.magic: Char.}

	Built-in 8 bit character type (unsigned). Source   Edit   

csize {.importc: "size_t", nodecl, ....} = int

	Deprecated: use `csize_t` instead
	This isn't the same as size_t in C. Don't use it. Source   Edit   

cstring {.magic: Cstring.}

	Built-in cstring (compatible string) type. Source   Edit   

Defect = object of Exception

	Abstract base class for all exceptions that Nim's runtime raises but that are strictly uncatchable as they can also be mapped to a quit / trap / exit operation. Source   Edit   

Endianness = enum
  littleEndian, bigEndian

	Type describing the endianness of a processor. Source   Edit   

Exception {.compilerproc, magic: "Exception".} = object of RootObj
  parent*: ref Exception 	## Parent exception (can be used as a stack).
  name*: cstring         	## The exception's name is its Nim identifier.
                         	## This field is filled automatically in the
                         	## `raise` statement.
  msg* {.exportc: "message".}: string ## The exception's message. Not
                                  	## providing an exception message
                                  	## is bad style.
  when defined(js):
	trace*: string
  else:
	trace*: seq[StackTraceEntry]

	Base exception class.

	Each exception has to inherit from Exception. See the full exception hierarchy.
	Source   Edit   

float {.magic: Float.}

	Default floating point type. Source   Edit   

float32 {.magic: Float32.}

	32 bit floating point type. Source   Edit   

float64 {.magic: Float.}

	64 bit floating point type. Source   Edit   

ForeignCell = object
  data*: pointer

	Source   Edit   

ForLoopStmt {.compilerproc.} = object

	A special type that marks a macro as a for-loop macro. See "For Loop Macro". Source   Edit   

GC_Strategy = enum
  gcThroughput,         	## optimize for throughput
  gcResponsiveness,     	## optimize for responsiveness (default)
  gcOptimizeTime,       	## optimize for speed
  gcOptimizeSpace        	## optimize for memory footprint

	The strategy the GC should use for the application. Source   Edit   

HSlice[T; U] = object
  a*: T                  	## The lower bound (inclusive).
  b*: U                  	## The upper bound (inclusive).

	"Heterogeneous" slice type. Source   Edit   

int {.magic: Int.}

	Default integer type; bitwidth depends on architecture, but is always the same as a pointer. Source   Edit   

int8 {.magic: Int8.}

	Signed 8 bit integer type. Source   Edit   

int16 {.magic: Int16.}

	Signed 16 bit integer type. Source   Edit   

int32 {.magic: Int32.}

	Signed 32 bit integer type. Source   Edit   

int64 {.magic: Int64.}

	Signed 64 bit integer type. Source   Edit   

iterable[T] {.magic: IterableType.}

	Represents an expression that yields T Source   Edit   

JsRoot = ref object of RootObj

	Root type of the JavaScript object hierarchy Source   Edit   

lent[T] {.magic: "BuiltinType".}

	Source   Edit   

Natural = range[0 .. high(int)]

	is an int type ranging from zero to the maximum value of an int. This type is often useful for documentation and debugging. Source   Edit   

NimNode {.magic: "PNimrodNode".} = ref NimNodeObj

	Represents a Nim AST node. Macros operate on this type. Source   Edit   

openArray[T] {.magic: "OpenArray".}

	Generic type to construct open arrays. Open arrays are implemented as a pointer to the array data and a length field. Source   Edit   

Ordinal[T] {.magic: Ordinal.}

	Generic ordinal type. Includes integer, bool, character, and enumeration types as well as their subtypes. See also SomeOrdinal. Source   Edit   

owned[T] {.magic: "BuiltinType".}

	type constructor to mark a ref/ptr or a closure as owned. Source   Edit   

PFrame = ptr TFrame

	Represents a runtime frame of the call stack; part of the debugger API. Source   Edit   

pointer {.magic: Pointer.}

	Built-in pointer type, use the addr operator to get a pointer to a variable. Source   Edit   

Positive = range[1 .. high(int)]

	is an int type ranging from one to the maximum value of an int. This type is often useful for documentation and debugging. Source   Edit   

ptr[T] {.magic: Pointer.}

	Built-in generic untraced pointer type. Source   Edit   

range[T] {.magic: "Range".}

	Generic type to construct range types. Source   Edit   

ref[T] {.magic: Pointer.}

	Built-in generic traced pointer type. Source   Edit   

RootEffect {.compilerproc.} = object of RootObj

	Base effect class.

	Each effect should inherit from RootEffect unless you know what you're doing.
	Source   Edit   

RootObj {.compilerproc, inheritable.} = object

	The root of Nim's object hierarchy.

	Objects should inherit from RootObj or one of its descendants. However, objects that have no ancestor are also allowed.
	Source   Edit   

RootRef = ref RootObj

	Reference to RootObj. Source   Edit   

seq[T] {.magic: "Seq".}

	Generic type to construct sequences. Source   Edit   

set[T] {.magic: "Set".}

	Generic type to construct bit sets. Source   Edit   

sink[T] {.magic: "BuiltinType".}

	Source   Edit   

Slice[T] = HSlice[T, T]

	An alias for HSlice[T, T]. Source   Edit   

SomeFloat = float | float32 | float64

	Type class matching all floating point number types. Source   Edit   

SomeInteger = SomeSignedInt | SomeUnsignedInt

	Type class matching all integer types. Source   Edit   

SomeNumber = SomeInteger | SomeFloat

	Type class matching all number types. Source   Edit   

SomeOrdinal = int | int8 | int16 | int32 | int64 | bool | enum | uint | uint8 |
	uint16 |
	uint32 |
	uint64

	Type class matching all ordinal types; however this includes enums with holes. See also Ordinal Source   Edit   

SomeSignedInt = int | int8 | int16 | int32 | int64

	Type class matching all signed integer types. Source   Edit   

SomeUnsignedInt = uint | uint8 | uint16 | uint32 | uint64

	Type class matching all unsigned integer types. Source   Edit   

StackTraceEntry = object
  procname*: cstring     	## Name of the proc that is currently executing.
  line*: int             	## Line number of the proc that is currently executing.
  filename*: cstring     	## Filename of the proc that is currently executing.
  when NimStackTraceMsgs:
	frameMsg*: string ## When a stacktrace is generated in a given frame and
                  	## rendered at a later time, we should ensure the stacktrace
                  	## data isn't invalidated; any pointer into PFrame is
                  	## subject to being invalidated so shouldn't be stored.
  when defined(nimStackTraceOverride):
	programCounter*: uint ## Program counter - will be used to get the rest of the info,
                      	## when `$` is called on this type. We can't use
                      	## "cuintptr_t" in here.
	procnameStr*, filenameStr*: string ## GC-ed alternatives to "procname" and "filename"

	In debug mode exceptions store the stack trace that led to them. A StackTraceEntry is a single entry of the stack trace. Source   Edit   

static[T] {.magic: "Static".}

	Meta type representing all values that can be evaluated at compile-time.

	The type coercion static(x) can be used to force the compile-time evaluation of the given expression x.
	Source   Edit   

string {.magic: String.}

	Built-in string type. Source   Edit   

TaintedString {.....} = string

	Deprecated: Deprecated since 1.5
	Source   Edit   

TFrame {.importc, nodecl, final.} = object
  prev*: PFrame          	## Previous frame; used for chaining the call stack.
  procname*: cstring     	## Name of the proc that is currently executing.
  line*: int             	## Line number of the proc that is currently executing.
  filename*: cstring     	## Filename of the proc that is currently executing.
  len*: int16            	## Length of the inspectable slots.
  calldepth*: int16      	## Used for max call depth checking.
  when NimStackTraceMsgs:
	frameMsgLen*: int    	## end position in frameMsgBuf for this frame.

	The frame itself. Source   Edit   

type[T] {.magic: "Type".}

	Meta type representing the type of all type values.

	The coercion type(x) can be used to obtain the type of the given expression x.
	Source   Edit   

typed {.magic: Stmt.}

	Meta type to denote an expression that is resolved (for templates). Source   Edit   

typedesc {.magic: TypeDesc.}

	Meta type to denote a type description. Source   Edit   

TypeOfMode = enum
  typeOfProc,           	## Prefer the interpretation that means `x` is a proc call.
  typeOfIter             	## Prefer the interpretation that means `x` is an iterator call.

	Possible modes of typeof. Source   Edit   

uint {.magic: UInt.}

	Unsigned default integer type. Source   Edit   

uint8 {.magic: UInt8.}

	Unsigned 8 bit integer type. Source   Edit   

uint16 {.magic: UInt16.}

	Unsigned 16 bit integer type. Source   Edit   

uint32 {.magic: UInt32.}

	Unsigned 32 bit integer type. Source   Edit   

uint64 {.magic: UInt64.}

	Unsigned 64 bit integer type. Source   Edit   

UncheckedArray[T] {.magic: "UncheckedArray".}

	Source   Edit   

untyped {.magic: Expr.}

	Meta type to denote an expression that is not resolved (for templates). Source   Edit   

varargs[T] {.magic: "Varargs".}

	Generic type to construct a varargs type. Source   Edit   

void {.magic: "VoidType".}

	Meta type to denote the absence of any type. Source   Edit   

Vars

errorMessageWriter: (proc (msg: string) {....nimcall.})

	Function that will be called instead of stdmsg.write when printing stacktrace. Unstable API. Source   Edit   

globalRaiseHook: proc (e: ref Exception): bool {.nimcall, ....}

	With this hook you can influence exception handling on a global level. If not nil, every 'raise' statement ends up calling this hook.
	Warning: Ordinary application code should never set this hook! You better know what you do when setting this.

	If globalRaiseHook returns false, the exception is caught and does not propagate further through the call stack.
	Source   Edit   

localRaiseHook {.threadvar.}: proc (e: ref Exception): bool {.nimcall, ....}

	With this hook you can influence exception handling on a thread local level. If not nil, every 'raise' statement ends up calling this hook.
	Warning: Ordinary application code should never set this hook! You better know what you do when setting this.

	If localRaiseHook returns false, the exception is caught and does not propagate further through the call stack.
	Source   Edit   

nimThreadDestructionHandlers {.threadvar.}: seq[
	proc () {.closure, ....}]

	Source   Edit   

onUnhandledException: (proc (errorMsg: string) {.nimcall, ....})

	Set this error handler to override the existing behaviour on an unhandled exception.

	The default is to write a stacktrace to stderr and then call quit(1). Unstable API.
	Source   Edit   

outOfMemHook: proc () {.nimcall, ....}

Set this variable to provide a procedure that should be called in case of an out of memory event. The standard handler writes an error message and terminates the program.

outOfMemHook can be used to raise an exception in case of OOM like so:

var gOutOfMem: ref EOutOfMemory
new(gOutOfMem) # need to be allocated *before* OOM really happened!
gOutOfMem.msg = "out of memory"

proc handleOOM() =
  raise gOutOfMem

system.outOfMemHook = handleOOM

	If the handler does not raise an exception, ordinary control flow continues and the program is terminated.
	Source   Edit   

programResult {.compilerproc, exportc: "nim_program_result".}: int

	deprecated, prefer quit or exitprocs.getProgramResult, exitprocs.setProgramResult. Source   Edit   

unhandledExceptionHook: proc (e: ref Exception) {.nimcall, ....}

	Set this variable to provide a procedure that should be called in case of an unhandle exception event. The standard handler writes an error message and terminates the program, except when using --os:any Source   Edit   

Lets

nimvm {.magic: "Nimvm", compileTime.}: bool = false

	May be used only in when expression. It is true in Nim VM context and false otherwise. Source   Edit   

Consts

appType {.magic: "AppType".}: string = ""

	A string that describes the application type. Possible values: "console", "gui", "lib". Source   Edit   

CompileDate {.magic: "CompileDate".}: string = "0000-00-00"

	The date (in UTC) of compilation as a string of the form YYYY-MM-DD. This works thanks to compiler magic. Source   Edit   

CompileTime {.magic: "CompileTime".}: string = "00:00:00"

	The time (in UTC) of compilation as a string of the form HH:MM:SS. This works thanks to compiler magic. Source   Edit   

cpuEndian {.magic: "CpuEndian".}: Endianness = littleEndian

	The endianness of the target CPU. This is a valuable piece of information for low-level code only. This works thanks to compiler magic. Source   Edit   

hostCPU {.magic: "HostCPU".}: string = ""

	A string that describes the host CPU.

	Possible values: "i386", "alpha", "powerpc", "powerpc64", "powerpc64el", "sparc", "amd64", "mips", "mipsel", "arm", "arm64", "mips64", "mips64el", "riscv32", "riscv64", "loongarch64".
	Source   Edit   

hostOS {.magic: "HostOS".}: string = ""

	A string that describes the host operating system.

	Possible values: "windows", "macosx", "linux", "netbsd", "freebsd", "openbsd", "solaris", "aix", "haiku", "standalone".
	Source   Edit   

Inf = 0x7FF0000000000000'f64

	Contains the IEEE floating point value of positive infinity. Source   Edit   

isMainModule {.magic: "IsMainModule".}: bool = false

	True only when accessed in the main module. This works thanks to compiler magic. It is useful to embed testing code in a module. Source   Edit   

NaN = 0x7FF7FFFFFFFFFFFF'f64

	Contains an IEEE floating point value of Not A Number.

	Note that you cannot compare a floating point value to this value and expect a reasonable result - use the isNaN or classify procedure in the math module for checking for NaN.
	Source   Edit   

NegInf = 0xFFF0000000000000'f64

	Contains the IEEE floating point value of negative infinity. Source   Edit   

NimMajor {.intdefine.}: int = 2

is the major number of Nim's version. Example:

when (NimMajor, NimMinor, NimPatch) >= (1, 3, 1): discard

	Source   Edit   

NimMinor {.intdefine.}: int = 0

	is the minor number of Nim's version. Odd for devel, even for releases. Source   Edit   

NimPatch {.intdefine.}: int = 8

	is the patch number of Nim's version. Odd for devel, even for releases. Source   Edit   

NimVersion: string = "2.0.8"

	is the version of Nim as a string. Source   Edit   

off = false

	Alias for false. Source   Edit   

on = true

	Alias for true. Source   Edit   

QuitFailure = 1

	is the value that should be passed to quit to indicate failure. Source   Edit   

QuitSuccess = 0

	is the value that should be passed to quit to indicate success. Source   Edit   

Procs

proc `%%`(x, y: int): int {.inline, ....}

	Treats x and y as unsigned and compute the modulo of x and y.

	The result is truncated to fit into the result. This implements modulo arithmetic. No overflow errors are possible.
	Source   Edit   

proc `%%`(x, y: int8): int8 {.inline, ....}

	Source   Edit   

proc `%%`(x, y: int16): int16 {.inline, ....}

	Source   Edit   

proc `%%`(x, y: int32): int32 {.inline, ....}

	Source   Edit   

proc `%%`(x, y: int64): int64 {.inline, ....}

	Source   Edit   

proc `&`(x, y: char): string {.magic: "ConStrStr", noSideEffect, ....}

Concatenates characters x and y into a string.

assert('a' & 'b' == "ab")

	Source   Edit   

proc `&`(x, y: string): string {.magic: "ConStrStr", noSideEffect, ....}

Concatenates strings x and y.

assert("ab" & "cd" == "abcd")

	Source   Edit   

proc `&`(x: char; y: string): string {.magic: "ConStrStr", noSideEffect,
                                   	....}

Concatenates x with y.

assert('a' & "bc" == "abc")

	Source   Edit   

proc `&`(x: string; y: char): string {.magic: "ConStrStr", noSideEffect,
                                   	....}

Concatenates x with y.

assert("ab" & 'c' == "abc")

	Source   Edit   

proc `&`[T](x, y: seq[T]): seq[T] {.noSideEffect.}

Concatenates two sequences.

Requires copying of the sequences.

assert(@[1, 2, 3, 4] & @[5, 6] == @[1, 2, 3, 4, 5, 6])

	See also:

    	add(var seq[T], openArray[T])

	Source   Edit   

proc `&`[T](x: seq[T]; y: T): seq[T] {.noSideEffect.}

Appends element y to the end of the sequence.

Requires copying of the sequence.

assert(@[1, 2, 3] & 4 == @[1, 2, 3, 4])

	See also:

    	add(var seq[T], T)

	Source   Edit   

proc `&`[T](x: T; y: seq[T]): seq[T] {.noSideEffect.}

Prepends the element x to the beginning of the sequence.

Requires copying of the sequence.

assert(1 & @[2, 3, 4] == @[1, 2, 3, 4])

	Source   Edit   

proc `&=`(x: var string; y: string) {.magic: "AppendStrStr", noSideEffect,
                                  	....}

Appends in place to a string.

var a = "abc"
a &= "de" # a <- "abcde"

	Source   Edit   

proc `*`(x, y: float): float {.magic: "MulF64", noSideEffect, ....}

	Source   Edit   

proc `*`(x, y: float32): float32 {.magic: "MulF64", noSideEffect, ....}

	Source   Edit   

proc `*`(x, y: int): int {.magic: "MulI", noSideEffect, ....}

	Binary * operator for an integer. Source   Edit   

proc `*`(x, y: int8): int8 {.magic: "MulI", noSideEffect, ....}

	Source   Edit   

proc `*`(x, y: int16): int16 {.magic: "MulI", noSideEffect, ....}

	Source   Edit   

proc `*`(x, y: int32): int32 {.magic: "MulI", noSideEffect, ....}

	Source   Edit   

proc `*`(x, y: int64): int64 {.magic: "MulI", noSideEffect, ....}

	Source   Edit   

proc `*`(x, y: uint): uint {.magic: "MulU", noSideEffect, ....}

	Binary * operator for unsigned integers. Source   Edit   

proc `*`(x, y: uint8): uint8 {.magic: "MulU", noSideEffect, ....}

	Source   Edit   

proc `*`(x, y: uint16): uint16 {.magic: "MulU", noSideEffect, ....}

	Source   Edit   

proc `*`(x, y: uint32): uint32 {.magic: "MulU", noSideEffect, ....}

	Source   Edit   

proc `*`(x, y: uint64): uint64 {.magic: "MulU", noSideEffect, ....}

	Source   Edit   

func `*`[T](x, y: set[T]): set[T] {.magic: "MulSet", ....}

This operator computes the intersection of two sets.

Example:

assert {1, 2, 3} * {2, 3, 4} == {2, 3}

	Source   Edit   

proc `*%`(x, y: int): int {.inline, ....}

	Treats x and y as unsigned and multiplies them.

	The result is truncated to fit into the result. This implements modulo arithmetic. No overflow errors are possible.
	Source   Edit   

proc `*%`(x, y: int8): int8 {.inline, ....}

	Source   Edit   

proc `*%`(x, y: int16): int16 {.inline, ....}

	Source   Edit   

proc `*%`(x, y: int32): int32 {.inline, ....}

	Source   Edit   

proc `*%`(x, y: int64): int64 {.inline, ....}

	Source   Edit   

proc `*=`[T: float | float32 | float64](x: var T; y: T) {.inline, noSideEffect.}

	Multiplies in place a floating point number. Source   Edit   

proc `*=`[T: SomeInteger](x: var T; y: T) {.inline, noSideEffect.}

	Binary *= operator for integers. Source   Edit   

proc `+`(x, y: float): float {.magic: "AddF64", noSideEffect, ....}

	Source   Edit   

proc `+`(x, y: float32): float32 {.magic: "AddF64", noSideEffect, ....}

	Source   Edit   

proc `+`(x, y: int): int {.magic: "AddI", noSideEffect, ....}

	Binary + operator for an integer. Source   Edit   

proc `+`(x, y: int8): int8 {.magic: "AddI", noSideEffect, ....}

	Source   Edit   

proc `+`(x, y: int16): int16 {.magic: "AddI", noSideEffect, ....}

	Source   Edit   

proc `+`(x, y: int32): int32 {.magic: "AddI", noSideEffect, ....}

	Source   Edit   

proc `+`(x, y: int64): int64 {.magic: "AddI", noSideEffect, ....}

	Source   Edit   

proc `+`(x, y: uint): uint {.magic: "AddU", noSideEffect, ....}

	Binary + operator for unsigned integers. Source   Edit   

proc `+`(x, y: uint8): uint8 {.magic: "AddU", noSideEffect, ....}

	Source   Edit   

proc `+`(x, y: uint16): uint16 {.magic: "AddU", noSideEffect, ....}

	Source   Edit   

proc `+`(x, y: uint32): uint32 {.magic: "AddU", noSideEffect, ....}

	Source   Edit   

proc `+`(x, y: uint64): uint64 {.magic: "AddU", noSideEffect, ....}

	Source   Edit   

proc `+`(x: float): float {.magic: "UnaryPlusF64", noSideEffect, ....}

	Source   Edit   

proc `+`(x: float32): float32 {.magic: "UnaryPlusF64", noSideEffect, ....}

	Source   Edit   

proc `+`(x: int): int {.magic: "UnaryPlusI", noSideEffect, ....}

	Unary + operator for an integer. Has no effect. Source   Edit   

proc `+`(x: int8): int8 {.magic: "UnaryPlusI", noSideEffect, ....}

	Source   Edit   

proc `+`(x: int16): int16 {.magic: "UnaryPlusI", noSideEffect, ....}

	Source   Edit   

proc `+`(x: int32): int32 {.magic: "UnaryPlusI", noSideEffect, ....}

	Source   Edit   

proc `+`(x: int64): int64 {.magic: "UnaryPlusI", noSideEffect, ....}

	Source   Edit   

func `+`[T](x, y: set[T]): set[T] {.magic: "PlusSet", ....}

This operator computes the union of two sets.

Example:

assert {1, 2, 3} + {2, 3, 4} == {1, 2, 3, 4}

	Source   Edit   

proc `+%`(x, y: int): int {.inline, ....}

	Treats x and y as unsigned and adds them.

	The result is truncated to fit into the result. This implements modulo arithmetic. No overflow errors are possible.
	Source   Edit   

proc `+%`(x, y: int8): int8 {.inline, ....}

	Source   Edit   

proc `+%`(x, y: int16): int16 {.inline, ....}

	Source   Edit   

proc `+%`(x, y: int32): int32 {.inline, ....}

	Source   Edit   

proc `+%`(x, y: int64): int64 {.inline, ....}

	Source   Edit   

proc `+=`[T: float | float32 | float64](x: var T; y: T) {.inline, noSideEffect.}

	Increments in place a floating point number. Source   Edit   

proc `+=`[T: SomeInteger](x: var T; y: T) {.magic: "Inc", noSideEffect,
	....}

	Increments an integer. Source   Edit   

proc `-`(a, b: AllocStats): AllocStats {.....}

	Source   Edit   

proc `-`(x, y: float): float {.magic: "SubF64", noSideEffect, ....}

	Source   Edit   

proc `-`(x, y: float32): float32 {.magic: "SubF64", noSideEffect, ....}

	Source   Edit   

proc `-`(x, y: int): int {.magic: "SubI", noSideEffect, ....}

	Binary - operator for an integer. Source   Edit   

proc `-`(x, y: int8): int8 {.magic: "SubI", noSideEffect, ....}

	Source   Edit   

proc `-`(x, y: int16): int16 {.magic: "SubI", noSideEffect, ....}

	Source   Edit   

proc `-`(x, y: int32): int32 {.magic: "SubI", noSideEffect, ....}

	Source   Edit   

proc `-`(x, y: int64): int64 {.magic: "SubI", noSideEffect, ....}

	Source   Edit   

proc `-`(x, y: uint): uint {.magic: "SubU", noSideEffect, ....}

	Binary - operator for unsigned integers. Source   Edit   

proc `-`(x, y: uint8): uint8 {.magic: "SubU", noSideEffect, ....}

	Source   Edit   

proc `-`(x, y: uint16): uint16 {.magic: "SubU", noSideEffect, ....}

	Source   Edit   

proc `-`(x, y: uint32): uint32 {.magic: "SubU", noSideEffect, ....}

	Source   Edit   

proc `-`(x, y: uint64): uint64 {.magic: "SubU", noSideEffect, ....}

	Source   Edit   

proc `-`(x: float): float {.magic: "UnaryMinusF64", noSideEffect, ....}

	Source   Edit   

proc `-`(x: float32): float32 {.magic: "UnaryMinusF64", noSideEffect,
                            	....}

	Source   Edit   

proc `-`(x: int): int {.magic: "UnaryMinusI", noSideEffect, ....}

	Unary - operator for an integer. Negates x. Source   Edit   

proc `-`(x: int8): int8 {.magic: "UnaryMinusI", noSideEffect, ....}

	Source   Edit   

proc `-`(x: int16): int16 {.magic: "UnaryMinusI", noSideEffect, ....}

	Source   Edit   

proc `-`(x: int32): int32 {.magic: "UnaryMinusI", noSideEffect, ....}

	Source   Edit   

proc `-`(x: int64): int64 {.magic: "UnaryMinusI64", noSideEffect, ....}

	Source   Edit   

func `-`[T](x, y: set[T]): set[T] {.magic: "MinusSet", ....}

This operator computes the difference of two sets.

Example:

assert {1, 2, 3} - {2, 3, 4} == {1}

	Source   Edit   

proc `-%`(x, y: int): int {.inline, ....}

	Treats x and y as unsigned and subtracts them.

	The result is truncated to fit into the result. This implements modulo arithmetic. No overflow errors are possible.
	Source   Edit   

proc `-%`(x, y: int8): int8 {.inline, ....}

	Source   Edit   

proc `-%`(x, y: int16): int16 {.inline, ....}

	Source   Edit   

proc `-%`(x, y: int32): int32 {.inline, ....}

	Source   Edit   

proc `-%`(x, y: int64): int64 {.inline, ....}

	Source   Edit   

proc `-=`[T: float | float32 | float64](x: var T; y: T) {.inline, noSideEffect.}

	Decrements in place a floating point number. Source   Edit   

proc `-=`[T: SomeInteger](x: var T; y: T) {.magic: "Dec", noSideEffect,
	....}

	Decrements an integer. Source   Edit   

proc `..`[T, U](a: sink T; b: sink U): HSlice[T, U] {.noSideEffect, inline,
	magic: "DotDot", ....}

Binary slice operator that constructs an interval [a, b], both a and b are inclusive.

Slices can also be used in the set constructor and in ordinal case statements, but then they are special-cased by the compiler.

let a = [10, 20, 30, 40, 50]
echo a[2 .. 3] # @[30, 40]

	Source   Edit   

proc `..`[T](b: sink T): HSlice[int, T] {.noSideEffect, inline, magic: "DotDot",
	....}

Deprecated: replace `..b` with `0..b`

Unary slice operator that constructs an interval [default(int), b].

let a = [10, 20, 30, 40, 50]
echo a[.. 2] # @[10, 20, 30]

	Source   Edit   

proc `/`(x, y: float): float {.magic: "DivF64", noSideEffect, ....}

	Source   Edit   

proc `/`(x, y: float32): float32 {.magic: "DivF64", noSideEffect, ....}

	Source   Edit   

proc `/`(x, y: int): float {.inline, noSideEffect, ....}

Division of integers that results in a float.

echo 7 / 5 # => 1.4

	See also:

    	div
    	mod

	Source   Edit   

proc `/%`(x, y: int): int {.inline, ....}

	Treats x and y as unsigned and divides them.

	The result is truncated to fit into the result. This implements modulo arithmetic. No overflow errors are possible.
	Source   Edit   

proc `/%`(x, y: int8): int8 {.inline, ....}

	Source   Edit   

proc `/%`(x, y: int16): int16 {.inline, ....}

	Source   Edit   

proc `/%`(x, y: int32): int32 {.inline, ....}

	Source   Edit   

proc `/%`(x, y: int64): int64 {.inline, ....}

	Source   Edit   

proc `/=`(x: var float64; y: float64) {.inline, noSideEffect, ....}

	Divides in place a floating point number. Source   Edit   

proc `/=`[T: float | float32](x: var T; y: T) {.inline, noSideEffect.}

	Divides in place a floating point number. Source   Edit   

proc `<`(x, y: bool): bool {.magic: "LtB", noSideEffect, ....}

	Source   Edit   

proc `<`(x, y: char): bool {.magic: "LtCh", noSideEffect, ....}

Compares two chars and returns true if x is lexicographically before y (uppercase letters come before lowercase letters).

Example:

let
  a = 'a'
  b = 'b'
  c = 'Z'
assert a < b
assert not (a < a)
assert not (a < c)

	Source   Edit   

proc `<`(x, y: float): bool {.magic: "LtF64", noSideEffect, ....}

	Source   Edit   

proc `<`(x, y: float32): bool {.magic: "LtF64", noSideEffect, ....}

	Source   Edit   

proc `<`(x, y: int): bool {.magic: "LtI", noSideEffect, ....}

	Returns true if x is less than y. Source   Edit   

proc `<`(x, y: int8): bool {.magic: "LtI", noSideEffect, ....}

	Source   Edit   

proc `<`(x, y: int16): bool {.magic: "LtI", noSideEffect, ....}

	Source   Edit   

proc `<`(x, y: int32): bool {.magic: "LtI", noSideEffect, ....}

	Source   Edit   

proc `<`(x, y: int64): bool {.magic: "LtI", noSideEffect, ....}

	Source   Edit   

proc `<`(x, y: pointer): bool {.magic: "LtPtr", noSideEffect, ....}

	Source   Edit   

proc `<`(x, y: string): bool {.magic: "LtStr", noSideEffect, ....}

Compares two strings and returns true if x is lexicographically before y (uppercase letters come before lowercase letters).

Example:

let
  a = "abc"
  b = "abd"
  c = "ZZZ"
assert a < b
assert not (a < a)
assert not (a < c)

	Source   Edit   

proc `<`(x, y: uint): bool {.magic: "LtU", noSideEffect, ....}

	Returns true if x < y. Source   Edit   

proc `<`(x, y: uint8): bool {.magic: "LtU", noSideEffect, ....}

	Source   Edit   

proc `<`(x, y: uint16): bool {.magic: "LtU", noSideEffect, ....}

	Source   Edit   

proc `<`(x, y: uint32): bool {.magic: "LtU", noSideEffect, ....}

	Source   Edit   

proc `<`(x, y: uint64): bool {.magic: "LtU", noSideEffect, ....}

	Source   Edit   

proc `<`[Enum: enum](x, y: Enum): bool {.magic: "LtEnum", noSideEffect,
	....}

	Source   Edit   

proc `<`[T: tuple](x, y: T): bool

	Generic lexicographic < operator for tuples that is lifted from the components of x and y. This implementation uses cmp. Source   Edit   

proc `<`[T](x, y: ptr T): bool {.magic: "LtPtr", noSideEffect, ....}

	Source   Edit   

proc `<`[T](x, y: ref T): bool {.magic: "LtPtr", noSideEffect, ....}

	Source   Edit   

proc `<`[T](x, y: set[T]): bool {.magic: "LtSet", noSideEffect, ....}

Returns true if x is a strict or proper subset of y.

A strict or proper subset x has all of its members in y but y has more elements than y.

Example:

let
  a = {3, 5}
  b = {1, 3, 5, 7}
  c = {2}
assert a < b
assert not (a < a)
assert not (a < c)

	Source   Edit   

proc `<%`(x, y: int): bool {.inline, ....}

	Treats x and y as unsigned and compares them. Returns true if unsigned(x) < unsigned(y). Source   Edit   

proc `<%`(x, y: int8): bool {.inline, ....}

	Source   Edit   

proc `<%`(x, y: int16): bool {.inline, ....}

	Source   Edit   

proc `<%`(x, y: int32): bool {.inline, ....}

	Source   Edit   

proc `<%`(x, y: int64): bool {.inline, ....}

	Source   Edit   

proc `<=`(x, y: bool): bool {.magic: "LeB", noSideEffect, ....}

	Source   Edit   

proc `<=`(x, y: char): bool {.magic: "LeCh", noSideEffect, ....}

Compares two chars and returns true if x is lexicographically before y (uppercase letters come before lowercase letters).

Example:

let
  a = 'a'
  b = 'b'
  c = 'Z'
assert a <= b
assert a <= a
assert not (a <= c)

	Source   Edit   

proc `<=`(x, y: float): bool {.magic: "LeF64", noSideEffect, ....}

	Source   Edit   

proc `<=`(x, y: float32): bool {.magic: "LeF64", noSideEffect, ....}

	Source   Edit   

proc `<=`(x, y: int): bool {.magic: "LeI", noSideEffect, ....}

	Returns true if x is less than or equal to y. Source   Edit   

proc `<=`(x, y: int8): bool {.magic: "LeI", noSideEffect, ....}

	Source   Edit   

proc `<=`(x, y: int16): bool {.magic: "LeI", noSideEffect, ....}

	Source   Edit   

proc `<=`(x, y: int32): bool {.magic: "LeI", noSideEffect, ....}

	Source   Edit   

proc `<=`(x, y: int64): bool {.magic: "LeI", noSideEffect, ....}

	Source   Edit   

proc `<=`(x, y: pointer): bool {.magic: "LePtr", noSideEffect, ....}

	Source   Edit   

proc `<=`(x, y: string): bool {.magic: "LeStr", noSideEffect, ....}

Compares two strings and returns true if x is lexicographically before y (uppercase letters come before lowercase letters).

Example:

let
  a = "abc"
  b = "abd"
  c = "ZZZ"
assert a <= b
assert a <= a
assert not (a <= c)

	Source   Edit   

proc `<=`(x, y: uint): bool {.magic: "LeU", noSideEffect, ....}

	Returns true if x <= y. Source   Edit   

proc `<=`(x, y: uint8): bool {.magic: "LeU", noSideEffect, ....}

	Source   Edit   

proc `<=`(x, y: uint16): bool {.magic: "LeU", noSideEffect, ....}

	Source   Edit   

proc `<=`(x, y: uint32): bool {.magic: "LeU", noSideEffect, ....}

	Source   Edit   

proc `<=`(x, y: uint64): bool {.magic: "LeU", noSideEffect, ....}

	Source   Edit   

proc `<=`[Enum: enum](x, y: Enum): bool {.magic: "LeEnum", noSideEffect,
	....}

	Source   Edit   

proc `<=`[T: tuple](x, y: T): bool

	Generic lexicographic <= operator for tuples that is lifted from the components of x and y. This implementation uses cmp. Source   Edit   

proc `<=`[T](x, y: ref T): bool {.magic: "LePtr", noSideEffect, ....}

	Source   Edit   

proc `<=`[T](x, y: set[T]): bool {.magic: "LeSet", noSideEffect, ....}

Returns true if x is a subset of y.

A subset x has all of its members in y and y doesn't necessarily have more members than x. That is, x can be equal to y.

Example:

let
  a = {3, 5}
  b = {1, 3, 5, 7}
  c = {2}
assert a <= b
assert a <= a
assert not (a <= c)

	Source   Edit   

proc `<=%`(x, y: int): bool {.inline, ....}

	Treats x and y as unsigned and compares them. Returns true if unsigned(x) <= unsigned(y). Source   Edit   

proc `<=%`(x, y: int8): bool {.inline, ....}

	Source   Edit   

proc `<=%`(x, y: int16): bool {.inline, ....}

	Source   Edit   

proc `<=%`(x, y: int32): bool {.inline, ....}

	Source   Edit   

proc `<=%`(x, y: int64): bool {.inline, ....}

	Source   Edit   

proc `=`[T](dest: var T; src: T) {.noSideEffect, magic: "Asgn", ....}

	Source   Edit   

proc `==`(x, y: bool): bool {.magic: "EqB", noSideEffect, ....}

	Checks for equality between two bool variables. Source   Edit   

proc `==`(x, y: char): bool {.magic: "EqCh", noSideEffect, ....}

	Checks for equality between two char variables. Source   Edit   

proc `==`(x, y: cstring): bool {.magic: "EqCString", noSideEffect, inline,
                             	....}

	Checks for equality between two cstring variables. Source   Edit   

proc `==`(x, y: float): bool {.magic: "EqF64", noSideEffect, ....}

	Source   Edit   

proc `==`(x, y: float32): bool {.magic: "EqF64", noSideEffect, ....}

	Source   Edit   

proc `==`(x, y: int): bool {.magic: "EqI", noSideEffect, ....}

	Compares two integers for equality. Source   Edit   

proc `==`(x, y: int8): bool {.magic: "EqI", noSideEffect, ....}

	Source   Edit   

proc `==`(x, y: int16): bool {.magic: "EqI", noSideEffect, ....}

	Source   Edit   

proc `==`(x, y: int32): bool {.magic: "EqI", noSideEffect, ....}

	Source   Edit   

proc `==`(x, y: int64): bool {.magic: "EqI", noSideEffect, ....}

	Source   Edit   

proc `==`(x, y: pointer): bool {.magic: "EqRef", noSideEffect, ....}

Checks for equality between two pointer variables.

Example:

var # this is a wildly dangerous example
  a = cast[pointer](0)
  b = cast[pointer](nil)
assert a == b # true due to the special meaning of `nil`/0 as a pointer

	Source   Edit   

proc `==`(x, y: string): bool {.magic: "EqStr", noSideEffect, ....}

	Checks for equality between two string variables. Source   Edit   

proc `==`(x, y: uint): bool {.magic: "EqI", noSideEffect, ....}

	Compares two unsigned integers for equality. Source   Edit   

proc `==`(x, y: uint8): bool {.magic: "EqI", noSideEffect, ....}

	Source   Edit   

proc `==`(x, y: uint16): bool {.magic: "EqI", noSideEffect, ....}

	Source   Edit   

proc `==`(x, y: uint32): bool {.magic: "EqI", noSideEffect, ....}

	Source   Edit   

proc `==`(x, y: uint64): bool {.magic: "EqI", noSideEffect, ....}

	Source   Edit   

proc `==`[Enum: enum](x, y: Enum): bool {.magic: "EqEnum", noSideEffect,
	....}

Checks whether values within the same enum have the same underlying value.

Example:

type
  Enum1 = enum
	field1 = 3, field2
  Enum2 = enum
	place1, place2 = 3
var
  e1 = field1
  e2 = place2.ord.Enum1
assert e1 == e2
assert not compiles(e1 == place2) # raises error

	Source   Edit   

proc `==`[I, T](x, y: array[I, T]): bool

	Source   Edit   

proc `==`[T: proc | iterator](x, y: T): bool {.magic: "EqProc", noSideEffect,
	....}

	Checks that two proc variables refer to the same procedure. Source   Edit   

proc `==`[T: tuple | object](x, y: T): bool

	Generic == operator for tuples that is lifted from the components. of x and y. Source   Edit   

proc `==`[T](x, y: openArray[T]): bool

	Source   Edit   

proc `==`[T](x, y: ptr T): bool {.magic: "EqRef", noSideEffect, ....}

	Checks that two ptr variables refer to the same item. Source   Edit   

proc `==`[T](x, y: ref T): bool {.magic: "EqRef", noSideEffect, ....}

	Checks that two ref variables refer to the same item. Source   Edit   

proc `==`[T](x, y: seq[T]): bool {.noSideEffect.}

	Generic equals operator for sequences: relies on a equals operator for the element type T. Source   Edit   

proc `==`[T](x, y: set[T]): bool {.magic: "EqSet", noSideEffect, ....}

Checks for equality between two variables of type set.

Example:

assert {1, 2, 2, 3} == {1, 2, 3} # duplication in sets is ignored

	Source   Edit   

proc `=copy`[T](dest: var T; src: T) {.noSideEffect, magic: "Asgn", ....}

	Source   Edit   

proc `=destroy`[T](x: var T) {.inline, magic: "Destroy", ....}

	Generic destructor implementation that can be overridden. Source   Edit   

proc `=dup`[T](x: T): T {.inline, magic: "Dup", ....}

	Generic dup implementation that can be overridden. Source   Edit   

proc `=sink`[T](x: var T; y: T) {.inline, nodestroy, magic: "Asgn", ....}

	Generic sink implementation that can be overridden. Source   Edit   

proc `=trace`[T](x: var T; env: pointer) {.inline, magic: "Trace", ....}

	Generic trace implementation that can be overridden. Source   Edit   

proc `=wasMoved`[T](obj: var T) {.magic: "WasMoved", noSideEffect, ....}

	Generic wasMoved implementation that can be overridden. Source   Edit   

proc `@`[IDX, T](a: sink array[IDX, T]): seq[T] {.magic: "ArrToSeq",
	noSideEffect, ....}

Turns an array into a sequence.

This most often useful for constructing sequences with the array constructor: @[1, 2, 3] has the type seq[int], while [1, 2, 3] has the type array[0..2, int].

let
  a = [1, 3, 5]
  b = "foo"

echo @a # => @[1, 3, 5]
echo @b # => @['f', 'o', 'o']

	Source   Edit   

proc `@`[T](a: openArray[T]): seq[T] {.magic: "OpenArrayToSeq", ....}

	Turns an openArray into a sequence.

	This is not as efficient as turning a fixed length array into a sequence as it always copies every element of a.
	Source   Edit   

proc `[]`(s: string; i: BackwardsIndex): char {.inline, systemRaisesDefect,
	....}

	Source   Edit   

proc `[]`(s: var string; i: BackwardsIndex): var char {.inline,
	systemRaisesDefect, ....}

	Source   Edit   

proc `[]`[I: Ordinal; T](a: T; i: I): T {.noSideEffect, magic: "ArrGet",
	....}

	Source   Edit   

proc `[]`[Idx, T; U, V: Ordinal](a: array[Idx, T]; x: HSlice[U, V]): seq[T] {.
	systemRaisesDefect.}

Slice operation for arrays. Returns the inclusive range [a[x.a], a[x.b]]:

var a = [1, 2, 3, 4]
assert a[0..2] == @[1, 2, 3]

	Source   Edit   

proc `[]`[Idx, T](a: array[Idx, T]; i: BackwardsIndex): T {.inline,
	systemRaisesDefect.}

	Source   Edit   

proc `[]`[Idx, T](a: var array[Idx, T]; i: BackwardsIndex): var T {.inline,
	systemRaisesDefect.}

	Source   Edit   

proc `[]`[T, U: Ordinal](s: string; x: HSlice[T, U]): string {.inline,
	systemRaisesDefect.}

Slice operation for strings. Returns the inclusive range [s[x.a], s[x.b]]:

var s = "abcdef"
assert s[1..3] == "bcd"

	Source   Edit   

proc `[]`[T; U, V: Ordinal](s: openArray[T]; x: HSlice[U, V]): seq[T] {.
	systemRaisesDefect.}

Slice operation for sequences. Returns the inclusive range [s[x.a], s[x.b]]:

var s = @[1, 2, 3, 4]
assert s[0..2] == @[1, 2, 3]

	Source   Edit   

proc `[]`[T](s: openArray[T]; i: BackwardsIndex): T {.inline, systemRaisesDefect.}

	Source   Edit   

proc `[]`[T](s: var openArray[T]; i: BackwardsIndex): var T {.inline,
	systemRaisesDefect.}

	Source   Edit   

proc `[]=`(s: var string; i: BackwardsIndex; x: char) {.inline,
	systemRaisesDefect, ....}

	Source   Edit   

proc `[]=`[I: Ordinal; T, S](a: T; i: I; x: sink S) {.noSideEffect,
	magic: "ArrPut", ....}

	Source   Edit   

proc `[]=`[Idx, T; U, V: Ordinal](a: var array[Idx, T]; x: HSlice[U, V];
                              	b: openArray[T]) {.systemRaisesDefect.}

Slice assignment for arrays.

var a = [10, 20, 30, 40, 50]
a[1..2] = @[99, 88]
assert a == [10, 99, 88, 40, 50]

	Source   Edit   

proc `[]=`[Idx, T](a: var array[Idx, T]; i: BackwardsIndex; x: T) {.inline,
	systemRaisesDefect.}

	Source   Edit   

proc `[]=`[T, U: Ordinal](s: var string; x: HSlice[T, U]; b: string) {.
	systemRaisesDefect.}

Slice assignment for strings.

If b.len is not exactly the number of elements that are referred to by x, a splice is performed:

Example:

var s = "abcdefgh"
s[1 .. ^2] = "xyz"
assert s == "axyzh"

	Source   Edit   

proc `[]=`[T; U, V: Ordinal](s: var seq[T]; x: HSlice[U, V]; b: openArray[T]) {.
	systemRaisesDefect.}

Slice assignment for sequences.

If b.len is not exactly the number of elements that are referred to by x, a splice is performed.

Example:

var s = @"abcdefgh"
s[1 .. ^2] = @"xyz"
assert s == @"axyzh"

	Source   Edit   

proc `[]=`[T](s: var openArray[T]; i: BackwardsIndex; x: T) {.inline,
	systemRaisesDefect.}

	Source   Edit   

func abs(x: int): int {.magic: "AbsI", inline, ....}

	Source   Edit   

func abs(x: int8): int8 {.magic: "AbsI", inline, ....}

	Source   Edit   

func abs(x: int16): int16 {.magic: "AbsI", inline, ....}

	Source   Edit   

func abs(x: int32): int32 {.magic: "AbsI", inline, ....}

	Source   Edit   

func abs(x: int64): int64 {.magic: "AbsI", inline, ....}

	Returns the absolute value of x.

	If x is low(x) (that is -MININT for its type), an overflow exception is thrown (if overflow checking is turned on).
	Source   Edit   

proc abs[T: float64 | float32](x: T): T {.noSideEffect, inline.}

	Source   Edit   

proc add(x: var cstring; y: cstring) {.magic: "AppendStrStr", ....}

Appends y to x in place. Only implemented for JS backend.

Example:

when defined(js):
  var tmp: cstring = ""
  tmp.add(cstring("ab"))
  tmp.add(cstring("cd"))
  doAssert tmp == cstring("abcd")

	Source   Edit   

proc add(x: var string; y: char) {.magic: "AppendStrCh", noSideEffect,
                               	....}

Appends y to x in place.

var tmp = ""
tmp.add('a')
tmp.add('b')
assert(tmp == "ab")

	Source   Edit   

proc add(x: var string; y: cstring) {.asmNoStackFrame, ....}

Appends y to x in place.

Example:

var tmp = ""
tmp.add(cstring("ab"))
tmp.add(cstring("cd"))
doAssert tmp == "abcd"

	Source   Edit   

proc add(x: var string; y: string) {.magic: "AppendStrStr", noSideEffect,
                                 	....}

Concatenates x and y in place.

See also strbasics.add.

Example:

var tmp = ""
tmp.add("ab")
tmp.add("cd")
assert tmp == "abcd"

	Source   Edit   

proc add[T](x: var seq[T]; y: openArray[T]) {.noSideEffect.}

Generic proc for adding a container y to a container x.

For containers that have an order, add means append. New generic containers should also call their adding proc add for consistency. Generic code becomes much easier to write if the Nim naming scheme is respected.

See also:

	& proc

Example:

var a = @["a1", "a2"]
a.add(["b1", "b2"])
assert a == @["a1", "a2", "b1", "b2"]
var c = @["c0", "c1", "c2", "c3"]
a.add(c.toOpenArray(1, 2))
assert a == @["a1", "a2", "b1", "b2", "c1", "c2"]

	Source   Edit   

proc add[T](x: var seq[T]; y: sink T) {.magic: "AppendSeqElem", noSideEffect,
                                    	....}

Generic proc for adding a data item y to a container x.

For containers that have an order, add means append. New generic containers should also call their adding proc add for consistency. Generic code becomes much easier to write if the Nim naming scheme is respected.

var s: seq[string] = @["test2","test2"]
s.add("test")
assert s == @["test2", "test2", "test"]

	Source   Edit   

proc addEscapedChar(s: var string; c: char) {.noSideEffect, inline, ....}

	Adds a char to string s and applies the following escaping:

    	replaces any \ by \\
    	replaces any ' by \'
    	replaces any " by \"
    	replaces any \a by \\a
    	replaces any \b by \\b
    	replaces any \t by \\t
    	replaces any \n by \\n
    	replaces any \v by \\v
    	replaces any \f by \\f
    	replaces any \r by \\r
    	replaces any \e by \\e
    	replaces any other character not in the set {\21..\126} by \xHH where HH is its hexadecimal value

	The procedure has been designed so that its output is usable for many different common syntaxes.
	Warning: This is not correct for producing ANSI C code!
	Source   Edit   

proc addQuitProc(quitProc: proc () {.noconv.}) {.importc: "atexit",
	header: "<stdlib.h>", ....}

	Deprecated: use exitprocs.addExitProc

	Adds/registers a quit procedure.

	Each call to addQuitProc registers another quit procedure. Up to 30 procedures can be registered. They are executed on a last-in, first-out basis (that is, the last function registered is the first to be executed). addQuitProc raises an EOutOfIndex exception if quitProc cannot be registered.
	Source   Edit   

proc addQuoted[T](s: var string; x: T)

Appends x to string s in place, applying quoting and escaping if x is a string or char.

See addEscapedChar for the escaping scheme. When x is a string, characters in the range {\128..\255} are never escaped so that multibyte UTF-8 characters are untouched (note that this behavior is different from addEscapedChar).

The Nim standard library uses this function on the elements of collections when producing a string representation of a collection. It is recommended to use this function as well for user-side collections. Users may overload addQuoted for custom (string-like) types if they want to implement a customized element representation.

var tmp = ""
tmp.addQuoted(1)
tmp.add(", ")
tmp.addQuoted("string")
tmp.add(", ")
tmp.addQuoted('c')
assert(tmp == """1, "string", 'c'""")

	Source   Edit   

proc `addr`[T](x: T): ptr T {.magic: "Addr", noSideEffect, ....}

Builtin addr operator for taking the address of a memory location.
Note: This works for let variables or parameters for better interop with C. When you use it to write a wrapper for a C library and take the address of let variables or parameters, you should always check that the original library does never write to data behind the pointer that is returned from this procedure.

Cannot be overloaded.

var
  buf: seq[char] = @['a','b','c']
  p = buf[1].addr
echo p.repr # ref 0x7faa35c40059 --> 'b'
echo p[]	# b

	Source   Edit   

proc alignof(x: typedesc): int {.magic: "AlignOf", noSideEffect, ....}

	Source   Edit   

proc alignof[T](x: T): int {.magic: "AlignOf", noSideEffect, ....}

	Source   Edit   

proc alloc0Impl(size: Natural): pointer {.noconv, ....}

	Source   Edit   

proc allocCStringArray(a: openArray[string]): cstringArray {.....}

	Creates a NULL terminated cstringArray from a. The result has to be freed with deallocCStringArray after it's not needed anymore. Source   Edit   

proc allocImpl(size: Natural): pointer {.noconv, ....}

	Source   Edit   

proc allocShared0Impl(size: Natural): pointer {.noconv, ....}

	Source   Edit   

proc allocSharedImpl(size: Natural): pointer {.noconv, compilerproc, ....}

	Source   Edit   

proc `and`(a, b: typedesc): typedesc {.magic: "TypeTrait", noSideEffect,
                                   	....}

	Constructs an and meta class. Source   Edit   

proc `and`(x, y: bool): bool {.magic: "And", noSideEffect, ....}

	Boolean and; returns true if x == y == true (if both arguments are true).

	Evaluation is lazy: if x is false, y will not even be evaluated.
	Source   Edit   

proc `and`(x, y: int): int {.magic: "BitandI", noSideEffect, ....}

Computes the bitwise and of numbers x and y.

Example:

assert (0b0011 and 0b0101) == 0b0001
assert (0b0111 and 0b1100) == 0b0100

	Source   Edit   

proc `and`(x, y: int8): int8 {.magic: "BitandI", noSideEffect, ....}

	Source   Edit   

proc `and`(x, y: int16): int16 {.magic: "BitandI", noSideEffect, ....}

	Source   Edit   

proc `and`(x, y: int32): int32 {.magic: "BitandI", noSideEffect, ....}

	Source   Edit   

proc `and`(x, y: int64): int64 {.magic: "BitandI", noSideEffect, ....}

	Source   Edit   

proc `and`(x, y: uint): uint {.magic: "BitandI", noSideEffect, ....}

	Computes the bitwise and of numbers x and y. Source   Edit   

proc `and`(x, y: uint8): uint8 {.magic: "BitandI", noSideEffect, ....}

	Source   Edit   

proc `and`(x, y: uint16): uint16 {.magic: "BitandI", noSideEffect, ....}

	Source   Edit   

proc `and`(x, y: uint32): uint32 {.magic: "BitandI", noSideEffect, ....}

	Source   Edit   

proc `and`(x, y: uint64): uint64 {.magic: "BitandI", noSideEffect, ....}

	Source   Edit   

proc arrayWith[T](y: T; size: static int): array[size, T] {.....}

	Creates a new array filled with y. Source   Edit   

proc ashr(x: int8; y: SomeInteger): int8 {.magic: "AshrI", noSideEffect,
	....}

	Source   Edit   

proc ashr(x: int16; y: SomeInteger): int16 {.magic: "AshrI", noSideEffect,
	....}

	Source   Edit   

proc ashr(x: int32; y: SomeInteger): int32 {.magic: "AshrI", noSideEffect,
	....}

	Source   Edit   

proc ashr(x: int64; y: SomeInteger): int64 {.magic: "AshrI", noSideEffect,
	....}

	Source   Edit   

proc ashr(x: int; y: SomeInteger): int {.magic: "AshrI", noSideEffect,
	....}

Shifts right by pushing copies of the leftmost bit in from the left, and let the rightmost bits fall off.

Note that ashr is not an operator so use the normal function call syntax for it.

See also:

	shr func

Example:

assert ashr(0b0001_0000'i8, 2) == 0b0000_0100'i8
assert ashr(0b1000_0000'i8, 8) == 0b1111_1111'i8
assert ashr(0b1000_0000'i8, 1) == 0b1100_0000'i8

	Source   Edit   

proc astToStr[T](x: T): string {.magic: "AstToStr", noSideEffect, ....}

	Converts the AST of x into a string representation. This is very useful for debugging. Source   Edit   

func capacity(self: string): int {.inline, ....}

Returns the current capacity of the string.

Example:

var str = newStringOfCap(cap = 42)
str.add "Nim"
assert str.capacity == 42

	Source   Edit   

func capacity[T](self: seq[T]): int {.inline.}

Returns the current capacity of the seq.

Example:

var lst = newSeqOfCap[string](cap = 42)
lst.add "Nim"
assert lst.capacity == 42

	Source   Edit   

func card[T](x: set[T]): int {.magic: "Card", ....}

Returns the cardinality of the set x, i.e. the number of elements in the set.

Example:

var a = {1, 3, 5, 7}
assert card(a) == 4
var b = {1, 3, 5, 7, 5}
assert card(b) == 4 # repeated 5 doesn't count

	Source   Edit   

func chr(u: range[0 .. 255]): char {.magic: "Chr", ....}

Converts u to a char, same as char(u).

Example:

doAssert chr(65) == 'A'
doAssert chr(255) == '\255'
doAssert chr(255) == char(255)
doAssert not compiles chr(256)
doAssert not compiles char(256)
var x = 256
doAssertRaises(RangeDefect): discard chr(x)
doAssertRaises(RangeDefect): discard char(x)

	Source   Edit   

proc clamp[T](x, a, b: T): T

Limits the value x within the interval [a, b]. This proc is equivalent to but faster than max(a, min(b, x)).
Warning: a <= b is assumed and will not be checked (currently).

See also: math.clamp for a version that takes a Slice[T] instead.

Example:

assert (1.4).clamp(0.0, 1.0) == 1.0
assert (0.5).clamp(0.0, 1.0) == 0.5
assert 4.clamp(1, 3) == max(1, min(3, 4))

	Source   Edit   

proc close[TMsg](c: var Channel[TMsg])

	Closes a channel c and frees its associated resources. Source   Edit   

proc cmp(x, y: string): int {.noSideEffect, ....}

	Compare proc for strings. More efficient than the generic version.

	Note: The precise result values depend on the used C runtime library and can differ between operating systems!
	Source   Edit   

proc cmp[T](x, y: T): int

Generic compare proc.

Returns:

	a value less than zero, if x < y
	a value greater than zero, if x > y
	zero, if x == y

This is useful for writing generic algorithms without performance loss. This generic implementation uses the == and < operators.

import std/algorithm
echo sorted(@[4, 2, 6, 5, 8, 7], cmp[int])

	Source   Edit   

proc cmpMem(a, b: pointer; size: Natural): int {.inline, noSideEffect, ....}

	Compares the memory blocks a and b. size bytes will be compared.

	Returns:

    	a value less than zero, if a < b
    	a value greater than zero, if a > b
    	zero, if a == b

	Like any procedure dealing with raw memory this is unsafe.
	Source   Edit   

proc compileOption(option, arg: string): bool {.magic: "CompileOptionArg",
	noSideEffect, ....}

Can be used to determine an enum compile-time option.

See also:

	compileOption for on|off options
	defined
	std/compilesettings module

Example:

when compileOption("opt", "size") and compileOption("gc", "boehm"):
  discard "compiled with optimization for size and uses Boehm's GC"

	Source   Edit   

proc compileOption(option: string): bool {.magic: "CompileOption", noSideEffect,
	....}

Can be used to determine an on|off compile-time option.

See also:

	compileOption for enum options
	defined
	std/compilesettings module

Example: cmd: --floatChecks:off

static: doAssert not compileOption("floatchecks")
{.push floatChecks: on.}
static: doAssert compileOption("floatchecks")
# floating point NaN and Inf checks enabled in this scope
{.pop.}

	Source   Edit   

proc compiles(x: untyped): bool {.magic: "Compiles", noSideEffect, compileTime,
                              	....}

Special compile-time procedure that checks whether x can be compiled without any semantic error. This can be used to check whether a type supports some operation:

when compiles(3 + 4):
  echo "'+' for integers is available"

	Source   Edit   

proc contains[T](a: openArray[T]; item: T): bool {.inline.}

Returns true if item is in a or false if not found. This is a shortcut for find(a, item) >= 0.

This allows the in operator: a.contains(item) is the same as item in a.

var a = @[1, 3, 5]
assert a.contains(5)
assert 3 in a
assert 99 notin a

	Source   Edit   

func contains[T](x: set[T]; y: T): bool {.magic: "InSet", ....}

One should overload this proc if one wants to overload the in operator.

The parameters are in reverse order! a in b is a template for contains(b, a). This is because the unification algorithm that Nim uses for overload resolution works from left to right. But for the in operator that would be the wrong direction for this piece of code:

Example:

var s: set[range['a'..'z']] = {'a'..'c'}
assert s.contains('c')
assert 'b' in s
assert 'd' notin s
assert set['a'..'z'] is set[range['a'..'z']]

	If in had been declared as [T](elem: T, s: set[T]) then T would have been bound to char. But s is not compatible to type set[char]! The solution is to bind T to range['a'..'z']. This is achieved by reversing the parameters for contains; in then passes its arguments in reverse order. Source   Edit   

proc contains[U, V, W](s: HSlice[U, V]; value: W): bool {.noSideEffect, inline.}

Checks if value is within the range of s; returns true if value >= s.a and value <= s.b.

assert((1..3).contains(1) == true)
assert((1..3).contains(2) == true)
assert((1..3).contains(4) == false)

	Source   Edit   

proc copyMem(dest, source: pointer; size: Natural) {.inline, ....}

	Copies the contents from the memory at source to the memory at dest. Exactly size bytes will be copied. The memory regions may not overlap. Like any procedure dealing with raw memory this is unsafe. Source   Edit   

proc create(T: typedesc; size = 1.Positive): ptr T:type {.inline, ....}

	Allocates a new memory block with at least T.sizeof * size bytes.

	The block has to be freed with resize(block, 0) or dealloc(block). The block is initialized with all bytes containing zero, so it is somewhat safer than createU.

	The allocated memory belongs to its allocating thread! Use createShared to allocate from a shared heap.
	Source   Edit   

proc createShared(T: typedesc; size = 1.Positive): ptr T:type {.inline.}

	Allocates a new memory block on the shared heap with at least T.sizeof * size bytes.

	The block has to be freed with resizeShared(block, 0) or freeShared(block).

	The block is initialized with all bytes containing zero, so it is somewhat safer than createSharedU.
	Source   Edit   

proc createSharedU(T: typedesc; size = 1.Positive): ptr T:type {.inline,
	....}

	Allocates a new memory block on the shared heap with at least T.sizeof * size bytes.

	The block has to be freed with resizeShared(block, 0) or freeShared(block).

	The block is not initialized, so reading from it before writing to it is undefined behaviour!

	See also:

    	createShared

	Source   Edit   

proc createU(T: typedesc; size = 1.Positive): ptr T:type {.inline, ....}

	Allocates a new memory block with at least T.sizeof * size bytes.

	The block has to be freed with resize(block, 0) or dealloc(block). The block is not initialized, so reading from it before writing to it is undefined behaviour!

	The allocated memory belongs to its allocating thread! Use createSharedU to allocate from a shared heap.

	See also:

    	create

	Source   Edit   

proc cstringArrayToSeq(a: cstringArray): seq[string] {.....}

	Converts a cstringArray to a seq[string]. a is supposed to be terminated by nil. Source   Edit   

proc cstringArrayToSeq(a: cstringArray; len: Natural): seq[string] {.....}

	Converts a cstringArray to a seq[string]. a is supposed to be of length len. Source   Edit   

proc dealloc(p: pointer) {.noconv, compilerproc, ....}

	Frees the memory allocated with alloc, alloc0, realloc, create or createU.

	This procedure is dangerous! If one forgets to free the memory a leak occurs; if one tries to access freed memory (or just freeing it twice!) a core dump may happen or other memory may be corrupted.

	The freed memory must belong to its allocating thread! Use deallocShared to deallocate from a shared heap.
	Source   Edit   

proc deallocCStringArray(a: cstringArray) {.....}

	Frees a NULL terminated cstringArray. Source   Edit   

proc deallocHeap(runFinalizers = true; allowGcAfterwards = true) {.....}

	Frees the thread local heap. Runs every finalizer if runFinalizers is true. If allowGcAfterwards is true, a minimal amount of allocation happens to ensure the GC can continue to work after the call to deallocHeap. Source   Edit   

proc deallocImpl(p: pointer) {.noconv, ....}

	Source   Edit   

proc deallocShared(p: pointer) {.noconv, compilerproc, ....}

	Frees the memory allocated with allocShared, allocShared0 or reallocShared.

	This procedure is dangerous! If one forgets to free the memory a leak occurs; if one tries to access freed memory (or just freeing it twice!) a core dump may happen or other memory may be corrupted.
	Source   Edit   

proc deallocSharedImpl(p: pointer) {.noconv, ....}

	Source   Edit   

proc debugEcho(x: varargs[typed, `$`]) {.magic: "Echo", noSideEffect, ....}

	Same as echo, but as a special semantic rule, debugEcho pretends to be free of side effects, so that it can be used for debugging routines marked as noSideEffect. Source   Edit   

proc dec[T, V: Ordinal](x: var T; y: V = 1) {.magic: "Dec", noSideEffect,
	....}

Decrements the ordinal x by y.

If such a value does not exist, OverflowDefect is raised or a compile time error occurs. This is a short notation for: x = pred(x, y).

Example:

var i = 2
dec(i)
assert i == 1
dec(i, 3)
assert i == -2

	Source   Edit   

proc declared(x: untyped): bool {.magic: "Declared", noSideEffect, compileTime,
                              	....}

Special compile-time procedure that checks whether x is declared. x has to be an identifier or a qualified identifier.

This can be used to check whether a library provides a certain feature or not:

when not declared(strutils.toUpper):
  # provide our own toUpper proc here, because strutils is
  # missing it.

	See also:

    	declaredInScope

	Source   Edit   

proc declaredInScope(x: untyped): bool {.magic: "DeclaredInScope", noSideEffect,
	compileTime, ....}

	Special compile-time procedure that checks whether x is declared in the current scope. x has to be an identifier. Source   Edit   

proc deepCopy[T](x: var T; y: T) {.noSideEffect, magic: "DeepCopy", ....}

	Performs a deep copy of y and copies it into x.

	This is also used by the code generator for the implementation of spawn.

	For --mm:arc or --mm:orc deepcopy support has to be enabled via --deepcopy:on.
	Source   Edit   

proc deepCopy[T](y: T): T

	Convenience wrapper around deepCopy overload. Source   Edit   

proc default[T](_: typedesc[T]): T {.magic: "Default", noSideEffect, ....}

Returns the default value of the type T. Contrary to zeroDefault, it takes default fields of an object into consideration.

See also:

	zeroDefault

Example: cmd: -d:nimPreviewRangeDefault

assert (int, float).default == (0, 0.0)
type Foo = object
  a: range[2..6]
var x = Foo.default
assert x.a == 2

	Source   Edit   

proc defined(x: untyped): bool {.magic: "Defined", noSideEffect, compileTime,
                             	....}

Special compile-time procedure that checks whether x is defined.

x is an external symbol introduced through the compiler's -d:x switch to enable build time conditionals:

when not defined(release):
  # Do here programmer friendly expensive sanity checks.
# Put here the normal code

	See also:

    	compileOption for on|off options
    	compileOption for enum options
    	define pragmas

	Source   Edit   

proc del[T](x: var seq[T]; i: Natural) {.noSideEffect.}

Deletes the item at index i by putting x[high(x)] into position i.

This is an O(1) operation.

See also:

	delete for preserving the order

Example:

var a = @[10, 11, 12, 13, 14]
a.del(2)
assert a == @[10, 11, 14, 13]

	Source   Edit   

proc delete[T](x: var seq[T]; i: Natural) {.noSideEffect.}

Deletes the item at index i by moving all x[i+1..^1] items by one position.

This is an O(n) operation.
Note: With -d:nimStrictDelete, an index error is produced when the index passed to it was out of bounds. -d:nimStrictDelete will become the default in upcoming versions.

See also:

	del for O(1) operation

Example:

var s = @[1, 2, 3, 4, 5]
s.delete(2)
doAssert s == @[1, 2, 4, 5]

	Source   Edit   

proc dispose(x: ForeignCell) {.....}

	Source   Edit   

proc `div`(x, y: int): int {.magic: "DivI", noSideEffect, ....}

Computes the integer division.

This is roughly the same as math.trunc(x/y).int.

Example:

assert (1 div 2) == 0
assert (2 div 2) == 1
assert (3 div 2) == 1
assert (7 div 3) == 2
assert (-7 div 3) == -2
assert (7 div -3) == -2
assert (-7 div -3) == 2

	Source   Edit   

proc `div`(x, y: int8): int8 {.magic: "DivI", noSideEffect, ....}

	Source   Edit   

proc `div`(x, y: int16): int16 {.magic: "DivI", noSideEffect, ....}

	Source   Edit   

proc `div`(x, y: int32): int32 {.magic: "DivI", noSideEffect, ....}

	Source   Edit   

proc `div`(x, y: int64): int64 {.magic: "DivI", noSideEffect, ....}

	Source   Edit   

proc `div`(x, y: uint): uint {.magic: "DivU", noSideEffect, ....}

	Computes the integer division for unsigned integers. This is roughly the same as trunc(x/y). Source   Edit   

proc `div`(x, y: uint8): uint8 {.magic: "DivU", noSideEffect, ....}

	Source   Edit   

proc `div`(x, y: uint16): uint16 {.magic: "DivU", noSideEffect, ....}

	Source   Edit   

proc `div`(x, y: uint32): uint32 {.magic: "DivU", noSideEffect, ....}

	Source   Edit   

proc `div`(x, y: uint64): uint64 {.magic: "DivU", noSideEffect, ....}

	Source   Edit   

proc echo(x: varargs[typed, `$`]) {.magic: "Echo", ...sideEffect,
                                	....}

	Writes and flushes the parameters to the standard output.

	Special built-in that takes a variable number of arguments. Each argument is converted to a string via $, so it works for user-defined types that have an overloaded $ operator. It is roughly equivalent to writeLine(stdout, x); flushFile(stdout), but available for the JavaScript target too.

	Unlike other IO operations this is guaranteed to be thread-safe as echo is very often used for debugging convenience. If you want to use echo inside a proc without side effects you can use debugEcho instead.
	Source   Edit   

proc ensureMove[T](x: T): T {.magic: "EnsureMove", noSideEffect, ....}

Ensures that x is moved to the new location, otherwise it gives an error at the compile time.

Example:

proc foo =
  var x = "Hello"
  let y = ensureMove(x)
  doAssert y == "Hello"
foo()

	Source   Edit   

proc equalMem(a, b: pointer; size: Natural): bool {.inline, noSideEffect,
	....}

	Compares the memory blocks a and b. size bytes will be compared.

	If the blocks are equal, true is returned, false otherwise. Like any procedure dealing with raw memory this is unsafe.
	Source   Edit   

func excl[T](x: var set[T]; y: T) {.magic: "Excl", ....}

Excludes element y from the set x.

This is the same as x = x - {y}, but it might be more efficient.

Example:

var b = {2, 3, 5, 6, 12, 54}
b.excl(5)
assert b == {2, 3, 6, 12, 54}

	Source   Edit   

proc find[T, S](a: T; item: S): int {.inline.}

	Returns the first index of item in a or -1 if not found. This requires appropriate items and == operations to work. Source   Edit   

proc finished[T: iterator {.closure.}](x: T): bool {.noSideEffect, inline,
	magic: "Finished", ....}

	It can be used to determine if a first class iterator has finished. Source   Edit   

proc freeShared[T](p: ptr T) {.inline, ....}

	Frees the memory allocated with createShared, createSharedU or resizeShared.

	This procedure is dangerous! If one forgets to free the memory a leak occurs; if one tries to access freed memory (or just freeing it twice!) a core dump may happen or other memory may be corrupted.
	Source   Edit   

proc GC_collectZct() {.....}

	Collect the ZCT (zero count table). Unstable, experimental API for testing purposes. DO NOT USE! Source   Edit   

proc GC_disable() {....inline, ....}

	Disables the GC. If called n times, n calls to GC_enable are needed to reactivate the GC.

	Note that in most circumstances one should only disable the mark and sweep phase with GC_disableMarkAndSweep.
	Source   Edit   

proc GC_disableMarkAndSweep() {.....}

	The current implementation uses a reference counting garbage collector with a seldomly run mark and sweep phase to free cycles. The mark and sweep phase may take a long time and is not needed if the application does not create cycles. Thus the mark and sweep phase can be deactivated and activated separately from the rest of the GC. Source   Edit   

proc GC_enable() {....inline, ....}

	Enables the GC again. Source   Edit   

proc GC_enableMarkAndSweep() {.....}

	Source   Edit   

proc GC_fullCollect() {.....}

	Forces a full garbage collection pass. Ordinary code does not need to call this (and should not). Source   Edit   

proc GC_getStatistics(): string {.....}

	Returns an informative string about the GC's activity. This may be useful for tweaking. Source   Edit   

proc GC_ref(x: string) {.magic: "GCref", ....}

	Marks the object x as referenced, so that it will not be freed until it is unmarked via GC_unref. If called n-times for the same object x, n calls to GC_unref are needed to unmark x. Source   Edit   

proc GC_ref[T](x: ref T) {.magic: "GCref", ....}

	Source   Edit   

proc GC_ref[T](x: seq[T]) {.magic: "GCref", ....}

	Source   Edit   

proc GC_unref(x: string) {.magic: "GCunref", ....}

	See the documentation of GC_ref. Source   Edit   

proc GC_unref[T](x: ref T) {.magic: "GCunref", ....}

	Source   Edit   

proc GC_unref[T](x: seq[T]) {.magic: "GCunref", ....}

	Source   Edit   

proc gcInvariant() {.....}

	Source   Edit   

proc getAllocStats(): AllocStats {.....}

	Source   Edit   

proc getCurrentException(): ref Exception {.compilerproc, inline, ....}

	Retrieves the current exception; if there is none, nil is returned. Source   Edit   

proc getCurrentExceptionMsg(): string {.inline, ....}

	Retrieves the error message that was attached to the current exception; if there is none, "" is returned. Source   Edit   

proc getFrame(): PFrame {.compilerproc, inline, ....}

	Source   Edit   

proc getFrameState(): FrameState {.compilerproc, inline, ....}

	Source   Edit   

proc getFreeMem(): int {.....}

	Returns the number of bytes that are owned by the process, but do not hold any meaningful data. Source   Edit   

proc getFreeSharedMem(): int {.....}

	Returns the number of bytes that are owned by the process on the shared heap, but do not hold any meaningful data. This is only available when threads are enabled. Source   Edit   

proc getGcFrame(): GcFrame {.compilerproc, inline, ....}

	Source   Edit   

proc getMaxMem(): int {.....}

	Source   Edit   

proc getOccupiedMem(): int {.....}

	Returns the number of bytes that are owned by the process and hold data. Source   Edit   

proc getOccupiedSharedMem(): int {.....}

	Returns the number of bytes that are owned by the process on the shared heap and hold data. This is only available when threads are enabled. Source   Edit   

proc getStackTrace(): string {.....}

	Gets the current stack trace. This only works for debug builds. Source   Edit   

proc getStackTrace(e: ref Exception): string {.....}

	Gets the stack trace associated with e, which is the stack that lead to the raise statement. This only works for debug builds. Source   Edit   

proc getStackTraceEntries(): seq[StackTraceEntry] {.....}

	Returns the stack trace entries for the current stack trace. This is not yet available for the JS backend. Source   Edit   

proc getStackTraceEntries(e: ref Exception): lent seq[StackTraceEntry] {.
	....}

	Source   Edit   

proc getTotalMem(): int {.....}

	Returns the number of bytes that are owned by the process. Source   Edit   

proc getTotalSharedMem(): int {.....}

	Returns the number of bytes on the shared heap that are owned by the process. This is only available when threads are enabled. Source   Edit   

proc getTypeInfo[T](x: T): pointer {.magic: "GetTypeInfo", ....}

	Get type information for x.

	Ordinary code should not use this, but the typeinfo module instead.
	Source   Edit   

proc gorge(command: string; input = ""; cache = ""): string {.
	magic: "StaticExec", ....}

	This is an alias for staticExec. Source   Edit   

proc gorgeEx(command: string; input = ""; cache = ""): tuple[output: string,
	exitCode: int] {.....}

	Similar to gorge but also returns the precious exit code. Source   Edit   

proc high(T: typedesc[SomeFloat]): T:type

	Source   Edit   

proc high(x: cstring): int {.magic: "High", noSideEffect, ....}

	Returns the highest possible index of a compatible string x. This is sometimes an O(n) operation.

	See also:

    	low(cstring)

	Source   Edit   

proc high(x: string): int {.magic: "High", noSideEffect, ....}

Returns the highest possible index of a string x.

var str = "Hello world!"
high(str) # => 11

	See also:

    	low(string)

	Source   Edit   

proc high[I, T](x: array[I, T]): I {.magic: "High", noSideEffect, ....}

Returns the highest possible index of an array x.

For empty arrays, the return type is int.

var arr = [1, 2, 3, 4, 5, 6, 7]
high(arr) # => 6
for i in low(arr)..high(arr):
  echo arr[i]

	See also:

    	low(array)

	Source   Edit   

proc high[I, T](x: typedesc[array[I, T]]): I {.magic: "High", noSideEffect,
	....}

Returns the highest possible index of an array type.

For empty arrays, the return type is int.

high(array[7, int]) # => 6

	See also:

    	low(typedesc[array])

	Source   Edit   

proc high[T: Ordinal | enum | range](x: T): T {.magic: "High", noSideEffect, ....}

Deprecated: Deprecated since v1.4; there should not be `high(value)`. Use `high(type)`.

Returns the highest possible value of an ordinal value x.

As a special semantic rule, x may also be a type identifier.

This proc is deprecated, use this one instead:

	high(typedesc)

high(2) # => 9223372036854775807

	Source   Edit   

proc high[T: Ordinal | enum | range](x: typedesc[T]): T {.magic: "High",
	noSideEffect, ....}

Returns the highest possible value of an ordinal or enum type.

high(int) is Nim's way of writing INT_MAX or MAX_INT.

high(int) # => 9223372036854775807

	See also:

    	low(typedesc)

	Source   Edit   

proc high[T](x: openArray[T]): int {.magic: "High", noSideEffect, ....}

Returns the highest possible index of a sequence x.

var s = @[1, 2, 3, 4, 5, 6, 7]
high(s) # => 6
for i in low(s)..high(s):
  echo s[i]

	See also:

    	low(openArray)

	Source   Edit   

proc inc[T, V: Ordinal](x: var T; y: V = 1) {.magic: "Inc", noSideEffect,
	....}

Increments the ordinal x by y.

If such a value does not exist, OverflowDefect is raised or a compile time error occurs. This is a short notation for: x = succ(x, y).

Example:

var i = 2
inc(i)
assert i == 3
inc(i, 3)
assert i == 6

	Source   Edit   

func incl[T](x: var set[T]; y: T) {.magic: "Incl", ....}

Includes element y in the set x.

This is the same as x = x + {y}, but it might be more efficient.

Example:

var a = {1, 3, 5}
a.incl(2)
assert a == {1, 2, 3, 5}
a.incl(4)
assert a == {1, 2, 3, 4, 5}

	Source   Edit   

proc insert(x: var string; item: string; i = 0.Natural) {.noSideEffect,
	....}

Inserts item into x at position i.

var a = "abc"
a.insert("zz", 0) # a <- "zzabc"

	Source   Edit   

proc insert[T](x: var seq[T]; item: sink T; i = 0.Natural) {.noSideEffect.}

Inserts item into x at position i.

var i = @[1, 3, 5]
i.insert(99, 0) # i <- @[99, 1, 3, 5]

	Source   Edit   

proc instantiationInfo(index = -1; fullPaths = false): tuple[filename: string,
	line: int, column: int] {.magic: "InstantiationInfo", noSideEffect,
                          	....}

Provides access to the compiler's instantiation stack line information of a template.

While similar to the caller info of other languages, it is determined at compile time.

This proc is mostly useful for meta programming (eg. assert template) to retrieve information about the current filename and line number. Example:

import std/strutils

template testException(exception, code: untyped): typed =
  try:
	let pos = instantiationInfo()
	discard(code)
	echo "Test failure at $1:$2 with '$3'" % [pos.filename,
  	$pos.line, astToStr(code)]
	assert false, "A test expecting failure succeeded?"
  except exception:
	discard

proc tester(pos: int): int =
  let
	a = @[1, 2, 3]
  result = a[pos]

when isMainModule:
  testException(IndexDefect, tester(30))
  testException(IndexDefect, tester(1))
  # --> Test failure at example.nim:20 with 'tester(1)'

	Source   Edit   

proc internalNew[T](a: var ref T) {.magic: "New", noSideEffect, ....}

	Leaked implementation detail. Do not use. Source   Edit   

proc `is`[T, S](x: T; y: S): bool {.magic: "Is", noSideEffect, ....}

Checks if T is of the same type as S.

For a negated version, use isnot.

assert 42 is int
assert @[1, 2] is seq

proc test[T](a: T): int =
  when (T is int):
	return a
  else:
	return 0

assert(test[int](3) == 3)
assert(test[string]("xyz") == 0)

	Source   Edit   

proc isNil(x: cstring): bool {.noSideEffect, magic: "IsNil", ....}

	Source   Edit   

proc isNil(x: pointer): bool {.noSideEffect, magic: "IsNil", ....}

	Source   Edit   

proc isNil[T: proc | iterator {.closure.}](x: T): bool {.noSideEffect,
	magic: "IsNil", ....}

	Fast check whether x is nil. This is sometimes more efficient than == nil. Source   Edit   

proc isNil[T](x: ptr T): bool {.noSideEffect, magic: "IsNil", ....}

	Source   Edit   

proc isNil[T](x: ref T): bool {.noSideEffect, magic: "IsNil", ....}

	Source   Edit   

proc isNotForeign(x: ForeignCell): bool {.....}

	returns true if 'x' belongs to the calling thread. No deep copy has to be performed then. Source   Edit   

proc iterToProc(iter: typed; envType: typedesc; procName: untyped) {.
	magic: "Plugin", compileTime, ....}

	Source   Edit   

func len(x: (type array) | array): int {.magic: "LengthArray", ....}

Returns the length of an array or an array type. This is roughly the same as high(T)-low(T)+1.

Example:

var a = [1, 1, 1]
assert a.len == 3
assert array[0, float].len == 0
static: assert array[-2..2, float].len == 5

	Source   Edit   

proc len(x: cstring): int {.magic: "LengthStr", noSideEffect, ....}

Returns the length of a compatible string. This is an O(n) operation except in js at runtime.

Note: On the JS backend this currently counts UTF-16 code points instead of bytes at runtime (not at compile time). For now, if you need the byte length of the UTF-8 encoding, convert to string with $ first then call len.

Example:

doAssert len(cstring"abc") == 3
doAssert len(cstring r"ab\0c") == 5 # \0 is escaped
doAssert len(cstring"ab\0c") == 5 # ditto
var a: cstring = "ab\0c"
when defined(js): doAssert a.len == 4 # len ignores \0 for js
else: doAssert a.len == 2 # \0 is a null terminator
static:
  var a2: cstring = "ab\0c"
  doAssert a2.len == 2 # \0 is a null terminator, even in js vm

	Source   Edit   

func len(x: string): int {.magic: "LengthStr", ....}

Returns the length of a string.

Example:

assert "abc".len == 3
assert "".len == 0
assert string.default.len == 0

	Source   Edit   

func len[T](x: seq[T]): int {.magic: "LengthSeq", ....}

Returns the length of x.

Example:

assert @[0, 1].len == 2
assert seq[int].default.len == 0
assert newSeq[int](3).len == 3
let s = newSeqOfCap[int](3)
assert s.len == 0

	Source   Edit   

func len[T](x: set[T]): int {.magic: "Card", ....}

	An alias for card(x). Source   Edit   

func len[TOpenArray: openArray | varargs](x: TOpenArray): int {.
	magic: "LengthOpenArray", ....}

Returns the length of an openArray.

Example:

proc bar[T](a: openArray[T]): int = len(a)
assert bar([1,2]) == 2
assert [1,2].len == 2

	Source   Edit   

proc len[U: Ordinal; V: Ordinal](x: HSlice[U, V]): int {.noSideEffect, inline.}

Length of ordinal slice. When x.b < x.a returns zero length.

assert((0..5).len == 6)
assert((5..2).len == 0)

	Source   Edit   

proc locals(): RootObj {.magic: "Plugin", noSideEffect, ....}

Generates a tuple constructor expression listing all the local variables in the current scope.

This is quite fast as it does not rely on any debug or runtime information. Note that in contrast to what the official signature says, the return type is not RootObj but a tuple of a structure that depends on the current scope. Example:

proc testLocals() =
  var
	a = "something"
	b = 4
	c = locals()
	d = "super!"
 
  b = 1
  for name, value in fieldPairs(c):
	echo "name ", name, " with value ", value
  echo "B is ", b
# -> name a with value something
# -> name b with value 4
# -> B is 1

	Source   Edit   

proc low(T: typedesc[SomeFloat]): T:type

	Source   Edit   

proc low(x: cstring): int {.magic: "Low", noSideEffect, ....}

	Returns the lowest possible index of a compatible string x.

	See also:

    	high(cstring)

	Source   Edit   

proc low(x: string): int {.magic: "Low", noSideEffect, ....}

Returns the lowest possible index of a string x.

var str = "Hello world!"
low(str) # => 0

	See also:

    	high(string)

	Source   Edit   

proc low[I, T](x: array[I, T]): I {.magic: "Low", noSideEffect, ....}

Returns the lowest possible index of an array x.

For empty arrays, the return type is int.

var arr = [1, 2, 3, 4, 5, 6, 7]
low(arr) # => 0
for i in low(arr)..high(arr):
  echo arr[i]

	See also:

    	high(array)

	Source   Edit   

proc low[I, T](x: typedesc[array[I, T]]): I {.magic: "Low", noSideEffect,
	....}

Returns the lowest possible index of an array type.

For empty arrays, the return type is int.

low(array[7, int]) # => 0

	See also:

    	high(typedesc[array])

	Source   Edit   

proc low[T: Ordinal | enum | range](x: T): T {.magic: "Low", noSideEffect, ....}

Deprecated: Deprecated since v1.4; there should not be `low(value)`. Use `low(type)`.

Returns the lowest possible value of an ordinal value x. As a special semantic rule, x may also be a type identifier.

This proc is deprecated, use this one instead:

	low(typedesc)

low(2) # => -9223372036854775808

	Source   Edit   

proc low[T: Ordinal | enum | range](x: typedesc[T]): T {.magic: "Low",
	noSideEffect, ....}

Returns the lowest possible value of an ordinal or enum type.

low(int) is Nim's way of writing INT_MIN or MIN_INT.

low(int) # => -9223372036854775808

	See also:

    	high(typedesc)

	Source   Edit   

proc low[T](x: openArray[T]): int {.magic: "Low", noSideEffect, ....}

Returns the lowest possible index of a sequence x.

var s = @[1, 2, 3, 4, 5, 6, 7]
low(s) # => 0
for i in low(s)..high(s):
  echo s[i]

	See also:

    	high(openArray)

	Source   Edit   

proc max(x, y: float32): float32 {.noSideEffect, inline, ....}

	Source   Edit   

proc max(x, y: float64): float64 {.noSideEffect, inline, ....}

	Source   Edit   

proc max(x, y: int): int {.magic: "MaxI", noSideEffect, ....}

	Source   Edit   

proc max(x, y: int8): int8 {.magic: "MaxI", noSideEffect, ....}

	Source   Edit   

proc max(x, y: int16): int16 {.magic: "MaxI", noSideEffect, ....}

	Source   Edit   

proc max(x, y: int32): int32 {.magic: "MaxI", noSideEffect, ....}

	Source   Edit   

proc max(x, y: int64): int64 {.magic: "MaxI", noSideEffect, ....}

	The maximum value of two integers. Source   Edit   

proc max[T: not SomeFloat](x, y: T): T {.inline.}

	Generic maximum operator of 2 values based on <=. Source   Edit   

proc max[T](x: openArray[T]): T

	The maximum value of x. T needs to have a < operator. Source   Edit   

proc min(x, y: float32): float32 {.noSideEffect, inline, ....}

	Source   Edit   

proc min(x, y: float64): float64 {.noSideEffect, inline, ....}

	Source   Edit   

proc min(x, y: int): int {.magic: "MinI", noSideEffect, ....}

	Source   Edit   

proc min(x, y: int8): int8 {.magic: "MinI", noSideEffect, ....}

	Source   Edit   

proc min(x, y: int16): int16 {.magic: "MinI", noSideEffect, ....}

	Source   Edit   

proc min(x, y: int32): int32 {.magic: "MinI", noSideEffect, ....}

	Source   Edit   

proc min(x, y: int64): int64 {.magic: "MinI", noSideEffect, ....}

	The minimum value of two integers. Source   Edit   

proc min[T: not SomeFloat](x, y: T): T {.inline.}

	Generic minimum operator of 2 values based on <=. Source   Edit   

proc min[T](x: openArray[T]): T

	The minimum value of x. T needs to have a < operator. Source   Edit   

proc `mod`(x, y: int): int {.magic: "ModI", noSideEffect, ....}

Computes the integer modulo operation (remainder).

This is the same as x - (x div y) * y.

Example:

assert (7 mod 5) == 2
assert (-7 mod 5) == -2
assert (7 mod -5) == 2
assert (-7 mod -5) == -2

	Source   Edit   

proc `mod`(x, y: int8): int8 {.magic: "ModI", noSideEffect, ....}

	Source   Edit   

proc `mod`(x, y: int16): int16 {.magic: "ModI", noSideEffect, ....}

	Source   Edit   

proc `mod`(x, y: int32): int32 {.magic: "ModI", noSideEffect, ....}

	Source   Edit   

proc `mod`(x, y: int64): int64 {.magic: "ModI", noSideEffect, ....}

	Source   Edit   

proc `mod`(x, y: uint): uint {.magic: "ModU", noSideEffect, ....}

	Computes the integer modulo operation (remainder) for unsigned integers. This is the same as x - (x div y) * y. Source   Edit   

proc `mod`(x, y: uint8): uint8 {.magic: "ModU", noSideEffect, ....}

	Source   Edit   

proc `mod`(x, y: uint16): uint16 {.magic: "ModU", noSideEffect, ....}

	Source   Edit   

proc `mod`(x, y: uint32): uint32 {.magic: "ModU", noSideEffect, ....}

	Source   Edit   

proc `mod`(x, y: uint64): uint64 {.magic: "ModU", noSideEffect, ....}

	Source   Edit   

proc move[T](x: var T): T {.magic: "Move", noSideEffect, ....}

	Source   Edit   

proc moveMem(dest, source: pointer; size: Natural) {.inline, ....}

	Copies the contents from the memory at source to the memory at dest.

	Exactly size bytes will be copied. The memory regions may overlap, moveMem handles this case appropriately and is thus somewhat more safe than copyMem. Like any procedure dealing with raw memory this is still unsafe, though.
	Source   Edit   

proc new(t: typedesc): auto

	Creates a new object of type T and returns a safe (traced) reference to it as result value.

	When T is a ref type then the resulting type will be T, otherwise it will be ref T.
	Source   Edit   

proc new[T](a: var ref T) {.magic: "New", noSideEffect, ....}

	Creates a new object of type T and returns a safe (traced) reference to it in a. Source   Edit   

proc new[T](a: var ref T; finalizer: proc (x: ref T) {.nimcall.}) {.
	magic: "NewFinalize", noSideEffect, ....}

	Creates a new object of type T and returns a safe (traced) reference to it in a.

	When the garbage collector frees the object, finalizer is called. The finalizer may not keep a reference to the object pointed to by x. The finalizer cannot prevent the GC from freeing the object.

	Note: The finalizer refers to the type T, not to the object! This means that for each object of type T the finalizer will be called!
	Source   Edit   

proc newSeq[T](len = 0.Natural): seq[T]

Creates a new sequence of type seq[T] with length len.

Note that the sequence will be filled with zeroed entries. After the creation of the sequence you should assign entries to the sequence instead of adding them.

var inputStrings = newSeq[string](3)
assert len(inputStrings) == 3
inputStrings[0] = "The fourth"
inputStrings[1] = "assignment"
inputStrings[2] = "would crash"
#inputStrings[3] = "out of bounds"

	See also:

    	newSeqOfCap
    	newSeqUninitialized

	Source   Edit   

proc newSeq[T](s: var seq[T]; len: Natural) {.magic: "NewSeq", noSideEffect,
	....}

Creates a new sequence of type seq[T] with length len.

This is equivalent to s = @[]; setlen(s, len), but more efficient since no reallocation is needed.

Note that the sequence will be filled with zeroed entries. After the creation of the sequence you should assign entries to the sequence instead of adding them. Example:

var inputStrings: seq[string]
newSeq(inputStrings, 3)
assert len(inputStrings) == 3
inputStrings[0] = "The fourth"
inputStrings[1] = "assignment"
inputStrings[2] = "would crash"
#inputStrings[3] = "out of bounds"

	Source   Edit   

proc newSeqOfCap[T](cap: Natural): seq[T] {.magic: "NewSeqOfCap", noSideEffect,
	....}

Creates a new sequence of type seq[T] with length zero and capacity cap. Example:

var x = newSeqOfCap[int](5)
assert len(x) == 0
x.add(10)
assert len(x) == 1

	Source   Edit   

proc newSeqUninitialized[T: SomeNumber](len: Natural): seq[T]

Creates a new sequence of type seq[T] with length len.

Only available for numbers types. Note that the sequence will be uninitialized. After the creation of the sequence you should assign entries to the sequence instead of adding them. Example:

var x = newSeqUninitialized[int](3)
assert len(x) == 3
x[0] = 10

	Source   Edit   

proc newString(len: Natural): string {.magic: "NewString",
                                   	importc: "mnewString", noSideEffect,
                                   	....}

	Returns a new string of length len but with uninitialized content. One needs to fill the string character after character with the index operator s[i].

	This procedure exists only for optimization purposes; the same effect can be achieved with the & operator or with add.
	Source   Edit   

proc newStringOfCap(cap: Natural): string {.magic: "NewStringOfCap",
	importc: "rawNewString", noSideEffect, ....}

	Returns a new string of length 0 but with capacity cap.

	This procedure exists only for optimization purposes; the same effect can be achieved with the & operator or with add.
	Source   Edit   

proc nimGC_setStackBottom(theStackBottom: pointer) {.compilerproc, noinline,
	....}

	Expands operating GC stack range to theStackBottom. Does nothing if current stack bottom is already lower than theStackBottom. Source   Edit   

proc `not`(a: typedesc): typedesc {.magic: "TypeTrait", noSideEffect,
                                	....}

	Constructs an not meta class. Source   Edit   

proc `not`(x: bool): bool {.magic: "Not", noSideEffect, ....}

	Boolean not; returns true if x == false. Source   Edit   

proc `not`(x: int): int {.magic: "BitnotI", noSideEffect, ....}

Computes the bitwise complement of the integer x.

Example:

assert not 0'u8 == 255
assert not 0'i8 == -1
assert not 1000'u16 == 64535
assert not 1000'i16 == -1001

	Source   Edit   

proc `not`(x: int8): int8 {.magic: "BitnotI", noSideEffect, ....}

	Source   Edit   

proc `not`(x: int16): int16 {.magic: "BitnotI", noSideEffect, ....}

	Source   Edit   

proc `not`(x: int32): int32 {.magic: "BitnotI", noSideEffect, ....}

	Source   Edit   

proc `not`(x: int64): int64 {.magic: "BitnotI", noSideEffect, ....}

	Source   Edit   

proc `not`(x: uint): uint {.magic: "BitnotI", noSideEffect, ....}

	Computes the bitwise complement of the integer x. Source   Edit   

proc `not`(x: uint8): uint8 {.magic: "BitnotI", noSideEffect, ....}

	Source   Edit   

proc `not`(x: uint16): uint16 {.magic: "BitnotI", noSideEffect, ....}

	Source   Edit   

proc `not`(x: uint32): uint32 {.magic: "BitnotI", noSideEffect, ....}

	Source   Edit   

proc `not`(x: uint64): uint64 {.magic: "BitnotI", noSideEffect, ....}

	Source   Edit   

proc `of`[T, S](x: T; y: typedesc[S]): bool {.magic: "Of", noSideEffect,
	....}

Checks if x is an instance of y.

Example:

type
  Base = ref object of RootObj
  Sub1 = ref object of Base
  Sub2 = ref object of Base
  Unrelated = ref object

var base: Base = Sub1() # downcast
doAssert base of Base # generates `CondTrue` (statically true)
doAssert base of Sub1
doAssert base isnot Sub1
doAssert not (base of Sub2)

base = Sub2() # re-assign
doAssert base of Sub2
doAssert Sub2(base) != nil # upcast
doAssertRaises(ObjectConversionDefect): discard Sub1(base)

var sub1 = Sub1()
doAssert sub1 of Base
doAssert sub1.Base of Sub1

doAssert not compiles(base of Unrelated)

	Source   Edit   

proc onThreadDestruction(handler: proc () {.closure, ....}) {.
	....}

	Registers a thread local handler that is called at the thread's destruction.

	A thread is destructed when the .thread proc returns normally or when it raises an exception. Note that unhandled exceptions in a thread nevertheless cause the whole process to die.
	Source   Edit   

proc open[TMsg](c: var Channel[TMsg]; maxItems: int = 0)

	Opens a channel c for inter thread communication.

	The send operation will block until number of unprocessed items is less than maxItems.

	For unlimited queue set maxItems to 0.
	Source   Edit   

proc `or`(a, b: typedesc): typedesc {.magic: "TypeTrait", noSideEffect,
                                  	....}

	Constructs an or meta class. Source   Edit   

proc `or`(x, y: bool): bool {.magic: "Or", noSideEffect, ....}

	Boolean or; returns true if not (not x and not y) (if any of the arguments is true).

	Evaluation is lazy: if x is true, y will not even be evaluated.
	Source   Edit   

proc `or`(x, y: int): int {.magic: "BitorI", noSideEffect, ....}

Computes the bitwise or of numbers x and y.

Example:

assert (0b0011 or 0b0101) == 0b0111
assert (0b0111 or 0b1100) == 0b1111

	Source   Edit   

proc `or`(x, y: int8): int8 {.magic: "BitorI", noSideEffect, ....}

	Source   Edit   

proc `or`(x, y: int16): int16 {.magic: "BitorI", noSideEffect, ....}

	Source   Edit   

proc `or`(x, y: int32): int32 {.magic: "BitorI", noSideEffect, ....}

	Source   Edit   

proc `or`(x, y: int64): int64 {.magic: "BitorI", noSideEffect, ....}

	Source   Edit   

proc `or`(x, y: uint): uint {.magic: "BitorI", noSideEffect, ....}

	Computes the bitwise or of numbers x and y. Source   Edit   

proc `or`(x, y: uint8): uint8 {.magic: "BitorI", noSideEffect, ....}

	Source   Edit   

proc `or`(x, y: uint16): uint16 {.magic: "BitorI", noSideEffect, ....}

	Source   Edit   

proc `or`(x, y: uint32): uint32 {.magic: "BitorI", noSideEffect, ....}

	Source   Edit   

proc `or`(x, y: uint64): uint64 {.magic: "BitorI", noSideEffect, ....}

	Source   Edit   

func ord[T: Ordinal | enum](x: T): int {.magic: "Ord", ....}

Returns the internal int value of x, including for enum with holes and distinct ordinal types.

Example:

assert ord('A') == 65
type Foo = enum
  f0 = 0, f1 = 3
assert f1.ord == 3
type Bar = distinct int
assert 3.Bar.ord == 3

	Source   Edit   

proc peek[TMsg](c: var Channel[TMsg]): int

	Returns the current number of messages in the channel c.

	Returns -1 if the channel has been closed.

	Note: This is dangerous to use as it encourages races. It's much better to use tryRecv proc instead.
	Source   Edit   

proc pop[T](s: var seq[T]): T {.inline, noSideEffect.}

Returns the last item of s and decreases s.len by one. This treats s as a stack and implements the common pop operation.

Raises IndexDefect if s is empty.

Example:

var a = @[1, 3, 5, 7]
let b = pop(a)
assert b == 7
assert a == @[1, 3, 5]

	Source   Edit   

proc popGcFrame() {.compilerproc, inline, ....}

	Source   Edit   

proc pred[T, V: Ordinal](x: T; y: V = 1): T {.magic: "Pred", noSideEffect,
	....}

Returns the y-th predecessor (default: 1) of the value x.

If such a value does not exist, OverflowDefect is raised or a compile time error occurs.

Example:

assert pred(5) == 4
assert pred(5, 3) == 2

	Source   Edit   

proc prepareMutation(s: var string) {.inline, ....}

String literals (e.g. "abc", etc) in the ARC/ORC mode are "copy on write", therefore you should call prepareMutation before modifying the strings via addr.

Example:

var x = "abc"
var y = "defgh"
prepareMutation(y) # without this, you may get a `SIGBUS` or `SIGSEGV`
moveMem(addr y[0], addr x[0], x.len)
assert y == "abcgh"

	Source   Edit   

proc procCall(x: untyped) {.magic: "ProcCall", compileTime, ....}

Special magic to prohibit dynamic binding for method calls. This is similar to super in ordinary OO languages.

# 'someMethod' will be resolved fully statically:
procCall someMethod(a, b)

	Source   Edit   

proc protect(x: pointer): ForeignCell {.....}

	Source   Edit   

proc pushGcFrame(s: GcFrame) {.compilerproc, inline, ....}

	Source   Edit   

proc quit(errorcode: int = QuitSuccess) {.magic: "Exit", noreturn, ....}

	Stops the program immediately with an exit code.

	Before stopping the program the "exit procedures" are called in the opposite order they were added with addExitProc.

	The proc quit(QuitSuccess) is called implicitly when your nim program finishes without incident for platforms where this is the expected behavior. A raised unhandled exception is equivalent to calling quit(QuitFailure).

	Note that this is a runtime call and using quit inside a macro won't have any compile time effect. If you need to stop the compiler inside a macro, use the error or fatal pragmas.
	Warning: errorcode gets saturated when it exceeds the valid range on the specific platform. On Posix, the valid range is low(int8)..high(int8). On Windows, the valid range is low(int32)..high(int32). For instance, quit(int(0x100000000)) is equal to quit(127) on Linux.
	Danger: In almost all cases, in particular in library code, prefer alternatives, e.g. doAssert false or raise a Defect. quit bypasses regular control flow in particular defer, try, catch, finally and destructors, and exceptions that may have been raised by an addExitProc proc, as well as cleanup code in other threads. It does not call the garbage collector to free all the memory, unless an addExitProc proc calls GC_fullCollect.
	Source   Edit   

proc quit(errormsg: string; errorcode = QuitFailure) {.noreturn, ....}

	A shorthand for echo(errormsg); quit(errorcode). Source   Edit   

proc rawEnv[T: proc {.closure.} | iterator {.closure.}](x: T): pointer {.
	noSideEffect, inline.}

	Retrieves the raw environment pointer of the closure x. See also rawProc. Source   Edit   

proc rawProc[T: proc {.closure.} | iterator {.closure.}](x: T): pointer {.
	noSideEffect, inline.}

	Retrieves the raw proc pointer of the closure x. This is useful for interfacing closures with C/C++, hash compuations, etc. Source   Edit   

proc ready[TMsg](c: var Channel[TMsg]): bool

	Returns true if some thread is waiting on the channel c for new messages. Source   Edit   

proc realloc0Impl(p: pointer; oldSize, newSize: Natural): pointer {.noconv,
	....}

	Source   Edit   

proc reallocImpl(p: pointer; newSize: Natural): pointer {.noconv, ....}

	Source   Edit   

proc reallocShared0Impl(p: pointer; oldSize, newSize: Natural): pointer {.
	noconv, ....}

	Source   Edit   

proc reallocSharedImpl(p: pointer; newSize: Natural): pointer {.noconv, ....}

	Source   Edit   

proc recv[TMsg](c: var Channel[TMsg]): TMsg

	Receives a message from the channel c.

	This blocks until a message has arrived! You may use peek proc to avoid the blocking.
	Source   Edit   

proc repr[T, U](x: HSlice[T, U]): string

Generic repr operator for slices that is lifted from the components of x. Example:

$(1 .. 5) == "1 .. 5"

	Source   Edit   

proc repr[T](x: T): string {.magic: "Repr", noSideEffect, ....}

Takes any Nim variable and returns its string representation. No trailing newline is inserted (so echo won't add an empty newline). Use -d:nimLegacyReprWithNewline to revert to old behavior where newlines were added in some cases.

It works even for complex data graphs with cycles. This is a great debugging tool.

var s: seq[string] = @["test2", "test2"]
var i = @[1, 2, 3, 4, 5]
echo repr(s) # => 0x1055eb050[0x1055ec050"test2", 0x1055ec078"test2"]
echo repr(i) # => 0x1055ed050[1, 2, 3, 4, 5]

	Source   Edit   

proc reprDiscriminant(e: int; typ: PNimType): string {.compilerproc, ....}

	Source   Edit   

proc reset[T](obj: var T) {.noSideEffect.}

	Resets an object obj to its default value. Source   Edit   

proc resize[T](p: ptr T; newSize: Natural): ptr T {.inline, ....}

	Grows or shrinks a given memory block.

	If p is nil then a new memory block is returned. In either way the block has at least T.sizeof * newSize bytes. If newSize == 0 and p is not nil resize calls dealloc(p). In other cases the block has to be freed with free.

	The allocated memory belongs to its allocating thread! Use resizeShared to reallocate from a shared heap.
	Source   Edit   

proc resizeShared[T](p: ptr T; newSize: Natural): ptr T {.inline, ....}

	Grows or shrinks a given memory block on the heap.

	If p is nil then a new memory block is returned. In either way the block has at least T.sizeof * newSize bytes. If newSize == 0 and p is not nil resizeShared calls freeShared(p). In other cases the block has to be freed with freeShared.
	Source   Edit   

proc runnableExamples(rdoccmd = ""; body: untyped) {.magic: "RunnableExamples",
	....}

A section you should use to mark runnable example code with.

	In normal debug and release builds code within a runnableExamples section is ignored.
	The documentation generator is aware of these examples and considers them part of the ## doc comment. As the last step of documentation generation each runnableExample is put in its own file $file_examples$i.nim, compiled and tested. The collected examples are put into their own module to ensure the examples do not refer to non-exported symbols.

Example:

proc timesTwo*(x: int): int =
  ## This proc doubles a number.
  runnableExamples:
	# at module scope
	const exported* = 123
	assert timesTwo(5) == 10
	block: # at block scope
  	defer: echo "done"
  runnableExamples "-d:foo -b:cpp":
	import std/compilesettings
	assert querySetting(backend) == "cpp"
	assert defined(foo)
  runnableExamples "-r:off": ## this one is only compiled
 	import std/browsers
 	openDefaultBrowser "https://forum.nim-lang.org/"
  2 * x

	Source   Edit   

proc send[TMsg](c: var Channel[TMsg]; msg: sink TMsg) {.inline.}

	Sends a message to a thread. msg is deeply copied. Source   Edit   

proc setControlCHook(hook: proc () {.noconv.}) {.....}

Allows you to override the behaviour of your application when CTRL+C is pressed. Only one such hook is supported. Example:

proc ctrlc() {.noconv.} =
  echo "Ctrl+C fired!"
  # do clean up stuff
  quit()

setControlCHook(ctrlc)

	Source   Edit   

proc setCurrentException(exc: ref Exception) {.inline, ....}

	Sets the current exception.
	Warning: Only use this if you know what you are doing.
	Source   Edit   

proc setFrame(s: PFrame) {.compilerproc, inline, ....}

	Source   Edit   

proc setFrameState(state: FrameState) {.compilerproc, inline, ....}

	Source   Edit   

proc setGcFrame(s: GcFrame) {.compilerproc, inline, ....}

	Source   Edit   

proc setLen(s: var string; newlen: Natural) {.magic: "SetLengthStr",
	noSideEffect, ....}

Sets the length of string s to newlen.

If the current length is greater than the new length, s will be truncated.

var myS = "Nim is great!!"
myS.setLen(3) # myS <- "Nim"
echo myS, " is fantastic!!"

	Source   Edit   

proc setLen[T](s: var seq[T]; newlen: Natural) {.magic: "SetLengthSeq",
	noSideEffect, nodestroy, ....}

Sets the length of seq s to newlen. T may be any sequence type.

If the current length is greater than the new length, s will be truncated.

var x = @[10, 20]
x.setLen(5)
x[4] = 50
assert x == @[10, 20, 0, 0, 50]
x.setLen(1)
assert x == @[10]

	Source   Edit   

proc setupForeignThreadGc() {.....}

	Call this if you registered a callback that will be run from a thread not under your control. This has a cheap thread-local guard, so the GC for this thread will only be initialized once per thread, no matter how often it is called.

	This function is available only when --threads:on and --tlsEmulation:off switches are used
	Source   Edit   

proc shallow(s: var string) {.noSideEffect, inline, ....}

	Marks a string s as shallow. Subsequent assignments will not perform deep copies of s.

	This is only useful for optimization purposes.
	Source   Edit   

proc shallow[T](s: var seq[T]) {.noSideEffect, inline.}

	Marks a sequence s as shallow. Subsequent assignments will not perform deep copies of s.

	This is only useful for optimization purposes.
	Source   Edit   

proc shallowCopy[T](x: var T; y: T) {.noSideEffect, magic: "ShallowCopy",
                                  	....}

	Use this instead of = for a shallow copy.

	The shallow copy only changes the semantics for sequences and strings (and types which contain those).

	Be careful with the changed semantics though! There is a reason why the default assignment does a deep copy of sequences and strings.
	Source   Edit   

proc `shl`(x: int8; y: SomeInteger): int8 {.magic: "ShlI", noSideEffect,
	....}

	Source   Edit   

proc `shl`(x: int16; y: SomeInteger): int16 {.magic: "ShlI", noSideEffect,
	....}

	Source   Edit   

proc `shl`(x: int32; y: SomeInteger): int32 {.magic: "ShlI", noSideEffect,
	....}

	Source   Edit   

proc `shl`(x: int64; y: SomeInteger): int64 {.magic: "ShlI", noSideEffect,
	....}

	Source   Edit   

proc `shl`(x: int; y: SomeInteger): int {.magic: "ShlI", noSideEffect,
	....}

Computes the shift left operation of x and y.

Note: Operator precedence is different than in C.

Example:

assert 1'i32 shl 4 == 0x0000_0010
assert 1'i64 shl 4 == 0x0000_0000_0000_0010

	Source   Edit   

proc `shl`(x: uint8; y: SomeInteger): uint8 {.magic: "ShlI", noSideEffect,
	....}

	Source   Edit   

proc `shl`(x: uint16; y: SomeInteger): uint16 {.magic: "ShlI", noSideEffect,
	....}

	Source   Edit   

proc `shl`(x: uint32; y: SomeInteger): uint32 {.magic: "ShlI", noSideEffect,
	....}

	Source   Edit   

proc `shl`(x: uint64; y: SomeInteger): uint64 {.magic: "ShlI", noSideEffect,
	....}

	Source   Edit   

proc `shl`(x: uint; y: SomeInteger): uint {.magic: "ShlI", noSideEffect,
	....}

	Computes the shift left operation of x and y. Source   Edit   

proc `shr`(x: int8; y: SomeInteger): int8 {.magic: "AshrI", noSideEffect,
	....}

	Source   Edit   

proc `shr`(x: int16; y: SomeInteger): int16 {.magic: "AshrI", noSideEffect,
	....}

	Source   Edit   

proc `shr`(x: int32; y: SomeInteger): int32 {.magic: "AshrI", noSideEffect,
	....}

	Source   Edit   

proc `shr`(x: int64; y: SomeInteger): int64 {.magic: "AshrI", noSideEffect,
	....}

	Source   Edit   

proc `shr`(x: int; y: SomeInteger): int {.magic: "AshrI", noSideEffect,
	....}

Computes the shift right operation of x and y, filling vacant bit positions with the sign bit.

Note: Operator precedence is different than in C.

See also:

	ashr func for arithmetic shift right

Example:

assert 0b0001_0000'i8 shr 2 == 0b0000_0100'i8
assert 0b0000_0001'i8 shr 1 == 0b0000_0000'i8
assert 0b1000_0000'i8 shr 4 == 0b1111_1000'i8
assert -1 shr 5 == -1
assert 1 shr 5 == 0
assert 16 shr 2 == 4
assert -16 shr 2 == -4

	Source   Edit   

proc `shr`(x: uint8; y: SomeInteger): uint8 {.magic: "ShrI", noSideEffect,
	....}

	Source   Edit   

proc `shr`(x: uint16; y: SomeInteger): uint16 {.magic: "ShrI", noSideEffect,
	....}

	Source   Edit   

proc `shr`(x: uint32; y: SomeInteger): uint32 {.magic: "ShrI", noSideEffect,
	....}

	Source   Edit   

proc `shr`(x: uint64; y: SomeInteger): uint64 {.magic: "ShrI", noSideEffect,
	....}

	Source   Edit   

proc `shr`(x: uint; y: SomeInteger): uint {.magic: "ShrI", noSideEffect,
	....}

	Computes the shift right operation of x and y. Source   Edit   

proc sizeof(x: typedesc): int {.magic: "SizeOf", noSideEffect, ....}

	Source   Edit   

proc sizeof[T](x: T): int {.magic: "SizeOf", noSideEffect, ....}

Returns the size of x in bytes.

Since this is a low-level proc, its usage is discouraged - using new for the most cases suffices that one never needs to know x's size.

As a special semantic rule, x may also be a type identifier (sizeof(int) is valid).

Limitations: If used for types that are imported from C or C++, sizeof should fallback to the sizeof in the C compiler. The result isn't available for the Nim compiler and therefore can't be used inside of macros.

sizeof('A') # => 1
sizeof(2) # => 8

	Source   Edit   

proc slurp(filename: string): string {.magic: "Slurp", ....}

	This is an alias for staticRead. Source   Edit   

proc stackTraceAvailable(): bool {.....}

	Source   Edit   

proc staticExec(command: string; input = ""; cache = ""): string {.
	magic: "StaticExec", ....}

Executes an external process at compile-time and returns its text output (stdout + stderr).

If input is not an empty string, it will be passed as a standard input to the executed program.

const buildInfo = "Revision " & staticExec("git rev-parse HEAD") &
              	"\nCompiled on " & staticExec("uname -v")

gorge is an alias for staticExec.

Note that you can use this proc inside a pragma like passc or passl.

If cache is not empty, the results of staticExec are cached within the nimcache directory. Use --forceBuild to get rid of this caching behaviour then. command & input & cache (the concatenated string) is used to determine whether the entry in the cache is still valid. You can use versioning information for cache:

const stateMachine = staticExec("dfaoptimizer", "input", "0.8.0")

	Source   Edit   

proc staticRead(filename: string): string {.magic: "Slurp", ....}

Compile-time readFile proc for easy resource embedding:

The maximum file size limit that staticRead and slurp can read is near or equal to the free memory of the device you are using to compile.

const myResource = staticRead"mydatafile.bin"

	slurp is an alias for staticRead.
	Source   Edit   

proc substr(s: openArray[char]): string {.....}

Copies a slice of s into a new string and returns this new string.

Example:

let a = "abcdefgh"
assert a.substr(2, 5) == "cdef"
assert a.substr(2) == "cdefgh"
assert a.substr(5, 99) == "fgh"

	Source   Edit   

proc substr(s: string; first = 0): string {.....}

	Source   Edit   

proc substr(s: string; first, last: int): string {.....}

Copies a slice of s into a new string and returns this new string.

The bounds first and last denote the indices of the first and last characters that shall be copied. If last is omitted, it is treated as high(s). If last >= s.len, s.len is used instead: This means substr can also be used to cut or limit a string's length.

Example:

let a = "abcdefgh"
assert a.substr(2, 5) == "cdef"
assert a.substr(2) == "cdefgh"
assert a.substr(5, 99) == "fgh"

	Source   Edit   

proc succ[T, V: Ordinal](x: T; y: V = 1): T {.magic: "Succ", noSideEffect,
	....}

Returns the y-th successor (default: 1) of the value x.

If such a value does not exist, OverflowDefect is raised or a compile time error occurs.

Example:

assert succ(5) == 6
assert succ(5, 3) == 8

	Source   Edit   

proc swap[T](a, b: var T) {.magic: "Swap", noSideEffect, ....}

Swaps the values a and b.

This is often more efficient than tmp = a; a = b; b = tmp. Particularly useful for sorting algorithms.

var
  a = 5
  b = 9

swap(a, b)

assert a == 9
assert b == 5

	Source   Edit   

proc tearDownForeignThreadGc() {.....}

	Call this to tear down the GC, previously initialized by setupForeignThreadGc. If GC has not been previously initialized, or has already been torn down, the call does nothing.

	This function is available only when --threads:on and --tlsEmulation:off switches are used
	Source   Edit   

proc toBiggestFloat(i: BiggestInt): BiggestFloat {.noSideEffect, inline,
	....}

	Same as toFloat but for BiggestInt to BiggestFloat. Source   Edit   

proc toBiggestInt(f: BiggestFloat): BiggestInt {.noSideEffect, ....}

	Same as toInt but for BiggestFloat to BiggestInt. Source   Edit   

proc toFloat(i: int): float {.noSideEffect, inline, ....}

Converts an integer i into a float. Same as float(i).

If the conversion fails, ValueError is raised. However, on most platforms the conversion cannot fail.

let
  a = 2
  b = 3.7

echo a.toFloat + b # => 5.7

	Source   Edit   

proc toInt(f: float): int {.noSideEffect, ....}

Converts a floating point number f into an int.

Conversion rounds f half away from 0, see Round half away from zero, as opposed to a type conversion which rounds towards zero.

Note that some floating point numbers (e.g. infinity or even 1e19) cannot be accurately converted.

doAssert toInt(0.49) == 0
doAssert toInt(0.5) == 1
doAssert toInt(-0.5) == -1 # rounding is symmetrical

	Source   Edit   

proc toOpenArray(x: cstring; first, last: int): openArray[char] {.
	magic: "Slice", ....}

	Source   Edit   

proc toOpenArray(x: string; first, last: int): openArray[char] {.magic: "Slice",
	....}

	Source   Edit   

proc toOpenArray[I, T](x: array[I, T]; first, last: I): openArray[T] {.
	magic: "Slice", ....}

	Source   Edit   

proc toOpenArray[T](x: openArray[T]; first, last: int): openArray[T] {.
	magic: "Slice", ....}

	Source   Edit   

proc toOpenArray[T](x: ptr UncheckedArray[T]; first, last: int): openArray[T] {.
	magic: "Slice", ....}

	Source   Edit   

proc toOpenArray[T](x: seq[T]; first, last: int): openArray[T] {.magic: "Slice",
	....}

	Source   Edit   

proc toOpenArrayByte(x: cstring; first, last: int): openArray[byte] {.
	magic: "Slice", ....}

	Source   Edit   

proc toOpenArrayByte(x: openArray[char]; first, last: int): openArray[byte] {.
	magic: "Slice", ....}

	Source   Edit   

proc toOpenArrayByte(x: seq[char]; first, last: int): openArray[byte] {.
	magic: "Slice", ....}

	Source   Edit   

proc toOpenArrayByte(x: string; first, last: int): openArray[byte] {.
	magic: "Slice", ....}

	Source   Edit   

proc tryRecv[TMsg](c: var Channel[TMsg]): tuple[dataAvailable: bool, msg: TMsg]

	Tries to receive a message from the channel c, but this can fail for all sort of reasons, including contention.

	If it fails, it returns (false, default(msg)) otherwise it returns (true, msg).
	Source   Edit   

proc trySend[TMsg](c: var Channel[TMsg]; msg: sink TMsg): bool {.inline.}

	Tries to send a message to a thread.

	msg is deeply copied. Doesn't block.

	Returns false if the message was not sent because number of pending items in the channel exceeded maxItems.
	Source   Edit   

proc typeof(x: untyped; mode = typeOfIter): typedesc {.magic: "TypeOf",
	noSideEffect, compileTime, ....}

Builtin typeof operation for accessing the type of an expression. Since version 0.20.0.

Example:

proc myFoo(): float = 0.0
iterator myFoo(): string = yield "abc"
iterator myFoo2(): string = yield "abc"
iterator myFoo3(): string {.closure.} = yield "abc"
doAssert type(myFoo()) is string
doAssert typeof(myFoo()) is string
doAssert typeof(myFoo(), typeOfIter) is string
doAssert typeof(myFoo3) is iterator

doAssert typeof(myFoo(), typeOfProc) is float
doAssert typeof(0.0, typeOfProc) is float
doAssert typeof(myFoo3, typeOfProc) is iterator
doAssert not compiles(typeof(myFoo2(), typeOfProc))
  # this would give: Error: attempting to call routine: 'myFoo2'
  # since `typeOfProc` expects a typed expression and `myFoo2()` can
  # only be used in a `for` context.

	Source   Edit   

proc unsafeAddr[T](x: T): ptr T {.magic: "Addr", noSideEffect, ....}

	Warning: unsafeAddr is a deprecated alias for addr, use addr instead.
	Source   Edit   

proc unsafeNew[T](a: var ref T; size: Natural) {.magic: "New", noSideEffect,
	....}

	Creates a new object of type T and returns a safe (traced) reference to it in a.

	This is unsafe as it allocates an object of the passed size. This should only be used for optimization purposes when you know what you're doing!

	See also:

    	new

	Source   Edit   

proc unsetControlCHook() {.....}

	Reverts a call to setControlCHook. Source   Edit   

proc wasMoved[T](obj: var T) {.inline, noSideEffect.}

	Resets an object obj to its initial (binary zero) value to signify it was "moved" and to signify its destructor should do nothing and ideally be optimized away. Source   Edit   

proc writeStackTrace() {.....}

	Writes the current stack trace to stderr. This is only works for debug builds. Since it's usually used for debugging, this is proclaimed to have no IO effect! Source   Edit   

proc `xor`(x, y: bool): bool {.magic: "Xor", noSideEffect, ....}

	Boolean exclusive or; returns true if x != y (if either argument is true while the other is false). Source   Edit   

proc `xor`(x, y: int): int {.magic: "BitxorI", noSideEffect, ....}

Computes the bitwise xor of numbers x and y.

Example:

assert (0b0011 xor 0b0101) == 0b0110
assert (0b0111 xor 0b1100) == 0b1011

	Source   Edit   

proc `xor`(x, y: int8): int8 {.magic: "BitxorI", noSideEffect, ....}

	Source   Edit   

proc `xor`(x, y: int16): int16 {.magic: "BitxorI", noSideEffect, ....}

	Source   Edit   

proc `xor`(x, y: int32): int32 {.magic: "BitxorI", noSideEffect, ....}

	Source   Edit   

proc `xor`(x, y: int64): int64 {.magic: "BitxorI", noSideEffect, ....}

	Source   Edit   

proc `xor`(x, y: uint): uint {.magic: "BitxorI", noSideEffect, ....}

	Computes the bitwise xor of numbers x and y. Source   Edit   

proc `xor`(x, y: uint8): uint8 {.magic: "BitxorI", noSideEffect, ....}

	Source   Edit   

proc `xor`(x, y: uint16): uint16 {.magic: "BitxorI", noSideEffect, ....}

	Source   Edit   

proc `xor`(x, y: uint32): uint32 {.magic: "BitxorI", noSideEffect, ....}

	Source   Edit   

proc `xor`(x, y: uint64): uint64 {.magic: "BitxorI", noSideEffect, ....}

	Source   Edit   

func zeroDefault[T](_: typedesc[T]): T {.magic: "ZeroDefault", ....}

	Returns the binary zeros representation of the type T. It ignores default fields of an object.

	See also:

    	default

	Source   Edit   

proc zeroMem(p: pointer; size: Natural) {.inline, noSideEffect, ....}

	Overwrites the contents of the memory at p with the value 0.

	Exactly size bytes will be overwritten. Like any procedure dealing with raw memory this is unsafe.
	Source   Edit   

proc `|`(a, b: typedesc): typedesc

	Source   Edit   

Iterators

iterator `..`(a, b: int32): int32 {.inline, ....}

	A type specialized version of .. for convenience so that mixing integer types works better.

	See also:

    	..<

	Source   Edit   

iterator `..`(a, b: int64): int64 {.inline, ....}

	A type specialized version of .. for convenience so that mixing integer types works better.

	See also:

    	..<

	Source   Edit   

iterator `..`(a, b: uint32): uint32 {.inline, ....}

	A type specialized version of .. for convenience so that mixing integer types works better.

	See also:

    	..<

	Source   Edit   

iterator `..`(a, b: uint64): uint64 {.inline, ....}

	A type specialized version of .. for convenience so that mixing integer types works better.

	See also:

    	..<

	Source   Edit   

iterator `..`[T](a, b: T): T {.inline.}

An alias for countup(a, b, 1).

See also:

	..<

Example:

import std/sugar

let x = collect(newSeq):
  for i in 3 .. 7:
	i

assert x == @[3, 4, 5, 6, 7]

	Source   Edit   

iterator `..<`(a, b: int32): int32 {.inline, ....}

	A type specialized version of ..< for convenience so that mixing integer types works better. Source   Edit   

iterator `..<`(a, b: int64): int64 {.inline, ....}

	A type specialized version of ..< for convenience so that mixing integer types works better. Source   Edit   

iterator `..<`(a, b: uint32): uint32 {.inline, ....}

	A type specialized version of ..< for convenience so that mixing integer types works better. Source   Edit   

iterator `..<`(a, b: uint64): uint64 {.inline, ....}

	A type specialized version of ..< for convenience so that mixing integer types works better. Source   Edit   

iterator `..<`[T](a, b: T): T {.inline.}

	Source   Edit   

iterator countdown[T](a, b: T; step: Positive = 1): T {.inline.}

Counts from ordinal value a down to b (inclusive) with the given step count.

T may be any ordinal type, step may only be positive.

Note: This fails to count to low(int) if T = int for efficiency reasons.

Example:

import std/sugar
let x = collect(newSeq):
  for i in countdown(7, 3):
	i

assert x == @[7, 6, 5, 4, 3]

let y = collect(newseq):
  for i in countdown(9, 2, 3):
	i
assert y == @[9, 6, 3]

	Source   Edit   

iterator countup[T](a, b: T; step: Positive = 1): T {.inline.}

Counts from ordinal value a to b (inclusive) with the given step count.

T may be any ordinal type, step may only be positive.

Note: This fails to count to high(int) if T = int for efficiency reasons.

Example:

import std/sugar
let x = collect(newSeq):
  for i in countup(3, 7):
	i

assert x == @[3, 4, 5, 6, 7]

let y = collect(newseq):
  for i in countup(2, 9, 3):
	i
assert y == @[2, 5, 8]

	Source   Edit   

iterator `||`[S, T](a: S; b: T; annotation: static string = "parallel for"): T {.
	inline, magic: "OmpParFor", sideEffect, ....}

	OpenMP parallel loop iterator. Same as .. but the loop may run in parallel.

	annotation is an additional annotation for the code generator to use. The default annotation is parallel for. Please refer to the OpenMP Syntax Reference for further information.

	Note that the compiler maps that to the #pragma omp parallel for construct of OpenMP and as such isn't aware of the parallelism in your code! Be careful! Later versions of || will get proper support by Nim's code generator and GC.
	Source   Edit   

iterator `||`[S, T](a: S; b: T; step: Positive;
                	annotation: static string = "parallel for"): T {.inline,
	magic: "OmpParFor", sideEffect, ....}

	OpenMP parallel loop iterator with stepping.  Same as countup but the loop may run in parallel.

	annotation is an additional annotation for the code generator to use. The default annotation is parallel for. Please refer to the OpenMP Syntax Reference for further information.

	Note that the compiler maps that to the #pragma omp parallel for construct of OpenMP and as such isn't aware of the parallelism in your code! Be careful! Later versions of || will get proper support by Nim's code generator and GC.
	Source   Edit   

Macros

macro varargsLen(x: varargs[untyped]): int

	returns number of variadic arguments in x Source   Edit   

Templates

template `!=`(x, y: untyped): untyped {.callsite.}

	Unequals operator. This is a shorthand for not (x == y). Source   Edit   

template `&=`(x, y: typed)

	Generic 'sink' operator for Nim.

	If not specialized further, an alias for add.
	Source   Edit   

template `..<`(a, b: untyped): untyped

A shortcut for a .. pred(b).

for i in 5 ..< 9:
  echo i # => 5; 6; 7; 8

	Source   Edit   

template `..^`(a, b: untyped): untyped

	A shortcut for .. ^ to avoid the common gotcha that a space between '..' and '^' is required. Source   Edit   

template `>`(x, y: untyped): untyped {.callsite.}

	"is greater" operator. This is the same as y < x. Source   Edit   

template `>%`(x, y: untyped): untyped

	Treats x and y as unsigned and compares them. Returns true if unsigned(x) > unsigned(y). Source   Edit   

template `>=`(x, y: untyped): untyped {.callsite.}

	"is greater or equals" operator. This is the same as y <= x. Source   Edit   

template `>=%`(x, y: untyped): untyped

	Treats x and y as unsigned and compares them. Returns true if unsigned(x) >= unsigned(y). Source   Edit   

template `[]`(s: string; i: int): char

	Source   Edit   

template `[]=`(s: string; i: int; val: char)

	Source   Edit   

template `^`(x: int): BackwardsIndex

Builtin roof operator that can be used for convenient array access. a[^x] is a shortcut for a[a.len-x].

let
  a = [1, 3, 5, 7, 9]
  b = "abcdefgh"

echo a[^1] # => 9
echo b[^2] # => g

	Source   Edit   

template alloc(size: Natural): pointer

	Allocates a new memory block with at least size bytes.

	The block has to be freed with realloc(block, 0) or dealloc(block). The block is not initialized, so reading from it before writing to it is undefined behaviour!

	The allocated memory belongs to its allocating thread! Use allocShared to allocate from a shared heap.

	See also:

    	alloc0

	Source   Edit   

template alloc0(size: Natural): pointer

	Allocates a new memory block with at least size bytes.

	The block has to be freed with realloc(block, 0) or dealloc(block). The block is initialized with all bytes containing zero, so it is somewhat safer than alloc.

	The allocated memory belongs to its allocating thread! Use allocShared0 to allocate from a shared heap.
	Source   Edit   

template allocShared(size: Natural): pointer

	Allocates a new memory block on the shared heap with at least size bytes.

	The block has to be freed with reallocShared(block, 0) or deallocShared(block).

	The block is not initialized, so reading from it before writing to it is undefined behaviour!

	See also:

    	allocShared0.

	Source   Edit   

template allocShared0(size: Natural): pointer

	Allocates a new memory block on the shared heap with at least size bytes.

	The block has to be freed with reallocShared(block, 0) or deallocShared(block).

	The block is initialized with all bytes containing zero, so it is somewhat safer than allocShared.
	Source   Edit   

template closureScope(body: untyped): untyped

Useful when creating a closure in a loop to capture local loop variables by their current iteration values.

Note: This template may not work in some cases, use capture instead.

Example:

var myClosure : proc()
# without closureScope:
for i in 0 .. 5:
  let j = i
  if j == 3:
	myClosure = proc() = echo j
myClosure() # outputs 5. `j` is changed after closure creation
# with closureScope:
for i in 0 .. 5:
  closureScope: # Everything in this scope is locked after closure creation
	let j = i
	if j == 3:
  	myClosure = proc() = echo j
myClosure() # outputs 3

	Source   Edit   

template currentSourcePath(): string

	Returns the full file-system path of the current source.

	To get the directory containing the current source, use it with ospaths2.parentDir() as currentSourcePath.parentDir().

	The path returned by this template is set at compile time.

	See the docstring of macros.getProjectPath() for an example to see the distinction between the currentSourcePath() and getProjectPath().

	See also:

    	ospaths2.getCurrentDir() proc

	Source   Edit   

template disarm(x: typed)

	Useful for disarming dangling pointers explicitly for --newruntime. Regardless of whether --newruntime is used or not this sets the pointer or callback x to nil. This is an experimental API! Source   Edit   

template dumpAllocstats(code: untyped)

	Source   Edit   

template excl[T](x: var set[T]; y: set[T]) {.callsite.}

Excludes the set y from the set x.

Example:

var a = {1, 3, 5, 7}
var b = {3, 4, 5}
a.excl(b)
assert a == {1, 7}

	Source   Edit   

template formatErrorIndexBound[T](i, a, b: T): string

	Source   Edit   

template formatErrorIndexBound[T](i, n: T): string

	Source   Edit   

template formatFieldDefect(f, discVal): string

	Source   Edit   

template `in`(x, y: untyped): untyped {.dirty, callsite.}

Sugar for contains.

assert(1 in (1..3) == true)
assert(5 in (1..3) == false)

	Source   Edit   

template incl[T](x: var set[T]; y: set[T]) {.callsite.}

Includes the set y in the set x.

Example:

var a = {1, 3, 5, 7}
var b = {4, 5, 6}
a.incl(b)
assert a == {1, 3, 4, 5, 6, 7}

	Source   Edit   

template `isnot`(x, y: untyped): untyped {.callsite.}

Negated version of is. Equivalent to not(x is y).

assert 42 isnot float
assert @[1, 2] isnot enum

	Source   Edit   

template likely(val: bool): bool

Hints the optimizer that val is likely going to be true.

You can use this template to decorate a branch condition. On certain platforms this can help the processor predict better which branch is going to be run. Example:

for value in inputValues:
  if likely(value <= 100):
	process(value)
  else:
	echo "Value too big!"

	On backends without branch prediction (JS and the nimscript VM), this template will not affect code execution.
	Source   Edit   

template newException(exceptn: typedesc; message: string;
                  	parentException: ref Exception = nil): untyped

	Creates an exception object of type exceptn and sets its msg field to message. Returns the new exception object. Source   Edit   

template nimThreadProcWrapperBody(closure: untyped): untyped

	Source   Edit   

template `notin`(x, y: untyped): untyped {.dirty, callsite.}

Sugar for not contains.

assert(1 notin (1..3) == false)
assert(5 notin (1..3) == true)

	Source   Edit   

template offsetOf[T](t: typedesc[T]; member: untyped): int

	Source   Edit   

template offsetOf[T](value: T; member: untyped): int

	Source   Edit   

template once(body: untyped): untyped

Executes a block of code only once (the first time the block is reached).

proc draw(t: Triangle) =
  once:
	graphicsInit()
  line(t.p1, t.p2)
  line(t.p2, t.p3)
  line(t.p3, t.p1)

	Source   Edit   

template rangeCheck(cond)

	Helper for performing user-defined range checks. Such checks will be performed only when the rangechecks compile-time option is enabled. Source   Edit   

template realloc(p: pointer; newSize: Natural): pointer

	Grows or shrinks a given memory block.

	If p is nil then a new memory block is returned. In either way the block has at least newSize bytes. If newSize == 0 and p is not nil realloc calls dealloc(p). In other cases the block has to be freed with dealloc(block).

	The allocated memory belongs to its allocating thread! Use reallocShared to reallocate from a shared heap.
	Source   Edit   

template realloc0(p: pointer; oldSize, newSize: Natural): pointer

	Grows or shrinks a given memory block.

	If p is nil then a new memory block is returned. In either way the block has at least newSize bytes. If newSize == 0 and p is not nil realloc calls dealloc(p). In other cases the block has to be freed with dealloc(block).

	The block is initialized with all bytes containing zero, so it is somewhat safer then realloc

	The allocated memory belongs to its allocating thread! Use reallocShared to reallocate from a shared heap.
	Source   Edit   

template reallocShared(p: pointer; newSize: Natural): pointer

	Grows or shrinks a given memory block on the heap.

	If p is nil then a new memory block is returned. In either way the block has at least newSize bytes. If newSize == 0 and p is not nil reallocShared calls deallocShared(p). In other cases the block has to be freed with deallocShared.
	Source   Edit   

template reallocShared0(p: pointer; oldSize, newSize: Natural): pointer

	Grows or shrinks a given memory block on the heap.

	When growing, the new bytes of the block is initialized with all bytes containing zero, so it is somewhat safer then reallocShared

	If p is nil then a new memory block is returned. In either way the block has at least newSize bytes. If newSize == 0 and p is not nil reallocShared calls deallocShared(p). In other cases the block has to be freed with deallocShared.
	Source   Edit   

template unlikely(val: bool): bool

Hints the optimizer that val is likely going to be false.

You can use this proc to decorate a branch condition. On certain platforms this can help the processor predict better which branch is going to be run. Example:

for value in inputValues:
  if unlikely(value > 100):
	echo "Value too big!"
  else:
	process(value)

	On backends without branch prediction (JS and the nimscript VM), this template will not affect code execution.
	Source   Edit   

template unown(x: typed): untyped

	Source   Edit   


Core
std/atomics


std/atomics
Source   Edit  

Types and operations for atomic operations and lockless algorithms.

Unstable API.

Example:

import std/atomics
# Atomic
var loc: Atomic[int]
loc.store(4)
assert loc.load == 4
loc.store(2)
assert loc.load(moRelaxed) == 2
loc.store(9)
assert loc.load(moAcquire) == 9
loc.store(0, moRelease)
assert loc.load == 0

assert loc.exchange(7) == 0
assert loc.load == 7

var expected = 7
assert loc.compareExchange(expected, 5, moRelaxed, moRelaxed)
assert expected == 7
assert loc.load == 5

assert not loc.compareExchange(expected, 12, moRelaxed, moRelaxed)
assert expected == 5
assert loc.load == 5

assert loc.fetchAdd(1) == 5
assert loc.fetchAdd(2) == 6
assert loc.fetchSub(3) == 8

loc.atomicInc(1)
assert loc.load == 6

# AtomicFlag
var flag: AtomicFlag

assert not flag.testAndSet
assert flag.testAndSet
flag.clear(moRelaxed)
assert not flag.testAndSet

Types

Atomic[T] {.importcpp: "std::atomic", completeStruct.} = object

	An atomic object with underlying type T. Source   Edit   

AtomicFlag {.importcpp: "std::atomic_flag", size: 1.} = object

	An atomic boolean state. Source   Edit   

MemoryOrder {.importcpp: "std::memory_order".} = enum
  moRelaxed, ## No ordering constraints. Only the atomicity and ordering against
          	## other atomic operations is guaranteed.
  moConsume, ## This ordering is currently discouraged as it's semantics are
          	## being revised. Acquire operations should be preferred.
  moAcquire, ## When applied to a load operation, no reads or writes in the
          	## current thread can be reordered before this operation.
  moRelease, ## When applied to a store operation, no reads or writes in the
          	## current thread can be reorderd after this operation.
  moAcquireRelease, ## When applied to a read-modify-write operation, this behaves like
                 	## both an acquire and a release operation.
  moSequentiallyConsistent ## Behaves like Acquire when applied to load, like Release when
                       	## applied to a store and like AcquireRelease when applied to a
                       	## read-modify-write operation.
                       	## Also guarantees that all threads observe the same total ordering
                       	## with other moSequentiallyConsistent operations.

	Specifies how non-atomic operations can be reordered around atomic operations. Source   Edit   

Procs

proc `+=`[T: SomeInteger](location: var Atomic[T]; value: T) {.inline.}

	Atomically increments the atomic integer by some value. Source   Edit   

proc `-=`[T: SomeInteger](location: var Atomic[T]; value: T) {.inline.}

	Atomically decrements the atomic integer by some value. Source   Edit   

proc atomicDec[T: SomeInteger](location: var Atomic[T]; value: T = 1) {.inline.}

	Atomically decrements the atomic integer by some value. Source   Edit   

proc atomicInc[T: SomeInteger](location: var Atomic[T]; value: T = 1) {.inline.}

	Atomically increments the atomic integer by some value. Source   Edit   

proc clear(location: var AtomicFlag;
       	order: MemoryOrder = moSequentiallyConsistent) {.
	importcpp: "#.clear(@)", header: "<atomic>", ....}

	Atomically sets the value of the atomic flag to false. Source   Edit   

proc compareExchange[T](location: var Atomic[T]; expected: var T; desired: T;
                    	order: MemoryOrder = moSequentiallyConsistent): bool {.
	importcpp: "#.compare_exchange_strong(@)", header: "<atomic>", ....}

	Atomically compares the value of the atomic object with the expected value and performs exchange with the desired one if equal or load if not. Returns true if the exchange was successful. Source   Edit   

proc compareExchange[T](location: var Atomic[T]; expected: var T; desired: T;
                    	success, failure: MemoryOrder): bool {.
	importcpp: "#.compare_exchange_strong(@)", header: "<atomic>", ....}

	Same as above, but allows for different memory orders for success and failure. Source   Edit   

proc compareExchangeWeak[T](location: var Atomic[T]; expected: var T;
                        	desired: T;
                        	order: MemoryOrder = moSequentiallyConsistent): bool {.
	importcpp: "#.compare_exchange_weak(@)", header: "<atomic>", ....}

	Same as above, but is allowed to fail spuriously. Source   Edit   

proc compareExchangeWeak[T](location: var Atomic[T]; expected: var T;
                        	desired: T; success, failure: MemoryOrder): bool {.
	importcpp: "#.compare_exchange_weak(@)", header: "<atomic>", ....}

	Same as above, but allows for different memory orders for success and failure. Source   Edit   

proc exchange[T](location: var Atomic[T]; desired: T;
             	order: MemoryOrder = moSequentiallyConsistent): T {.
	importcpp: "#.exchange(@)", header: "<atomic>", ....}

	Atomically replaces the value of the atomic object with the desired value and returns the old value. Source   Edit   

proc fence(order: MemoryOrder) {.importcpp: "std::atomic_thread_fence(@)",
                             	header: "<atomic>", ....}

	Ensures memory ordering without using atomic operations. Source   Edit   

proc fetchAdd[T: SomeInteger](location: var Atomic[T]; value: T;
                          	order: MemoryOrder = moSequentiallyConsistent): T {.
	importcpp: "#.fetch_add(@)", header: "<atomic>", ....}

	Atomically adds a value to the atomic integer and returns the original value. Source   Edit   

proc fetchAnd[T: SomeInteger](location: var Atomic[T]; value: T;
                          	order: MemoryOrder = moSequentiallyConsistent): T {.
	importcpp: "#.fetch_and(@)", header: "<atomic>", ....}

	Atomically replaces the atomic integer with it's bitwise AND with the specified value and returns the original value. Source   Edit   

proc fetchOr[T: SomeInteger](location: var Atomic[T]; value: T;
                         	order: MemoryOrder = moSequentiallyConsistent): T {.
	importcpp: "#.fetch_or(@)", header: "<atomic>", ....}

	Atomically replaces the atomic integer with it's bitwise OR with the specified value and returns the original value. Source   Edit   

proc fetchSub[T: SomeInteger](location: var Atomic[T]; value: T;
                          	order: MemoryOrder = moSequentiallyConsistent): T {.
	importcpp: "#.fetch_sub(@)", header: "<atomic>", ....}

	Atomically subtracts a value to the atomic integer and returns the original value. Source   Edit   

proc fetchXor[T: SomeInteger](location: var Atomic[T]; value: T;
                          	order: MemoryOrder = moSequentiallyConsistent): T {.
	importcpp: "#.fetch_xor(@)", header: "<atomic>", ....}

	Atomically replaces the atomic integer with it's bitwise XOR with the specified value and returns the original value. Source   Edit   

proc load[T](location: var Atomic[T];
         	order: MemoryOrder = moSequentiallyConsistent): T {.
	importcpp: "#.load(@)", header: "<atomic>", ....}

	Atomically obtains the value of the atomic object. Source   Edit   

proc signalFence(order: MemoryOrder) {.importcpp: "std::atomic_signal_fence(@)",
                                   	header: "<atomic>", ....}

	Prevents reordering of accesses by the compiler as would fence, but inserts no CPU instructions for memory ordering. Source   Edit   

proc store[T](location: var Atomic[T]; desired: T;
          	order: MemoryOrder = moSequentiallyConsistent) {.
	importcpp: "#.store(@)", header: "<atomic>", ....}

	Atomically replaces the value of the atomic object with the desired value. Source   Edit   

proc testAndSet(location: var AtomicFlag;
            	order: MemoryOrder = moSequentiallyConsistent): bool {.
	importcpp: "#.test_and_set(@)", header: "<atomic>", ....}

	Atomically sets the atomic flag to true and returns the original value. Source   Edit   


std/bitops

std/bitops
Source   Edit  
This module implements a series of low level methods for bit manipulation.
By default, compiler intrinsics are used where possible to improve performance on supported compilers: GCC, LLVM_GCC, CLANG, VCC, ICC.
The module will fallback to pure nim procs in case the backend is not supported. You can also use the flag noIntrinsicsBitOpts to disable compiler intrinsics.
This module is also compatible with other backends: JavaScript, NimScript as well as the compiletime VM.
As a result of using optimized functions/intrinsics, some functions can return undefined results if the input is invalid. You can use the flag noUndefinedBitOpts to force predictable behaviour for all input, causing a small performance hit.
At this time only fastLog2, firstSetBit, countLeadingZeroBits and countTrailingZeroBits may return undefined and/or platform dependent values if given invalid input.
Imports
macros, since, bitops_utils, countbits_impl
Types
BitsRange[T] = range[0 .. sizeof(T) * 8 - 1]
A range with all bit positions for type T. Source   Edit  
Procs
func bitnot[T: SomeInteger](x: T): T {.magic: "BitnotI", ....}
Computes the bitwise complement of the integer x. Source   Edit  
proc bitslice[T: SomeInteger](v: var T; slice: Slice[int]) {.inline.}
Mutates v into an extracted (and shifted) slice of bits from v.
Example:
var x = 0b101110
x.bitslice(2 .. 4)
doAssert x == 0b011
Source   Edit  
func bitsliced[T: SomeInteger](v: T; slice: Slice[int]): T {.inline.}
Returns an extracted (and shifted) slice of bits from v.
Example:
doAssert 0b10111.bitsliced(2 .. 4) == 0b101
doAssert 0b11100.bitsliced(0 .. 2) == 0b100
doAssert 0b11100.bitsliced(0 ..< 3) == 0b100
Source   Edit  
proc clearBit[T: SomeInteger](v: var T; bit: BitsRange[T]) {.inline.}
Mutates v, with the bit at position bit set to 0.
Example:
var v = 0b0000_0011'u8
v.clearBit(1'u8)
doAssert v == 0b0000_0001'u8
Source   Edit  
proc clearMask[T: SomeInteger](v: var T; mask: T) {.inline.}
Mutates v, with all the 1 bits from mask set to 0.
Effectively maps to a bitand operation with an inverted mask.
Example:
var v = 0b0000_0011'u8
v.clearMask(0b0000_1010'u8)
doAssert v == 0b0000_0001'u8
Source   Edit  
proc clearMask[T: SomeInteger](v: var T; slice: Slice[int]) {.inline.}
Mutates v, with all the 1 bits in the range of slice set to 0.
Effectively maps to a bitand operation with an inverted mask.
Example:
var v = 0b0000_0011'u8
v.clearMask(1 .. 3)
doAssert v == 0b0000_0001'u8
Source   Edit  
func clearMasked[T: SomeInteger](v, mask: T): T {.inline.}
Returns v, with all the 1 bits from mask set to 0.
Effectively maps to a bitand operation with an inverted mask.
Example:
let v = 0b0000_0011'u8
doAssert v.clearMasked(0b0000_1010'u8) == 0b0000_0001'u8
Source   Edit  
func clearMasked[T: SomeInteger](v: T; slice: Slice[int]): T {.inline.}
Returns v, with all the 1 bits in the range of slice set to 0.
Effectively maps to a bitand operation with an inverted mask.
Example:
let v = 0b0000_0011'u8
doAssert v.clearMasked(1 .. 3) == 0b0000_0001'u8
Source   Edit  
func countLeadingZeroBits(x: SomeInteger): int {.inline.}
Returns the number of leading zero bits in an integer. If x is zero, when noUndefinedBitOpts is set, the result is 0, otherwise the result is undefined.
See also:
countTrailingZeroBits proc
Example:
doAssert countLeadingZeroBits(0b0000_0001'u8) == 7
doAssert countLeadingZeroBits(0b0000_0010'u8) == 6
doAssert countLeadingZeroBits(0b0000_0100'u8) == 5
doAssert countLeadingZeroBits(0b0000_1000'u8) == 4
doAssert countLeadingZeroBits(0b0000_1111'u8) == 4
Source   Edit  
func countSetBits(x: SomeInteger): int {.inline.}
Counts the set bits in an integer (also called Hamming weight).
Example:
doAssert countSetBits(0b0000_0011'u8) == 2
doAssert countSetBits(0b1010_1010'u8) == 4
Source   Edit  
func countTrailingZeroBits(x: SomeInteger): int {.inline.}
Returns the number of trailing zeros in an integer. If x is zero, when noUndefinedBitOpts is set, the result is 0, otherwise the result is undefined.
See also:
countLeadingZeroBits proc
Example:
doAssert countTrailingZeroBits(0b0000_0001'u8) == 0
doAssert countTrailingZeroBits(0b0000_0010'u8) == 1
doAssert countTrailingZeroBits(0b0000_0100'u8) == 2
doAssert countTrailingZeroBits(0b0000_1000'u8) == 3
doAssert countTrailingZeroBits(0b0000_1111'u8) == 0
Source   Edit  
func fastLog2(x: SomeInteger): int {.inline.}
Quickly find the log base 2 of an integer. If x is zero, when noUndefinedBitOpts is set, the result is -1, otherwise the result is undefined.
Example:
doAssert fastLog2(0b0000_0001'u8) == 0
doAssert fastLog2(0b0000_0010'u8) == 1
doAssert fastLog2(0b0000_0100'u8) == 2
doAssert fastLog2(0b0000_1000'u8) == 3
doAssert fastLog2(0b0000_1111'u8) == 3
Source   Edit  
func firstSetBit(x: SomeInteger): int {.inline.}
Returns the 1-based index of the least significant set bit of x. If x is zero, when noUndefinedBitOpts is set, the result is 0, otherwise the result is undefined.
Example:
doAssert firstSetBit(0b0000_0001'u8) == 1
doAssert firstSetBit(0b0000_0010'u8) == 2
doAssert firstSetBit(0b0000_0100'u8) == 3
doAssert firstSetBit(0b0000_1000'u8) == 4
doAssert firstSetBit(0b0000_1111'u8) == 1
Source   Edit  
proc flipBit[T: SomeInteger](v: var T; bit: BitsRange[T]) {.inline.}
Mutates v, with the bit at position bit flipped.
Example:
var v = 0b0000_0011'u8
v.flipBit(1'u8)
doAssert v == 0b0000_0001'u8

v = 0b0000_0011'u8
v.flipBit(2'u8)
doAssert v == 0b0000_0111'u8
Source   Edit  
proc flipMask[T: SomeInteger](v: var T; mask: T) {.inline.}
Mutates v, with all the 1 bits from mask flipped.
Effectively maps to a bitxor operation.
Example:
var v = 0b0000_0011'u8
v.flipMask(0b0000_1010'u8)
doAssert v == 0b0000_1001'u8
Source   Edit  
proc flipMask[T: SomeInteger](v: var T; slice: Slice[int]) {.inline.}
Mutates v, with all the 1 bits in the range of slice flipped.
Effectively maps to a bitxor operation.
Example:
var v = 0b0000_0011'u8
v.flipMask(1 .. 3)
doAssert v == 0b0000_1101'u8
Source   Edit  
func flipMasked[T: SomeInteger](v, mask: T): T {.inline.}
Returns v, with all the 1 bits from mask flipped.
Effectively maps to a bitxor operation.
Example:
let v = 0b0000_0011'u8
doAssert v.flipMasked(0b0000_1010'u8) == 0b0000_1001'u8
Source   Edit  
func flipMasked[T: SomeInteger](v: T; slice: Slice[int]): T {.inline.}
Returns v, with all the 1 bits in the range of slice flipped.
Effectively maps to a bitxor operation.
Example:
let v = 0b0000_0011'u8
doAssert v.flipMasked(1 .. 3) == 0b0000_1101'u8
Source   Edit  
proc mask[T: SomeInteger](v: var T; mask: T) {.inline.}
Mutates v, with only the 1 bits from mask matching those of v set to 1.
Effectively maps to a bitand operation.
Example:
var v = 0b0000_0011'u8
v.mask(0b0000_1010'u8)
doAssert v == 0b0000_0010'u8
Source   Edit  
proc mask[T: SomeInteger](v: var T; slice: Slice[int]) {.inline.}
Mutates v, with only the 1 bits in the range of slice matching those of v set to 1.
Effectively maps to a bitand operation.
Example:
var v = 0b0000_1011'u8
v.mask(1 .. 3)
doAssert v == 0b0000_1010'u8
Source   Edit  
proc masked[T: SomeInteger](v, mask: T): T {.inline.}
Returns v, with only the 1 bits from mask matching those of v set to 1.
Effectively maps to a bitand operation.
Example:
let v = 0b0000_0011'u8
doAssert v.masked(0b0000_1010'u8) == 0b0000_0010'u8
Source   Edit  
func masked[T: SomeInteger](v: T; slice: Slice[int]): T {.inline.}
Returns v, with only the 1 bits in the range of slice matching those of v set to 1.
Effectively maps to a bitand operation.
Example:
let v = 0b0000_1011'u8
doAssert v.masked(1 .. 3) == 0b0000_1010'u8
Source   Edit  
func parityBits(x: SomeInteger): int {.inline.}
Calculate the bit parity in an integer. If the number of 1-bits is odd, the parity is 1, otherwise 0.
Example:
doAssert parityBits(0b0000_0000'u8) == 0
doAssert parityBits(0b0101_0001'u8) == 1
doAssert parityBits(0b0110_1001'u8) == 0
doAssert parityBits(0b0111_1111'u8) == 1
Source   Edit  
func popcount(x: SomeInteger): int {.inline.}
Alias for countSetBits (Hamming weight). Source   Edit  
func reverseBits[T: SomeUnsignedInt](x: T): T
Return the bit reversal of x.
Example:
doAssert reverseBits(0b10100100'u8) == 0b00100101'u8
doAssert reverseBits(0xdd'u8) == 0xbb'u8
doAssert reverseBits(0xddbb'u16) == 0xddbb'u16
doAssert reverseBits(0xdeadbeef'u32) == 0xf77db57b'u32
Source   Edit  
func rotateLeftBits[T: SomeUnsignedInt](value: T;
                                        shift: range[0 .. (sizeof(T) * 8)]): T {.
    inline.}
Left-rotate bits in a value.
Example:
doAssert rotateLeftBits(0b0110_1001'u8, 4) == 0b1001_0110'u8
doAssert rotateLeftBits(0b00111100_11000011'u16, 8) ==
  0b11000011_00111100'u16
doAssert rotateLeftBits(0b0000111111110000_1111000000001111'u32, 16) ==
  0b1111000000001111_0000111111110000'u32
doAssert rotateLeftBits(0b00000000111111111111111100000000_11111111000000000000000011111111'u64, 32) ==
  0b11111111000000000000000011111111_00000000111111111111111100000000'u64
Source   Edit  
func rotateRightBits[T: SomeUnsignedInt](value: T;
    shift: range[0 .. (sizeof(T) * 8)]): T {.inline.}
Right-rotate bits in a value.
Example:
doAssert rotateRightBits(0b0110_1001'u8, 4) == 0b1001_0110'u8
doAssert rotateRightBits(0b00111100_11000011'u16, 8) ==
  0b11000011_00111100'u16
doAssert rotateRightBits(0b0000111111110000_1111000000001111'u32, 16) ==
  0b1111000000001111_0000111111110000'u32
doAssert rotateRightBits(0b00000000111111111111111100000000_11111111000000000000000011111111'u64, 32) ==
  0b11111111000000000000000011111111_00000000111111111111111100000000'u64
Source   Edit  
proc setBit[T: SomeInteger](v: var T; bit: BitsRange[T]) {.inline.}
Mutates v, with the bit at position bit set to 1.
Example:
var v = 0b0000_0011'u8
v.setBit(5'u8)
doAssert v == 0b0010_0011'u8
Source   Edit  
proc setMask[T: SomeInteger](v: var T; mask: T) {.inline.}
Mutates v, with all the 1 bits from mask set to 1.
Effectively maps to a bitor operation.
Example:
var v = 0b0000_0011'u8
v.setMask(0b0000_1010'u8)
doAssert v == 0b0000_1011'u8
Source   Edit  
proc setMask[T: SomeInteger](v: var T; slice: Slice[int]) {.inline.}
Mutates v, with all the 1 bits in the range of slice set to 1.
Effectively maps to a bitor operation.
Example:
var v = 0b0000_0011'u8
v.setMask(2 .. 3)
doAssert v == 0b0000_1111'u8
Source   Edit  
func setMasked[T: SomeInteger](v, mask: T): T {.inline.}
Returns v, with all the 1 bits from mask set to 1.
Effectively maps to a bitor operation.
Example:
let v = 0b0000_0011'u8
doAssert v.setMasked(0b0000_1010'u8) == 0b0000_1011'u8
Source   Edit  
func setMasked[T: SomeInteger](v: T; slice: Slice[int]): T {.inline.}
Returns v, with all the 1 bits in the range of slice set to 1.
Effectively maps to a bitor operation.
Example:
let v = 0b0000_0011'u8
doAssert v.setMasked(2 .. 3) == 0b0000_1111'u8
Source   Edit  
proc testBit[T: SomeInteger](v: T; bit: BitsRange[T]): bool {.inline.}
Returns true if the bit in v at positions bit is set to 1.
Example:
let v = 0b0000_1111'u8
doAssert v.testBit(0)
doAssert not v.testBit(7)
Source   Edit  
func toMask[T: SomeInteger](slice: Slice[int]): T {.inline.}
Creates a bitmask based on a slice of bits.
Example:
doAssert toMask[int32](1 .. 3) == 0b1110'i32
doAssert toMask[int32](0 .. 3) == 0b1111'i32
Source   Edit  
Macros
macro bitand[T: SomeInteger](x, y: T; z: varargs[T]): T
Computes the bitwise and of all arguments collectively. Source   Edit  
macro bitor[T: SomeInteger](x, y: T; z: varargs[T]): T
Computes the bitwise or of all arguments collectively. Source   Edit  
macro bitxor[T: SomeInteger](x, y: T; z: varargs[T]): T
Computes the bitwise xor of all arguments collectively. Source   Edit  
macro clearBits(v: typed; bits: varargs[typed]): untyped
Mutates v, with the bits at positions bits set to 0.
Example:
var v = 0b1111_1111'u8
v.clearBits(1, 3, 5, 7)
doAssert v == 0b0101_0101'u8
Source   Edit  
macro flipBits(v: typed; bits: varargs[typed]): untyped
Mutates v, with the bits at positions bits set to 0.
Example:
var v = 0b0000_1111'u8
v.flipBits(1, 3, 5, 7)
doAssert v == 0b1010_0101'u8
Source   Edit  
macro setBits(v: typed; bits: varargs[typed]): untyped
Mutates v, with the bits at positions bits set to 1.
Example:
var v = 0b0000_0011'u8
v.setBits(3, 5, 7)
doAssert v == 0b1010_1011'u8
Source   Edit  



std/compilesettings


std/compilesettings
Source   Edit  

This module allows querying the compiler about diverse configuration settings. See also compileOption.
Types

MultipleValueSetting {.pure.} = enum
  nimblePaths,          	## the nimble path(s)
  searchPaths,          	## the search path for modules
  lazyPaths,            	## experimental: even more paths
  commandArgs,          	## the arguments passed to the Nim compiler
  cincludes,            	## the #include paths passed to the C/C++ compiler
  clibs                  	## libraries passed to the C/C++ compiler

	settings resulting in a seq of string values Source   Edit   

SingleValueSetting {.pure.} = enum
  arguments,            	## experimental: the arguments passed after '-r'
  outFile,              	## experimental: the output file
  outDir,               	## the output directory
  nimcacheDir,          	## the location of the 'nimcache' directory
  projectName,          	## the project's name that is being compiled
  projectPath,          	## experimental: some path to the project that is being compiled
  projectFull,          	## the full path to the project that is being compiled
  command, ## experimental: the command (e.g. 'c', 'cpp', 'doc') passed to
        	## the Nim compiler
  commandLine,          	## experimental: the command line passed to Nim
  linkOptions,          	## additional options passed to the linker
  compileOptions,       	## additional options passed to the C/C++ compiler
  ccompilerPath,        	## the path to the C/C++ compiler
  backend, ## the backend (eg: c|cpp|objc|js); both `nim doc --backend:js`
        	## and `nim js` would imply backend=js
  libPath,              	## the absolute path to the stdlib library, i.e. nim's `--lib`, since 1.5.1
  gc {.....},    	## gc selected
  mm                     	## memory management selected

	settings resulting in a single string value Source   Edit   

Procs

proc querySetting(setting: SingleValueSetting): string {.compileTime,
	noSideEffect, ....}

Can be used to get a string compile-time option.

See also:

	compileOption for on|off options
	compileOption for enum options

Example:

const nimcache = querySetting(SingleValueSetting.nimcacheDir)

	Source   Edit   

proc querySettingSeq(setting: MultipleValueSetting): seq[string] {.compileTime,
	noSideEffect, ....}

Can be used to get a multi-string compile-time option.

See also:

	compileOption for on|off options
	compileOption for enum options

Example:

const nimblePaths = querySettingSeq(MultipleValueSetting.nimblePaths)


std/cpuinfo


std/cpuinfo
Source   Edit  

This module implements a proc to determine the number of CPUs / cores.

Example:

import std/cpuinfo
doAssert countProcessors() > 0

Imports

win_getsysteminfo

Procs

proc countProcessors(): int {.....}

	Returns the number of the processors/cores the machine has. Returns 0 if it cannot be detected. Source   Edit   



std/effecttraits


std/effecttraits
Source   Edit  

This module provides access to the inferred .raises effects for Nim's macro system. Since: Version 1.4.

One can test for the existence of this standard module via defined(nimHasEffectTraitsModule).

Imports

macros

Procs

proc getForbidsList(fn: NimNode): NimNode {.....}

	Extracts the .forbids list of the func/proc/etc fn. fn has to be a resolved symbol of kind nnkSym. This implies that the macro that calls this proc should accept typed arguments and not untyped arguments. Source   Edit   

proc getRaisesList(fn: NimNode): NimNode {.....}

	Extracts the .raises list of the func/proc/etc fn. fn has to be a resolved symbol of kind nnkSym. This implies that the macro that calls this proc should accept typed arguments and not untyped arguments. Source   Edit   

proc getTagsList(fn: NimNode): NimNode {.....}

	Extracts the .tags list of the func/proc/etc fn. fn has to be a resolved symbol of kind nnkSym. This implies that the macro that calls this proc should accept typed arguments and not untyped arguments. Source   Edit   

proc hasNoSideEffects(fn: NimNode): bool {.....}

	Return true if the func/proc/etc fn has noSideEffect. fn has to be a resolved symbol of kind nnkSym. This implies that the macro that calls this proc should accept typed arguments and not untyped arguments. Source   Edit   

proc isGcSafe(fn: NimNode): bool {.....}

	Return true if the func/proc/etc fn is gcsafe. fn has to be a resolved symbol of kind nnkSym. This implies that the macro that calls this proc should accept typed arguments and not untyped arguments. Source   Edit   



std/endians


std/endians
Source   Edit  

This module contains helpers that deal with different byte orders (endian).

Endianness is the order of bytes of a value in memory. Big-endian means that the most significant byte is stored at the smallest memory address, while little endian means that the least-significant byte is stored at the smallest address. See also https://en.wikipedia.org/wiki/Endianness.

Unstable API.

Procs

proc bigEndian16(outp, inp: pointer) {.inline, ....}

	Copies inp to outp, storing it in 16-bit big-endian order. Both buffers are supposed to contain at least 2 bytes. Source   Edit   

proc bigEndian32(outp, inp: pointer) {.inline, ....}

	Copies inp to outp, storing it in 32-bit big-endian order. Both buffers are supposed to contain at least 4 bytes. Source   Edit   

proc bigEndian64(outp, inp: pointer) {.inline, ....}

	Copies inp to outp, storing it in 64-bit big-endian order. Both buffers are supposed to contain at least 8 bytes. Source   Edit   

proc littleEndian16(outp, inp: pointer) {.inline, ....}

	Copies inp to outp, storing it in 16-bit little-endian order. Both buffers are supposed to contain at least 2 bytes. Source   Edit   

proc littleEndian32(outp, inp: pointer) {.inline, ....}

	Copies inp to outp, storing it in 32-bit little-endian order. Both buffers are supposed to contain at least 4 bytes. Source   Edit   

proc littleEndian64(outp, inp: pointer) {.inline, ....}

	Copies inp to outp, storing it in 64-bit little-endian order. Both buffers are supposed to contain at least 8 bytes. Source   Edit   

proc swapEndian16(outp, inp: pointer) {.inline, noSideEffect, ....}

Copies inp to outp, reversing the byte order. Both buffers are supposed to contain at least 2 bytes.

Example:

var a = [1'u8, 2]
var b: array[2, uint8]
swapEndian16(addr b, addr a)
assert b == [2'u8, 1]

	Source   Edit   

proc swapEndian32(outp, inp: pointer) {.inline, noSideEffect, ....}

Copies inp to outp, reversing the byte order. Both buffers are supposed to contain at least 4 bytes.

Example:

var a = [1'u8, 2, 3, 4]
var b: array[4, uint8]
swapEndian32(addr b, addr a)
assert b == [4'u8, 3, 2, 1]

	Source   Edit   

proc swapEndian64(outp, inp: pointer) {.inline, noSideEffect, ....}

Copies inp to outp, reversing the byte order. Both buffers are supposed to contain at least 8 bytes.

Example:

var a = [1'u8, 2, 3, 4, 5, 6, 7, 8]
var b: array[8, uint8]
swapEndian64(addr b, addr a)
assert b == [8'u8, 7, 6, 5, 4, 3, 2, 1]


std/locks 


std/locks
Source   Edit  

This module contains Nim's support for locks and condition vars.
Imports

syslocks

Types

Cond = SysCond

	Nim condition variable Source   Edit   

Lock = SysLock

	Nim lock; whether this is re-entrant or not is unspecified! Source   Edit   

Procs

proc `$`(lock: Lock): string {.....}

	Source   Edit   

proc acquire(lock: var Lock) {.inline, ....}

	Acquires the given lock. Source   Edit   

proc broadcast(cond: var Cond) {.inline, ....}

	Unblocks all threads currently blocked on the specified condition variable cond. Source   Edit   

proc deinitCond(cond: var Cond) {.inline, ....}

	Frees the resources associated with the condition variable. Source   Edit   

proc deinitLock(lock: var Lock) {.inline, ....}

	Frees the resources associated with the lock. Source   Edit   

proc initCond(cond: var Cond) {.inline, ....}

	Initializes the given condition variable. Source   Edit   

proc initLock(lock: var Lock) {.inline, ....}

	Initializes the given lock. Source   Edit   

proc release(lock: var Lock) {.inline, ....}

	Releases the given lock. Source   Edit   

proc signal(cond: var Cond) {.inline, ....}

	Sends a signal to the condition variable cond. Source   Edit   

proc tryAcquire(lock: var Lock): bool {.inline, ....}

	Tries to acquire the given lock. Returns true on success. Source   Edit   

proc wait(cond: var Cond; lock: var Lock) {.inline, ....}

	Waits on the condition variable cond. Source   Edit   

Templates

template withLock(a: Lock; body: untyped)

	Acquires the given lock, executes the statements in body and releases the lock after the statements finish executing. Source   Edit   


std/macrocache


std/macrocache
Source   Edit  

This module provides an API for macros to collect compile-time information across module boundaries. It should be used instead of global {.compileTime.} variables as those break incremental compilation.

The main feature of this module is that if you create CacheTables or any other Cache types with the same name in different modules, their content will be shared, meaning that you can fill a CacheTable in one module, and iterate over its contents in another.

Example:

import std/macrocache
import std/macros

const mcTable = CacheTable"myTable"
const mcSeq = CacheSeq"mySeq"
const mcCounter = CacheCounter"myCounter"

static:
  # add new key "val" with the value `myval`
  let myval = newLit("hello ic")
  mcTable["val"] = myval
  assert mcTable["val"].kind == nnkStrLit

# Can access the same cache from different static contexts
# All the information is retained
static:
  # get value from `mcTable` and add it to `mcSeq`
  mcSeq.add(mcTable["val"])
  assert mcSeq.len == 1

static:
  assert mcSeq[0].strVal == "hello ic"

  # increase `mcCounter` by 3
  mcCounter.inc(3)
  assert mcCounter.value == 3

Types

CacheCounter = distinct string

	Compile-time counter, uses int for storing the count. Source   Edit   

CacheSeq = distinct string

	Compile-time sequence of NimNodes. Source   Edit   

CacheTable = distinct string

	Compile-time table of key-value pairs.

	Keys are strings and values are NimNodes.
	Source   Edit   

Procs

proc `[]`(s: CacheSeq; i: BackwardsIndex): NimNode {.....}

Returns the ith last value from s.

Example:

import std/macros

const mySeq = CacheSeq"backTest"
static:
  mySeq &= newLit(42)
  mySeq &= newLit(7)
  assert mySeq[^1].intVal == 7  # Last item
  assert mySeq[^2].intVal == 42 # Second last item

	Source   Edit   

proc `[]`(s: CacheSeq; i: int): NimNode {.magic: "NcsAt", ....}

Returns the ith value from s.

Example:

import std/macros

const mySeq = CacheSeq"subTest"
static:
  mySeq.add(newLit(42))
  assert mySeq[0].intVal == 42

	Source   Edit   

proc `[]`(t: CacheTable; key: string): NimNode {.magic: "NctGet", ....}

Retrieves the NimNode value at t[key].

Example:

import std/macros

const mcTable = CacheTable"subTest"
static:
  mcTable["toAdd"] = newStmtList()

  # get the NimNode back
  assert mcTable["toAdd"].kind == nnkStmtList

	Source   Edit   

proc `[]=`(t: CacheTable; key: string; value: NimNode) {.magic: "NctPut",
	....}

Inserts a (key, value) pair into t.
Warning: key has to be unique! Assigning value to a key that is already in the table will result in a compiler error.

Example:

import std/macros

const mcTable = CacheTable"subTest"
static:
  # assign newLit(5) to the key "value"
  mcTable["value"] = newLit(5)

  # check that we can get the value back
  assert mcTable["value"].kind == nnkIntLit

	Source   Edit   

proc add(s: CacheSeq; value: NimNode) {.magic: "NcsAdd", ....}

Adds value to s.

Example:

import std/macros
const mySeq = CacheSeq"addTest"

static:
  mySeq.add(newLit(5))
  mySeq.add(newLit("hello ic"))

  assert mySeq.len == 2
  assert mySeq[1].strVal == "hello ic"

	Source   Edit   

proc contains(t: CacheTable; key: string): bool {.inline, ....}

Alias of hasKey for use with the in operator.

Example:

import std/macros
const mcTable = CacheTable"containsEx"
static:
  mcTable["foo"] = newEmptyNode()
  # Will be true since we gave it a value before
  assert "foo" in mcTable

	Source   Edit   

proc hasKey(t: CacheTable; key: string): bool {.....}

Returns true if key is in the table t.

See also:

	contains proc for use with the in operator

Example:

import std/macros
const mcTable = CacheTable"hasKeyEx"
static:
  assert not mcTable.hasKey("foo")
  mcTable["foo"] = newEmptyNode()
  # Will now be true since we inserted a value
  assert mcTable.hasKey("foo")

	Source   Edit   

proc inc(c: CacheCounter; by = 1) {.magic: "NccInc", ....}

Increments the counter c with the value by.

Example:

static:
  let counter = CacheCounter"incTest"
  inc counter
  inc counter, 5

  assert counter.value == 6

	Source   Edit   

proc incl(s: CacheSeq; value: NimNode) {.magic: "NcsIncl", ....}

Adds value to s.
Hint: This doesn't do anything if value is already in s.

Example:

import std/macros
const mySeq = CacheSeq"inclTest"

static:
  mySeq.incl(newLit(5))
  mySeq.incl(newLit(5))

  # still one element
  assert mySeq.len == 1

	Source   Edit   

proc len(s: CacheSeq): int {.magic: "NcsLen", ....}

Returns the length of s.

Example:

import std/macros

const mySeq = CacheSeq"lenTest"
static:
  let val = newLit("helper")
  mySeq.add(val)
  assert mySeq.len == 1

  mySeq.add(val)
  assert mySeq.len == 2

	Source   Edit   

proc len(t: CacheTable): int {.magic: "NctLen", ....}

Returns the number of elements in t.

Example:

import std/macros

const dataTable = CacheTable"lenTest"
static:
  dataTable["key"] = newLit(5)
  assert dataTable.len == 1

	Source   Edit   

proc value(c: CacheCounter): int {.magic: "NccValue", ....}

Returns the value of a counter c.

Example:

static:
  let counter = CacheCounter"valTest"
  # default value is 0
  assert counter.value == 0

  inc counter
  assert counter.value == 1

	Source   Edit   

Iterators

iterator items(s: CacheSeq): NimNode {.....}

Iterates over each item in s.

Example:

import std/macros
const myseq = CacheSeq"itemsTest"

static:
  myseq.add(newLit(5))
  myseq.add(newLit(42))

  for val in myseq:
	# check that all values in `myseq` are int literals
	assert val.kind == nnkIntLit

	Source   Edit   

iterator pairs(t: CacheTable): (string, NimNode) {.....}

Iterates over all (key, value) pairs in t.

Example:

import std/macros
const mytabl = CacheTable"values"

static:
  mytabl["intVal"] = newLit(5)
  mytabl["otherVal"] = newLit(6)
  for key, val in mytabl:
	# make sure that we actually get the same keys
	assert key in ["intVal", "otherVal"]

	# all vals are int literals
	assert val.kind == nnkIntLit

	Source   Edit   



std/macros


std/macros
Source   Edit  

This module contains the interface to the compiler's abstract syntax tree (AST). Macros operate on this tree.

See also:

	macros tutorial
	macros section in Nim manual

The AST in Nim

This section describes how the AST is modelled with Nim's type system. The AST consists of nodes (NimNode) with a variable number of children. Each node has a field named kind which describes what the node contains:

type
  NimNodeKind = enum 	## kind of a node; only explanatory
	nnkNone,         	## invalid node kind
	nnkEmpty,        	## empty node
	nnkIdent,        	## node contains an identifier
	nnkIntLit,       	## node contains an int literal (example: 10)
	nnkStrLit,       	## node contains a string literal (example: "abc")
	nnkNilLit,       	## node contains a nil literal (example: nil)
	nnkCaseStmt,     	## node represents a case statement
	...              	## many more
 
  NimNode = ref NimNodeObj
  NimNodeObj = object
	case kind: NimNodeKind       	## the node's kind
	of nnkNone, nnkEmpty, nnkNilLit:
  	discard                    	## node contains no additional fields
	of nnkCharLit..nnkUInt64Lit:
  	intVal: BiggestInt         	## the int literal
	of nnkFloatLit..nnkFloat64Lit:
  	floatVal: BiggestFloat     	## the float literal
	of nnkStrLit..nnkTripleStrLit, nnkCommentStmt, nnkIdent, nnkSym:
  	strVal: string             	## the string literal
	else:
  	sons: seq[NimNode]         	## the node's sons (or children)

For the NimNode type, the [] operator has been overloaded: n[i] is n's i-th child.

To specify the AST for the different Nim constructs, the notation nodekind(son1, son2, ...) or nodekind(value) or nodekind(field=value) is used.

Some child may be missing. A missing child is a node of kind nnkEmpty; a child can never be nil.
Leaf nodes/Atoms

A leaf of the AST often corresponds to a terminal symbol in the concrete syntax. Note that the default float in Nim maps to float64 such that the default AST for a float is nnkFloat64Lit as below.
Nim expression	Corresponding AST
42	nnkIntLit(intVal = 42)
42'i8	nnkInt8Lit(intVal = 42)
42'i16	nnkInt16Lit(intVal = 42)
42'i32	nnkInt32Lit(intVal = 42)
42'i64	nnkInt64Lit(intVal = 42)
42'u8	nnkUInt8Lit(intVal = 42)
42'u16	nnkUInt16Lit(intVal = 42)
42'u32	nnkUInt32Lit(intVal = 42)
42'u64	nnkUInt64Lit(intVal = 42)
42.0	nnkFloat64Lit(floatVal = 42.0)
42.0'f32	nnkFloat32Lit(floatVal = 42.0)
42.0'f64	nnkFloat64Lit(floatVal = 42.0)
"abc"	nnkStrLit(strVal = "abc")
r"abc"	nnkRStrLit(strVal = "abc")
"""abc"""	nnkTripleStrLit(strVal = "abc")
' '	nnkCharLit(intVal = 32)
nil	nnkNilLit()
myIdentifier	nnkIdent(strVal = "myIdentifier")
myIdentifier	after lookup pass: nnkSym(strVal = "myIdentifier", ...)

Identifiers are nnkIdent nodes. After the name lookup pass these nodes get transferred into nnkSym nodes.
Calls/expressions
Command call

Concrete syntax:

echo "abc", "xyz"

AST:

nnkCommand(
  nnkIdent("echo"),
  nnkStrLit("abc"),
  nnkStrLit("xyz")
)

Call with ()

Concrete syntax:

echo("abc", "xyz")

AST:

nnkCall(
  nnkIdent("echo"),
  nnkStrLit("abc"),
  nnkStrLit("xyz")
)

Infix operator call

Concrete syntax:

"abc" & "xyz"

AST:

nnkInfix(
  nnkIdent("&"),
  nnkStrLit("abc"),
  nnkStrLit("xyz")
)

Note that with multiple infix operators, the command is parsed by operator precedence.

Concrete syntax:

5 + 3 * 4

AST:

nnkInfix(
  nnkIdent("+"),
  nnkIntLit(5),
  nnkInfix(
	nnkIdent("*"),
	nnkIntLit(3),
	nnkIntLit(4)
  )
)

As a side note, if you choose to use infix operators in a prefix form, the AST behaves as a parenthetical function call with nnkAccQuoted, as follows:

Concrete syntax:

`+`(3, 4)

AST:

nnkCall(
  nnkAccQuoted(
	nnkIdent("+")
  ),
  nnkIntLit(3),
  nnkIntLit(4)
)

Prefix operator call

Concrete syntax:

? "xyz"

AST:

nnkPrefix(
  nnkIdent("?"),
  nnkStrLit("abc")
)

Postfix operator call

Note: There are no postfix operators in Nim. However, the nnkPostfix node is used for the asterisk export marker *:

Concrete syntax:

identifier*

AST:

nnkPostfix(
  nnkIdent("*"),
  nnkIdent("identifier")
)

Call with named arguments

Concrete syntax:

writeLine(file=stdout, "hallo")

AST:

nnkCall(
  nnkIdent("writeLine"),
  nnkExprEqExpr(
	nnkIdent("file"),
	nnkIdent("stdout")
  ),
  nnkStrLit("hallo")
)

Call with raw string literal

This is used, for example, in the bindSym examples here and with re"some regexp" in the regular expression module.

Concrete syntax:

echo"abc"

AST:

nnkCallStrLit(
  nnkIdent("echo"),
  nnkRStrLit("hello")
)

Dereference operator []

Concrete syntax:

x[]

AST:

nnkDerefExpr(nnkIdent("x"))

Addr operator

Concrete syntax:

addr(x)

AST:

nnkAddr(nnkIdent("x"))

Cast operator

Concrete syntax:

cast[T](x)

AST:

nnkCast(nnkIdent("T"), nnkIdent("x"))

Object access operator .

Concrete syntax:

x.y

AST:

nnkDotExpr(nnkIdent("x"), nnkIdent("y"))

If you use Nim's flexible calling syntax (as in x.len()), the result is the same as above but wrapped in an nnkCall.
Array access operator []

Concrete syntax:

x[y]

AST:

nnkBracketExpr(nnkIdent("x"), nnkIdent("y"))

Parentheses

Parentheses for affecting operator precedence use the nnkPar node.

Concrete syntax:

(a + b) * c

AST:

nnkInfix(nnkIdent("*"),
  nnkPar(
	nnkInfix(nnkIdent("+"), nnkIdent("a"), nnkIdent("b"))),
  nnkIdent("c"))

Tuple Constructors

Nodes for tuple construction are built with the nnkTupleConstr node.

Concrete syntax:

(1, 2, 3)
(a: 1, b: 2, c: 3)
()

AST:

nnkTupleConstr(nnkIntLit(1), nnkIntLit(2), nnkIntLit(3))
nnkTupleConstr(
  nnkExprColonExpr(nnkIdent("a"), nnkIntLit(1)),
  nnkExprColonExpr(nnkIdent("b"), nnkIntLit(2)),
  nnkExprColonExpr(nnkIdent("c"), nnkIntLit(3)))
nnkTupleConstr()

Since the one tuple would be syntactically identical to parentheses with an expression in them, the parser expects a trailing comma for them. For tuple constructors with field names, this is not necessary.

(1,)
(a: 1)

AST:

nnkTupleConstr(nnkIntLit(1))
nnkTupleConstr(
  nnkExprColonExpr(nnkIdent("a"), nnkIntLit(1)))

Curly braces

Curly braces are used as the set constructor.

Concrete syntax:

{1, 2, 3}

AST:

nnkCurly(nnkIntLit(1), nnkIntLit(2), nnkIntLit(3))

When used as a table constructor, the syntax is different.

Concrete syntax:

{a: 3, b: 5}

AST:

nnkTableConstr(
  nnkExprColonExpr(nnkIdent("a"), nnkIntLit(3)),
  nnkExprColonExpr(nnkIdent("b"), nnkIntLit(5))
)

Brackets

Brackets are used as the array constructor.

Concrete syntax:

[1, 2, 3]

AST:

nnkBracket(nnkIntLit(1), nnkIntLit(2), nnkIntLit(3))

Ranges

Ranges occur in set constructors, case statement branches, or array slices. Internally, the node kind nnkRange is used, but when constructing the AST, construction with .. as an infix operator should be used instead.

Concrete syntax:

1..3

AST:

nnkInfix(
  nnkIdent(".."),
  nnkIntLit(1),
  nnkIntLit(3)
)

Example code:

macro genRepeatEcho() =
  result = newNimNode(nnkStmtList)
 
  var forStmt = newNimNode(nnkForStmt) # generate a for statement
  forStmt.add(ident("i")) # use the variable `i` for iteration
 
  var rangeDef = newNimNode(nnkInfix).add(
	ident("..")).add(
	newIntLitNode(3),newIntLitNode(5)) # iterate over the range 3..5
 
  forStmt.add(rangeDef)
  forStmt.add(newCall(ident("echo"), newIntLitNode(3))) # meat of the loop
  result.add(forStmt)

genRepeatEcho() # gives:
            	# 3
            	# 3
            	# 3

If expression

The representation of the if expression is subtle, but easy to traverse.

Concrete syntax:

if cond1: expr1 elif cond2: expr2 else: expr3

AST:

nnkIfExpr(
  nnkElifExpr(cond1, expr1),
  nnkElifExpr(cond2, expr2),
  nnkElseExpr(expr3)
)

Documentation Comments

Double-hash (##) comments in the code actually have their own format, using strVal to get and set the comment text. Single-hash (#) comments are ignored.

Concrete syntax:

## This is a comment
## This is part of the first comment
stmt1
## Yet another

AST:

nnkCommentStmt() # only appears once for the first two lines!
stmt1
nnkCommentStmt() # another nnkCommentStmt because there is another comment
             	# (separate from the first)

Pragmas

One of Nim's cool features is pragmas, which allow fine-tuning of various aspects of the language. They come in all types, such as adorning procs and objects, but the standalone emit pragma shows the basics with the AST.

Concrete syntax:

{.emit: "#include <stdio.h>".}

AST:

nnkPragma(
  nnkExprColonExpr(
	nnkIdent("emit"),
	nnkStrLit("#include <stdio.h>") # the "argument"
  )
)

As many nnkIdent appear as there are pragmas between {..}. Note that the declaration of new pragmas is essentially the same:

Concrete syntax:

{.pragma: cdeclRename, cdecl.}

AST:

nnkPragma(
  nnkExprColonExpr(
	nnkIdent("pragma"), # this is always first when declaring a new pragma
	nnkIdent("cdeclRename") # the name of the pragma
  ),
  nnkIdent("cdecl")
)

Statements
If statement

The representation of the if statement is subtle, but easy to traverse. If there is no else branch, no nnkElse child exists.

Concrete syntax:

if cond1:
  stmt1
elif cond2:
  stmt2
elif cond3:
  stmt3
else:
  stmt4

AST:

nnkIfStmt(
  nnkElifBranch(cond1, stmt1),
  nnkElifBranch(cond2, stmt2),
  nnkElifBranch(cond3, stmt3),
  nnkElse(stmt4)
)

When statement

Like the if statement, but the root has the kind nnkWhenStmt.
Assignment

Concrete syntax:

x = 42

AST:

nnkAsgn(nnkIdent("x"), nnkIntLit(42))

This is not the syntax for assignment when combined with var, let, or const.
Statement list

Concrete syntax:

stmt1
stmt2
stmt3

AST:

nnkStmtList(stmt1, stmt2, stmt3)

Case statement

Concrete syntax:

case expr1
of expr2, expr3..expr4:
  stmt1
of expr5:
  stmt2
elif cond1:
  stmt3
else:
  stmt4

AST:

nnkCaseStmt(
  expr1,
  nnkOfBranch(expr2, nnkRange(expr3, expr4), stmt1),
  nnkOfBranch(expr5, stmt2),
  nnkElifBranch(cond1, stmt3),
  nnkElse(stmt4)
)

The nnkElifBranch and nnkElse parts may be missing.
While statement

Concrete syntax:

while expr1:
  stmt1

AST:

nnkWhileStmt(expr1, stmt1)

For statement

Concrete syntax:

for ident1, ident2 in expr1:
  stmt1

AST:

nnkForStmt(ident1, ident2, expr1, stmt1)

Try statement

Concrete syntax:

try:
  stmt1
except e1, e2:
  stmt2
except e3:
  stmt3
except:
  stmt4
finally:
  stmt5

AST:

nnkTryStmt(
  stmt1,
  nnkExceptBranch(e1, e2, stmt2),
  nnkExceptBranch(e3, stmt3),
  nnkExceptBranch(stmt4),
  nnkFinally(stmt5)
)

Return statement

Concrete syntax:

return expr1

AST:

nnkReturnStmt(expr1)

Yield statement

Like return, but with nnkYieldStmt kind.

nnkYieldStmt(expr1)

Discard statement

Like return, but with nnkDiscardStmt kind.

nnkDiscardStmt(expr1)

Continue statement

Concrete syntax:

continue

AST:

nnkContinueStmt()

Break statement

Concrete syntax:

break otherLocation

AST:

nnkBreakStmt(nnkIdent("otherLocation"))

If break is used without a jump-to location, nnkEmpty replaces nnkIdent.
Block statement

Concrete syntax:

block name:

AST:

nnkBlockStmt(nnkIdent("name"), nnkStmtList(...))

A block doesn't need an name, in which case nnkEmpty is used.
Asm statement

Concrete syntax:

asm """
  some asm
"""

AST:

nnkAsmStmt(
  nnkEmpty(), # for pragmas
  nnkTripleStrLit("some asm"),
)

Import section

Nim's import statement actually takes different variations depending on what keywords are present. Let's start with the simplest form.

Concrete syntax:

import math

AST:

nnkImportStmt(nnkIdent("math"))

With except, we get nnkImportExceptStmt.

Concrete syntax:

import math except pow

AST:

nnkImportExceptStmt(nnkIdent("math"),nnkIdent("pow"))

Note that import math as m does not use a different node; rather, we use nnkImportStmt with as as an infix operator.

Concrete syntax:

import strutils as su

AST:

nnkImportStmt(
  nnkInfix(
	nnkIdent("as"),
	nnkIdent("strutils"),
	nnkIdent("su")
  )
)

From statement

If we use from ... import, the result is different, too.

Concrete syntax:

from math import pow

AST:

nnkFromStmt(nnkIdent("math"), nnkIdent("pow"))

Using from math as m import pow works identically to the as modifier with the import statement, but wrapped in nnkFromStmt.
Export statement

When you are making an imported module accessible by modules that import yours, the export syntax is pretty straightforward.

Concrete syntax:

export unsigned

AST:

nnkExportStmt(nnkIdent("unsigned"))

Similar to the import statement, the AST is different for export ... except.

Concrete syntax:

export math except pow # we're going to implement our own exponentiation

AST:

nnkExportExceptStmt(nnkIdent("math"),nnkIdent("pow"))

Include statement

Like a plain import statement but with nnkIncludeStmt.

Concrete syntax:

include blocks

AST:

nnkIncludeStmt(nnkIdent("blocks"))

Var section

Concrete syntax:

var a = 3

AST:

nnkVarSection(
  nnkIdentDefs(
	nnkIdent("a"),
	nnkEmpty(), # or nnkIdent(...) if the variable declares the type
	nnkIntLit(3),
  )
)

Note that either the second or third (or both) parameters above must exist, as the compiler needs to know the type somehow (which it can infer from the given assignment).

This is not the same AST for all uses of var. See Procedure declaration for details.
Let section

This is equivalent to var, but with nnkLetSection rather than nnkVarSection.

Concrete syntax:

let a = 3

AST:

nnkLetSection(
  nnkIdentDefs(
	nnkIdent("a"),
	nnkEmpty(), # or nnkIdent(...) for the type
	nnkIntLit(3),
  )
)

Const section

Concrete syntax:

const a = 3

AST:

nnkConstSection(
  nnkConstDef( # not nnkConstDefs!
	nnkIdent("a"),
	nnkEmpty(), # or nnkIdent(...) if the variable declares the type
	nnkIntLit(3), # required in a const declaration!
  )
)

Type section

Starting with the simplest case, a type section appears much like var and const.

Concrete syntax:

type A = int

AST:

nnkTypeSection(
  nnkTypeDef(
	nnkIdent("A"),
	nnkEmpty(),
	nnkIdent("int")
  )
)

Declaring distinct types is similar, with the last nnkIdent wrapped in nnkDistinctTy.

Concrete syntax:

type MyInt = distinct int

AST:

# ...
nnkTypeDef(
  nnkIdent("MyInt"),
  nnkEmpty(),
  nnkDistinctTy(
	nnkIdent("int")
  )
)

If a type section uses generic parameters, they are treated here:

Concrete syntax:

type A[T] = expr1

AST:

nnkTypeSection(
  nnkTypeDef(
	nnkIdent("A"),
	nnkGenericParams(
  	nnkIdentDefs(
    	nnkIdent("T"),
    	nnkEmpty(), # if the type is declared with options, like
                	# ``[T: SomeInteger]``, they are given here
    	nnkEmpty(),
  	)
	)
	expr1,
  )
)

Note that not all nnkTypeDef utilize nnkIdent as their parameter. One of the most common uses of type declarations is to work with objects.

Concrete syntax:

type IO = object of RootObj

AST:

# ...
nnkTypeDef(
  nnkIdent("IO"),
  nnkEmpty(),
  nnkObjectTy(
	nnkEmpty(), # no pragmas here
	nnkOfInherit(
  	nnkIdent("RootObj") # inherits from RootObj
	),
	nnkEmpty()
  )
)

Nim's object syntax is rich. Let's take a look at an involved example in its entirety to see some of the complexities.

Concrete syntax:

type Obj[T] {.inheritable.} = object
  name: string
  case isFat: bool
  of true:
	m: array[100_000, T]
  of false:
	m: array[10, T]

AST:

# ...
nnkPragmaExpr(
  nnkIdent("Obj"),
  nnkPragma(nnkIdent("inheritable"))
),
nnkGenericParams(
nnkIdentDefs(
  nnkIdent("T"),
  nnkEmpty(),
  nnkEmpty())
),
nnkObjectTy(
  nnkEmpty(),
  nnkEmpty(),
  nnkRecList( # list of object parameters
	nnkIdentDefs(
  	nnkIdent("name"),
  	nnkIdent("string"),
  	nnkEmpty()
	),
	nnkRecCase( # case statement within object (not nnkCaseStmt)
  	nnkIdentDefs(
    	nnkIdent("isFat"),
    	nnkIdent("bool"),
    	nnkEmpty()
  	),
  	nnkOfBranch(
    	nnkIdent("true"),
    	nnkRecList( # again, a list of object parameters
      	nnkIdentDefs(
        	nnkIdent("m"),
        	nnkBracketExpr(
          	nnkIdent("array"),
          	nnkIntLit(100000),
          	nnkIdent("T")
        	),
        	nnkEmpty()
    	)
  	),
  	nnkOfBranch(
    	nnkIdent("false"),
    	nnkRecList(
      	nnkIdentDefs(
        	nnkIdent("m"),
        	nnkBracketExpr(
          	nnkIdent("array"),
          	nnkIntLit(10),
          	nnkIdent("T")
        	),
        	nnkEmpty()
      	)
    	)
  	)
	)
  )
)

Using an enum is similar to using an object.

Concrete syntax:

type X = enum
  First

AST:

# ...
nnkEnumTy(
  nnkEmpty(),
  nnkIdent("First") # you need at least one nnkIdent or the compiler complains
)

The usage of concept (experimental) is similar to objects.

Concrete syntax:

type Con = concept x,y,z
  (x & y & z) is string

AST:

# ...
nnkTypeClassTy( # note this isn't nnkConceptTy!
  nnkArgList(
	# ... idents for x, y, z
  )
  # ...
)

Static types, like static[int], use nnkIdent wrapped in nnkStaticTy.

Concrete syntax:

type A[T: static[int]] = object

AST:

# ... within nnkGenericParams
nnkIdentDefs(
  nnkIdent("T"),
  nnkStaticTy(
	nnkIdent("int")
  ),
  nnkEmpty()
)
# ...

In general, declaring types mirrors this syntax (i.e., nnkStaticTy for static, etc.). Examples follow (exceptions marked by *):
Nim type	Corresponding AST
static	nnkStaticTy
tuple	nnkTupleTy
var	nnkVarTy
ptr	nnkPtrTy
ref	nnkRefTy
distinct	nnkDistinctTy
enum	nnkEnumTy
concept	nnkTypeClassTy*
array	nnkBracketExpr(nnkIdent("array"),...*
proc	nnkProcTy
iterator	nnkIteratorTy
object	nnkObjectTy

Take special care when declaring types as proc. The behavior is similar to Procedure declaration, below, but does not treat nnkGenericParams. Generic parameters are treated in the type, not the proc itself.

Concrete syntax:

type MyProc[T] = proc(x: T) {.nimcall.}

AST:

# ...
nnkTypeDef(
  nnkIdent("MyProc"),
  nnkGenericParams( # here, not with the proc
	# ...
  )
  nnkProcTy( # behaves like a procedure declaration from here on
	nnkFormalParams(
  	# ...
	),
	nnkPragma(nnkIdent("nimcall"))
  )
)

The same syntax applies to iterator (with nnkIteratorTy), but does not apply to converter or template.

Type class versions of these nodes generally share the same node kind but without any child nodes. The tuple type class is represented by nnkTupleClassTy, while a proc or iterator type class with pragmas has an nnkEmpty node in place of the nnkFormalParams node of a concrete proc or iterator type node.

type TypeClass = proc {.nimcall.} | ref | tuple

AST:

nnkTypeDef(
  nnkIdent("TypeClass"),
  nnkEmpty(),
  nnkInfix(
	nnkIdent("|"),
	nnkProcTy(
  	nnkEmpty(),
  	nnkPragma(nnkIdent("nimcall"))
	),
	nnkInfix(
  	nnkIdent("|"),
  	nnkRefTy(),
  	nnkTupleClassTy()
	)
  )
)

Mixin statement

Concrete syntax:

mixin x

AST:

nnkMixinStmt(nnkIdent("x"))

Bind statement

Concrete syntax:

bind x

AST:

nnkBindStmt(nnkIdent("x"))

Procedure declaration

Let's take a look at a procedure with a lot of interesting aspects to get a feel for how procedure calls are broken down.

Concrete syntax:

proc hello*[T: SomeInteger](x: int = 3, y: float32): int {.inline.} = discard

AST:

nnkProcDef(
  nnkPostfix(nnkIdent("*"), nnkIdent("hello")), # the exported proc name
  nnkEmpty(), # patterns for term rewriting in templates and macros (not procs)
  nnkGenericParams( # generic type parameters, like with type declaration
	nnkIdentDefs(
  	nnkIdent("T"),
  	nnkIdent("SomeInteger"),
  	nnkEmpty()
	)
  ),
  nnkFormalParams(
	nnkIdent("int"), # the first FormalParam is the return type. nnkEmpty() if there is none
	nnkIdentDefs(
  	nnkIdent("x"),
  	nnkIdent("int"), # type type (required for procs, not for templates)
  	nnkIntLit(3) # a default value
	),
	nnkIdentDefs(
  	nnkIdent("y"),
  	nnkIdent("float32"),
  	nnkEmpty()
	)
  ),
  nnkPragma(nnkIdent("inline")),
  nnkEmpty(), # reserved slot for future use
  nnkStmtList(nnkDiscardStmt(nnkEmpty())) # the meat of the proc
)

There is another consideration. Nim has flexible type identification for its procs. Even though proc(a: int, b: int) and proc(a, b: int) are equivalent in the code, the AST is a little different for the latter.

Concrete syntax:

proc(a, b: int)

AST:

# ...AST as above...
nnkFormalParams(
  nnkEmpty(), # no return here
  nnkIdentDefs(
	nnkIdent("a"), # the first parameter
	nnkIdent("b"), # directly to the second parameter
	nnkIdent("int"), # their shared type identifier
	nnkEmpty(), # default value would go here
  )
),
# ...

When a procedure uses the special var type return variable, the result is different from that of a var section.

Concrete syntax:

proc hello(): var int

AST:

# ...
nnkFormalParams(
  nnkVarTy(
	nnkIdent("int")
  )
)

Iterator declaration

The syntax for iterators is similar to procs, but with nnkIteratorDef replacing nnkProcDef.

Concrete syntax:

iterator nonsense[T](x: seq[T]): float {.closure.} = ...

AST:

nnkIteratorDef(
  nnkIdent("nonsense"),
  nnkEmpty(),
  ...
)

Converter declaration

A converter is similar to a proc.

Concrete syntax:

converter toBool(x: float): bool

AST:

nnkConverterDef(
  nnkIdent("toBool"),
  # ...
)

Template declaration

Templates (as well as macros, as we'll see) have a slightly expanded AST when compared to procs and iterators. The reason for this is term-rewriting macros. Notice the nnkEmpty() as the second argument to nnkProcDef and nnkIteratorDef above? That's where the term-rewriting macros go.

Concrete syntax:

template optOpt{expr1}(a: int): int

AST:

nnkTemplateDef(
  nnkIdent("optOpt"),
  nnkStmtList( # instead of nnkEmpty()
	expr1
  ),
  # follows like a proc or iterator
)

If the template does not have types for its parameters, the type identifiers inside nnkFormalParams just becomes nnkEmpty.
Macro declaration

Macros behave like templates, but nnkTemplateDef is replaced with nnkMacroDef.
Hidden Standard Conversion

var f: float = 1

The type of "f" is float but the type of "1" is actually int. Inserting int into a float is a type error. Nim inserts the nnkHiddenStdConv node around the nnkIntLit node so that the new node has the correct type of float. This works for any auto converted nodes and makes the conversion explicit.
Special node kinds

There are several node kinds that are used for semantic checking or code generation. These are accessible from this module, but should not be used. Other node kinds are especially designed to make AST manipulations easier. These are explained here.

To be written.

Imports

since

Types

BindSymRule = enum
  brClosed,             	## only the symbols in current scope are bound
  brOpen,               	## open for overloaded symbols, but may be a single
                         	## symbol if not ambiguous (the rules match that of
                         	## binding in generics)
  brForceOpen            	## same as brOpen, but it will always be open even
                         	## if not ambiguous (this cannot be achieved with
                         	## any other means in the language currently)

	Specifies how bindSym behaves. The difference between open and closed symbols can be found in manual.html#symbol-lookup-in-generics-open-and-closed-symbols Source   Edit   

LineInfo = object
  filename*: string
  line*, column*: int

	Source   Edit   

NimIdent {.....} = object of RootObj

	Deprecated
	Represents a Nim identifier in the AST. Note: This is only rarely useful, for identifier construction from a string use ident"abc". Source   Edit   

NimNodeKind = enum
  nnkNone, nnkEmpty, nnkIdent, nnkSym, nnkType, nnkCharLit, nnkIntLit,
  nnkInt8Lit, nnkInt16Lit, nnkInt32Lit, nnkInt64Lit, nnkUIntLit, nnkUInt8Lit,
  nnkUInt16Lit, nnkUInt32Lit, nnkUInt64Lit, nnkFloatLit, nnkFloat32Lit,
  nnkFloat64Lit, nnkFloat128Lit, nnkStrLit, nnkRStrLit, nnkTripleStrLit,
  nnkNilLit, nnkComesFrom, nnkDotCall, nnkCommand, nnkCall, nnkCallStrLit,
  nnkInfix, nnkPrefix, nnkPostfix, nnkHiddenCallConv, nnkExprEqExpr,
  nnkExprColonExpr, nnkIdentDefs, nnkVarTuple, nnkPar, nnkObjConstr, nnkCurly,
  nnkCurlyExpr, nnkBracket, nnkBracketExpr, nnkPragmaExpr, nnkRange, nnkDotExpr,
  nnkCheckedFieldExpr, nnkDerefExpr, nnkIfExpr, nnkElifExpr, nnkElseExpr,
  nnkLambda, nnkDo, nnkAccQuoted, nnkTableConstr, nnkBind, nnkClosedSymChoice,
  nnkOpenSymChoice, nnkHiddenStdConv, nnkHiddenSubConv, nnkConv, nnkCast,
  nnkStaticExpr, nnkAddr, nnkHiddenAddr, nnkHiddenDeref, nnkObjDownConv,
  nnkObjUpConv, nnkChckRangeF, nnkChckRange64, nnkChckRange, nnkStringToCString,
  nnkCStringToString, nnkAsgn, nnkFastAsgn, nnkGenericParams, nnkFormalParams,
  nnkOfInherit, nnkImportAs, nnkProcDef, nnkMethodDef, nnkConverterDef,
  nnkMacroDef, nnkTemplateDef, nnkIteratorDef, nnkOfBranch, nnkElifBranch,
  nnkExceptBranch, nnkElse, nnkAsmStmt, nnkPragma, nnkPragmaBlock, nnkIfStmt,
  nnkWhenStmt, nnkForStmt, nnkParForStmt, nnkWhileStmt, nnkCaseStmt,
  nnkTypeSection, nnkVarSection, nnkLetSection, nnkConstSection, nnkConstDef,
  nnkTypeDef, nnkYieldStmt, nnkDefer, nnkTryStmt, nnkFinally, nnkRaiseStmt,
  nnkReturnStmt, nnkBreakStmt, nnkContinueStmt, nnkBlockStmt, nnkStaticStmt,
  nnkDiscardStmt, nnkStmtList, nnkImportStmt, nnkImportExceptStmt,
  nnkExportStmt, nnkExportExceptStmt, nnkFromStmt, nnkIncludeStmt, nnkBindStmt,
  nnkMixinStmt, nnkUsingStmt, nnkCommentStmt, nnkStmtListExpr, nnkBlockExpr,
  nnkStmtListType, nnkBlockType, nnkWith, nnkWithout, nnkTypeOfExpr,
  nnkObjectTy, nnkTupleTy, nnkTupleClassTy, nnkTypeClassTy, nnkStaticTy,
  nnkRecList, nnkRecCase, nnkRecWhen, nnkRefTy, nnkPtrTy, nnkVarTy, nnkConstTy,
  nnkOutTy, nnkDistinctTy, nnkProcTy, nnkIteratorTy, nnkSinkAsgn, nnkEnumTy,
  nnkEnumFieldDef, nnkArgList, nnkPattern, nnkHiddenTryStmt, nnkClosure,
  nnkGotoState, nnkState, nnkBreakState, nnkFuncDef, nnkTupleConstr, nnkError ## erroneous AST node

	Source   Edit   

NimNodeKinds = set[NimNodeKind]

	Source   Edit   

NimSym {.....} = ref NimSymObj

	Deprecated
	Represents a Nim symbol in the compiler; a symbol is a looked-up ident. Source   Edit   

NimSymKind = enum
  nskUnknown, nskConditional, nskDynLib, nskParam, nskGenericParam, nskTemp,
  nskModule, nskType, nskVar, nskLet, nskConst, nskResult, nskProc, nskFunc,
  nskMethod, nskIterator, nskConverter, nskMacro, nskTemplate, nskField,
  nskEnumField, nskForVar, nskLabel, nskStub

	Source   Edit   

NimTypeKind = enum
  ntyNone, ntyBool, ntyChar, ntyEmpty, ntyAlias, ntyNil, ntyExpr, ntyStmt,
  ntyTypeDesc, ntyGenericInvocation, ntyGenericBody, ntyGenericInst,
  ntyGenericParam, ntyDistinct, ntyEnum, ntyOrdinal, ntyArray, ntyObject,
  ntyTuple, ntySet, ntyRange, ntyPtr, ntyRef, ntyVar, ntySequence, ntyProc,
  ntyPointer, ntyOpenArray, ntyString, ntyCString, ntyForward, ntyInt, ntyInt8,
  ntyInt16, ntyInt32, ntyInt64, ntyFloat, ntyFloat32, ntyFloat64, ntyFloat128,
  ntyUInt, ntyUInt8, ntyUInt16, ntyUInt32, ntyUInt64, ntyUnused0, ntyUnused1,
  ntyUnused2, ntyVarargs, ntyUncheckedArray, ntyError, ntyBuiltinTypeClass,
  ntyUserTypeClass, ntyUserTypeClassInst, ntyCompositeTypeClass, ntyInferred,
  ntyAnd, ntyOr, ntyNot, ntyAnything, ntyStatic, ntyFromExpr, ntyOptDeprecated,
  ntyVoid

	Source   Edit   

TNimSymKinds {.....} = set[NimSymKind]

	Deprecated
	Source   Edit   

TNimTypeKinds {.....} = set[NimTypeKind]

	Deprecated
	Source   Edit   

Consts

AtomicNodes = {nnkNone..nnkNilLit}

	Source   Edit   

CallNodes = {nnkCall, nnkInfix, nnkPrefix, nnkPostfix, nnkCommand,
         	nnkCallStrLit, nnkHiddenCallConv}

	Source   Edit   

nnkCallKinds = {nnkCall, nnkInfix, nnkPrefix, nnkPostfix, nnkCommand,
            	nnkCallStrLit, nnkHiddenCallConv}

	Source   Edit   

nnkLiterals = {nnkCharLit..nnkNilLit}

	Source   Edit   

nnkMutableTy {.....} = nnkOutTy

	Source   Edit   

nnkSharedTy {.....} = nnkSinkAsgn

	Source   Edit   

RoutineNodes = {nnkProcDef, nnkFuncDef, nnkMethodDef, nnkDo, nnkLambda,
            	nnkIteratorDef, nnkTemplateDef, nnkConverterDef, nnkMacroDef}

	Source   Edit   

Procs

proc `$`(arg: LineInfo): string {.....}

	Return a string representation in the form filepath(line, column). Source   Edit   

proc `$`(i: NimIdent): string {.magic: "NStrVal", noSideEffect, ....}

	Deprecated: Deprecated since version 0.18.1; Use 'strVal' instead.
	Converts a Nim identifier to a string. Source   Edit   

proc `$`(node: NimNode): string {.....}

	Get the string of an identifier node. Source   Edit   

proc `$`(s: NimSym): string {.magic: "NStrVal", noSideEffect, ....}

	Deprecated: Deprecated since version 0.18.1; Use 'strVal' instead.
	Converts a Nim symbol to a string. Source   Edit   

proc `==`(a, b: NimIdent): bool {.magic: "EqIdent", noSideEffect, ....}

	Deprecated: Deprecated since version 0.18.1; Use '==' on 'NimNode' instead.
	Compares two Nim identifiers. Source   Edit   

proc `==`(a, b: NimNode): bool {.magic: "EqNimrodNode", noSideEffect,
                             	....}

	Compare two Nim nodes. Return true if nodes are structurally equivalent. This means two independently created nodes can be equal. Source   Edit   

proc `==`(a, b: NimSym): bool {.magic: "EqNimrodNode", noSideEffect, ....}

	Deprecated: Deprecated since version 0.18.1; Use '==(NimNode, NimNode)' instead.
	Compares two Nim symbols. Source   Edit   

proc `[]`(n: NimNode; i: BackwardsIndex): NimNode {.....}

	Get n's i'th child. Source   Edit   

proc `[]`(n: NimNode; i: int): NimNode {.magic: "NChild", noSideEffect,
	....}

	Get n's i'th child. Source   Edit   

proc `[]`[T, U: Ordinal](n: NimNode; x: HSlice[T, U]): seq[NimNode]

	Slice operation for NimNode. Returns a seq of child of n who inclusive range [n[x.a], n[x.b]]. Source   Edit   

proc `[]=`(n: NimNode; i: BackwardsIndex; child: NimNode) {.....}

	Set n's i'th child to child. Source   Edit   

proc `[]=`(n: NimNode; i: int; child: NimNode) {.magic: "NSetChild",
	noSideEffect, ....}

	Set n's i'th child to child. Source   Edit   

proc add(father, child: NimNode): NimNode {.magic: "NAdd", discardable,
	noSideEffect, ....}

	Adds the child to the father node. Returns the father node so that calls can be nested. Source   Edit   

proc add(father: NimNode; children: varargs[NimNode]): NimNode {.
	magic: "NAddMultiple", discardable, noSideEffect, ....}

	Adds each child of children to the father node. Returns the father node so that calls can be nested. Source   Edit   

proc addIdentIfAbsent(dest: NimNode; ident: string) {.....}

	Add ident to dest if it is not present. This is intended for use with pragmas. Source   Edit   

proc addPragma(someProc, pragma: NimNode) {.....}

	Adds pragma to routine definition. Source   Edit   

proc astGenRepr(n: NimNode): string {.....}

	Convert the AST n to the code required to generate that AST.

	See also system: repr, treeRepr, and lispRepr.
	Source   Edit   

proc basename(a: NimNode): NimNode {.....}

	Pull an identifier from prefix/postfix expressions. Source   Edit   

proc basename=(a: NimNode; val: string) {.....}

	Source   Edit   

proc bindSym(ident: string | NimNode; rule: BindSymRule = brClosed): NimNode {.
	magic: "NBindSym", noSideEffect, ....}

	Creates a node that binds ident to a symbol node. The bound symbol may be an overloaded symbol. if ident is a NimNode, it must have nnkIdent kind. If rule == brClosed either an nnkClosedSymChoice tree is returned or nnkSym if the symbol is not ambiguous. If rule == brOpen either an nnkOpenSymChoice tree is returned or nnkSym if the symbol is not ambiguous. If rule == brForceOpen always an nnkOpenSymChoice tree is returned even if the symbol is not ambiguous.

	See the manual for more details.
	Source   Edit   

proc body(someProc: NimNode): NimNode {.....}

	Source   Edit   

proc body=(someProc: NimNode; val: NimNode) {.....}

	Source   Edit   

proc boolVal(n: NimNode): bool {.noSideEffect, ....}

	Source   Edit   

proc callsite(): NimNode {.magic: "NCallSite", ....}

	Deprecated: Deprecated since v0.18.1; use `varargs[untyped]` in the macro prototype instead
	Returns the AST of the invocation expression that invoked this macro. Source   Edit   

proc copy(node: NimNode): NimNode {.....}

	An alias for copyNimTree. Source   Edit   

proc copyChildrenTo(src, dest: NimNode) {.....}

	Copy all children from src to dest. Source   Edit   

proc copyLineInfo(arg: NimNode; info: NimNode) {.magic: "NLineInfo",
	noSideEffect, ....}

	Copy lineinfo from info. Source   Edit   

proc copyNimNode(n: NimNode): NimNode {.magic: "NCopyNimNode", noSideEffect,
                                    	....}

Creates a new AST node by copying the node n. Note that unlike copyNimTree, child nodes of n are not copied.

Example:

macro foo(x: typed) =
  var s = copyNimNode(x)
  doAssert s.len == 0
  doAssert s.kind == nnkStmtList

foo:
  let x = 12
  echo x

	Source   Edit   

proc copyNimTree(n: NimNode): NimNode {.magic: "NCopyNimTree", noSideEffect,
                                    	....}

Creates a new AST node by recursively copying the node n. Note that unlike copyNimNode, this copies n, the children of n, etc.

Example:

macro foo(x: typed) =
  var s = copyNimTree(x)
  doAssert s.len == 2
  doAssert s.kind == nnkStmtList

foo:
  let x = 12
  echo x

	Source   Edit   

proc del(father: NimNode; idx = 0; n = 1) {.magic: "NDel", noSideEffect,
	....}

	Deletes n children of father starting at index idx. Source   Edit   

proc eqIdent(a: NimNode; b: NimNode): bool {.magic: "EqIdent", noSideEffect,
	....}

	Style insensitive comparison. a and b can be an identifier or a symbol. Both may be wrapped in an export marker (nnkPostfix) or quoted with backticks (nnkAccQuoted), these nodes will be unwrapped. Source   Edit   

proc eqIdent(a: NimNode; b: string): bool {.magic: "EqIdent", noSideEffect,
	....}

	Style insensitive comparison. a can be an identifier or a symbol. a may be wrapped in an export marker (nnkPostfix) or quoted with backticks (nnkAccQuoted), these nodes will be unwrapped. Source   Edit   

proc eqIdent(a: string; b: NimNode): bool {.magic: "EqIdent", noSideEffect,
	....}

	Style insensitive comparison. b can be an identifier or a symbol. b may be wrapped in an export marker (nnkPostfix) or quoted with backticks (nnkAccQuoted), these nodes will be unwrapped. Source   Edit   

proc eqIdent(a: string; b: string): bool {.magic: "EqIdent", noSideEffect,
	....}

	Style insensitive comparison. Source   Edit   

proc error(msg: string; n: NimNode = nil) {.magic: "NError", ...noreturn,
	....}

	Writes an error message at compile time. The optional n: NimNode parameter is used as the source for file and line number information in the compilation error message. Source   Edit   

proc expectIdent(n: NimNode; name: string) {.....}

	Check that eqIdent(n,name) holds true. If this is not the case, compilation aborts with an error message. This is useful for writing macros that check the AST that is passed to them. Source   Edit   

proc expectKind(n: NimNode; k: NimNodeKind) {.....}

	Checks that n is of kind k. If this is not the case, compilation aborts with an error message. This is useful for writing macros that check the AST that is passed to them. Source   Edit   

proc expectKind(n: NimNode; k: set[NimNodeKind]) {.....}

	Checks that n is of kind k. If this is not the case, compilation aborts with an error message. This is useful for writing macros that check the AST that is passed to them. Source   Edit   

proc expectLen(n: NimNode; len: int) {.....}

	Checks that n has exactly len children. If this is not the case, compilation aborts with an error message. This is useful for writing macros that check its number of arguments. Source   Edit   

proc expectLen(n: NimNode; min, max: int) {.....}

	Checks that n has a number of children in the range min..max. If this is not the case, compilation aborts with an error message. This is useful for writing macros that check its number of arguments. Source   Edit   

proc expectMinLen(n: NimNode; min: int) {.....}

	Checks that n has at least min children. If this is not the case, compilation aborts with an error message. This is useful for writing macros that check its number of arguments. Source   Edit   

proc extractDocCommentsAndRunnables(n: NimNode): NimNode {.....}

returns a nnkStmtList containing the top-level doc comments and runnableExamples in a, stopping at the first child that is neither. Example:

import std/macros
macro transf(a): untyped =
  result = quote do:
	proc fun2*() = discard
  let header = extractDocCommentsAndRunnables(a.body)
  # correct usage: rest is appended
  result.body = header
  result.body.add quote do: discard # just an example
  # incorrect usage: nesting inside a nnkStmtList:
  # result.body = quote do: (`header`; discard)

proc fun*() {.transf.} =
  ## first comment
  runnableExamples: discard
  runnableExamples: discard
  ## last comment
  discard # first statement after doc comments + runnableExamples
  ## not docgen'd

	Source   Edit   

proc floatVal(n: NimNode): BiggestFloat {.magic: "NFloatVal", noSideEffect,
	....}

	Returns a float from any floating point literal. Source   Edit   

proc floatVal=(n: NimNode; val: BiggestFloat) {.magic: "NSetFloatVal",
	noSideEffect, ....}

	Source   Edit   

proc genSym(kind: NimSymKind = nskLet; ident = ""): NimNode {.magic: "NGenSym",
	noSideEffect, ....}

	Generates a fresh symbol that is guaranteed to be unique. The symbol needs to occur in a declaration context. Source   Edit   

proc getAlign(arg: NimNode): int {.magic: "NSizeOf", noSideEffect, ....}

	Returns the same result as system.alignof if the alignment is known by the Nim compiler. It works on NimNode for use in macro context. Returns a negative value if the Nim compiler does not know the alignment. Source   Edit   

proc getAst(macroOrTemplate: untyped): NimNode {.magic: "ExpandToAst",
	noSideEffect, ....}

Obtains the AST nodes returned from a macro or template invocation. See also genasts.genAst. Example:

macro FooMacro() =
  var ast = getAst(BarTemplate())

	Source   Edit   

proc getImpl(s: NimSym): NimNode {.magic: "GetImpl", noSideEffect, ....}

	Deprecated: use `getImpl: NimNode -> NimNode` instead
	Source   Edit   

proc getImpl(symbol: NimNode): NimNode {.magic: "GetImpl", noSideEffect,
	....}

	Returns a copy of the declaration of a symbol or nil. Source   Edit   

proc getImplTransformed(symbol: NimNode): NimNode {.magic: "GetImplTransf",
	noSideEffect, ....}

	For a typed proc returns the AST after transformation pass; this is useful for debugging how the compiler transforms code (e.g.: defer, for) but note that code transformations are implementation dependent and subject to change. See an example in tests/macros/tmacros_various.nim. Source   Edit   

proc getOffset(arg: NimNode): int {.magic: "NSizeOf", noSideEffect, ....}

	Returns the same result as system.offsetof if the offset is known by the Nim compiler. It expects a resolved symbol node from a field of a type. Therefore it only requires one argument instead of two. Returns a negative value if the Nim compiler does not know the offset. Source   Edit   

proc getProjectPath(): string {.....}

	Returns the path to the currently compiling project.

	This is not to be confused with system.currentSourcePath which returns the path of the source file containing that template call.

	For example, assume a dir1/foo.nim that imports a dir2/bar.nim, have the bar.nim print out both getProjectPath and currentSourcePath outputs.

	Now when foo.nim is compiled, the getProjectPath from bar.nim will return the dir1/ path, while the currentSourcePath will return the path to the bar.nim source file.

	Now when bar.nim is compiled directly, the getProjectPath will now return the dir2/ path, and the currentSourcePath will still return the same path, the path to the bar.nim source file.

	The path returned by this proc is set at compile time.

	See also:

    	getCurrentDir proc

	Source   Edit   

proc getSize(arg: NimNode): int {.magic: "NSizeOf", noSideEffect, ....}

	Returns the same result as system.sizeof if the size is known by the Nim compiler. Returns a negative value if the Nim compiler does not know the size. Source   Edit   

proc getType(n: NimNode): NimNode {.magic: "NGetType", noSideEffect, ....}

	With 'getType' you can access the node's type. A Nim type is mapped to a Nim AST too, so it's slightly confusing but it means the same API can be used to traverse types. Recursive types are flattened for you so there is no danger of infinite recursions during traversal. To resolve recursive types, you have to call 'getType' again. To see what kind of type it is, call typeKind on getType's result. Source   Edit   

proc getType(n: typedesc): NimNode {.magic: "NGetType", noSideEffect,
                                 	....}

	Version of getType which takes a typedesc. Source   Edit   

proc getTypeImpl(n: NimNode): NimNode {.magic: "NGetType", noSideEffect,
                                    	....}

Returns the type of a node in a form matching the implementation of the type. Any intermediate aliases are expanded to arrive at the final type implementation. You can instead use getImpl on a symbol if you want to find the intermediate aliases.

Example:

type
  Vec[N: static[int], T] = object
	arr: array[N, T]
  Vec4[T] = Vec[4, T]
  Vec4f = Vec4[float32]
var a: Vec4f
var b: Vec4[float32]
var c: Vec[4, float32]
macro dumpTypeImpl(x: typed): untyped =
  newLit(x.getTypeImpl.repr)
let t = """
object
  arr: array[0 .. 3, float32]"""
doAssert(dumpTypeImpl(a) == t)
doAssert(dumpTypeImpl(b) == t)
doAssert(dumpTypeImpl(c) == t)

	Source   Edit   

proc getTypeImpl(n: typedesc): NimNode {.magic: "NGetType", noSideEffect,
	....}

	Version of getTypeImpl which takes a typedesc. Source   Edit   

proc getTypeInst(n: NimNode): NimNode {.magic: "NGetType", noSideEffect,
                                    	....}

Returns the type of a node in a form matching the way the type instance was declared in the code.

Example:

type
  Vec[N: static[int], T] = object
	arr: array[N, T]
  Vec4[T] = Vec[4, T]
  Vec4f = Vec4[float32]
var a: Vec4f
var b: Vec4[float32]
var c: Vec[4, float32]
macro dumpTypeInst(x: typed): untyped =
  newLit(x.getTypeInst.repr)
doAssert(dumpTypeInst(a) == "Vec4f")
doAssert(dumpTypeInst(b) == "Vec4[float32]")
doAssert(dumpTypeInst(c) == "Vec[4, float32]")

	Source   Edit   

proc getTypeInst(n: typedesc): NimNode {.magic: "NGetType", noSideEffect,
	....}

	Version of getTypeInst which takes a typedesc. Source   Edit   

proc hasArgOfName(params: NimNode; name: string): bool {.....}

	Search nnkFormalParams for an argument. Source   Edit   

proc hint(msg: string; n: NimNode = nil) {.magic: "NHint", ....}

	Writes a hint message at compile time. Source   Edit   

proc ident(n: NimNode): NimIdent {.magic: "NIdent", noSideEffect, ....}

	Deprecated: Deprecated since version 0.18.1; All functionality is defined on 'NimNode'.
	Source   Edit   

proc ident(name: string): NimNode {.magic: "StrToIdent", noSideEffect,
                                	....}

	Create a new ident node from a string. Source   Edit   

proc ident=(n: NimNode; val: NimIdent) {.magic: "NSetIdent", noSideEffect, ....}

	Deprecated: Deprecated since version 0.18.1; Generate a new 'NimNode' with 'ident(string)' instead.
	Source   Edit   

proc infix(a: NimNode; op: string; b: NimNode): NimNode {.....}

	Source   Edit   

proc insert(a: NimNode; pos: int; b: NimNode) {.....}

	Insert node b into node a at pos. Source   Edit   

proc internalErrorFlag(): string {.magic: "NError", noSideEffect, ....}

	Some builtins set an error flag. This is then turned into a proper exception. Note: Ordinary application code should not call this. Source   Edit   

proc intVal(n: NimNode): BiggestInt {.magic: "NIntVal", noSideEffect,
                                  	....}

	Returns an integer value from any integer literal or enum field symbol. Source   Edit   

proc intVal=(n: NimNode; val: BiggestInt) {.magic: "NSetIntVal", noSideEffect,
	....}

	Source   Edit   

proc isExported(n: NimNode): bool {.noSideEffect, ....}

	Returns whether the symbol is exported or not. Source   Edit   

proc isInstantiationOf(instanceProcSym, genProcSym: NimNode): bool {.
	magic: "SymIsInstantiationOf", noSideEffect, ....}

	Checks if a proc symbol is an instance of the generic proc symbol. Useful to check proc symbols against generic symbols returned by bindSym. Source   Edit   

proc kind(n: NimNode): NimNodeKind {.magic: "NKind", noSideEffect, ....}

	Returns the kind of the node n. Source   Edit   

proc last(node: NimNode): NimNode {.....}

	Return the last item in nodes children. Same as node[^1]. Source   Edit   

proc len(n: NimNode): int {.magic: "NLen", noSideEffect, ....}

	Returns the number of children of n. Source   Edit   

proc lineInfo(arg: NimNode): string {.....}

	Return line info in the form filepath(line, column). Source   Edit   

proc lineInfoObj(n: NimNode): LineInfo {.....}

	Returns LineInfo of n, using absolute path for filename. Source   Edit   

proc lispRepr(n: NimNode; indented = false): string {.....}

	Convert the AST n to a human-readable lisp-like string.

	See also repr, treeRepr, and astGenRepr.
	Source   Edit   

proc name(someProc: NimNode): NimNode {.....}

	Source   Edit   

proc name=(someProc: NimNode; val: NimNode) {.....}

	Source   Edit   

proc nestList(op: NimNode; pack: NimNode): NimNode {.....}

	Nests the list pack into a tree of call expressions: [a, b, c] is transformed into op(a, op(c, d)). This is also known as fold expression. Source   Edit   

proc nestList(op: NimNode; pack: NimNode; init: NimNode): NimNode {.....}

	Nests the list pack into a tree of call expressions: [a, b, c] is transformed into op(a, op(c, d)). This is also known as fold expression. Source   Edit   

proc newAssignment(lhs, rhs: NimNode): NimNode {.....}

	Source   Edit   

proc newBlockStmt(body: NimNode): NimNode {.....}

	Create a new block: stmt. Source   Edit   

proc newBlockStmt(label, body: NimNode): NimNode {.....}

	Create a new block statement with label. Source   Edit   

proc newCall(theProc: NimIdent; args: varargs[NimNode]): NimNode {.....}

	Deprecated: Deprecated since v0.18.1; use 'newCall(string, ...)' or 'newCall(NimNode, ...)' instead
	Produces a new call node. theProc is the proc that is called with the arguments args[0..]. Source   Edit   

proc newCall(theProc: NimNode; args: varargs[NimNode]): NimNode {.....}

	Produces a new call node. theProc is the proc that is called with the arguments args[0..]. Source   Edit   

proc newCall(theProc: string; args: varargs[NimNode]): NimNode {.....}

	Produces a new call node. theProc is the proc that is called with the arguments args[0..]. Source   Edit   

proc newColonExpr(a, b: NimNode): NimNode {.....}

	Create new colon expression. newColonExpr(a, b) -> a: b Source   Edit   

proc newCommentStmtNode(s: string): NimNode {.noSideEffect, ....}

	Creates a comment statement node. Source   Edit   

proc newConstStmt(name, value: NimNode): NimNode {.....}

	Create a new const stmt. Source   Edit   

proc newDotExpr(a, b: NimNode): NimNode {.....}

	Create new dot expression. a.dot(b) -> a.b Source   Edit   

proc newEmptyNode(): NimNode {.noSideEffect, ....}

	Create a new empty node. Source   Edit   

proc newEnum(name: NimNode; fields: openArray[NimNode]; public, pure: bool): NimNode {.
	....}

Creates a new enum. name must be an ident. Fields are allowed to be either idents or EnumFieldDef:

newEnum(
  name	= ident("Colors"),
  fields  = [ident("Blue"), ident("Red")],
  public  = true, pure = false)

# type Colors* = Blue Red

	Source   Edit   

proc newFloatLitNode(f: BiggestFloat): NimNode {.....}

	Creates a float literal node from f. Source   Edit   

proc newIdentDefs(name, kind: NimNode; default = newEmptyNode()): NimNode {.
	....}

Creates a new nnkIdentDefs node of a specific kind and value.

nnkIdentDefs need to have at least three children, but they can have more: first comes a list of identifiers followed by a type and value nodes. This helper proc creates a three node subtree, the first subnode being a single identifier name. Both the kind node and default (value) nodes may be empty depending on where the nnkIdentDefs appears: tuple or object definitions will have an empty default node, let or var blocks may have an empty kind node if the identifier is being assigned a value. Example:

var varSection = newNimNode(nnkVarSection).add(
  newIdentDefs(ident("a"), ident("string")),
  newIdentDefs(ident("b"), newEmptyNode(), newLit(3)))
# --> var
#   	a: string
#   	b = 3

If you need to create multiple identifiers you need to use the lower level newNimNode:

result = newNimNode(nnkIdentDefs).add(
  ident("a"), ident("b"), ident("c"), ident("string"),
	newStrLitNode("Hello"))

	Source   Edit   

proc newIdentNode(i: NimIdent): NimNode {.....}

	Deprecated: use ident(string)
	Creates an identifier node from i. Source   Edit   

proc newIdentNode(i: string): NimNode {.magic: "StrToIdent", noSideEffect,
                                    	....}

	Creates an identifier node from i. It is simply an alias for ident(string). Use that, it's shorter. Source   Edit   

proc newIfStmt(branches: varargs[tuple[cond, body: NimNode]]): NimNode {.
	....}

Constructor for if statements.

newIfStmt(
  (Ident, StmtList),
  ...
)

	Source   Edit   

proc newIntLitNode(i: BiggestInt): NimNode {.....}

	Creates an int literal node from i. Source   Edit   

proc newLetStmt(name, value: NimNode): NimNode {.....}

	Create a new let stmt. Source   Edit   

proc newLit(arg: enum): NimNode

	Source   Edit   

proc newLit(arg: object): NimNode

	Source   Edit   

proc newLit(arg: ref object): NimNode

	produces a new ref type literal node. Source   Edit   

proc newLit(b: bool): NimNode {.....}

	Produces a new boolean literal node. Source   Edit   

proc newLit(c: char): NimNode {.....}

	Produces a new character literal node. Source   Edit   

proc newLit(f: float32): NimNode {.....}

	Produces a new float literal node. Source   Edit   

proc newLit(f: float64): NimNode {.....}

	Produces a new float literal node. Source   Edit   

proc newLit(i: int): NimNode {.....}

	Produces a new integer literal node. Source   Edit   

proc newLit(i: int8): NimNode {.....}

	Produces a new integer literal node. Source   Edit   

proc newLit(i: int16): NimNode {.....}

	Produces a new integer literal node. Source   Edit   

proc newLit(i: int32): NimNode {.....}

	Produces a new integer literal node. Source   Edit   

proc newLit(i: int64): NimNode {.....}

	Produces a new integer literal node. Source   Edit   

proc newLit(i: uint): NimNode {.....}

	Produces a new unsigned integer literal node. Source   Edit   

proc newLit(i: uint8): NimNode {.....}

	Produces a new unsigned integer literal node. Source   Edit   

proc newLit(i: uint16): NimNode {.....}

	Produces a new unsigned integer literal node. Source   Edit   

proc newLit(i: uint32): NimNode {.....}

	Produces a new unsigned integer literal node. Source   Edit   

proc newLit(i: uint64): NimNode {.....}

	Produces a new unsigned integer literal node. Source   Edit   

proc newLit(s: string): NimNode {.....}

	Produces a new string literal node. Source   Edit   

proc newLit[N, T](arg: array[N, T]): NimNode

	Source   Edit   

proc newLit[T: tuple](arg: T): NimNode

	Source   Edit   

proc newLit[T](arg: seq[T]): NimNode

	Source   Edit   

proc newLit[T](s: set[T]): NimNode

	Source   Edit   

proc newNilLit(): NimNode {.....}

	New nil literal shortcut. Source   Edit   

proc newNimNode(kind: NimNodeKind; lineInfoFrom: NimNode = nil): NimNode {.
	magic: "NNewNimNode", noSideEffect, ....}

	Creates a new AST node of the specified kind.

	The lineInfoFrom parameter is used for line information when the produced code crashes. You should ensure that it is set to a node that you are transforming.
	Source   Edit   

proc newPar(exprs: NimNode): NimNode {.....}

	Create a new parentheses-enclosed expression. Source   Edit   

proc newPar(exprs: varargs[NimNode]): NimNode {.....}

	Deprecated: don't use newPar/nnkPar to construct tuple expressions; use nnkTupleConstr instead
	Create a new parentheses-enclosed expression. Source   Edit   

proc newProc(name = newEmptyNode();
         	params: openArray[NimNode] = [newEmptyNode()];
         	body: NimNode = newStmtList(); procType = nnkProcDef;
         	pragmas: NimNode = newEmptyNode()): NimNode {.....}

	Shortcut for creating a new proc.

	The params array must start with the return type of the proc, followed by a list of IdentDefs which specify the params.
	Source   Edit   

proc newStmtList(stmts: varargs[NimNode]): NimNode {.....}

	Create a new statement list. Source   Edit   

proc newStrLitNode(s: string): NimNode {.noSideEffect, ....}

	Creates a string literal node from s. Source   Edit   

proc newTree(kind: NimNodeKind; children: varargs[NimNode]): NimNode {.
	....}

	Produces a new node with children. Source   Edit   

proc newVarStmt(name, value: NimNode): NimNode {.....}

	Create a new var stmt. Source   Edit   

proc nodeID(n: NimNode): int {.magic: "NodeId", ....}

	Returns the id of n, when the compiler has been compiled with the flag -d:useNodeids, otherwise returns -1. This proc is for the purpose to debug the compiler only. Source   Edit   

proc owner(sym: NimNode): NimNode {.magic: "SymOwner", noSideEffect, ....}

	Accepts a node of kind nnkSym and returns its owner's symbol. The meaning of 'owner' depends on sym's NimSymKind and declaration context. For top level declarations this is an nskModule symbol, for proc local variables an nskProc symbol, for enum/object fields an nskType symbol, etc. For symbols without an owner, nil is returned.

	See also:

    	symKind proc to get the kind of a symbol
    	getImpl proc to get the declaration of a symbol

	Source   Edit   

proc params(someProc: NimNode): NimNode {.....}

	Source   Edit   

proc params=(someProc: NimNode; params: NimNode) {.....}

	Source   Edit   

proc parseExpr(s: string; filename: string = ""): NimNode {.noSideEffect,
	....}

	Compiles the passed string to its AST representation. Expects a single expression. Raises ValueError for parsing errors. A filename can be given for more informative errors. Source   Edit   

proc parseStmt(s: string; filename: string = ""): NimNode {.noSideEffect,
	....}

	Compiles the passed string to its AST representation. Expects one or more statements. Raises ValueError for parsing errors. A filename can be given for more informative errors. Source   Edit   

proc postfix(node: NimNode; op: string): NimNode {.....}

	Source   Edit   

proc pragma(someProc: NimNode): NimNode {.....}

	Get the pragma of a proc type. These will be expanded. Source   Edit   

proc pragma=(someProc: NimNode; val: NimNode) {.....}

	Set the pragma of a proc type. Source   Edit   

proc prefix(node: NimNode; op: string): NimNode {.....}

	Source   Edit   

proc quote(bl: typed; op = "``"): NimNode {.magic: "QuoteAst", noSideEffect,
	....}

Quasi-quoting operator. Accepts an expression or a block and returns the AST that represents it. Within the quoted AST, you are able to interpolate NimNode expressions from the surrounding scope. If no operator is given, quoting is done using backticks. Otherwise, the given operator must be used as a prefix operator for any interpolated expression. The original meaning of the interpolation operator may be obtained by escaping it (by prefixing it with itself) when used as a unary operator: e.g. @ is escaped as @@, &% is escaped as &%&% and so on; see examples.

A custom operator interpolation needs accent quoted (``) whenever it resolves to a symbol.

See also genasts which avoids some issues with quote.

Example:

macro check(ex: untyped) =
  # this is a simplified version of the check macro from the
  # unittest module.

  # If there is a failed check, we want to make it easy for
  # the user to jump to the faulty line in the code, so we
  # get the line info here:
  var info = ex.lineinfo

  # We will also display the code string of the failed check:
  var expString = ex.toStrLit

  # Finally we compose the code to implement the check:
  result = quote do:
	if not `ex`:
  	echo `info` & ": Check failed: " & `expString`
check 1 + 1 == 2

Example:

# example showing how to define a symbol that requires backtick without
# quoting it.
var destroyCalled = false
macro bar() =
  let s = newTree(nnkAccQuoted, ident"=destroy")
  # let s = ident"`=destroy`" # this would not work
  result = quote do:
	type Foo = object
	# proc `=destroy`(a: var Foo) = destroyCalled = true # this would not work
	proc `s`(a: var Foo) = destroyCalled = true
	block:
  	let a = Foo()
bar()
doAssert destroyCalled

Example:

# custom `op`
var destroyCalled = false
macro bar(ident) =
  var x = 1.5
  result = quote("@") do:
	type Foo = object
	let `@ident` = 0 # custom op interpolated symbols need quoted (``)
	proc `=destroy`(a: var Foo) =
  	doAssert @x == 1.5
  	doAssert compiles(@x == 1.5)
  	let b1 = @[1,2]
  	let b2 = @@[1,2]
  	doAssert $b1 == "[1, 2]"
  	doAssert $b2 == "@[1, 2]"
  	destroyCalled = true
	block:
  	let a = Foo()
bar(someident)
doAssert destroyCalled

proc `&%`(x: int): int = 1
proc `&%`(x, y: int): int = 2

macro bar2() =
  var x = 3
  result = quote("&%") do:
	var y = &%x # quoting operator
	doAssert &%&%y == 1 # unary operator => need to escape
	doAssert y &% y == 2 # binary operator => no need to escape
	doAssert y == 3
bar2()

	Source   Edit   

proc sameType(a, b: NimNode): bool {.magic: "SameNodeType", noSideEffect,
                                 	....}

	Compares two Nim nodes' types. Return true if the types are the same, e.g. true when comparing alias with original type. Source   Edit   

proc setLineInfo(arg: NimNode; file: string; line: int; column: int) {.
	....}

	Sets the line info on the NimNode. The file needs to exists, but can be a relative path. If you want to attach line info to a block using quote you'll need to add the line information after the quote block. Source   Edit   

proc setLineInfo(arg: NimNode; lineInfo: LineInfo) {.....}

	See setLineInfo proc Source   Edit   

proc signatureHash(n: NimNode): string {.magic: "NSigHash", noSideEffect,
	....}

	Returns a stable identifier derived from the signature of a symbol. The signature combines many factors such as the type of the symbol, the owning module of the symbol and others. The same identifier is used in the back-end to produce the mangled symbol name. Source   Edit   

proc strVal(n: NimNode): string {.magic: "NStrVal", noSideEffect, ....}

	Returns the string value of an identifier, symbol, comment, or string literal.

	See also:

    	strVal= proc for setting the string value.

	Source   Edit   

proc strVal=(n: NimNode; val: string) {.magic: "NSetStrVal", noSideEffect,
                                    	....}

	Sets the string value of a string literal or comment. Setting strVal is disallowed for nnkIdent and nnkSym nodes; a new node must be created using ident or bindSym instead.

	See also:

    	strVal proc for getting the string value.
    	ident proc for creating an identifier.
    	bindSym proc for binding a symbol.

	Source   Edit   

proc symBodyHash(s: NimNode): string {.noSideEffect, ....}

	Returns a stable digest for symbols derived not only from type signature and owning module, but also implementation body. All procs/variables used in the implementation of this symbol are hashed recursively as well, including magics from system module. Source   Edit   

proc symbol(n: NimNode): NimSym {.magic: "NSymbol", noSideEffect, ....}

	Deprecated: Deprecated since version 0.18.1; All functionality is defined on 'NimNode'.
	Source   Edit   

proc symbol=(n: NimNode; val: NimSym) {.magic: "NSetSymbol", noSideEffect, ....}

	Deprecated: Deprecated since version 0.18.1; Generate a new 'NimNode' with 'genSym' instead.
	Source   Edit   

proc symKind(symbol: NimNode): NimSymKind {.magic: "NSymKind", noSideEffect,
	....}

	Source   Edit   

proc toNimIdent(s: string): NimIdent {.magic: "StrToIdent", noSideEffect, ....}

	Deprecated: Deprecated since version 0.18.0: Use 'ident' or 'newIdentNode' instead.
	Constructs an identifier from the string s. Source   Edit   

proc toStrLit(n: NimNode): NimNode {.....}

	Converts the AST n to the concrete Nim code and wraps that in a string literal node. Source   Edit   

proc treeRepr(n: NimNode): string {.....}

	Convert the AST n to a human-readable tree-like string.

	See also repr, lispRepr, and astGenRepr.
	Source   Edit   

proc typeKind(n: NimNode): NimTypeKind {.magic: "NGetType", noSideEffect,
	....}

	Returns the type kind of the node 'n' that should represent a type, that means the node should have been obtained via getType. Source   Edit   

proc unpackInfix(node: NimNode): tuple[left: NimNode, op: string, right: NimNode] {.
	....}

	Source   Edit   

proc unpackPostfix(node: NimNode): tuple[node: NimNode, op: string] {.
	....}

	Source   Edit   

proc unpackPrefix(node: NimNode): tuple[node: NimNode, op: string] {.....}

	Source   Edit   

proc warning(msg: string; n: NimNode = nil) {.magic: "NWarning", ....}

	Writes a warning message at compile time. Source   Edit   

Iterators

iterator children(n: NimNode): NimNode {.inline, ....}

	Iterates over the children of the NimNode n. Source   Edit   

iterator items(n: NimNode): NimNode {.inline, ....}

	Iterates over the children of the NimNode n. Source   Edit   

iterator pairs(n: NimNode): (int, NimNode) {.inline, ....}

	Iterates over the children of the NimNode n and its indices. Source   Edit   

Macros

macro dumpAstGen(s: untyped): untyped

Accepts a block of nim code and prints the parsed abstract syntax tree using the astGenRepr proc. Printing is done at compile time.

You can use this as a tool to write macros quicker by writing example outputs and then copying the snippets into the macro for modification.

For example:

dumpAstGen:
  echo "Hello, World!"

Outputs:

nnkStmtList.newTree(
  nnkCommand.newTree(
	newIdentNode("echo"),
	newLit("Hello, World!")
  )
)

	Also see dumpTree and dumpLisp.
	Source   Edit   

macro dumpLisp(s: untyped): untyped

Accepts a block of nim code and prints the parsed abstract syntax tree using the lispRepr proc. Printing is done at compile time.

You can use this as a tool to explore the Nim's abstract syntax tree and to discover what kind of nodes must be created to represent a certain expression/statement.

For example:

dumpLisp:
  echo "Hello, World!"

Outputs:

(StmtList
 (Command
  (Ident "echo")
  (StrLit "Hello, World!")))

	Also see dumpAstGen and dumpTree.
	Source   Edit   

macro dumpTree(s: untyped): untyped

Accepts a block of nim code and prints the parsed abstract syntax tree using the treeRepr proc. Printing is done at compile time.

You can use this as a tool to explore the Nim's abstract syntax tree and to discover what kind of nodes must be created to represent a certain expression/statement.

For example:

dumpTree:
  echo "Hello, World!"

Outputs:

StmtList
  Command
	Ident "echo"
	StrLit "Hello, World!"

	Also see dumpAstGen and dumpLisp.
	Source   Edit   

macro expandMacros(body: typed): untyped

Expands one level of macro - useful for debugging. Can be used to inspect what happens when a macro call is expanded, without altering its result.

For instance,

import std/[sugar, macros]

let
  x = 10
  y = 20
expandMacros:
  dump(x + y)

	will actually dump x + y, but at the same time will print at compile time the expansion of the dump macro, which in this case is debugEcho ["x + y", " = ", x + y].
	Source   Edit   

macro getCustomPragmaVal(n: typed; cp: typed{nkSym}): untyped

Expands to value of custom pragma cp of expression n which is expected to be nnkDotExpr, a proc or a type.

See also hasCustomPragma.

template serializationKey(key: string) {.pragma.}
type
  MyObj {.serializationKey: "mo".} = object
	myField {.serializationKey: "mf".}: int
var o: MyObj
assert(o.myField.getCustomPragmaVal(serializationKey) == "mf")
assert(o.getCustomPragmaVal(serializationKey) == "mo")
assert(MyObj.getCustomPragmaVal(serializationKey) == "mo")

	Source   Edit   

macro hasCustomPragma(n: typed; cp: typed{nkSym}): untyped

Expands to true if expression n which is expected to be nnkDotExpr (if checking a field), a proc or a type has custom pragma cp.

See also getCustomPragmaVal.

template myAttr() {.pragma.}
type
  MyObj = object
	myField {.myAttr.}: int

proc myProc() {.myAttr.} = discard

var o: MyObj
assert(o.myField.hasCustomPragma(myAttr))
assert(myProc.hasCustomPragma(myAttr))

	Source   Edit   

macro unpackVarargs(callee: untyped; args: varargs[untyped]): untyped

Calls callee with args unpacked as individual arguments. This is useful in 2 cases:

	when forwarding varargs[T] for some typed T
	when forwarding varargs[untyped] when args can potentially be empty, due to a compiler limitation

Example:

template call1(fun: typed; args: varargs[untyped]): untyped =
  unpackVarargs(fun, args)
  # when varargsLen(args) > 0: fun(args) else: fun() # this would also work
template call2(fun: typed; args: varargs[typed]): untyped =
  unpackVarargs(fun, args)
proc fn1(a = 0, b = 1) = discard (a, b)
call1(fn1, 10, 11)
call1(fn1) # `args` is empty in this case
if false: call2(echo, 10, 11) # would print 1011

	Source   Edit   

Templates

template findChild(n: NimNode; cond: untyped): NimNode {.dirty.}

Find the first child node matching condition (or nil).

var res = findChild(n, it.kind == nnkPostfix and
                   	it.basename.ident == ident"foo")

	Source   Edit   

template `or`(x, y: NimNode): NimNode

Evaluate x and when it is not an empty node, return it. Otherwise evaluate to y. Can be used to chain several expressions to get the first expression that is not empty.

let node = mightBeEmpty() or mightAlsoBeEmpty() or fallbackNode

	Source   Edit   




std/rlocks


std/rlocks
Source   Edit  

This module contains Nim's support for reentrant locks.
Imports

syslocks

Types

RLock = SysLock

	Nim lock, re-entrant Source   Edit   

Procs

proc acquire(lock: var RLock) {.inline, ....}

	Acquires the given lock. Source   Edit   

proc deinitRLock(lock: var RLock) {.inline, ....}

	Frees the resources associated with the lock. Source   Edit   

proc initRLock(lock: var RLock) {.inline, ....}

	Initializes the given lock. Source   Edit   

proc release(lock: var RLock) {.inline, ....}

	Releases the given lock. Source   Edit   

proc tryAcquire(lock: var RLock): bool {.inline, ....}

	Tries to acquire the given lock. Returns true on success. Source   Edit   

Templates

template withRLock(lock: RLock; code: untyped)

	Acquires the given lock and then executes the code. Source   Edit   



std/typeinfo


std/typeinfo
Source   Edit  

This module implements an interface to Nim's runtime type information (RTTI). See the marshal module for an example of what this allows you to do.
Note: Even though Any and its operations hide the nasty low level details from its users, it remains inherently unsafe! Also, Nim's runtime type information will evolve and may eventually be deprecated. As an alternative approach to programmatically understanding and manipulating types, consider using the macros module to work with the types' AST representation at compile time. See for example the getTypeImpl proc. As an alternative approach to storing arbitrary types at runtime, consider using generics.

Example:

import std/typeinfo
var x: Any

var i = 42
x = i.toAny
assert x.kind == akInt
assert x.getInt == 42

var s = @[1, 2, 3]
x = s.toAny
assert x.kind == akSequence
assert x.len == 3

Imports

strimpl

Types

Any = object
  when defined(js):
  else:

	A type that can represent any nim value.
	Danger: The wrapped value can be modified with its wrapper! This means that Any keeps a non-traced pointer to its wrapped value and must not live longer than its wrapped value.
	Source   Edit   

AnyKind = enum
  akNone = 0,           	## invalid
  akBool = 1,           	## bool
  akChar = 2,           	## char
  akEnum = 14,          	## enum
  akArray = 16,         	## array
  akObject = 17,        	## object
  akTuple = 18,         	## tuple
  akSet = 19,           	## set
  akRange = 20,         	## range
  akPtr = 21,           	## ptr
  akRef = 22,           	## ref
  akSequence = 24,      	## sequence
  akProc = 25,          	## proc
  akPointer = 26,       	## pointer
  akString = 28,        	## string
  akCString = 29,       	## cstring
  akInt = 31,           	## int
  akInt8 = 32,          	## int8
  akInt16 = 33,         	## int16
  akInt32 = 34,         	## int32
  akInt64 = 35,         	## int64
  akFloat = 36,         	## float
  akFloat32 = 37,       	## float32
  akFloat64 = 38,       	## float64
  akFloat128 = 39,      	## float128
  akUInt = 40,          	## uint
  akUInt8 = 41,         	## uint8
  akUInt16 = 42,        	## uin16
  akUInt32 = 43,        	## uint32
  akUInt64 = 44          	## uint64

	The kind of Any. Source   Edit   

Procs

proc `[]`(x: Any): Any {.....}

	Dereference operator for Any. x needs to represent a ptr or a ref. Source   Edit   

proc `[]`(x: Any; fieldName: string): Any {.....}

	Gets a field of x. x needs to represent an object or a tuple. Source   Edit   

proc `[]`(x: Any; i: int): Any {.....}

	Accessor for an any x that represents an array or a sequence. Source   Edit   

proc `[]=`(x, y: Any) {.....}

	Dereference operator for Any. x needs to represent a ptr or a ref. Source   Edit   

proc `[]=`(x: Any; fieldName: string; value: Any) {.....}

	Sets a field of x. x needs to represent an object or a tuple. Source   Edit   

proc `[]=`(x: Any; i: int; y: Any) {.....}

	Accessor for an any x that represents an array or a sequence. Source   Edit   

proc assign(x, y: Any) {.....}

	Copies the value of y to x. The assignment operator for Any does NOT do this; it performs a shallow copy instead! Source   Edit   

proc base(x: Any): Any {.....}

	Returns the base type of x (useful for inherited object types). Source   Edit   

proc baseTypeKind(x: Any): AnyKind {.inline, ....}

	Gets the base type's kind. If x has no base type, akNone is returned. Source   Edit   

proc baseTypeSize(x: Any): int {.inline, ....}

	Returns the size of x's base type. If x has no base type, 0 is returned. Source   Edit   

proc extendSeq(x: Any) {.....}

	Performs setLen(x, x.len+1). x needs to represent a seq. Source   Edit   

proc getBiggestFloat(x: Any): BiggestFloat {.....}

	Retrieves the float value out of x. x needs to represent some float. The value is extended to BiggestFloat. Source   Edit   

proc getBiggestInt(x: Any): BiggestInt {.....}

	Retrieves the integer value out of x. x needs to represent some integer, a bool, a char, an enum or a small enough bit set. The value might be sign-extended to BiggestInt. Source   Edit   

proc getBiggestUint(x: Any): uint64 {.....}

	Retrieves the unsigned integer value out of x. x needs to represent an unsigned integer. Source   Edit   

proc getBool(x: Any): bool {.....}

	Retrieves the bool value out of x. x needs to represent a bool. Source   Edit   

proc getChar(x: Any): char {.....}

	Retrieves the char value out of x. x needs to represent a char. Source   Edit   

proc getCString(x: Any): cstring {.....}

	Retrieves the cstring value out of x. x needs to represent a cstring. Source   Edit   

proc getEnumField(x: Any): string {.....}

	Gets the enum field name as a string. x needs to represent an enum. Source   Edit   

proc getEnumField(x: Any; ordinalValue: int): string {.....}

	Gets the enum field name as a string. x needs to represent an enum but is only used to access the type information. The field name of ordinalValue is returned. Source   Edit   

proc getEnumOrdinal(x: Any; name: string): int {.....}

	Gets the enum field ordinal from name. x needs to represent an enum but is only used to access the type information. In case of an error low(int) is returned. Source   Edit   

proc getFloat(x: Any): float {.....}

	Retrieves the float value out of x. x needs to represent a float. Source   Edit   

proc getFloat32(x: Any): float32 {.....}

	Retrieves the float32 value out of x. x needs to represent a float32. Source   Edit   

proc getFloat64(x: Any): float64 {.....}

	Retrieves the float64 value out of x. x needs to represent a float64. Source   Edit   

proc getInt(x: Any): int {.....}

	Retrieves the int value out of x. x needs to represent an int. Source   Edit   

proc getInt8(x: Any): int8 {.....}

	Retrieves the int8 value out of x. x needs to represent an int8. Source   Edit   

proc getInt16(x: Any): int16 {.....}

	Retrieves the int16 value out of x. x needs to represent an int16. Source   Edit   

proc getInt32(x: Any): int32 {.....}

	Retrieves the int32 value out of x. x needs to represent an int32. Source   Edit   

proc getInt64(x: Any): int64 {.....}

	Retrieves the int64 value out of x. x needs to represent an int64. Source   Edit   

proc getPointer(x: Any): pointer {.....}

	Retrieves the pointer value out of x. x needs to be of kind akString, akCString, akProc, akRef, akPtr, akPointer or akSequence. Source   Edit   

proc getString(x: Any): string {.....}

	Retrieves the string value out of x. x needs to represent a string. Source   Edit   

proc getUInt(x: Any): uint {.....}

	Retrieves the uint value out of x. x needs to represent a uint. Source   Edit   

proc getUInt8(x: Any): uint8 {.....}

	Retrieves the uint8 value out of x. x needs to represent a uint8. Source   Edit   

proc getUInt16(x: Any): uint16 {.....}

	Retrieves the uint16 value out of x. x needs to represent a uint16. Source   Edit   

proc getUInt32(x: Any): uint32 {.....}

	Retrieves the uint32 value out of x. x needs to represent a uint32. Source   Edit   

proc getUInt64(x: Any): uint64 {.....}

	Retrieves the uint64 value out of x. x needs to represent a uint64. Source   Edit   

proc inclSetElement(x: Any; elem: int) {.....}

	Includes an element elem in x. x needs to represent a Nim bitset. Source   Edit   

proc invokeNew(x: Any) {.....}

	Performs new(x). x needs to represent a ref. Source   Edit   

proc invokeNewSeq(x: Any; len: int) {.....}

	Performs newSeq(x, len). x needs to represent a seq. Source   Edit   

proc isNil(x: Any): bool {.....}

	isNil for an x that represents a cstring, proc or some pointer type. Source   Edit   

proc kind(x: Any): AnyKind {.inline, ....}

	Gets the type kind. Source   Edit   

proc len(x: Any): int {.....}

	len for an any x that represents an array or a sequence. Source   Edit   

proc setBiggestFloat(x: Any; y: BiggestFloat) {.....}

	Sets the float value of x. x needs to represent some float. Source   Edit   

proc setBiggestInt(x: Any; y: BiggestInt) {.....}

	Sets the integer value of x. x needs to represent some integer, a bool, a char, an enum or a small enough bit set. Source   Edit   

proc setBiggestUint(x: Any; y: uint64) {.....}

	Sets the unsigned integer value of x. x needs to represent an unsigned integer. Source   Edit   

proc setObjectRuntimeType(x: Any) {.....}

	This needs to be called to set x's runtime object type field. Source   Edit   

proc setPointer(x: Any; y: pointer) {.....}

	Sets the pointer value of x. x needs to be of kind akString, akCString, akProc, akRef, akPtr, akPointer or akSequence. Source   Edit   

proc setString(x: Any; y: string) {.....}

	Sets the string value of x. x needs to represent a string. Source   Edit   

proc size(x: Any): int {.inline, ....}

	Returns the size of x's type. Source   Edit   

proc skipRange(x: Any): Any {.....}

	Skips the range information of x. Source   Edit   

proc toAny[T](x: var T): Any {.inline.}

	Constructs an Any object from x. This captures x's address, so x can be modified with its Any wrapper! The caller needs to ensure that the wrapper does not live longer than x! Source   Edit   

Iterators

iterator elements(x: Any): int {.....}

	Iterates over every element of x. x needs to represent a set. Source   Edit   

iterator fields(x: Any): tuple[name: string, any: Any] {.....}

	Iterates over every active field of x. x needs to represent an object or a tuple. Source   Edit   


std/typetraits


std/typetraits
Source   Edit  

This module defines compile-time reflection procs for working with types.

Unstable API.

Example:

import std/typetraits
type A = enum a0 = 2, a1 = 4, a2
type B = enum b0 = 2, b1, b2
assert A is enum
assert A is HoleyEnum
assert A isnot OrdinalEnum
assert B isnot HoleyEnum
assert B is OrdinalEnum
assert int isnot HoleyEnum
type C[T] = enum h0 = 2, h1 = 4
assert C[float] is HoleyEnum

Imports

since, macros

Types

HoleyEnum = (not Ordinal) and enum

	Enum with holes. Source   Edit   

OrdinalEnum = Ordinal and enum

	Enum without holes. Source   Edit   

StaticParam[value] = object

	Used to wrap a static value in genericParams. Source   Edit   

Procs

proc arity(t: typedesc): int {.magic: "TypeTrait", ....}

Returns the arity of t. This is the number of "type" components or the number of generic parameters a given type t has.

Example:

doAssert arity(int) == 0
doAssert arity(seq[string]) == 1
doAssert arity(array[3, int]) == 2
doAssert arity((int, int, float, string)) == 4

	Source   Edit   

proc distinctBase(T: typedesc; recursive: static bool = true): typedesc {.
	magic: "TypeTrait", ....}

Returns the base type for distinct types, or the type itself otherwise. If recursive is false, only the immediate distinct base will be returned.

See also:

	distinctBase template

Example:

type MyInt = distinct int
type MyOtherInt = distinct MyInt
doAssert distinctBase(MyInt) is int
doAssert distinctBase(MyOtherInt) is int
doAssert distinctBase(MyOtherInt, false) is MyInt
doAssert distinctBase(int) is int

	Source   Edit   

proc genericHead(t: typedesc): typedesc {.magic: "TypeTrait", ....}

Accepts an instantiated generic type and returns its uninstantiated form. A compile-time error will be produced if the supplied type is not generic.

See also:

	stripGenericParams proc

Example:

type
  Foo[T] = object
  FooInst = Foo[int]
  Foo2 = genericHead(FooInst)

doAssert Foo2 is Foo and Foo is Foo2
doAssert genericHead(Foo[seq[string]]) is Foo
doAssert not compiles(genericHead(int))

type Generic = concept f
  type _ = genericHead(typeof(f))

proc bar(a: Generic): typeof(a) = a

doAssert bar(Foo[string].default) == Foo[string]()
doAssert not compiles bar(string.default)

when false: # these don't work yet
  doAssert genericHead(Foo[int])[float] is Foo[float]
  doAssert seq[int].genericHead is seq

	Source   Edit   

proc hasClosure(fn: NimNode): bool {.....}

	Returns true if the func/proc/etc fn has closure. fn has to be a resolved symbol of kind nnkSym. This implies that the macro that calls this proc should accept typed arguments and not untyped arguments. Source   Edit   

proc isNamedTuple(T: typedesc): bool {.magic: "TypeTrait", ....}

Returns true for named tuples, false for any other type.

Example:

doAssert not isNamedTuple(int)
doAssert not isNamedTuple((string, int))
doAssert isNamedTuple(tuple[name: string, age: int])

	Source   Edit   

proc name(t: typedesc): string {.magic: "TypeTrait", ....}

Returns the name of t.

Alias for system.`$`(t) since Nim v0.20.

Example:

doAssert name(int) == "int"
doAssert name(seq[string]) == "seq[string]"

	Source   Edit   

proc stripGenericParams(t: typedesc): typedesc {.magic: "TypeTrait", ....}

This trait is similar to genericHead, but instead of producing an error for non-generic types, it will just return them unmodified.

Example:

type Foo[T] = object

doAssert stripGenericParams(Foo[string]) is Foo
doAssert stripGenericParams(int) is int

	Source   Edit   

proc supportsCopyMem(t: typedesc): bool {.magic: "TypeTrait", ....}

	Returns true if t is safe to use for copyMem.

	Other languages name a type like these blob.
	Source   Edit   

proc tupleLen(T: typedesc[tuple]): int {.magic: "TypeTrait", ....}

Returns the number of elements of the tuple type T.

See also:

	tupleLen template

Example:

doAssert tupleLen((int, int, float, string)) == 4
doAssert tupleLen(tuple[name: string, age: int]) == 2

	Source   Edit   

Macros

macro enumLen(T: typedesc[enum]): int

Returns the number of items in the enum T.

Example:

type Foo = enum
  fooItem1
  fooItem2

doAssert Foo.enumLen == 2

	Source   Edit   

Templates

template distinctBase[T](a: T; recursive: static bool = true): untyped

Overload of distinctBase for values.

Example:

type MyInt = distinct int
type MyOtherInt = distinct MyInt
doAssert 12.MyInt.distinctBase == 12
doAssert 12.MyOtherInt.distinctBase == 12
doAssert 12.MyOtherInt.distinctBase(false) is MyInt
doAssert 12.distinctBase == 12

	Source   Edit   

template elementType(a: untyped): typedesc

Returns the element type of a, which can be any iterable (over which you can iterate).

Example:

iterator myiter(n: int): auto =
  for i in 0 ..< n:
	yield i

doAssert elementType(@[1,2]) is int
doAssert elementType("asdf") is char
doAssert elementType(myiter(3)) is int

	Source   Edit   

template genericParams(T: typedesc): untyped

Returns the tuple of generic parameters for the generic type T.

Note: For the builtin array type, the index generic parameter will always become a range type after it's bound to a variable.

Example:

type Foo[T1, T2] = object

doAssert genericParams(Foo[float, string]) is (float, string)

type Bar[N: static float, T] = object

doAssert genericParams(Bar[1.0, string]) is (StaticParam[1.0], string)
doAssert genericParams(Bar[1.0, string]).get(0).value == 1.0
doAssert genericParams(seq[Bar[2.0, string]]).get(0) is Bar[2.0, string]
var s: seq[Bar[3.0, string]]
doAssert genericParams(typeof(s)) is (Bar[3.0, string],)

doAssert genericParams(array[10, int]) is (StaticParam[10], int)
var a: array[10, int]
doAssert genericParams(typeof(a)) is (range[0..9], int)

	Source   Edit   

template get(T: typedesc[tuple]; i: static int): untyped

Returns the i-th element of T.

Example:

doAssert get((int, int, float, string), 2) is float

	Source   Edit   

template pointerBase[T](_: typedesc[ptr T | ref T]): typedesc

Returns T for ref T | ptr T.

Example:

assert (ref int).pointerBase is int
type A = ptr seq[float]
assert A.pointerBase is seq[float]
assert (ref A).pointerBase is A # not seq[float]
assert (var s = "abc"; s[0].addr).typeof.pointerBase is char

	Source   Edit   

template toSigned(T: typedesc[SomeInteger and not range]): untyped

Returns a signed type with same bit size as T.

Example:

assert int8.toSigned is int8
assert uint16.toSigned is int16
# range types are currently unsupported:
assert not compiles(toSigned(range[0..7]))

	Source   Edit   

template toUnsigned(T: typedesc[SomeInteger and not range]): untyped

Returns an unsigned type with same bit size as T.

Example:

assert int8.toUnsigned is uint8
assert uint.toUnsigned is uint
assert int.toUnsigned is uint
# range types are currently unsupported:
assert not compiles(toUnsigned(range[0..7]))

	Source   Edit   

template tupleLen(t: tuple): int

Returns the number of elements of the tuple t.

See also:

	tupleLen proc

Example:

doAssert tupleLen((1, 2)) == 2

	Source   Edit   

Exports

$, $, $, $, $, $, $, $, $, $, $, $, $, $, $, $, $, $, $, $, $, $



std/volatile


std/volatile
Source   Edit  

This module contains code for generating volatile loads and stores, which are useful in embedded and systems programming.
Templates

template volatileLoad[T](src: ptr T): T

	Generates a volatile load of the value stored in the container src. Note that this only effects code generation on C like backends. Source   Edit   

template volatileStore[T](dest: ptr T; val: T)

	Generates a volatile store into the container dest of the value val. Note that this only effects code generation on C like backends. Source   Edit   



Algorithms

std/algorithm


std/algorithm
Source   Edit  

This module implements some common generic algorithms on openArrays.
Basic usage

Example:

import std/algorithm
type People = tuple
  year: int
  name: string

var a: seq[People]

a.add((2000, "John"))
a.add((2005, "Marie"))
a.add((2010, "Jane"))

# Sorting with default system.cmp
a.sort()
assert a == @[(year: 2000, name: "John"), (year: 2005, name: "Marie"),
          	(year: 2010, name: "Jane")]

proc myCmp(x, y: People): int =
  cmp(x.name, y.name)

# Sorting with custom proc
a.sort(myCmp)
assert a == @[(year: 2010, name: "Jane"), (year: 2000, name: "John"),
          	(year: 2005, name: "Marie")]

See also

	sequtils module for working with the built-in seq type
	tables module for sorting tables

Imports

since

Types

SortOrder = enum
  Descending, Ascending

	Source   Edit   

Procs

proc `*`(x: int; order: SortOrder): int {.inline, ....}

Flips the sign of x if order == Descending. If order == Ascending then x is returned.

x is supposed to be the result of a comparator, i.e.

< 0 for less than,
== 0 for equal,
> 0 for greater than.

Example:

assert -123 * Descending == 123
assert 123 * Descending == -123
assert -123 * Ascending == -123
assert 123 * Ascending == 123

	Source   Edit   

proc binarySearch[T, K](a: openArray[T]; key: K;
                    	cmp: proc (x: T; y: K): int {.closure.}): int {.
	effectsOf: cmp.}

Binary search for key in a. Return the index of key or -1 if not found. Assumes that a is sorted according to cmp.

cmp is the comparator function to use, the expected return values are the same as those of system.cmp.

Example:

assert binarySearch(["a", "b", "c", "d"], "d", system.cmp[string]) == 3
assert binarySearch(["a", "b", "c", "d"], "c", system.cmp[string]) == 2

	Source   Edit   

proc binarySearch[T](a: openArray[T]; key: T): int

Binary search for key in a. Return the index of key or -1 if not found. Assumes that a is sorted.

Example:

assert binarySearch([0, 1, 2, 3, 4], 4) == 4
assert binarySearch([0, 1, 2, 3, 4], 2) == 2

	Source   Edit   

proc fill[T](a: var openArray[T]; first, last: Natural; value: T)

Assigns value to all elements of the slice a[first..last].

If an invalid range is passed, it raises IndexDefect.

Example:

var a: array[6, int]
a.fill(1, 3, 9)
assert a == [0, 9, 9, 9, 0, 0]
a.fill(3, 5, 7)
assert a == [0, 9, 9, 7, 7, 7]
doAssertRaises(IndexDefect, a.fill(1, 7, 9))

	Source   Edit   

proc fill[T](a: var openArray[T]; value: T)

Assigns value to all elements of the container a.

Example:

var a: array[6, int]
a.fill(9)
assert a == [9, 9, 9, 9, 9, 9]
a.fill(4)
assert a == [4, 4, 4, 4, 4, 4]

	Source   Edit   

func isSorted[T](a: openArray[T]; cmp: proc (x, y: T): int {.closure.};
             	order = SortOrder.Ascending): bool {.effectsOf: cmp.}

Checks to see whether a is already sorted in order using cmp for the comparison. The parameters are identical to sort. Requires O(n) time.

See also:

	isSorted proc

Example:

let
  a = [2, 3, 1, 5, 4]
  b = [1, 2, 3, 4, 5]
  c = [5, 4, 3, 2, 1]
  d = ["adam", "brian", "cat", "dande"]
  e = ["adam", "dande", "brian", "cat"]
assert isSorted(a) == false
assert isSorted(b) == true
assert isSorted(c) == false
assert isSorted(c, Descending) == true
assert isSorted(d) == true
assert isSorted(e) == false

	Source   Edit   

proc isSorted[T](a: openArray[T]; order = SortOrder.Ascending): bool

Shortcut version of isSorted that uses system.cmp[T] as the comparison function.

See also:

	isSorted func

Example:

let
  a = [2, 3, 1, 5, 4]
  b = [1, 2, 3, 4, 5]
  c = [5, 4, 3, 2, 1]
  d = ["adam", "brian", "cat", "dande"]
  e = ["adam", "dande", "brian", "cat"]
assert isSorted(a) == false
assert isSorted(b) == true
assert isSorted(c) == false
assert isSorted(c, Descending) == true
assert isSorted(d) == true
assert isSorted(e) == false

	Source   Edit   

proc lowerBound[T, K](a: openArray[T]; key: K;
                  	cmp: proc (x: T; k: K): int {.closure.}): int {.
	effectsOf: cmp.}

Returns the index of the first element in a that is not less than (i.e. greater or equal to) key, or last if no such element is found. In other words if you have a sorted sequence and you call insert(thing, elm, lowerBound(thing, elm)) the sequence will still be sorted. Assumes that a is sorted according to cmp.

If an invalid range is passed, it raises IndexDefect.

This version uses cmp to compare the elements. The expected return values are the same as those of system.cmp.

See also:

	upperBound proc sorted by cmp in the specified order
	upperBound proc

Example:

var arr = @[1, 2, 3, 5, 6, 7, 8, 9]
assert arr.lowerBound(3, system.cmp[int]) == 2
assert arr.lowerBound(4, system.cmp[int]) == 3
assert arr.lowerBound(5, system.cmp[int]) == 3
arr.insert(4, arr.lowerBound(4, system.cmp[int]))
assert arr == [1, 2, 3, 4, 5, 6, 7, 8, 9]

	Source   Edit   

proc lowerBound[T](a: openArray[T]; key: T): int

	Returns the index of the first element in a that is not less than (i.e. greater or equal to) key, or last if no such element is found. In other words if you have a sorted sequence and you call insert(thing, elm, lowerBound(thing, elm)) the sequence will still be sorted. Assumes that a is sorted.

	This version uses the default comparison function cmp.

	See also:

    	upperBound proc sorted by cmp in the specified order
    	upperBound proc

	Source   Edit   

proc merge[T](result: var seq[T]; x, y: openArray[T]) {.inline.}

Shortcut version of merge that uses system.cmp[T] as the comparison function.

See also:

	merge proc

Example:

let x = [5, 10, 15, 20, 25]
let y = [50, 40, 30, 20, 10].sorted

var merged: seq[int]
merged.merge(x, y)
assert merged.isSorted
assert merged == @[5, 10, 10, 15, 20, 20, 25, 30, 40, 50]

	Source   Edit   

proc merge[T](result: var seq[T]; x, y: openArray[T];
          	cmp: proc (x, y: T): int {.closure.}) {.effectsOf: cmp.}

Merges two sorted openArray. x and y are assumed to be sorted. If you do not wish to provide your own cmp, you may use system.cmp or instead call the overloaded version of merge, which uses system.cmp.
Note: The original data of result is not cleared, new data is appended to result.

See also:

	merge proc

Example:

let x = @[1, 3, 6]
let y = @[2, 3, 4]

block:
  var merged = @[7] # new data is appended to merged sequence
  merged.merge(x, y, system.cmp[int])
  assert merged == @[7, 1, 2, 3, 3, 4, 6]

block:
  var merged = @[7] # if you only want new data, clear merged sequence first
  merged.setLen(0)
  merged.merge(x, y, system.cmp[int])
  assert merged.isSorted
  assert merged == @[1, 2, 3, 3, 4, 6]

import std/sugar

var res: seq[(int, int)]
res.merge([(1, 1)], [(1, 2)], (a, b) => a[0] - b[0])
assert res == @[(1, 1), (1, 2)]

assert seq[int].default.dup(merge([1, 3], [2, 4])) == @[1, 2, 3, 4]

	Source   Edit   

proc nextPermutation[T](x: var openArray[T]): bool {.discardable.}

Calculates the next lexicographic permutation, directly modifying x. The result is whether a permutation happened, otherwise we have reached the last-ordered permutation.

If you start with an unsorted array/seq, the repeated permutations will not give you all permutations but stop with the last.

See also:

	prevPermutation proc

Example:

var v = @[0, 1, 2, 3]
assert v.nextPermutation() == true
assert v == @[0, 1, 3, 2]
assert v.nextPermutation() == true
assert v == @[0, 2, 1, 3]
assert v.prevPermutation() == true
assert v == @[0, 1, 3, 2]
v = @[3, 2, 1, 0]
assert v.nextPermutation() == false
assert v == @[3, 2, 1, 0]

	Source   Edit   

proc prevPermutation[T](x: var openArray[T]): bool {.discardable.}

Calculates the previous lexicographic permutation, directly modifying x. The result is whether a permutation happened, otherwise we have reached the first-ordered permutation.

See also:

	nextPermutation proc

Example:

var v = @[0, 1, 2, 3]
assert v.prevPermutation() == false
assert v == @[0, 1, 2, 3]
assert v.nextPermutation() == true
assert v == @[0, 1, 3, 2]
assert v.prevPermutation() == true
assert v == @[0, 1, 2, 3]

	Source   Edit   

proc product[T](x: openArray[seq[T]]): seq[seq[T]]

Produces the Cartesian product of the array. Every element of the result is a combination of one element from each seq in x, with the ith element coming from x[i].
Warning: complexity may explode.

Example:

assert product(@[@[1], @[2]]) == @[@[1, 2]]
assert product(@[@["A", "K"], @["Q"]]) == @[@["K", "Q"], @["A", "Q"]]

	Source   Edit   

proc reverse[T](a: var openArray[T])

Reverses the contents of the container a.

See also:

	reversed proc reverse a slice and returns a seq[T]
	reversed proc reverse and returns a seq[T]

Example:

var a = [1, 2, 3, 4, 5, 6]
a.reverse()
assert a == [6, 5, 4, 3, 2, 1]
a.reverse()
assert a == [1, 2, 3, 4, 5, 6]

	Source   Edit   

proc reverse[T](a: var openArray[T]; first, last: Natural)

Reverses the slice a[first..last].

If an invalid range is passed, it raises IndexDefect.

See also:

	reversed proc reverse a slice and returns a seq[T]
	reversed proc reverse and returns a seq[T]

Example:

var a = [1, 2, 3, 4, 5, 6]
a.reverse(1, 3)
assert a == [1, 4, 3, 2, 5, 6]
a.reverse(1, 3)
assert a == [1, 2, 3, 4, 5, 6]
doAssertRaises(IndexDefect, a.reverse(1, 7))

	Source   Edit   

proc reversed[T](a: openArray[T]): seq[T] {.inline.}

Returns the elements of a in reverse order.

See also:

	reverse proc

Example:

assert [10, 11, 12].reversed == @[12, 11, 10]
assert seq[string].default.reversed == @[]

	Source   Edit   

proc reversed[T](a: openArray[T]; first: Natural; last: int): seq[T] {.inline,
	....}

	Deprecated: use: `reversed(toOpenArray(a, first, last))`
	Source   Edit   

proc rotatedLeft[T](arg: openArray[T]; dist: int): seq[T]

Same as rotateLeft, just with the difference that it does not modify the argument. It creates a new seq instead.

See also:

	rotateLeft proc for the in-place version of this proc
	rotatedLeft proc for a version which rotates a range

Example:

var a = @[1, 2, 3, 4, 5]
a = rotatedLeft(a, 2)
assert a == @[3, 4, 5, 1, 2]
a = rotatedLeft(a, 4)
assert a == @[2, 3, 4, 5, 1]
a = rotatedLeft(a, -6)
assert a == @[1, 2, 3, 4, 5]

	Source   Edit   

proc rotatedLeft[T](arg: openArray[T]; slice: HSlice[int, int]; dist: int): seq[
	T]

Same as rotateLeft, just with the difference that it does not modify the argument. It creates a new seq instead.

Elements outside of slice will be left unchanged. If an invalid range (HSlice) is passed, it raises IndexDefect.

slice
	The indices of the element range that should be rotated.
dist
	The distance in amount of elements that the data should be rotated. Can be negative, can be any number.

See also:

	rotateLeft proc for the in-place version of this proc
	rotatedLeft proc for a version which rotates the whole container

Example:

var a = @[1, 2, 3, 4, 5]
a = rotatedLeft(a, 1 .. 4, 3)
assert a == @[1, 5, 2, 3, 4]
a = rotatedLeft(a, 1 .. 3, 2)
assert a == @[1, 3, 5, 2, 4]
a = rotatedLeft(a, 1 .. 3, -2)
assert a == @[1, 5, 2, 3, 4]

	Source   Edit   

proc rotateLeft[T](arg: var openArray[T]; dist: int): int {.discardable.}

Same as rotateLeft, but with default arguments for slice, so that this procedure operates on the entire arg, and not just on a part of it.

See also:

	rotateLeft proc for a version which rotates a range
	rotatedLeft proc for a version which returns a seq[T]

Example:

var a = [1, 2, 3, 4, 5]
a.rotateLeft(2)
assert a == [3, 4, 5, 1, 2]
a.rotateLeft(4)
assert a == [2, 3, 4, 5, 1]
a.rotateLeft(-6)
assert a == [1, 2, 3, 4, 5]

	Source   Edit   

proc rotateLeft[T](arg: var openArray[T]; slice: HSlice[int, int]; dist: int): int {.
	discardable.}

Performs a left rotation on a range of elements. If you want to rotate right, use a negative dist. Specifically, rotateLeft rotates the elements at slice by dist positions.

The element at index slice.a + dist will be at index slice.a.
The element at index slice.b will be at slice.a + dist - 1.
The element at index slice.a will be at slice.b + 1 - dist.
The element at index slice.a + dist - 1 will be at slice.b.

Elements outside of slice will be left unchanged. The time complexity is linear to slice.b - slice.a + 1. If an invalid range (HSlice) is passed, it raises IndexDefect.

slice
	The indices of the element range that should be rotated.
dist
	The distance in amount of elements that the data should be rotated. Can be negative, can be any number.

See also:

	rotateLeft proc for a version which rotates the whole container
	rotatedLeft proc for a version which returns a seq[T]

Example:

var a = [0, 1, 2, 3, 4, 5]
a.rotateLeft(1 .. 4, 3)
assert a == [0, 4, 1, 2, 3, 5]
a.rotateLeft(1 .. 4, 3)
assert a == [0, 3, 4, 1, 2, 5]
a.rotateLeft(1 .. 4, -3)
assert a == [0, 4, 1, 2, 3, 5]
doAssertRaises(IndexDefect, a.rotateLeft(1 .. 7, 2))

	Source   Edit   

func sort[T](a: var openArray[T]; cmp: proc (x, y: T): int {.closure.};
         	order = SortOrder.Ascending) {.effectsOf: cmp.}

Default Nim sort (an implementation of merge sort). The sorting is guaranteed to be stable (that is, equal elements stay in the same order) and the worst case is guaranteed to be O(n log n). Sorts by cmp in the specified order.

The current implementation uses an iterative mergesort to achieve this. It uses a temporary sequence of length a.len div 2. If you do not wish to provide your own cmp, you may use system.cmp or instead call the overloaded version of sort, which uses system.cmp.

sort(myIntArray, system.cmp[int])
# do not use cmp[string] here as we want to use the specialized
# overload:
sort(myStrArray, system.cmp)

You can inline adhoc comparison procs with the do notation. Example:

people.sort do (x, y: Person) -> int:
  result = cmp(x.surname, y.surname)
  if result == 0:
	result = cmp(x.name, y.name)

See also:

	sort proc
	sorted proc sorted by cmp in the specified order
	sorted proc
	sortedByIt template

Example:

var d = ["boo", "fo", "barr", "qux"]
proc myCmp(x, y: string): int =
  if x.len() > y.len() or x.len() == y.len(): 1
  else: -1
sort(d, myCmp)
assert d == ["fo", "qux", "boo", "barr"]

	Source   Edit   

proc sort[T](a: var openArray[T]; order = SortOrder.Ascending)

	Shortcut version of sort that uses system.cmp[T] as the comparison function.

	See also:

    	sort func
    	sorted proc sorted by cmp in the specified order
    	sorted proc
    	sortedByIt template

	Source   Edit   

proc sorted[T](a: openArray[T]; cmp: proc (x, y: T): int {.closure.};
           	order = SortOrder.Ascending): seq[T] {.effectsOf: cmp.}

Returns a sorted by cmp in the specified order.

See also:

	sort func
	sort proc
	sortedByIt template

Example:

let
  a = [2, 3, 1, 5, 4]
  b = sorted(a, system.cmp[int])
  c = sorted(a, system.cmp[int], Descending)
  d = sorted(["adam", "dande", "brian", "cat"], system.cmp[string])
assert b == @[1, 2, 3, 4, 5]
assert c == @[5, 4, 3, 2, 1]
assert d == @["adam", "brian", "cat", "dande"]

	Source   Edit   

proc sorted[T](a: openArray[T]; order = SortOrder.Ascending): seq[T]

Shortcut version of sorted that uses system.cmp[T] as the comparison function.

See also:

	sort func
	sort proc
	sortedByIt template

Example:

let
  a = [2, 3, 1, 5, 4]
  b = sorted(a)
  c = sorted(a, Descending)
  d = sorted(["adam", "dande", "brian", "cat"])
assert b == @[1, 2, 3, 4, 5]
assert c == @[5, 4, 3, 2, 1]
assert d == @["adam", "brian", "cat", "dande"]

	Source   Edit   

proc upperBound[T, K](a: openArray[T]; key: K;
                  	cmp: proc (x: T; k: K): int {.closure.}): int {.
	effectsOf: cmp.}

Returns the index of the first element in a that is greater than key, or last if no such element is found. In other words if you have a sorted sequence and you call insert(thing, elm, upperBound(thing, elm)) the sequence will still be sorted. Assumes that a is sorted according to cmp.

If an invalid range is passed, it raises IndexDefect.

This version uses cmp to compare the elements. The expected return values are the same as those of system.cmp.

See also:

	lowerBound proc sorted by cmp in the specified order
	lowerBound proc

Example:

var arr = @[1, 2, 3, 5, 6, 7, 8, 9]
assert arr.upperBound(2, system.cmp[int]) == 2
assert arr.upperBound(3, system.cmp[int]) == 3
assert arr.upperBound(4, system.cmp[int]) == 3
arr.insert(4, arr.upperBound(3, system.cmp[int]))
assert arr == [1, 2, 3, 4, 5, 6, 7, 8, 9]

	Source   Edit   

proc upperBound[T](a: openArray[T]; key: T): int

	Returns the index of the first element in a that is greater than key, or last if no such element is found. In other words if you have a sorted sequence and you call insert(thing, elm, upperBound(thing, elm)) the sequence will still be sorted. Assumes that a is sorted.

	This version uses the default comparison function cmp.

	See also:

    	lowerBound proc sorted by cmp in the specified order
    	lowerBound proc

	Source   Edit   

Templates

template sortedByIt(seq1, op: untyped): untyped

Convenience template around the sorted proc to reduce typing.

The template injects the it variable which you can use directly in an expression.

Because the underlying cmp() is defined for tuples you can also do a nested sort.

See also:

	sort func
	sort proc
	sorted proc sorted by cmp in the specified order
	sorted proc

Example:

type Person = tuple[name: string, age: int]
var
  p1: Person = (name: "p1", age: 60)
  p2: Person = (name: "p2", age: 20)
  p3: Person = (name: "p3", age: 30)
  p4: Person = (name: "p4", age: 30)
  people = @[p1, p2, p4, p3]

assert people.sortedByIt(it.name) == @[(name: "p1", age: 60), (name: "p2",
	age: 20), (name: "p3", age: 30), (name: "p4", age: 30)]
# Nested sort
assert people.sortedByIt((it.age, it.name)) == @[(name: "p2", age: 20),
   (name: "p3", age: 30), (name: "p4", age: 30), (name: "p1", age: 60)]

	Source   Edit   


std/enumutils


std/enumutils
Source   Edit  

Imports

macros, typetraits

Procs

func symbolName[T: enum](a: T): string

Returns the symbol name of an enum.

This uses symbolRank.

Example:

type B = enum
  b0 = (10, "kb0")
  b1 = "kb1"
  b2
let b = B.low
assert b.symbolName == "b0"
assert $b == "kb0"
static: assert B.high.symbolName == "b2"
type C = enum # HoleyEnum
  c0 = -3
  c1 = 4
  c2 = 20
assert c1.symbolName == "c1"

	Source   Edit   

Iterators

iterator items[T: HoleyEnum](E: typedesc[T]): T

Iterates over an enum with holes.

Example:

type
  A = enum
	a0 = 2
	a1 = 4
	a2
  B[T] = enum
	b0 = 2
	b1 = 4
from std/sequtils import toSeq
assert A.toSeq == [a0, a1, a2]
assert B[float].toSeq == [B[float].b0, B[float].b1]

	Source   Edit   

Macros

macro genEnumCaseStmt(typ: typedesc; argSym: typed; default: typed;
                  	userMin, userMax: static[int];
                  	normalizer: static[proc (s: string): string]): untyped

	Source   Edit   

Templates

template symbolRank[T: enum](a: T): int

Returns the index in which a is listed in T.

The cost for a HoleyEnum is implementation defined, currently optimized for small enums, otherwise is O(T.enumLen).

Example:

type
  A = enum # HoleyEnum
	a0 = -3
	a1 = 10
	a2
	a3 = (20, "f3Alt")
  B = enum # OrdinalEnum
	b0
	b1
	b2
  C = enum # OrdinalEnum
	c0 = 10
	c1
	c2
assert a2.symbolRank == 2
assert b2.symbolRank == 2
assert c2.symbolRank == 2
assert c2.ord == 12
assert a2.ord == 11
var invalid = 7.A
doAssertRaises(IndexDefect): discard invalid.symbolRank

	Source   Edit   


std/sequtils


std/sequtils
Source   Edit  

Although this module has seq in its name, it implements operations not only for the seq type, but for three built-in container types under the openArray umbrella:

	sequences
	strings
	array

The system module defines several common functions, such as:

	newSeq[T] for creating new sequences of type T
	@ for converting arrays and strings to sequences
	add for adding new elements to strings and sequences
	& for string and seq concatenation
	in (alias for contains) and notin for checking if an item is in a container

This module builds upon that, providing additional functionality in form of procs, iterators and templates inspired by functional programming languages.

For functional style programming you have different options at your disposal:

	the sugar.collect macro
	pass an anonymous proc
	import the sugar module and use the => macro
	use ...It templates (mapIt, filterIt, etc.)

Chaining of functions is possible thanks to the method call syntax.

Example:

import std/sequtils
import std/sugar

# Creating a sequence from 1 to 10, multiplying each member by 2,
# keeping only the members which are not divisible by 6.
let
  foo = toSeq(1..10).map(x => x * 2).filter(x => x mod 6 != 0)
  bar = toSeq(1..10).mapIt(it * 2).filterIt(it mod 6 != 0)
  baz = collect:
	for i in 1..10:
  	let j = 2 * i
  	if j mod 6 != 0:
    	j

doAssert foo == bar
doAssert foo == baz
doAssert foo == @[2, 4, 8, 10, 14, 16, 20]

doAssert foo.any(x => x > 17)
doAssert not bar.allIt(it < 20)
doAssert foo.foldl(a + b) == 74 # sum of all members

Example:

import std/sequtils
from std/strutils import join

let
  vowels = @"aeiou"
  foo = "sequtils is an awesome module"

doAssert (vowels is seq[char]) and (vowels == @['a', 'e', 'i', 'o', 'u'])
doAssert foo.filterIt(it notin vowels).join == "sqtls s n wsm mdl"

See also

	strutils module for common string functions
	sugar module for syntactic sugar macros
	algorithm module for common generic algorithms
	json module for a structure which allows heterogeneous members

Imports

since, macros

Procs

proc all[T](s: openArray[T]; pred: proc (x: T): bool {.closure.}): bool {.
	effectsOf: pred.}

Iterates through a container and checks if every item fulfills the predicate.

See also:

	allIt template
	any proc

Example:

let numbers = @[1, 4, 5, 8, 9, 7, 4]
assert all(numbers, proc (x: int): bool = x < 10) == true
assert all(numbers, proc (x: int): bool = x < 9) == false

	Source   Edit   

proc any[T](s: openArray[T]; pred: proc (x: T): bool {.closure.}): bool {.
	effectsOf: pred.}

Iterates through a container and checks if at least one item fulfills the predicate.

See also:

	anyIt template
	all proc

Example:

let numbers = @[1, 4, 5, 8, 9, 7, 4]
assert any(numbers, proc (x: int): bool = x > 8) == true
assert any(numbers, proc (x: int): bool = x > 9) == false

	Source   Edit   

proc apply[T](s: openArray[T]; op: proc (x: T) {.closure.}) {.inline,
	effectsOf: op.}

Same as apply but for a proc that does not return anything and does not mutate s directly.

Example:

var message: string
apply([0, 1, 2, 3, 4], proc(item: int) = message.addInt item)
assert message == "01234"

	Source   Edit   

proc apply[T](s: var openArray[T]; op: proc (x: T): T {.closure.}) {.inline,
	effectsOf: op.}

Applies op to every item in s modifying it directly.

Note that the container s must be declared as a var and it is required for your input and output types to be the same, since s is modified in-place. The parameter function takes and returns a T type variable.

See also:

	applyIt template
	map proc

Example:

var a = @["1", "2", "3", "4"]
apply(a, proc(x: string): string = x & "42")
assert a == @["142", "242", "342", "442"]

	Source   Edit   

proc apply[T](s: var openArray[T]; op: proc (x: var T) {.closure.}) {.inline,
	effectsOf: op.}

Applies op to every item in s, modifying it directly.

Note that the container s must be declared as a var, since s is modified in-place. The parameter function takes a var T type parameter.

See also:

	applyIt template
	map proc

Example:

var a = @["1", "2", "3", "4"]
apply(a, proc(x: var string) = x &= "42")
assert a == @["142", "242", "342", "442"]

	Source   Edit   

func concat[T](seqs: varargs[seq[T]]): seq[T]

Takes several sequences' items and returns them inside a new sequence. All sequences must be of the same type.

See also:

	distribute func for a reverse operation

Example:

let
  s1 = @[1, 2, 3]
  s2 = @[4, 5]
  s3 = @[6, 7]
  total = concat(s1, s2, s3)
assert total == @[1, 2, 3, 4, 5, 6, 7]

	Source   Edit   

func count[T](s: openArray[T]; x: T): int

Returns the number of occurrences of the item x in the container s.

Example:

let
  a = @[1, 2, 2, 3, 2, 4, 2]
  b = "abracadabra"
assert count(a, 2) == 4
assert count(a, 99) == 0
assert count(b, 'r') == 2

	Source   Edit   

func cycle[T](s: openArray[T]; n: Natural): seq[T]

Returns a new sequence with the items of the container s repeated n times. n must be a non-negative number (zero or more).

Example:

let
  s = @[1, 2, 3]
  total = s.cycle(3)
assert total == @[1, 2, 3, 1, 2, 3, 1, 2, 3]

	Source   Edit   

func deduplicate[T](s: openArray[T]; isSorted: bool = false): seq[T]

Returns a new sequence without duplicates.

Setting the optional argument isSorted to true (default: false) uses a faster algorithm for deduplication.

Example:

let
  dup1 = @[1, 1, 3, 4, 2, 2, 8, 1, 4]
  dup2 = @["a", "a", "c", "d", "d"]
  unique1 = deduplicate(dup1)
  unique2 = deduplicate(dup2, isSorted = true)
assert unique1 == @[1, 3, 4, 2, 8]
assert unique2 == @["a", "c", "d"]

	Source   Edit   

func delete[T](s: var seq[T]; first, last: Natural) {.
	....}

Deprecated: use `delete(s, first..last)`
Deletes the items of a sequence s at positions first..last (including both ends of the range). This modifies s itself, it does not return a copy.

Example: cmd: --warning:deprecated:off

let outcome = @[1, 1, 1, 1, 1, 1, 1, 1]
var dest = @[1, 1, 1, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1]
dest.delete(3, 8)
assert outcome == dest

	Source   Edit   

func delete[T](s: var seq[T]; slice: Slice[int])

Deletes the items s[slice], raising IndexDefect if the slice contains elements out of range.

This operation moves all elements after s[slice] in linear time.

Example:

var a = @[10, 11, 12, 13, 14]
doAssertRaises(IndexDefect): a.delete(4..5)
assert a == @[10, 11, 12, 13, 14]
a.delete(4..4)
assert a == @[10, 11, 12, 13]
a.delete(1..2)
assert a == @[10, 13]
a.delete(1..<1) # empty slice
assert a == @[10, 13]

	Source   Edit   

func distribute[T](s: seq[T]; num: Positive; spread = true): seq[seq[T]]

Splits and distributes a sequence s into num sub-sequences.

Returns a sequence of num sequences. For some input values this is the inverse of the concat func. The input sequence s can be empty, which will produce num empty sequences.

If spread is false and the length of s is not a multiple of num, the func will max out the first sub-sequence with 1 + len(s) div num entries, leaving the remainder of elements to the last sequence.

On the other hand, if spread is true, the func will distribute evenly the remainder of the division across all sequences, which makes the result more suited to multithreading where you are passing equal sized work units to a thread pool and want to maximize core usage.

Example:

let numbers = @[1, 2, 3, 4, 5, 6, 7]
assert numbers.distribute(3) == @[@[1, 2, 3], @[4, 5], @[6, 7]]
assert numbers.distribute(3, false) == @[@[1, 2, 3], @[4, 5, 6], @[7]]
assert numbers.distribute(6)[0] == @[1, 2]
assert numbers.distribute(6)[1] == @[3]

	Source   Edit   

proc filter[T](s: openArray[T]; pred: proc (x: T): bool {.closure.}): seq[T] {.
	inline, effectsOf: pred.}

Returns a new sequence with all the items of s that fulfill the predicate pred (a function that returns a bool).

Instead of using map and filter, consider using the collect macro from the sugar module.

See also:

	sugar.collect macro
	filterIt template
	filter iterator
	keepIf proc for the in-place version

Example:

let
  colors = @["red", "yellow", "black"]
  f1 = filter(colors, proc(x: string): bool = x.len < 6)
  f2 = filter(colors, proc(x: string): bool = x.contains('y'))
assert f1 == @["red", "black"]
assert f2 == @["yellow"]

	Source   Edit   

func insert[T](dest: var seq[T]; src: openArray[T]; pos = 0)

Inserts items from src into dest at position pos. This modifies dest itself, it does not return a copy.

Note that the elements of src and dest must be of the same type.

Example:

var dest = @[1, 1, 1, 1, 1, 1, 1, 1]
let
  src = @[2, 2, 2, 2, 2, 2]
  outcome = @[1, 1, 1, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1]
dest.insert(src, 3)
assert dest == outcome

	Source   Edit   

proc keepIf[T](s: var seq[T]; pred: proc (x: T): bool {.closure.}) {.inline,
	effectsOf: pred.}

Keeps the items in the passed sequence s if they fulfill the predicate pred (a function that returns a bool).

Note that s must be declared as a var.

Similar to the filter proc, but modifies the sequence directly.

See also:

	keepItIf template
	filter proc

Example:

var floats = @[13.0, 12.5, 5.8, 2.0, 6.1, 9.9, 10.1]
keepIf(floats, proc(x: float): bool = x > 10)
assert floats == @[13.0, 12.5, 10.1]

	Source   Edit   

proc map[T, S](s: openArray[T]; op: proc (x: T): S {.closure.}): seq[S] {.
	inline, effectsOf: op.}

Returns a new sequence with the results of the op proc applied to every item in the container s.

Since the input is not modified, you can use it to transform the type of the elements in the input container.

Instead of using map and filter, consider using the collect macro from the sugar module.

See also:

	sugar.collect macro
	mapIt template
	apply proc for the in-place version

Example:

let
  a = @[1, 2, 3, 4]
  b = map(a, proc(x: int): string = $x)
assert b == @["1", "2", "3", "4"]

	Source   Edit   

func maxIndex[T](s: openArray[T]): int

Returns the index of the maximum value of s. T needs to have a < operator.

Example:

let
  a = @[1, 2, 3, 4]
  b = @[6, 5, 4, 3]
  c = [2, -7, 8, -5]
  d = "ziggy"
assert maxIndex(a) == 3
assert maxIndex(b) == 0
assert maxIndex(c) == 2
assert maxIndex(d) == 0

	Source   Edit   

func minIndex[T](s: openArray[T]): int

Returns the index of the minimum value of s. T needs to have a < operator.

Example:

let
  a = @[1, 2, 3, 4]
  b = @[6, 5, 4, 3]
  c = [2, -7, 8, -5]
  d = "ziggy"
assert minIndex(a) == 0
assert minIndex(b) == 3
assert minIndex(c) == 1
assert minIndex(d) == 2

	Source   Edit   

func minmax[T](x: openArray[T]): (T, T)

	The minimum and maximum values of x. T needs to have a < operator. Source   Edit   

proc repeat[T](x: T; n: Natural): seq[T]

Returns a new sequence with the item x repeated n times. n must be a non-negative number (zero or more).

Example:

let
  total = repeat(5, 3)
assert total == @[5, 5, 5]

	Source   Edit   

proc unzip[S, T](s: openArray[(S, T)]): (seq[S], seq[T])

Returns a tuple of two sequences split out from a sequence of 2-field tuples.

Example:

let
  zipped = @[(1, 'a'), (2, 'b'), (3, 'c')]
  unzipped1 = @[1, 2, 3]
  unzipped2 = @['a', 'b', 'c']
assert zipped.unzip() == (unzipped1, unzipped2)
assert zip(unzipped1, unzipped2).unzip() == (unzipped1, unzipped2)

	Source   Edit   

proc zip[S, T](s1: openArray[S]; s2: openArray[T]): seq[(S, T)]

Returns a new sequence with a combination of the two input containers.

The input containers can be of different types. If one container is shorter, the remaining items in the longer container are discarded.

Note: For Nim 1.0.x and older version, zip returned a seq of named tuples with fields a and b. For Nim versions 1.1.x and newer, zip returns a seq of unnamed tuples.

Example:

let
  short = @[1, 2, 3]
  long = @[6, 5, 4, 3, 2, 1]
  words = @["one", "two", "three"]
  letters = "abcd"
  zip1 = zip(short, long)
  zip2 = zip(short, words)
assert zip1 == @[(1, 6), (2, 5), (3, 4)]
assert zip2 == @[(1, "one"), (2, "two"), (3, "three")]
assert zip1[2][0] == 3
assert zip2[1][1] == "two"
when (NimMajor, NimMinor) <= (1, 0):
  let
	zip3 = zip(long, letters)
  assert zip3 == @[(a: 6, b: 'a'), (5, 'b'), (4, 'c'), (3, 'd')]
  assert zip3[0].b == 'a'
else:
  let
	zip3: seq[tuple[num: int, letter: char]] = zip(long, letters)
  assert zip3 == @[(6, 'a'), (5, 'b'), (4, 'c'), (3, 'd')]
  assert zip3[0].letter == 'a'

	Source   Edit   

Iterators

iterator filter[T](s: openArray[T]; pred: proc (x: T): bool {.closure.}): T {.
	effectsOf: pred.}

Iterates through a container s and yields every item that fulfills the predicate pred (a function that returns a bool).

Instead of using map and filter, consider using the collect macro from the sugar module.

See also:

	sugar.collect macro
	filter proc
	filterIt template

Example:

let numbers = @[1, 4, 5, 8, 9, 7, 4]
var evens = newSeq[int]()
for n in filter(numbers, proc (x: int): bool = x mod 2 == 0):
  evens.add(n)
assert evens == @[4, 8, 4]

	Source   Edit   

iterator items[T](xs: iterator (): T): T

	Iterates over each element yielded by a closure iterator. This may not seem particularly useful on its own, but this allows closure iterators to be used by the mapIt, filterIt, allIt, anyIt, etc. templates. Source   Edit   

Macros

macro mapLiterals(constructor, op: untyped; nested = true): untyped

Applies op to each of the atomic literals like 3 or "abc" in the specified constructor AST. This can be used to map every array element to some target type:

Example:

let x = mapLiterals([0.1, 1.2, 2.3, 3.4], int)
doAssert x is array[4, int]
doAssert x == [int(0.1), int(1.2), int(2.3), int(3.4)]

If nested is true (which is the default), the literals are replaced everywhere in the constructor AST, otherwise only the first level is considered:

Example:

let a = mapLiterals((1.2, (2.3, 3.4), 4.8), int)
let b = mapLiterals((1.2, (2.3, 3.4), 4.8), int, nested=false)
assert a == (1, (2, 3), 4)
assert b == (1, (2.3, 3.4), 4)

let c = mapLiterals((1, (2, 3), 4, (5, 6)), `$`)
let d = mapLiterals((1, (2, 3), 4, (5, 6)), `$`, nested=false)
assert c == ("1", ("2", "3"), "4", ("5", "6"))
assert d == ("1", (2, 3), "4", (5, 6))

	There are no constraints for the constructor AST, it works for nested tuples of arrays of sets etc. Source   Edit   

Templates

template allIt(s, pred: untyped): bool

Iterates through a container and checks if every item fulfills the predicate.

Unlike the all proc, the predicate needs to be an expression using the it variable for testing, like: allIt("abba", it == 'a').

See also:

	all proc
	anyIt template

Example:

let numbers = @[1, 4, 5, 8, 9, 7, 4]
assert numbers.allIt(it < 10) == true
assert numbers.allIt(it < 9) == false

	Source   Edit   

template anyIt(s, pred: untyped): bool

Iterates through a container and checks if at least one item fulfills the predicate.

Unlike the any proc, the predicate needs to be an expression using the it variable for testing, like: anyIt("abba", it == 'a').

See also:

	any proc
	allIt template

Example:

let numbers = @[1, 4, 5, 8, 9, 7, 4]
assert numbers.anyIt(it > 8) == true
assert numbers.anyIt(it > 9) == false

	Source   Edit   

template applyIt(varSeq, op: untyped)

Convenience template around the mutable apply proc to reduce typing.

The template injects the it variable which you can use directly in an expression. The expression has to return the same type as the elements of the sequence you are mutating.

See also:

	apply proc
	mapIt template

Example:

var nums = @[1, 2, 3, 4]
nums.applyIt(it * 3)
assert nums[0] + nums[3] == 15

	Source   Edit   

template countIt(s, pred: untyped): int

Returns a count of all the items that fulfill the predicate.

The predicate needs to be an expression using the it variable for testing, like: countIt(@[1, 2, 3], it > 2).

Example:

let numbers = @[-3, -2, -1, 0, 1, 2, 3, 4, 5, 6]
iterator iota(n: int): int =
  for i in 0..<n: yield i
assert numbers.countIt(it < 0) == 3
assert countIt(iota(10), it < 2) == 2

	Source   Edit   

template filterIt(s, pred: untyped): untyped

Returns a new sequence with all the items of s that fulfill the predicate pred.

Unlike the filter proc and filter iterator, the predicate needs to be an expression using the it variable for testing, like: filterIt("abcxyz", it == 'x').

Instead of using mapIt and filterIt, consider using the collect macro from the sugar module.

See also:

	sugar.collect macro
	filter proc
	filter iterator

Example:

let
  temperatures = @[-272.15, -2.0, 24.5, 44.31, 99.9, -113.44]
  acceptable = temperatures.filterIt(it < 50 and it > -10)
  notAcceptable = temperatures.filterIt(it > 50 or it < -10)
assert acceptable == @[-2.0, 24.5, 44.31]
assert notAcceptable == @[-272.15, 99.9, -113.44]

	Source   Edit   

template foldl(sequence, operation, first): untyped

Template to fold a sequence from left to right, returning the accumulation.

This version of foldl gets a starting parameter. This makes it possible to accumulate the sequence into a different type than the sequence elements.

The operation parameter should be an expression which uses the variables a and b for each step of the fold. The first parameter is the start value (the first a) and therefore defines the type of the result.

See also:

	foldr template

Example:

let
  numbers = @[0, 8, 1, 5]
  digits = foldl(numbers, a & (chr(b + ord('0'))), "")
assert digits == "0815"

	Source   Edit   

template foldl(sequence, operation: untyped): untyped

Template to fold a sequence from left to right, returning the accumulation.

The sequence is required to have at least a single element. Debug versions of your program will assert in this situation but release versions will happily go ahead. If the sequence has a single element it will be returned without applying operation.

The operation parameter should be an expression which uses the variables a and b for each step of the fold. Since this is a left fold, for non associative binary operations like subtraction think that the sequence of numbers 1, 2 and 3 will be parenthesized as (((1) - 2) - 3).

See also:

	foldl template with a starting parameter
	foldr template

Example:

let
  numbers = @[5, 9, 11]
  addition = foldl(numbers, a + b)
  subtraction = foldl(numbers, a - b)
  multiplication = foldl(numbers, a * b)
  words = @["nim", "is", "cool"]
  concatenation = foldl(words, a & b)
  procs = @["proc", "Is", "Also", "Fine"]


func foo(acc, cur: string): string =
  result = acc & cur

assert addition == 25, "Addition is (((5)+9)+11)"
assert subtraction == -15, "Subtraction is (((5)-9)-11)"
assert multiplication == 495, "Multiplication is (((5)*9)*11)"
assert concatenation == "nimiscool"
assert foldl(procs, foo(a, b)) == "procIsAlsoFine"

	Source   Edit   

template foldr(sequence, operation: untyped): untyped

Template to fold a sequence from right to left, returning the accumulation.

The sequence is required to have at least a single element. Debug versions of your program will assert in this situation but release versions will happily go ahead. If the sequence has a single element it will be returned without applying operation.

The operation parameter should be an expression which uses the variables a and b for each step of the fold. Since this is a right fold, for non associative binary operations like subtraction think that the sequence of numbers 1, 2 and 3 will be parenthesized as (1 - (2 - (3))).

See also:

	foldl template
	foldl template with a starting parameter

Example:

let
  numbers = @[5, 9, 11]
  addition = foldr(numbers, a + b)
  subtraction = foldr(numbers, a - b)
  multiplication = foldr(numbers, a * b)
  words = @["nim", "is", "cool"]
  concatenation = foldr(words, a & b)
assert addition == 25, "Addition is (5+(9+(11)))"
assert subtraction == 7, "Subtraction is (5-(9-(11)))"
assert multiplication == 495, "Multiplication is (5*(9*(11)))"
assert concatenation == "nimiscool"

	Source   Edit   

template keepItIf(varSeq: seq; pred: untyped)

Keeps the items in the passed sequence (must be declared as a var) if they fulfill the predicate.

Unlike the keepIf proc, the predicate needs to be an expression using the it variable for testing, like: keepItIf("abcxyz", it == 'x').

See also:

	keepIf proc
	filterIt template

Example:

var candidates = @["foo", "bar", "baz", "foobar"]
candidates.keepItIf(it.len == 3 and it[0] == 'b')
assert candidates == @["bar", "baz"]

	Source   Edit   

template mapIt(s: typed; op: untyped): untyped

Returns a new sequence with the results of the op proc applied to every item in the container s.

Since the input is not modified you can use it to transform the type of the elements in the input container.

The template injects the it variable which you can use directly in an expression.

Instead of using mapIt and filterIt, consider using the collect macro from the sugar module.

See also:

	sugar.collect macro
	map proc
	applyIt template for the in-place version

Example:

let
  nums = @[1, 2, 3, 4]
  strings = nums.mapIt($(4 * it))
assert strings == @["4", "8", "12", "16"]

	Source   Edit   

template newSeqWith(len: int; init: untyped): untyped

Creates a new seq of length len, calling init to initialize each value of the seq.

Useful for creating "2D" seqs - seqs containing other seqs or to populate fields of the created seq.

Example:

## Creates a seq containing 5 bool seqs, each of length of 3.
var seq2D = newSeqWith(5, newSeq[bool](3))
assert seq2D.len == 5
assert seq2D[0].len == 3
assert seq2D[4][2] == false

## Creates a seq with random numbers
import std/random
var seqRand = newSeqWith(20, rand(1.0))
assert seqRand[0] != seqRand[1]

	Source   Edit   

template toSeq(iter: untyped): untyped

Transforms any iterable (anything that can be iterated over, e.g. with a for-loop) into a sequence.

Example:

let
  myRange = 1..5
  mySet: set[int8] = {5'i8, 3, 1}
assert typeof(myRange) is HSlice[system.int, system.int]
assert typeof(mySet) is set[int8]

let
  mySeq1 = toSeq(myRange)
  mySeq2 = toSeq(mySet)
assert mySeq1 == @[1, 2, 3, 4, 5]
assert mySeq2 == @[1'i8, 3, 5]

	Source   Edit   


std/setutils


std/setutils
Source   Edit  

This module adds functionality for the built-in set type.
See also

	std/packedsets
	std/sets

Imports

typetraits, macros

Procs

func `[]=`[T](t: var set[T]; key: T; val: bool) {.inline.}

Syntax sugar for if val: t.incl key else: t.excl key

Example:

type A = enum
  a0, a1, a2, a3
var s = {a0, a3}
s[a0] = false
s[a1] = false
assert s == {a3}
s[a2] = true
s[a3] = true
assert s == {a2, a3}

	Source   Edit   

func complement[T](s: set[T]): set[T] {.inline.}

Returns the set complement of a.

Example:

type Colors = enum
  red, green = 3, blue
assert complement({red, blue}) == {green}
assert complement({red, green, blue}).card == 0
assert complement({range[0..10](0), 1, 2, 3}) == {range[0..10](4), 5, 6, 7, 8, 9, 10}
assert complement({'0'..'9'}) == {0.char..255.char} - {'0'..'9'}

	Source   Edit   

func fullSet[T](U: typedesc[T]): set[T] {.inline.}

Returns a set containing all elements in U.

Example:

assert bool.fullSet == {true, false}
type A = range[1..3]
assert A.fullSet == {1.A, 2, 3}
assert int8.fullSet.len == 256

	Source   Edit   

Templates

template toSet(iter: untyped): untyped

Returns a built-in set from the elements of the iterable iter.

Example:

assert "helloWorld".toSet == {'W', 'd', 'e', 'h', 'l', 'o', 'r'}
assert toSet([10u16, 20, 30]) == {10u16, 20, 30}
assert [30u8, 100, 10].toSet == {10u8, 30, 100}
assert toSet(@[1321i16, 321, 90]) == {90i16, 321, 1321}
assert toSet([false]) == {false}
assert toSet(0u8..10) == {0u8..10}

	Source   Edit   

Collections

std/critbits


std/critbits
Source   Edit  

This module implements a crit bit tree which is an efficient container for a sorted set of strings, or for a sorted mapping of strings. Based on the excellent paper by Adam Langley. (A crit bit tree is a form of radix tree or patricia trie.)

Example:

import std/critbits
from std/sequtils import toSeq

var critbitAsSet: CritBitTree[void] = ["kitten", "puppy"].toCritBitTree
doAssert critbitAsSet.len == 2
critbitAsSet.incl("")
doAssert "" in critbitAsSet
critbitAsSet.excl("")
doAssert "" notin critbitAsSet
doAssert toSeq(critbitAsSet.items) == @["kitten", "puppy"]
let same = ["puppy", "kitten", "puppy"].toCritBitTree
doAssert toSeq(same.keys) == toSeq(critbitAsSet.keys)

var critbitAsDict: CritBitTree[int] = {"key1": 42}.toCritBitTree
doAssert critbitAsDict.len == 1
critbitAsDict["key2"] = 0
doAssert "key2" in critbitAsDict
doAssert critbitAsDict["key2"] == 0
critbitAsDict.excl("key1")
doAssert "key1" notin critbitAsDict
doAssert toSeq(critbitAsDict.pairs) == @[("key2", 0)]

Imports

since

Types

CritBitTree[T] = object

	The crit bit tree can either be used as a mapping from strings to some type T or as a set of strings if T is void. Source   Edit   

Procs

func `$`[T](c: CritBitTree[T]): string

Turns c into a string representation.

Example:

doAssert $CritBitTree[int].default == "{:}"
doAssert $toCritBitTree({"key1": 1, "key2": 2}) == """{"key1": 1, "key2": 2}"""
doAssert $CritBitTree[void].default == "{}"
doAssert $toCritBitTree(["key1", "key2"]) == """{"key1", "key2"}"""

	Source   Edit   

func `[]`[T](c: CritBitTree[T]; key: string): lent T {.inline.}

	Retrieves the value at c[key]. If key is not in t, the KeyError exception is raised. One can check with hasKey whether the key exists.

	See also:

    	[] proc
    	[]= proc

	Source   Edit   

func `[]`[T](c: var CritBitTree[T]; key: string): var T {.inline.}

	Retrieves the value at c[key]. The value can be modified. If key is not in t, the KeyError exception is raised.

	See also:

    	[] proc
    	[]= proc

	Source   Edit   

proc `[]=`[T](c: var CritBitTree[T]; key: string; val: sink T)

	Alias for incl.

	See also:

    	[] proc
    	[] proc

	Source   Edit   

func commonPrefixLen[T](c: CritBitTree[T]): int {.inline.}

Returns the length of the longest common prefix of all keys in c. If c is empty, returns 0.

Example:

var c: CritBitTree[void]
doAssert c.commonPrefixLen == 0
incl(c, "key1")
doAssert c.commonPrefixLen == 4
incl(c, "key2")
doAssert c.commonPrefixLen == 3

	Source   Edit   

func contains[T](c: CritBitTree[T]; key: string): bool {.inline.}

Returns true if c contains the given key.

Example:

var c: CritBitTree[void]
incl(c, "key")
doAssert c.contains("key")

	Source   Edit   

proc containsOrIncl(c: var CritBitTree[void]; key: string): bool {.....}

Returns true if c contains the given key. If the key does not exist, it is inserted into c.

See also:

	incl proc
	incl proc
	containsOrIncl proc
	missingOrExcl proc

Example:

block:
  var c: CritBitTree[void]
  doAssert not c.containsOrIncl("key")
  doAssert c.contains("key")
block:
  var c: CritBitTree[void]
  incl(c, "key")
  doAssert c.containsOrIncl("key")

	Source   Edit   

proc containsOrIncl[T](c: var CritBitTree[T]; key: string; val: sink T): bool

Returns true if c contains the given key. If the key does not exist, c[key] = val is performed.

See also:

	incl proc
	incl proc
	containsOrIncl proc
	missingOrExcl proc

Example:

block:
  var c: CritBitTree[int]
  doAssert not c.containsOrIncl("key", 42)
  doAssert c.contains("key")
block:
  var c: CritBitTree[int]
  incl(c, "key", 21)
  doAssert c.containsOrIncl("key", 42)
  doAssert c["key"] == 21

	Source   Edit   

proc excl[T](c: var CritBitTree[T]; key: string)

Removes key (and its associated value) from the set c. If the key does not exist, nothing happens.

See also:

	incl proc
	incl proc

Example:

var c: CritBitTree[void]
incl(c, "key")
excl(c, "key")
doAssert not c.contains("key")

	Source   Edit   

func hasKey[T](c: CritBitTree[T]; key: string): bool {.inline.}

	Alias for contains. Source   Edit   

proc inc(c: var CritBitTree[int]; key: string; val: int = 1) {.....}

Increments c[key] by val.

Example:

var c: CritBitTree[int]
c["key"] = 1
inc(c, "key")
doAssert c["key"] == 2

	Source   Edit   

proc incl(c: var CritBitTree[void]; key: string) {.....}

Includes key in c.

See also:

	excl proc
	incl proc

Example:

var c: CritBitTree[void]
incl(c, "key")
doAssert c.hasKey("key")

	Source   Edit   

proc incl[T](c: var CritBitTree[T]; key: string; val: sink T)

Inserts key with value val into c.

See also:

	excl proc
	incl proc

Example:

var c: CritBitTree[int]
incl(c, "key", 42)
doAssert c["key"] == 42

	Source   Edit   

func len[T](c: CritBitTree[T]): int {.inline.}

Returns the number of elements in c in O(1).

Example:

let c = ["key1", "key2"].toCritBitTree
doAssert c.len == 2

	Source   Edit   

proc missingOrExcl[T](c: var CritBitTree[T]; key: string): bool

Returns true if c does not contain the given key. If the key does exist, c.excl(key) is performed.

See also:

	excl proc
	containsOrIncl proc
	containsOrIncl proc

Example:

block:
  var c: CritBitTree[void]
  doAssert c.missingOrExcl("key")
block:
  var c: CritBitTree[void]
  incl(c, "key")
  doAssert not c.missingOrExcl("key")
  doAssert not c.contains("key")

	Source   Edit   

proc toCritBitTree(items: sink openArray[string]): CritBitTree[void] {.
	....}

Creates a new CritBitTree that contains the given items.

Example:

doAssert ["a", "b", "c"].toCritBitTree is CritBitTree[void]

	Source   Edit   

proc toCritBitTree[T](pairs: sink openArray[(string, T)]): CritBitTree[T]

Creates a new CritBitTree that contains the given pairs.

Example:

doAssert {"a": "0", "b": "1", "c": "2"}.toCritBitTree is CritBitTree[string]
doAssert {"a": 0, "b": 1, "c": 2}.toCritBitTree is CritBitTree[int]

	Source   Edit   

Iterators

iterator items[T](c: CritBitTree[T]): string

	Alias for keys. Source   Edit   

iterator itemsWithPrefix[T](c: CritBitTree[T]; prefix: string): string

	Alias for keysWithPrefix. Source   Edit   

iterator keys[T](c: CritBitTree[T]): string

Yields all keys in lexicographical order.

Example:

from std/sequtils import toSeq

let c = {"key1": 1, "key2": 2}.toCritBitTree
doAssert toSeq(c.keys) == @["key1", "key2"]

	Source   Edit   

iterator keysWithPrefix[T](c: CritBitTree[T]; prefix: string): string

Yields all keys starting with prefix.

Example:

from std/sequtils import toSeq

let c = {"key1": 42, "key2": 43}.toCritBitTree
doAssert toSeq(c.keysWithPrefix("key")) == @["key1", "key2"]

	Source   Edit   

iterator mpairs[T](c: var CritBitTree[T]): tuple[key: string, val: var T]

	Yields all (key, value)-pairs of c in the lexicographical order of the corresponding keys. The yielded values can be modified.

	See also:

    	pairs iterator

	Source   Edit   

iterator mpairsWithPrefix[T](c: var CritBitTree[T]; prefix: string): tuple[
	key: string, val: var T]

	Yields all (key, value)-pairs of c starting with prefix. The yielded values can be modified.

	See also:

    	pairsWithPrefix iterator

	Source   Edit   

iterator mvalues[T](c: var CritBitTree[T]): var T

	Yields all values of c in the lexicographical order of the corresponding keys. The values can be modified.

	See also:

    	values iterator

	Source   Edit   

iterator mvaluesWithPrefix[T](c: var CritBitTree[T]; prefix: string): var T

	Yields all values of c starting with prefix of the corresponding keys. The values can be modified.

	See also:

    	valuesWithPrefix iterator

	Source   Edit   

iterator pairs[T](c: CritBitTree[T]): tuple[key: string, val: T]

Yields all (key, value)-pairs of c in the lexicographical order of the corresponding keys.

See also:

	mpairs iterator

Example:

from std/sequtils import toSeq

let c = {"key1": 1, "key2": 2}.toCritBitTree
doAssert toSeq(c.pairs) == @[(key: "key1", val: 1), (key: "key2", val: 2)]

	Source   Edit   

iterator pairsWithPrefix[T](c: CritBitTree[T]; prefix: string): tuple[
	key: string, val: T]

Yields all (key, value)-pairs of c starting with prefix.

See also:

	mpairsWithPrefix iterator

Example:

from std/sequtils import toSeq

let c = {"key1": 42, "key2": 43}.toCritBitTree
doAssert toSeq(c.pairsWithPrefix("key")) == @[(key: "key1", val: 42), (key: "key2", val: 43)]

	Source   Edit   

iterator values[T](c: CritBitTree[T]): lent T

Yields all values of c in the lexicographical order of the corresponding keys.

See also:

	mvalues iterator

Example:

from std/sequtils import toSeq

let c = {"key1": 1, "key2": 2}.toCritBitTree
doAssert toSeq(c.values) == @[1, 2]

	Source   Edit   

iterator valuesWithPrefix[T](c: CritBitTree[T]; prefix: string): lent T

Yields all values of c starting with prefix of the corresponding keys.

See also:

	mvaluesWithPrefix iterator

Example:

from std/sequtils import toSeq

let c = {"key1": 42, "key2": 43}.toCritBitTree
doAssert toSeq(c.valuesWithPrefix("key")) == @[42, 43]

	Source   Edit   



std/deques


std/deques
Source   Edit  

An implementation of a deque (double-ended queue). The underlying implementation uses a seq.
Note: None of the procs that get an individual value from the deque should be used on an empty deque.

If compiled with the boundChecks option, those procs will raise an IndexDefect on such access. This should not be relied upon, as -d:danger or --checks:off will disable those checks and then the procs may return garbage or crash the program.

As such, a check to see if the deque is empty is needed before any access, unless your program logic guarantees it indirectly.

Example:

import std/deques
var a = [10, 20, 30, 40].toDeque

doAssertRaises(IndexDefect, echo a[4])

a.addLast(50)
assert $a == "[10, 20, 30, 40, 50]"

assert a.peekFirst == 10
assert a.peekLast == 50
assert len(a) == 5

assert a.popFirst == 10
assert a.popLast == 50
assert len(a) == 3

a.addFirst(11)
a.addFirst(22)
a.addFirst(33)
assert $a == "[33, 22, 11, 20, 30, 40]"

a.shrink(fromFirst = 1, fromLast = 2)
assert $a == "[22, 11, 20]"

See also

	lists module for singly and doubly linked lists and rings

Imports

since, math

Types

Deque[T] = object

	A double-ended queue backed with a ringed seq buffer.

	To initialize an empty deque, use the initDeque proc.
	Source   Edit   

Consts

defaultInitialSize = 4

	Source   Edit   

Procs

proc `$`[T](deq: Deque[T]): string

Turns a deque into its string representation.

Example:

let a = [10, 20, 30].toDeque
assert $a == "[10, 20, 30]"

	Source   Edit   

proc `[]`[T](deq: Deque[T]; i: BackwardsIndex): lent T {.inline.}

Accesses the backwards indexed i-th element.

deq[^1] is the last element.

Example:

let a = [10, 20, 30, 40, 50].toDeque
assert a[^1] == 50
assert a[^4] == 20
doAssertRaises(IndexDefect, echo a[^9])

	Source   Edit   

proc `[]`[T](deq: Deque[T]; i: Natural): lent T {.inline.}

Accesses the i-th element of deq.

Example:

let a = [10, 20, 30, 40, 50].toDeque
assert a[0] == 10
assert a[3] == 40
doAssertRaises(IndexDefect, echo a[8])

	Source   Edit   

proc `[]`[T](deq: var Deque[T]; i: BackwardsIndex): var T {.inline.}

Accesses the backwards indexed i-th element and returns a mutable reference to it.

deq[^1] is the last element.

Example:

var a = [10, 20, 30, 40, 50].toDeque
inc(a[^1])
assert a[^1] == 51

	Source   Edit   

proc `[]`[T](deq: var Deque[T]; i: Natural): var T {.inline.}

Accesses the i-th element of deq and returns a mutable reference to it.

Example:

var a = [10, 20, 30, 40, 50].toDeque
inc(a[0])
assert a[0] == 11

	Source   Edit   

proc `[]=`[T](deq: var Deque[T]; i: BackwardsIndex; x: sink T) {.inline.}

Sets the backwards indexed i-th element of deq to x.

deq[^1] is the last element.

Example:

var a = [10, 20, 30, 40, 50].toDeque
a[^1] = 99
a[^3] = 77
assert $a == "[10, 20, 77, 40, 99]"

	Source   Edit   

proc `[]=`[T](deq: var Deque[T]; i: Natural; val: sink T) {.inline.}

Sets the i-th element of deq to val.

Example:

var a = [10, 20, 30, 40, 50].toDeque
a[0] = 99
a[3] = 66
assert $a == "[99, 20, 30, 66, 50]"

	Source   Edit   

proc addFirst[T](deq: var Deque[T]; item: sink T)

Adds an item to the beginning of deq.

See also:

	addLast proc

Example:

var a = initDeque[int]()
for i in 1 .. 5:
  a.addFirst(10 * i)
assert $a == "[50, 40, 30, 20, 10]"

	Source   Edit   

proc addLast[T](deq: var Deque[T]; item: sink T)

Adds an item to the end of deq.

See also:

	addFirst proc

Example:

var a = initDeque[int]()
for i in 1 .. 5:
  a.addLast(10 * i)
assert $a == "[10, 20, 30, 40, 50]"

	Source   Edit   

proc clear[T](deq: var Deque[T]) {.inline.}

Resets the deque so that it is empty.

See also:

	shrink proc

Example:

var a = [10, 20, 30, 40, 50].toDeque
assert $a == "[10, 20, 30, 40, 50]"
clear(a)
assert len(a) == 0

	Source   Edit   

proc contains[T](deq: Deque[T]; item: T): bool {.inline.}

Returns true if item is in deq or false if not found.

Usually used via the in operator. It is the equivalent of deq.find(item) >= 0.

Example:

let q = [7, 9].toDeque
assert 7 in q
assert q.contains(7)
assert 8 notin q

	Source   Edit   

proc initDeque[T](initialSize: int = defaultInitialSize): Deque[T]

	Creates a new empty deque.

	Optionally, the initial capacity can be reserved via initialSize as a performance optimization (default: defaultInitialSize). The length of a newly created deque will still be 0.

	See also:

    	toDeque proc

	Source   Edit   

proc len[T](deq: Deque[T]): int {.inline.}

	Returns the number of elements of deq. Source   Edit   

proc peekFirst[T](deq: Deque[T]): lent T {.inline.}

Returns the first element of deq, but does not remove it from the deque.

See also:

	peekFirst proc which returns a mutable reference
	peekLast proc

Example:

let a = [10, 20, 30, 40, 50].toDeque
assert $a == "[10, 20, 30, 40, 50]"
assert a.peekFirst == 10
assert len(a) == 5

	Source   Edit   

proc peekFirst[T](deq: var Deque[T]): var T {.inline.}

Returns a mutable reference to the first element of deq, but does not remove it from the deque.

See also:

	peekFirst proc
	peekLast proc

Example:

var a = [10, 20, 30, 40, 50].toDeque
a.peekFirst() = 99
assert $a == "[99, 20, 30, 40, 50]"

	Source   Edit   

proc peekLast[T](deq: Deque[T]): lent T {.inline.}

Returns the last element of deq, but does not remove it from the deque.

See also:

	peekLast proc which returns a mutable reference
	peekFirst proc

Example:

let a = [10, 20, 30, 40, 50].toDeque
assert $a == "[10, 20, 30, 40, 50]"
assert a.peekLast == 50
assert len(a) == 5

	Source   Edit   

proc peekLast[T](deq: var Deque[T]): var T {.inline.}

Returns a mutable reference to the last element of deq, but does not remove it from the deque.

See also:

	peekFirst proc
	peekLast proc

Example:

var a = [10, 20, 30, 40, 50].toDeque
a.peekLast() = 99
assert $a == "[10, 20, 30, 40, 99]"

	Source   Edit   

proc popFirst[T](deq: var Deque[T]): T {.inline, discardable.}

Removes and returns the first element of the deq.

See also:

	popLast proc
	shrink proc

Example:

var a = [10, 20, 30, 40, 50].toDeque
assert $a == "[10, 20, 30, 40, 50]"
assert a.popFirst == 10
assert $a == "[20, 30, 40, 50]"

	Source   Edit   

proc popLast[T](deq: var Deque[T]): T {.inline, discardable.}

Removes and returns the last element of the deq.

See also:

	popFirst proc
	shrink proc

Example:

var a = [10, 20, 30, 40, 50].toDeque
assert $a == "[10, 20, 30, 40, 50]"
assert a.popLast == 50
assert $a == "[10, 20, 30, 40]"

	Source   Edit   

proc shrink[T](deq: var Deque[T]; fromFirst = 0; fromLast = 0)

Removes fromFirst elements from the front of the deque and fromLast elements from the back.

If the supplied number of elements exceeds the total number of elements in the deque, the deque will remain empty.

See also:

	clear proc
	popFirst proc
	popLast proc

Example:

var a = [10, 20, 30, 40, 50].toDeque
assert $a == "[10, 20, 30, 40, 50]"
a.shrink(fromFirst = 2, fromLast = 1)
assert $a == "[30, 40]"

	Source   Edit   

proc toDeque[T](x: openArray[T]): Deque[T]

Creates a new deque that contains the elements of x (in the same order).

See also:

	initDeque proc

Example:

let a = toDeque([7, 8, 9])
assert len(a) == 3
assert $a == "[7, 8, 9]"

	Source   Edit   

Iterators

iterator items[T](deq: Deque[T]): lent T

Yields every element of deq.

See also:

	mitems iterator

Example:

from std/sequtils import toSeq

let a = [10, 20, 30, 40, 50].toDeque
assert toSeq(a.items) == @[10, 20, 30, 40, 50]

	Source   Edit   

iterator mitems[T](deq: var Deque[T]): var T

Yields every element of deq, which can be modified.

See also:

	items iterator

Example:

var a = [10, 20, 30, 40, 50].toDeque
assert $a == "[10, 20, 30, 40, 50]"
for x in mitems(a):
  x = 5 * x - 1
assert $a == "[49, 99, 149, 199, 249]"

	Source   Edit   

iterator pairs[T](deq: Deque[T]): tuple[key: int, val: T]

Yields every (position, value)-pair of deq.

Example:

from std/sequtils import toSeq

let a = [10, 20, 30].toDeque
assert toSeq(a.pairs) == @[(0, 10), (1, 20), (2, 30)]

	Source   Edit   


std/heapqueue


std/heapqueue
Source   Edit  

The heapqueue module implements a binary heap data structure that can be used as a priority queue. They are represented as arrays for which a[k] <= a[2*k+1] and a[k] <= a[2*k+2] for all indices k (counting elements from 0). The interesting property of a heap is that a[0] is always its smallest element.
Basic usage

Example:

import std/heapqueue
var heap = [8, 2].toHeapQueue
heap.push(5)
# the first element is the lowest element
assert heap[0] == 2
# remove and return the lowest element
assert heap.pop() == 2
# the lowest element remaining is 5
assert heap[0] == 5

Usage with custom objects

To use a HeapQueue with a custom object, the < operator must be implemented.

Example:

import std/heapqueue
type Job = object
  priority: int

proc `<`(a, b: Job): bool = a.priority < b.priority

var jobs = initHeapQueue[Job]()
jobs.push(Job(priority: 1))
jobs.push(Job(priority: 2))

assert jobs[0].priority == 1

Imports

since

Types

HeapQueue[T] = object

	A heap queue, commonly known as a priority queue. Source   Edit   

Procs

proc `$`[T](heap: HeapQueue[T]): string

Turns a heap into its string representation.

Example:

let heap = [1, 2].toHeapQueue
assert $heap == "[1, 2]"

	Source   Edit   

proc `[]`[T](heap: HeapQueue[T]; i: Natural): lent T {.inline.}

	Accesses the i-th element of heap. Source   Edit   

proc clear[T](heap: var HeapQueue[T])

Removes all elements from heap, making it empty.

Example:

var heap = [9, 5, 8].toHeapQueue
heap.clear()
assert heap.len == 0

	Source   Edit   

proc del[T](heap: var HeapQueue[T]; index: Natural)

Removes the element at index from heap, maintaining the heap invariant.

Example:

var heap = [9, 5, 8].toHeapQueue
heap.del(1)
assert heap[0] == 5
assert heap[1] == 8

	Source   Edit   

proc find[T](heap: HeapQueue[T]; x: T): int

Linear scan to find the index of the item x or -1 if not found.

Example:

let heap = [9, 5, 8].toHeapQueue
assert heap.find(5) == 0
assert heap.find(9) == 1
assert heap.find(777) == -1

	Source   Edit   

proc initHeapQueue[T](): HeapQueue[T]

	Creates a new empty heap.

	Heaps are initialized by default, so it is not necessary to call this function explicitly.

	See also:

    	toHeapQueue proc

	Source   Edit   

proc len[T](heap: HeapQueue[T]): int {.inline.}

Returns the number of elements of heap.

Example:

let heap = [9, 5, 8].toHeapQueue
assert heap.len == 3

	Source   Edit   

proc pop[T](heap: var HeapQueue[T]): T

Pops and returns the smallest item from heap, maintaining the heap invariant.

Example:

var heap = [9, 5, 8].toHeapQueue
assert heap.pop() == 5

	Source   Edit   

proc push[T](heap: var HeapQueue[T]; item: sink T)

	Pushes item onto heap, maintaining the heap invariant. Source   Edit   

proc pushpop[T](heap: var HeapQueue[T]; item: sink T): T

Fast version of a push() followed by a pop().

See also:

	replace proc

Example:

var heap = [5, 12].toHeapQueue
assert heap.pushpop(6) == 5
assert heap.len == 2
assert heap[0] == 6
assert heap.pushpop(4) == 4

	Source   Edit   

proc replace[T](heap: var HeapQueue[T]; item: sink T): T

Pops and returns the current smallest value, and add the new item. This is more efficient than pop() followed by push(), and can be more appropriate when using a fixed-size heap. Note that the value returned may be larger than item! That constrains reasonable uses of this routine unless written as part of a conditional replacement.

See also:

	pushpop proc

Example:

var heap = [5, 12].toHeapQueue
assert heap.replace(6) == 5
assert heap.len == 2
assert heap[0] == 6
assert heap.replace(4) == 6

	Source   Edit   

proc toHeapQueue[T](x: openArray[T]): HeapQueue[T]

Creates a new HeapQueue that contains the elements of x.

See also:

	initHeapQueue proc

Example:

var heap = [9, 5, 8].toHeapQueue
assert heap.pop() == 5
assert heap[0] == 8

	Source   Edit   


std/intsets


std/intsets
Source   Edit  

Specialization of the generic packedsets module (see its documentation for more examples) for ordinal sparse sets.
Imports

since, packedsets

Types

IntSet = PackedSet[int]

	Source   Edit   

Procs

proc initIntSet(): IntSet {.inline, ....}

	Source   Edit   

proc toIntSet(x: openArray[int]): IntSet {.inline, ....}

	Source   Edit   

Exports

clear, union, missingOrExcl, isNil, incl, excl, items, ==, <=, =copy, toPackedSet, assign, PackedSet, symmetricDifference, contains, len, $, initPackedSet, <, *, -, excl, disjoint, difference, +, card, intersection, incl, containsOrIncl


std/lists


std/lists
Source   Edit  

Implementation of:

	singly linked lists
	doubly linked lists
	singly linked rings (circular lists)
	doubly linked rings (circular lists)

Basic Usage

Because it makes no sense to do otherwise, the next and prev pointers are not hidden from you and can be manipulated directly for efficiency.
Lists

Example:

import std/lists
var list = initDoublyLinkedList[int]()
let
  a = newDoublyLinkedNode[int](3)
  b = newDoublyLinkedNode[int](7)
  c = newDoublyLinkedNode[int](9)

list.add(a)
list.add(b)
list.prepend(c)

assert a.next == b
assert a.prev == c
assert c.next == a
assert c.next.next == b
assert c.prev == nil
assert b.next == nil

Rings

Example:

import std/lists
var ring = initSinglyLinkedRing[int]()
let
  a = newSinglyLinkedNode[int](3)
  b = newSinglyLinkedNode[int](7)
  c = newSinglyLinkedNode[int](9)

ring.add(a)
ring.add(b)
ring.prepend(c)

assert c.next == a
assert a.next == b
assert c.next.next == b
assert b.next == c
assert c.next.next.next == c

See also

	deques module for double-ended queues

Imports

since

Types

DoublyLinkedList[T] = object
  head*: DoublyLinkedNode[T]
  tail* {.cursor.}: DoublyLinkedNode[T]

	A doubly linked list. Source   Edit   

DoublyLinkedNode[T] = ref DoublyLinkedNodeObj[T]

	Source   Edit   

DoublyLinkedNodeObj[T] = object
  next*: DoublyLinkedNode[T]
  prev* {.cursor.}: DoublyLinkedNode[T]
  value*: T

	A node of a doubly linked list.

	It consists of a value field, and pointers to next and prev.
	Source   Edit   

DoublyLinkedRing[T] = object
  head*: DoublyLinkedNode[T]

	A doubly linked ring. Source   Edit   

SinglyLinkedList[T] = object
  head*: SinglyLinkedNode[T]
  tail* {.cursor.}: SinglyLinkedNode[T]

	A singly linked list. Source   Edit   

SinglyLinkedNode[T] = ref SinglyLinkedNodeObj[T]

	Source   Edit   

SinglyLinkedNodeObj[T] = object
  next*: SinglyLinkedNode[T]
  value*: T

	A node of a singly linked list.

	It consists of a value field, and a pointer to next.
	Source   Edit   

SinglyLinkedRing[T] = object
  head*: SinglyLinkedNode[T]
  tail* {.cursor.}: SinglyLinkedNode[T]

	A singly linked ring. Source   Edit   

SomeLinkedCollection[T] = SomeLinkedList[T] | SomeLinkedRing[T]

	Source   Edit   

SomeLinkedList[T] = SinglyLinkedList[T] | DoublyLinkedList[T]

	Source   Edit   

SomeLinkedNode[T] = SinglyLinkedNode[T] | DoublyLinkedNode[T]

	Source   Edit   

SomeLinkedRing[T] = SinglyLinkedRing[T] | DoublyLinkedRing[T]

	Source   Edit   

Procs

proc `$`[T](L: SomeLinkedCollection[T]): string

Turns a list into its string representation for logging and printing.

Example:

let a = [1, 2, 3, 4].toSinglyLinkedList
assert $a == "[1, 2, 3, 4]"

	Source   Edit   

proc add[T: SomeLinkedList](a: var T; b: T)

Appends a shallow copy of b to the end of a.

See also:

	addMoved proc
	addMoved proc for moving the second list instead of copying

Example:

from std/sequtils import toSeq
var a = [1, 2, 3].toSinglyLinkedList
let b = [4, 5].toSinglyLinkedList
a.add(b)
assert a.toSeq == [1, 2, 3, 4, 5]
assert b.toSeq == [4, 5]
a.add(a)
assert a.toSeq == [1, 2, 3, 4, 5, 1, 2, 3, 4, 5]

	Source   Edit   

proc add[T](L: var DoublyLinkedList[T]; n: DoublyLinkedNode[T])

Appends (adds to the end) a node n to L. Efficiency: O(1).

See also:

	add proc for appending a value
	prepend proc for prepending a node
	prepend proc for prepending a value
	remove proc for removing a node

Example:

var a = initDoublyLinkedList[int]()
let n = newDoublyLinkedNode[int](9)
a.add(n)
assert a.contains(9)

	Source   Edit   

proc add[T](L: var DoublyLinkedList[T]; value: T)

Appends (adds to the end) a value to L. Efficiency: O(1).

See also:

	add proc for appending a node
	prepend proc for prepending a node
	prepend proc for prepending a value
	remove proc for removing a node

Example:

var a = initDoublyLinkedList[int]()
a.add(9)
a.add(8)
assert a.contains(9)

	Source   Edit   

proc add[T](L: var DoublyLinkedRing[T]; n: DoublyLinkedNode[T])

Appends (adds to the end) a node n to L. Efficiency: O(1).

See also:

	add proc for appending a value
	prepend proc for prepending a node
	prepend proc for prepending a value
	remove proc for removing a node

Example:

var a = initDoublyLinkedRing[int]()
let n = newDoublyLinkedNode[int](9)
a.add(n)
assert a.contains(9)

	Source   Edit   

proc add[T](L: var DoublyLinkedRing[T]; value: T)

Appends (adds to the end) a value to L. Efficiency: O(1).

See also:

	add proc for appending a node
	prepend proc for prepending a node
	prepend proc for prepending a value
	remove proc for removing a node

Example:

var a = initDoublyLinkedRing[int]()
a.add(9)
a.add(8)
assert a.contains(9)

	Source   Edit   

proc add[T](L: var SinglyLinkedList[T]; n: SinglyLinkedNode[T]) {.inline.}

Appends (adds to the end) a node n to L. Efficiency: O(1).

See also:

	add proc for appending a value
	prepend proc for prepending a node
	prepend proc for prepending a value

Example:

var a = initSinglyLinkedList[int]()
let n = newSinglyLinkedNode[int](9)
a.add(n)
assert a.contains(9)

	Source   Edit   

proc add[T](L: var SinglyLinkedList[T]; value: T) {.inline.}

Appends (adds to the end) a value to L. Efficiency: O(1).

See also:

	add proc for appending a value
	prepend proc for prepending a node
	prepend proc for prepending a value

Example:

var a = initSinglyLinkedList[int]()
a.add(9)
a.add(8)
assert a.contains(9)

	Source   Edit   

proc add[T](L: var SinglyLinkedRing[T]; n: SinglyLinkedNode[T])

Appends (adds to the end) a node n to L. Efficiency: O(1).

See also:

	add proc for appending a value
	prepend proc for prepending a node
	prepend proc for prepending a value

Example:

var a = initSinglyLinkedRing[int]()
let n = newSinglyLinkedNode[int](9)
a.add(n)
assert a.contains(9)

	Source   Edit   

proc add[T](L: var SinglyLinkedRing[T]; value: T)

Appends (adds to the end) a value to L. Efficiency: O(1).

See also:

	add proc for appending a node
	prepend proc for prepending a node
	prepend proc for prepending a value

Example:

var a = initSinglyLinkedRing[int]()
a.add(9)
a.add(8)
assert a.contains(9)

	Source   Edit   

proc addMoved[T](a, b: var DoublyLinkedList[T])

Moves b to the end of a. Efficiency: O(1). Note that b becomes empty after the operation unless it has the same address as a. Self-adding results in a cycle.

See also:

	add proc for adding a copy of a list

Example:

import std/[sequtils, enumerate, sugar]
var
  a = [1, 2, 3].toDoublyLinkedList
  b = [4, 5].toDoublyLinkedList
  c = [0, 1].toDoublyLinkedList
a.addMoved(b)
assert a.toSeq == [1, 2, 3, 4, 5]
assert b.toSeq == []
c.addMoved(c)
let s = collect:
  for i, ci in enumerate(c):
	if i == 6: break
	ci
assert s == [0, 1, 0, 1, 0, 1]

	Source   Edit   

proc addMoved[T](a, b: var SinglyLinkedList[T])

Moves b to the end of a. Efficiency: O(1). Note that b becomes empty after the operation unless it has the same address as a. Self-adding results in a cycle.

See also:

	add proc for adding a copy of a list

Example:

import std/[sequtils, enumerate, sugar]
var
  a = [1, 2, 3].toSinglyLinkedList
  b = [4, 5].toSinglyLinkedList
  c = [0, 1].toSinglyLinkedList
a.addMoved(b)
assert a.toSeq == [1, 2, 3, 4, 5]
assert b.toSeq == []
c.addMoved(c)
let s = collect:
  for i, ci in enumerate(c):
	if i == 6: break
	ci
assert s == [0, 1, 0, 1, 0, 1]

	Source   Edit   

proc append[T](a: var (DoublyLinkedList[T] | DoublyLinkedRing[T]);
           	b: DoublyLinkedList[T] | DoublyLinkedNode[T] | T)

	Alias for a.add(b).

	See also:

    	add proc
    	add proc
    	add proc

	Source   Edit   

proc append[T](a: var (SinglyLinkedList[T] | SinglyLinkedRing[T]);
           	b: SinglyLinkedList[T] | SinglyLinkedNode[T] | T)

	Alias for a.add(b).

	See also:

    	add proc
    	add proc
    	add proc

	Source   Edit   

proc appendMoved[T: SomeLinkedList](a, b: var T)

	Alias for a.addMoved(b).

	See also:

    	addMoved proc
    	addMoved proc

	Source   Edit   

proc contains[T](L: SomeLinkedCollection[T]; value: T): bool {.inline.}

Searches in the list for a value. Returns false if the value does not exist, true otherwise. This allows the usage of the in and notin operators.

See also:

	find proc

Example:

let a = [9, 8].toSinglyLinkedList
assert a.contains(9)
assert 8 in a
assert(not a.contains(1))
assert 2 notin a

	Source   Edit   

func copy[T](a: DoublyLinkedList[T]): DoublyLinkedList[T]

Creates a shallow copy of a.

Example:

from std/sequtils import toSeq
type Foo = ref object
  x: int
var
  f = Foo(x: 1)
  a = [f].toDoublyLinkedList
let b = a.copy
a.add([f].toDoublyLinkedList)
assert a.toSeq == [f, f]
assert b.toSeq == [f] # b isn't modified...
f.x = 42
assert a.head.value.x == 42
assert b.head.value.x == 42 # ... but the elements are not deep copied

let c = [1, 2, 3].toDoublyLinkedList
assert $c == $c.copy

	Source   Edit   

func copy[T](a: SinglyLinkedList[T]): SinglyLinkedList[T]

Creates a shallow copy of a.

Example:

from std/sequtils import toSeq
type Foo = ref object
  x: int
var
  f = Foo(x: 1)
  a = [f].toSinglyLinkedList
let b = a.copy
a.add([f].toSinglyLinkedList)
assert a.toSeq == [f, f]
assert b.toSeq == [f] # b isn't modified...
f.x = 42
assert a.head.value.x == 42
assert b.head.value.x == 42 # ... but the elements are not deep copied

let c = [1, 2, 3].toSinglyLinkedList
assert $c == $c.copy

	Source   Edit   

proc find[T](L: SomeLinkedCollection[T]; value: T): SomeLinkedNode[T]

Searches in the list for a value. Returns nil if the value does not exist.

See also:

	contains proc

Example:

let a = [9, 8].toSinglyLinkedList
assert a.find(9).value == 9
assert a.find(1) == nil

	Source   Edit   

proc initDoublyLinkedList[T](): DoublyLinkedList[T]

Creates a new doubly linked list that is empty.

Doubly linked lists are initialized by default, so it is not necessary to call this function explicitly.

Example:

let a = initDoublyLinkedList[int]()

	Source   Edit   

proc initDoublyLinkedRing[T](): DoublyLinkedRing[T]

Creates a new doubly linked ring that is empty.

Doubly linked rings are initialized by default, so it is not necessary to call this function explicitly.

Example:

let a = initDoublyLinkedRing[int]()

	Source   Edit   

proc initSinglyLinkedList[T](): SinglyLinkedList[T]

Creates a new singly linked list that is empty.

Singly linked lists are initialized by default, so it is not necessary to call this function explicitly.

Example:

let a = initSinglyLinkedList[int]()

	Source   Edit   

proc initSinglyLinkedRing[T](): SinglyLinkedRing[T]

Creates a new singly linked ring that is empty.

Singly linked rings are initialized by default, so it is not necessary to call this function explicitly.

Example:

let a = initSinglyLinkedRing[int]()

	Source   Edit   

proc newDoublyLinkedNode[T](value: T): DoublyLinkedNode[T]

Creates a new doubly linked node with the given value.

Example:

let n = newDoublyLinkedNode[int](5)
assert n.value == 5

	Source   Edit   

proc newSinglyLinkedNode[T](value: T): SinglyLinkedNode[T]

Creates a new singly linked node with the given value.

Example:

let n = newSinglyLinkedNode[int](5)
assert n.value == 5

	Source   Edit   

proc prepend[T: SomeLinkedList](a: var T; b: T)

Prepends a shallow copy of b to the beginning of a.

See also:

	prependMoved proc for moving the second list instead of copying

Example:

from std/sequtils import toSeq
var a = [4, 5].toSinglyLinkedList
let b = [1, 2, 3].toSinglyLinkedList
a.prepend(b)
assert a.toSeq == [1, 2, 3, 4, 5]
assert b.toSeq == [1, 2, 3]
a.prepend(a)
assert a.toSeq == [1, 2, 3, 4, 5, 1, 2, 3, 4, 5]

	Source   Edit   

proc prepend[T](L: var DoublyLinkedList[T]; n: DoublyLinkedNode[T])

Prepends (adds to the beginning) a node n to L. Efficiency: O(1).

See also:

	add proc for appending a node
	add proc for appending a value
	prepend proc for prepending a value
	remove proc for removing a node

Example:

var a = initDoublyLinkedList[int]()
let n = newDoublyLinkedNode[int](9)
a.prepend(n)
assert a.contains(9)

	Source   Edit   

proc prepend[T](L: var DoublyLinkedList[T]; value: T)

Prepends (adds to the beginning) a value to L. Efficiency: O(1).

See also:

	add proc for appending a node
	add proc for appending a value
	prepend proc for prepending a node
	remove proc for removing a node

Example:

var a = initDoublyLinkedList[int]()
a.prepend(9)
a.prepend(8)
assert a.contains(9)

	Source   Edit   

proc prepend[T](L: var DoublyLinkedRing[T]; n: DoublyLinkedNode[T])

Prepends (adds to the beginning) a node n to L. Efficiency: O(1).

See also:

	add proc for appending a node
	add proc for appending a value
	prepend proc for prepending a value
	remove proc for removing a node

Example:

var a = initDoublyLinkedRing[int]()
let n = newDoublyLinkedNode[int](9)
a.prepend(n)
assert a.contains(9)

	Source   Edit   

proc prepend[T](L: var DoublyLinkedRing[T]; value: T)

Prepends (adds to the beginning) a value to L. Efficiency: O(1).

See also:

	add proc for appending a node
	add proc for appending a value
	prepend proc for prepending a node
	remove proc for removing a node

Example:

var a = initDoublyLinkedRing[int]()
a.prepend(9)
a.prepend(8)
assert a.contains(9)

	Source   Edit   

proc prepend[T](L: var SinglyLinkedList[T]; n: SinglyLinkedNode[T]) {.inline.}

Prepends (adds to the beginning) a node to L. Efficiency: O(1).

See also:

	add proc for appending a node
	add proc for appending a value
	prepend proc for prepending a value

Example:

var a = initSinglyLinkedList[int]()
let n = newSinglyLinkedNode[int](9)
a.prepend(n)
assert a.contains(9)

	Source   Edit   

proc prepend[T](L: var SinglyLinkedList[T]; value: T) {.inline.}

Prepends (adds to the beginning) a node to L. Efficiency: O(1).

See also:

	add proc for appending a node
	add proc for appending a value
	prepend proc for prepending a node

Example:

var a = initSinglyLinkedList[int]()
a.prepend(9)
a.prepend(8)
assert a.contains(9)

	Source   Edit   

proc prepend[T](L: var SinglyLinkedRing[T]; n: SinglyLinkedNode[T])

Prepends (adds to the beginning) a node n to L. Efficiency: O(1).

See also:

	add proc for appending a node
	add proc for appending a value
	prepend proc for prepending a value

Example:

var a = initSinglyLinkedRing[int]()
let n = newSinglyLinkedNode[int](9)
a.prepend(n)
assert a.contains(9)

	Source   Edit   

proc prepend[T](L: var SinglyLinkedRing[T]; value: T)

Prepends (adds to the beginning) a value to L. Efficiency: O(1).

See also:

	add proc for appending a node
	add proc for appending a value
	prepend proc for prepending a node

Example:

var a = initSinglyLinkedRing[int]()
a.prepend(9)
a.prepend(8)
assert a.contains(9)

	Source   Edit   

proc prependMoved[T: SomeLinkedList](a, b: var T)

Moves b before the head of a. Efficiency: O(1). Note that b becomes empty after the operation unless it has the same address as a. Self-prepending results in a cycle.

See also:

	prepend proc for prepending a copy of a list

Example:

import std/[sequtils, enumerate, sugar]
var
  a = [4, 5].toSinglyLinkedList
  b = [1, 2, 3].toSinglyLinkedList
  c = [0, 1].toSinglyLinkedList
a.prependMoved(b)
assert a.toSeq == [1, 2, 3, 4, 5]
assert b.toSeq == []
c.prependMoved(c)
let s = collect:
  for i, ci in enumerate(c):
	if i == 6: break
	ci
assert s == [0, 1, 0, 1, 0, 1]

	Source   Edit   

proc remove[T](L: var DoublyLinkedList[T]; n: DoublyLinkedNode[T])

Removes a node n from L. Efficiency: O(1). This function assumes, for the sake of efficiency, that n is contained in L, otherwise the effects are undefined. When the list is cyclic, the cycle is preserved after removal.

Example:

import std/[sequtils, enumerate, sugar]
var a = [0, 1, 2].toSinglyLinkedList
let n = a.head.next
assert n.value == 1
a.remove(n)
assert a.toSeq == [0, 2]
a.remove(n)
assert a.toSeq == [0, 2]
a.addMoved(a) # cycle: [0, 2, 0, 2, ...]
a.remove(a.head)
let s = collect:
  for i, ai in enumerate(a):
	if i == 4: break
	ai
assert s == [2, 2, 2, 2]

	Source   Edit   

proc remove[T](L: var DoublyLinkedRing[T]; n: DoublyLinkedNode[T])

Removes n from L. Efficiency: O(1). This function assumes, for the sake of efficiency, that n is contained in L, otherwise the effects are undefined.

Example:

var a = initDoublyLinkedRing[int]()
let n = newDoublyLinkedNode[int](5)
a.add(n)
assert 5 in a
a.remove(n)
assert 5 notin a

	Source   Edit   

proc remove[T](L: var SinglyLinkedList[T]; n: SinglyLinkedNode[T]): bool {.
	discardable.}

Removes a node n from L. Returns true if n was found in L. Efficiency: O(n); the list is traversed until n is found. Attempting to remove an element not contained in the list is a no-op. When the list is cyclic, the cycle is preserved after removal.

Example:

import std/[sequtils, enumerate, sugar]
var a = [0, 1, 2].toSinglyLinkedList
let n = a.head.next
assert n.value == 1
assert a.remove(n) == true
assert a.toSeq == [0, 2]
assert a.remove(n) == false
assert a.toSeq == [0, 2]
a.addMoved(a) # cycle: [0, 2, 0, 2, ...]
a.remove(a.head)
let s = collect:
  for i, ai in enumerate(a):
	if i == 4: break
	ai
assert s == [2, 2, 2, 2]

	Source   Edit   

func toDoublyLinkedList[T](elems: openArray[T]): DoublyLinkedList[T]

Creates a new DoublyLinkedList from the members of elems.

Example:

from std/sequtils import toSeq
let a = [1, 2, 3, 4, 5].toDoublyLinkedList
assert a.toSeq == [1, 2, 3, 4, 5]

	Source   Edit   

func toSinglyLinkedList[T](elems: openArray[T]): SinglyLinkedList[T]

Creates a new SinglyLinkedList from the members of elems.

Example:

from std/sequtils import toSeq
let a = [1, 2, 3, 4, 5].toSinglyLinkedList
assert a.toSeq == [1, 2, 3, 4, 5]

	Source   Edit   

Iterators

iterator items[T](L: SomeLinkedList[T]): T

Yields every value of L.

See also:

	mitems iterator
	nodes iterator

Example:

from std/sugar import collect
from std/sequtils import toSeq
let a = collect(initSinglyLinkedList):
  for i in 1..3: 10 * i
assert toSeq(items(a)) == toSeq(a)
assert toSeq(a) == @[10, 20, 30]

	Source   Edit   

iterator items[T](L: SomeLinkedRing[T]): T

Yields every value of L.

See also:

	mitems iterator
	nodes iterator

Example:

from std/sugar import collect
from std/sequtils import toSeq
let a = collect(initSinglyLinkedRing):
  for i in 1..3: 10 * i
assert toSeq(items(a)) == toSeq(a)
assert toSeq(a) == @[10, 20, 30]

	Source   Edit   

iterator mitems[T](L: var SomeLinkedList[T]): var T

Yields every value of L so that you can modify it.

See also:

	items iterator
	nodes iterator

Example:

var a = initSinglyLinkedList[int]()
for i in 1..5:
  a.add(10 * i)
assert $a == "[10, 20, 30, 40, 50]"
for x in mitems(a):
  x = 5 * x - 1
assert $a == "[49, 99, 149, 199, 249]"

	Source   Edit   

iterator mitems[T](L: var SomeLinkedRing[T]): var T

Yields every value of L so that you can modify it.

See also:

	items iterator
	nodes iterator

Example:

var a = initSinglyLinkedRing[int]()
for i in 1..5:
  a.add(10 * i)
assert $a == "[10, 20, 30, 40, 50]"
for x in mitems(a):
  x = 5 * x - 1
assert $a == "[49, 99, 149, 199, 249]"

	Source   Edit   

iterator nodes[T](L: SomeLinkedList[T]): SomeLinkedNode[T]

Iterates over every node of x. Removing the current node from the list during traversal is supported.

See also:

	items iterator
	mitems iterator

Example:

var a = initDoublyLinkedList[int]()
for i in 1..5:
  a.add(10 * i)
assert $a == "[10, 20, 30, 40, 50]"
for x in nodes(a):
  if x.value == 30:
	a.remove(x)
  else:
	x.value = 5 * x.value - 1
assert $a == "[49, 99, 199, 249]"

	Source   Edit   

iterator nodes[T](L: SomeLinkedRing[T]): SomeLinkedNode[T]

Iterates over every node of x. Removing the current node from the list during traversal is supported.

See also:

	items iterator
	mitems iterator

Example:

var a = initDoublyLinkedRing[int]()
for i in 1..5:
  a.add(10 * i)
assert $a == "[10, 20, 30, 40, 50]"
for x in nodes(a):
  if x.value == 30:
	a.remove(x)
  else:
	x.value = 5 * x.value - 1
assert $a == "[49, 99, 199, 249]"

	Source   Edit   


std/options


std/options
Source   Edit  

This module implements types which encapsulate an optional value.

A value of type Option[T] either contains a value x (represented as some(x)) or is empty (none(T)).

This can be useful when you have a value that can be present or not. The absence of a value is often represented by nil, but that is not always available, nor is it always a good solution.
Basic usage

Let's start with an example: a procedure that finds the index of a character in a string.

Example:

import std/options
proc find(haystack: string, needle: char): Option[int] =
  for i, c in haystack:
	if c == needle:
  	return some(i)
  return none(int)  # This line is actually optional,
                	# because the default is empty

let found = "abc".find('c')
assert found.isSome and found.get() == 2

The get operation demonstrated above returns the underlying value, or raises UnpackDefect if there is no value. Note that UnpackDefect inherits from system.Defect and should therefore never be caught. Instead, rely on checking if the option contains a value with the isSome and isNone procs.
Pattern matching
Note: This requires the fusion package.

fusion/matching supports pattern matching on Options, with the Some(<pattern>) and None() patterns.

{.experimental: "caseStmtMacros".}

import fusion/matching

case some(42)
of Some(@a):
  assert a == 42
of None():
  assert false

assertMatch(some(some(none(int))), Some(Some(None())))

Imports

typetraits

Types

Option[T] = object
  when T is SomePointer:
  else:

	An optional type that may or may not contain a value of type T. When T is a a pointer type (ptr, pointer, ref, proc or iterator {.closure.}), none(T) is represented as nil. Source   Edit   

UnpackDefect = object of Defect

	Source   Edit   

UnpackError {.....} = UnpackDefect

	Deprecated: See corresponding Defect
	Source   Edit   

Procs

proc `$`[T](self: Option[T]): string

Get the string representation of the Option.

Example:

assert $some(42) == "some(42)"
assert $none(int) == "none(int)"

	Source   Edit   

proc `==`[T](a, b: Option[T]): bool {.inline.}

Returns true if both Options are none, or if they are both some and have equal values.

Example:

let
  a = some(42)
  b = none(int)
  c = some(42)
  d = none(int)

assert a == c
assert b == d
assert not (a == b)

	Source   Edit   

proc filter[T](self: Option[T]; callback: proc (input: T): bool): Option[T] {.
	inline, effectsOf: callback.}

Applies a callback to the value of the Option.

If the callback returns true, the option is returned as some. If it returns false, it is returned as none.

See also:

	flatMap proc

Example:

proc isEven(x: int): bool =
  x mod 2 == 0

assert some(42).filter(isEven) == some(42)
assert none(int).filter(isEven) == none(int)
assert some(-11).filter(isEven) == none(int)

	Source   Edit   

proc flatMap[T, R](self: Option[T]; callback: proc (input: T): Option[R]): Option[
	R] {.inline, effectsOf: callback.}

Applies a callback function to the value of the Option and returns the new value.

If the Option has no value, none(R) will be returned.

This is similar to map, with the difference that the callback returns an Option, not a raw value. This allows multiple procs with a signature of A -> Option[B] to be chained together.

See also:

	flatten proc
	filter proc

Example:

proc doublePositives(x: int): Option[int] =
  if x > 0:
	some(2 * x)
  else:
	none(int)

assert some(42).flatMap(doublePositives) == some(84)
assert none(int).flatMap(doublePositives) == none(int)
assert some(-11).flatMap(doublePositives) == none(int)

	Source   Edit   

proc flatten[T](self: Option[Option[T]]): Option[T] {.inline.}

Remove one level of structure in a nested Option.

See also:

	flatMap proc

Example:

assert flatten(some(some(42))) == some(42)
assert flatten(none(Option[int])) == none(int)

	Source   Edit   

proc get[T](self: Option[T]): lent T {.inline.}

Returns the content of an Option. If it has no value, an UnpackDefect exception is raised.

See also:

	get proc with a default return value

Example:

assert some(42).get == 42
doAssertRaises(UnpackDefect):
  echo none(string).get

	Source   Edit   

proc get[T](self: Option[T]; otherwise: T): T {.inline.}

Returns the content of the Option or otherwise if the Option has no value.

Example:

assert some(42).get(9999) == 42
assert none(int).get(9999) == 9999

	Source   Edit   

proc get[T](self: var Option[T]): var T {.inline.}

Returns the content of the var Option mutably. If it has no value, an UnpackDefect exception is raised.

Example:

var
  a = some(42)
  b = none(string)
inc(a.get)
assert a.get == 43
doAssertRaises(UnpackDefect):
  echo b.get

	Source   Edit   

proc isNone[T](self: Option[T]): bool {.inline.}

Checks if an Option is empty.

See also:

	isSome proc
	none proc

Example:

assert not some(42).isNone
assert none(string).isNone

	Source   Edit   

proc isSome[T](self: Option[T]): bool {.inline.}

Checks if an Option contains a value.

See also:

	isNone proc
	some proc

Example:

assert some(42).isSome
assert not none(string).isSome

	Source   Edit   

proc map[T, R](self: Option[T]; callback: proc (input: T): R): Option[R] {.
	inline, effectsOf: callback.}

Applies a callback function to the value of the Option and returns an Option containing the new value.

If the Option has no value, none(R) will be returned.

See also:

	map proc
	flatMap proc for a version with a callback that returns an Option

Example:

proc isEven(x: int): bool =
  x mod 2 == 0

assert some(42).map(isEven) == some(true)
assert none(int).map(isEven) == none(bool)

	Source   Edit   

proc map[T](self: Option[T]; callback: proc (input: T)) {.inline,
	effectsOf: callback.}

Applies a callback function to the value of the Option, if it has one.

See also:

	map proc for a version with a callback which returns a value

Example:

var d = 0
proc saveDouble(x: int) =
  d = 2 * x

none(int).map(saveDouble)
assert d == 0
some(42).map(saveDouble)
assert d == 84

	Source   Edit   

proc none(T: typedesc): Option[T] {.inline.}

Returns an Option for this type that has no value.

See also:

	option proc
	some proc
	isNone proc

Example:

assert none(int).isNone

	Source   Edit   

proc none[T](): Option[T] {.inline.}

	Alias for none(T). Source   Edit   

proc option[T](val: sink T): Option[T] {.inline.}

Can be used to convert a pointer type (ptr, pointer, ref or proc) to an option type. It converts nil to none(T). When T is no pointer type, this is equivalent to some(val).

See also:

	some proc
	none proc

Example:

type
  Foo = ref object
	a: int
	b: string

assert option[Foo](nil).isNone
assert option(42).isSome

	Source   Edit   

proc some[T](val: sink T): Option[T] {.inline.}

Returns an Option that has the value val.

See also:

	option proc
	none proc
	isSome proc

Example:

let a = some("abc")

assert a.isSome
assert a.get == "abc"

	Source   Edit   

proc unsafeGet[T](self: Option[T]): lent T {.inline.}

	Returns the value of a some. The behavior is undefined for none.

	Note: Use this only when you are absolutely sure the value is present (e.g. after checking with isSome). Generally, using the get proc is preferred.
	Source   Edit   


std/packedsets


std/packedsets
Source   Edit  

The packedsets module implements an efficient Ordinal set implemented as a sparse bit set.

Supports any Ordinal type.
See also

	sets module for more general hash sets

Imports

since, hashes

Types

PackedSet[A] = object

	An efficient set of Ordinal types implemented as a sparse bit set. Source   Edit   

Procs

proc `$`[A](s: PackedSet[A]): string

Converts s to a string.

Example:

let a = [1, 2, 3].toPackedSet
assert $a == "{1, 2, 3}"

	Source   Edit   

proc `*`[A](s1, s2: PackedSet[A]): PackedSet[A] {.inline.}

	Alias for intersection(s1, s2). Source   Edit   

proc `+`[A](s1, s2: PackedSet[A]): PackedSet[A] {.inline.}

	Alias for union(s1, s2). Source   Edit   

proc `-`[A](s1, s2: PackedSet[A]): PackedSet[A] {.inline.}

	Alias for difference(s1, s2). Source   Edit   

proc `<`[A](s1, s2: PackedSet[A]): bool

Returns true if s1 is a proper subset of s2.

A strict or proper subset s1 has all of its elements in s2, but s2 has more elements than s1.

Example:

let
  a = [1].toPackedSet
  b = [1, 2].toPackedSet
  c = [1, 3].toPackedSet
assert a < b
assert not (b < b)
assert not (c < b)

	Source   Edit   

proc `<=`[A](s1, s2: PackedSet[A]): bool

Returns true if s1 is a subset of s2.

A subset s1 has all of its elements in s2, but s2 doesn't necessarily have more elements than s1. That is, s1 can be equal to s2.

Example:

let
  a = [1].toPackedSet
  b = [1, 2].toPackedSet
  c = [1, 3].toPackedSet
assert a <= b
assert b <= b
assert not (c <= b)

	Source   Edit   

proc `==`[A](s1, s2: PackedSet[A]): bool

Returns true if both s1 and s2 have the same elements and set size.

Example:

assert [1, 2].toPackedSet == [2, 1].toPackedSet
assert [1, 2].toPackedSet == [2, 1, 2].toPackedSet

	Source   Edit   

proc `=copy`[A](dest: var PackedSet[A]; src: PackedSet[A])

	Copies src to dest. dest does not need to be initialized by the initPackedSet proc. Source   Edit   

proc assign[A](dest: var PackedSet[A]; src: PackedSet[A]) {.inline, ....}

Deprecated
Copies src to dest. dest does not need to be initialized by the initPackedSet proc.

Example:

var
  a = initPackedSet[int]()
  b = initPackedSet[int]()
b.incl(5)
b.incl(7)
a.assign(b)
assert len(a) == 2

	Source   Edit   

proc card[A](s: PackedSet[A]): int {.inline.}

	Alias for len().

	Card stands for the cardinality of a set.
	Source   Edit   

proc clear[A](result: var PackedSet[A])

Clears the PackedSet[A] back to an empty state.

Example:

var a = [5, 7].toPackedSet
clear(a)
assert len(a) == 0

	Source   Edit   

proc contains[A](s: PackedSet[A]; key: A): bool

Returns true if key is in s.

This allows the usage of the in operator.

Example:

type ABCD = enum A, B, C, D

let a = [1, 3, 5].toPackedSet
assert a.contains(3)
assert 3 in a
assert not a.contains(8)
assert 8 notin a

let letters = [A, C].toPackedSet
assert A in letters
assert C in letters
assert B notin letters

	Source   Edit   

proc containsOrIncl[A](s: var PackedSet[A]; key: A): bool

Includes key in the set s and tells if key was already in s.

The difference with regards to the incl proc is that this proc returns true if s already contained key. The proc will return false if key was added as a new value to s during this call.

See also:

	incl proc for including an element
	missingOrExcl proc

Example:

var a = initPackedSet[int]()
assert a.containsOrIncl(3) == false
assert a.containsOrIncl(3) == true
assert a.containsOrIncl(4) == false

	Source   Edit   

proc difference[A](s1, s2: PackedSet[A]): PackedSet[A]

Returns the difference of the sets s1 and s2.

The same as s1 - s2.

Example:

let
  a = [1, 2, 3].toPackedSet
  b = [3, 4, 5].toPackedSet
  c = difference(a, b)
assert c.len == 2
assert c == [1, 2].toPackedSet

	Source   Edit   

proc disjoint[A](s1, s2: PackedSet[A]): bool

Returns true if the sets s1 and s2 have no items in common.

Example:

let
  a = [1, 2].toPackedSet
  b = [2, 3].toPackedSet
  c = [3, 4].toPackedSet
assert disjoint(a, b) == false
assert disjoint(a, c) == true

	Source   Edit   

proc excl[A](s: var PackedSet[A]; key: A)

Excludes key from the set s.

This doesn't do anything if key is not found in s.

See also:

	incl proc for including an element
	excl proc for excluding a set
	missingOrExcl proc

Example:

var a = [3].toPackedSet
a.excl(3)
a.excl(3)
a.excl(99)
assert len(a) == 0

	Source   Edit   

proc excl[A](s: var PackedSet[A]; other: PackedSet[A])

Excludes all elements from other from s.

This is the in-place version of s - other.

See also:

	incl proc for including a set
	excl proc for excluding an element
	missingOrExcl proc

Example:

var a = [1, 5].toPackedSet
a.excl([5].toPackedSet)
assert len(a) == 1
assert 5 notin a

	Source   Edit   

proc incl[A](s: var PackedSet[A]; key: A)

Includes an element key in s.

This doesn't do anything if key is already in s.

See also:

	excl proc for excluding an element
	incl proc for including a set
	containsOrIncl proc

Example:

var a = initPackedSet[int]()
a.incl(3)
a.incl(3)
assert len(a) == 1

	Source   Edit   

proc incl[A](s: var PackedSet[A]; other: PackedSet[A])

Includes all elements from other into s.

This is the in-place version of s + other.

See also:

	excl proc for excluding a set
	incl proc for including an element
	containsOrIncl proc

Example:

var a = [1].toPackedSet
a.incl([5].toPackedSet)
assert len(a) == 2
assert 5 in a

	Source   Edit   

proc initPackedSet[A](): PackedSet[A]

Returns an empty PackedSet[A]. A must be Ordinal.

See also:

	toPackedSet proc

Example:

let a = initPackedSet[int]()
assert len(a) == 0

type Id = distinct int
var ids = initPackedSet[Id]()
ids.incl(3.Id)

	Source   Edit   

proc intersection[A](s1, s2: PackedSet[A]): PackedSet[A]

Returns the intersection of the sets s1 and s2.

The same as s1 * s2.

Example:

let
  a = [1, 2, 3].toPackedSet
  b = [3, 4, 5].toPackedSet
  c = intersection(a, b)
assert c.len == 1
assert c == [3].toPackedSet

	Source   Edit   

proc isNil[A](x: PackedSet[A]): bool {.inline.}

Returns true if x is empty, false otherwise.

Example:

var a = initPackedSet[int]()
assert a.isNil
a.incl(2)
assert not a.isNil
a.excl(2)
assert a.isNil

	Source   Edit   

proc len[A](s: PackedSet[A]): int {.inline.}

Returns the number of elements in s.

Example:

let a = [1, 3, 5].toPackedSet
assert len(a) == 3

	Source   Edit   

proc missingOrExcl[A](s: var PackedSet[A]; key: A): bool

Excludes key from the set s and tells if key was already missing from s.

The difference with regards to the excl proc is that this proc returns true if key was missing from s. The proc will return false if key was in s and it was removed during this call.

See also:

	excl proc for excluding an element
	excl proc for excluding a set
	containsOrIncl proc

Example:

var a = [5].toPackedSet
assert a.missingOrExcl(5) == false
assert a.missingOrExcl(5) == true

	Source   Edit   

proc symmetricDifference[A](s1, s2: PackedSet[A]): PackedSet[A]

Returns the symmetric difference of the sets s1 and s2.

Example:

let
  a = [1, 2, 3].toPackedSet
  b = [3, 4, 5].toPackedSet
  c = symmetricDifference(a, b)
assert c.len == 4
assert c == [1, 2, 4, 5].toPackedSet

	Source   Edit   

proc toPackedSet[A](x: openArray[A]): PackedSet[A]

Creates a new PackedSet[A] that contains the elements of x.

Duplicates are removed.

See also:

	initPackedSet proc

Example:

let a = [5, 6, 7, 8, 8].toPackedSet
assert len(a) == 4
assert $a == "{5, 6, 7, 8}"

	Source   Edit   

proc union[A](s1, s2: PackedSet[A]): PackedSet[A]

Returns the union of the sets s1 and s2.

The same as s1 + s2.

Example:

let
  a = [1, 2, 3].toPackedSet
  b = [3, 4, 5].toPackedSet
  c = union(a, b)
assert c.len == 5
assert c == [1, 2, 3, 4, 5].toPackedSet

	Source   Edit   

Iterators

iterator items[A](s: PackedSet[A]): A {.inline.}

	Iterates over any included element of s. Source   Edit   


std/ropes


std/ropes
Source   Edit  

This module contains support for a rope data type. Ropes can represent very long strings efficiently; in particular, concatenation is done in O(1) instead of O(n). They are essentially concatenation trees that are only flattened when converting to a native Nim string. The empty string is represented by nil. Ropes are immutable and subtrees can be shared without copying. Leaves can be cached for better memory efficiency at the cost of runtime efficiency.
Imports

streams

Types

Rope {.acyclic.} = ref object

	A rope data type. The empty rope is represented by nil. Source   Edit   

Procs

proc `$`(r: Rope): string {.....}

	Converts a rope back to a string. Source   Edit   

proc `%`(frmt: string; args: openArray[Rope]): Rope {.....}

% substitution operator for ropes. Does not support the $identifier nor ${identifier} notations.

Example:

let r1 = "$1 $2 $3" % [rope("Nim"), rope("is"), rope("a great language")]
doAssert $r1 == "Nim is a great language"

let r2 = "$# $# $#" % [rope("Nim"), rope("is"), rope("a great language")]
doAssert $r2 == "Nim is a great language"

let r3 = "${1} ${2} ${3}" % [rope("Nim"), rope("is"), rope("a great language")]
doAssert $r3 == "Nim is a great language"

	Source   Edit   

proc `&`(a, b: Rope): Rope {.....}

The concatenation operator for ropes.

Example:

let r = rope("Hello, ") & rope("Nim!")
doAssert $r == "Hello, Nim!"

	Source   Edit   

proc `&`(a: openArray[Rope]): Rope {.....}

The concatenation operator for an openArray of ropes.

Example:

let r = &[rope("Hello, "), rope("Nim"), rope("!")]
doAssert $r == "Hello, Nim!"

	Source   Edit   

proc `&`(a: Rope; b: string): Rope {.....}

The concatenation operator for ropes.

Example:

let r = rope("Hello, ") & "Nim!"
doAssert $r == "Hello, Nim!"

	Source   Edit   

proc `&`(a: string; b: Rope): Rope {.....}

The concatenation operator for ropes.

Example:

let r = "Hello, " & rope("Nim!")
doAssert $r == "Hello, Nim!"

	Source   Edit   

proc `[]`(r: Rope; i: int): char {.....}

Returns the character at position i in the rope r. This is quite expensive! Worst-case: O(n). If i >= r.len or i < 0, \0 is returned.

Example:

let r = rope("Hello, Nim!")

doAssert r[0] == 'H'
doAssert r[7] == 'N'
doAssert r[22] == '\0'

	Source   Edit   

proc add(a: var Rope; b: Rope) {.....}

Adds b to the rope a.

Example:

var r = rope("Hello, ")
r.add(rope("Nim!"))
doAssert $r == "Hello, Nim!"

	Source   Edit   

proc add(a: var Rope; b: string) {.....}

Adds b to the rope a.

Example:

var r = rope("Hello, ")
r.add("Nim!")
doAssert $r == "Hello, Nim!"

	Source   Edit   

proc addf(c: var Rope; frmt: string; args: openArray[Rope]) {.....}

Shortcut for add(c, frmt % args).

Example:

var r = rope("Dash: ")
r.addf "$1 $2 $3", [rope("Nim"), rope("is"), rope("a great language")]
doAssert $r == "Dash: Nim is a great language"

	Source   Edit   

proc disableCache() {.....}

	The cache is discarded and disabled. The GC will reuse its used memory. Source   Edit   

proc enableCache() {.....}

	Enables the caching of leaves. This reduces the memory footprint at the cost of runtime efficiency. Source   Edit   

proc equalsFile(r: Rope; f: File): bool {.....}

	Returns true if the contents of the file f equal r. Source   Edit   

proc equalsFile(r: Rope; filename: string): bool {.....}

	Returns true if the contents of the file f equal r. If f does not exist, false is returned. Source   Edit   

proc len(a: Rope): int {.....}

	The rope's length. Source   Edit   

proc rope(f: BiggestFloat): Rope {.....}

Converts a float to a rope.

Example:

let r = rope(4.29)
doAssert $r == "4.29"

	Source   Edit   

proc rope(i: BiggestInt): Rope {.....}

Converts an int to a rope.

Example:

let r = rope(429)
doAssert $r == "429"

	Source   Edit   

proc rope(s: string = ""): Rope {.....}

Converts a string to a rope.

Example:

let r = rope("I'm a rope")
doAssert $r == "I'm a rope"

	Source   Edit   

proc write(f: File; r: Rope) {.....}

	Writes a rope to a file. Source   Edit   

proc write(s: Stream; r: Rope) {.....}

	Writes a rope to a stream. Source   Edit   

Iterators

iterator items(r: Rope): char {.....}

	Iterates over any character in the rope r. Source   Edit   

iterator leaves(r: Rope): string {.....}

Iterates over any leaf string in the rope r.

Example:

let r = rope("Hello") & rope(", Nim!")
let s = ["Hello", ", Nim!"]
var index = 0
for leave in r.leaves:
  doAssert leave == s[index]
  inc(index)

	Source   Edit   


std/sets


std/sets
Source   Edit  

The sets module implements an efficient hash set and ordered hash set.

Hash sets are different from the built in set type. Sets allow you to store any value that can be hashed and they don't contain duplicate entries.

Common usages of sets:

	removing duplicates from a container by converting it with toHashSet proc (see also sequtils.deduplicate func)
	membership testing
	mathematical operations on two sets, such as union, intersection, difference, and symmetric difference

echo toHashSet([9, 5, 1]) 	# {9, 1, 5}
echo toOrderedSet([9, 5, 1])  # {9, 5, 1}

let
  s1 = toHashSet([9, 5, 1])
  s2 = toHashSet([3, 5, 7])

echo s1 + s2	# {9, 1, 3, 5, 7}
echo s1 - s2	# {1, 9}
echo s1 * s2	# {5}
echo s1 -+- s2  # {9, 1, 3, 7}

Note: The data types declared here have value semantics: This means that = performs a copy of the set.

See also:

	intsets module for efficient int sets
	tables module for hash tables

Imports

hashes, math, outparams

Types

HashSet[A] {..} = object

	A generic hash set.

	Use init proc or initHashSet proc before calling other procs on it.
	Source   Edit   

OrderedSet[A] {..} = object

	A generic hash set that remembers insertion order.

	Use init proc or initOrderedSet proc before calling other procs on it.
	Source   Edit   

SomeSet[A] = HashSet[A] | OrderedSet[A]

	Type union representing HashSet or OrderedSet. Source   Edit   

Consts

defaultInitialSize = 64

	Source   Edit   

Procs

proc `$`[A](s: HashSet[A]): string

Converts the set s to a string, mostly for logging and printing purposes.

Don't use this proc for serialization, the representation may change at any moment and values are not escaped.

Examples:

echo toHashSet([2, 4, 5])
# --> {2, 4, 5}
echo toHashSet(["no", "esc'aping", "is \" provided"])
# --> {no, esc'aping, is " provided}

	Source   Edit   

proc `$`[A](s: OrderedSet[A]): string

Converts the ordered hash set s to a string, mostly for logging and printing purposes.

Don't use this proc for serialization, the representation may change at any moment and values are not escaped.

Examples:

echo toOrderedSet([2, 4, 5])
# --> {2, 4, 5}
echo toOrderedSet(["no", "esc'aping", "is \" provided"])
# --> {no, esc'aping, is " provided}

	Source   Edit   

proc `*`[A](s1, s2: HashSet[A]): HashSet[A] {.inline.}

	Alias for intersection(s1, s2). Source   Edit   

proc `+`[A](s1, s2: HashSet[A]): HashSet[A] {.inline.}

	Alias for union(s1, s2). Source   Edit   

proc `-`[A](s1, s2: HashSet[A]): HashSet[A] {.inline.}

	Alias for difference(s1, s2). Source   Edit   

proc `-+-`[A](s1, s2: HashSet[A]): HashSet[A] {.inline.}

	Alias for symmetricDifference(s1, s2). Source   Edit   

proc `<`[A](s, t: HashSet[A]): bool

Returns true if s is a strict or proper subset of t.

A strict or proper subset s has all of its members in t but t has more elements than s.

Example:

let
  a = toHashSet(["a", "b"])
  b = toHashSet(["b", "c"])
  c = intersection(a, b)
assert c < a and c < b
assert(not (a < a))

	Source   Edit   

proc `<=`[A](s, t: HashSet[A]): bool

Returns true if s is a subset of t.

A subset s has all of its members in t and t doesn't necessarily have more members than s. That is, s can be equal to t.

Example:

let
  a = toHashSet(["a", "b"])
  b = toHashSet(["b", "c"])
  c = intersection(a, b)
assert c <= a and c <= b
assert a <= a

	Source   Edit   

proc `==`[A](s, t: HashSet[A]): bool

Returns true if both s and t have the same members and set size.

Example:

var
  a = toHashSet([1, 2])
  b = toHashSet([2, 1])
assert a == b

	Source   Edit   

proc `==`[A](s, t: OrderedSet[A]): bool

Equality for ordered sets.

Example:

let
  a = toOrderedSet([1, 2])
  b = toOrderedSet([2, 1])
assert(not (a == b))

	Source   Edit   

proc `[]`[A](s: var HashSet[A]; key: A): var A

	Returns the element that is actually stored in s which has the same value as key or raises the KeyError exception.

	This is useful when one overloaded hash and == but still needs reference semantics for sharing.
	Source   Edit   

proc card[A](s: HashSet[A]): int

	Alias for len().

	Card stands for the cardinality of a set.
	Source   Edit   

proc card[A](s: OrderedSet[A]): int {.inline.}

	Alias for len().

	Card stands for the cardinality of a set.
	Source   Edit   

proc clear[A](s: var HashSet[A])

Clears the HashSet back to an empty state, without shrinking any of the existing storage.

O(n) operation, where n is the size of the hash bucket.

See also:

	pop proc

Example:

var s = toHashSet([3, 5, 7])
clear(s)
assert len(s) == 0

	Source   Edit   

proc clear[A](s: var OrderedSet[A])

Clears the OrderedSet back to an empty state, without shrinking any of the existing storage.

O(n) operation where n is the size of the hash bucket.

Example:

var s = toOrderedSet([3, 5, 7])
clear(s)
assert len(s) == 0

	Source   Edit   

proc contains[A](s: HashSet[A]; key: A): bool

Returns true if key is in s.

This allows the usage of in operator.

See also:

	incl proc
	containsOrIncl proc

Example:

var values = initHashSet[int]()
assert(not values.contains(2))
assert 2 notin values

values.incl(2)
assert values.contains(2)
assert 2 in values

	Source   Edit   

proc contains[A](s: OrderedSet[A]; key: A): bool

Returns true if key is in s.

This allows the usage of in operator.

See also:

	incl proc
	containsOrIncl proc

Example:

var values = initOrderedSet[int]()
assert(not values.contains(2))
assert 2 notin values

values.incl(2)
assert values.contains(2)
assert 2 in values

	Source   Edit   

proc containsOrIncl[A](s: var HashSet[A]; key: A): bool

Includes key in the set s and tells if key was already in s.

The difference with regards to the incl proc is that this proc returns true if s already contained key. The proc will return false if key was added as a new value to s during this call.

See also:

	incl proc for including an element
	incl proc for including other set
	missingOrExcl proc

Example:

var values = initHashSet[int]()
assert values.containsOrIncl(2) == false
assert values.containsOrIncl(2) == true
assert values.containsOrIncl(3) == false

	Source   Edit   

proc containsOrIncl[A](s: var OrderedSet[A]; key: A): bool

Includes key in the set s and tells if key was already in s.

The difference with regards to the incl proc is that this proc returns true if s already contained key. The proc will return false if key was added as a new value to s during this call.

See also:

	incl proc for including an element
	missingOrExcl proc

Example:

var values = initOrderedSet[int]()
assert values.containsOrIncl(2) == false
assert values.containsOrIncl(2) == true
assert values.containsOrIncl(3) == false

	Source   Edit   

proc difference[A](s1, s2: HashSet[A]): HashSet[A]

Returns the difference of the sets s1 and s2.

The same as s1 - s2.

The difference of two sets is represented mathematically as A ∖ B and is the set of all objects that are members of s1 and not members of s2.

See also:

	union proc
	intersection proc
	symmetricDifference proc

Example:

let
  a = toHashSet(["a", "b"])
  b = toHashSet(["b", "c"])
  c = difference(a, b)
assert c == toHashSet(["a"])

	Source   Edit   

proc disjoint[A](s1, s2: HashSet[A]): bool

Returns true if the sets s1 and s2 have no items in common.

Example:

let
  a = toHashSet(["a", "b"])
  b = toHashSet(["b", "c"])
assert disjoint(a, b) == false
assert disjoint(a, b - a) == true

	Source   Edit   

proc excl[A](s: var HashSet[A]; key: A)

Excludes key from the set s.

This doesn't do anything if key is not found in s.

See also:

	incl proc for including an element
	excl proc for excluding other set
	missingOrExcl proc

Example:

var s = toHashSet([2, 3, 6, 7])
s.excl(2)
s.excl(2)
assert s.len == 3

	Source   Edit   

proc excl[A](s: var HashSet[A]; other: HashSet[A])

Excludes all elements of other set from s.

This is the in-place version of s - other.

See also:

	incl proc for including other set
	excl proc for excluding an element
	missingOrExcl proc

Example:

var
  numbers = toHashSet([1, 2, 3, 4, 5])
  even = toHashSet([2, 4, 6, 8])
numbers.excl(even)
assert len(numbers) == 3
## numbers == {1, 3, 5}

	Source   Edit   

proc excl[A](s: var OrderedSet[A]; key: A)

Excludes key from the set s. Efficiency: O(n).

This doesn't do anything if key is not found in s.

See also:

	incl proc for including an element
	missingOrExcl proc

Example:

var s = toOrderedSet([2, 3, 6, 7])
s.excl(2)
s.excl(2)
assert s.len == 3

	Source   Edit   

proc hash[A](s: HashSet[A]): Hash

	Hashing of HashSet. Source   Edit   

proc hash[A](s: OrderedSet[A]): Hash

	Hashing of OrderedSet. Source   Edit   

proc incl[A](s: var HashSet[A]; key: A)

Includes an element key in s.

This doesn't do anything if key is already in s.

See also:

	excl proc for excluding an element
	incl proc for including other set
	containsOrIncl proc

Example:

var values = initHashSet[int]()
values.incl(2)
values.incl(2)
assert values.len == 1

	Source   Edit   

proc incl[A](s: var HashSet[A]; other: HashSet[A])

Includes all elements from other set into s (must be declared as var).

This is the in-place version of s + other.

See also:

	excl proc for excluding other set
	incl proc for including an element
	containsOrIncl proc

Example:

var
  values = toHashSet([1, 2, 3])
  others = toHashSet([3, 4, 5])
values.incl(others)
assert values.len == 5

	Source   Edit   

proc incl[A](s: var HashSet[A]; other: OrderedSet[A])

Includes all elements from the OrderedSet other into HashSet s (must be declared as var).

See also:

	incl proc for including an element
	containsOrIncl proc

Example:

var
  values = toHashSet([1, 2, 3])
  others = toOrderedSet([3, 4, 5])
values.incl(others)
assert values.len == 5

	Source   Edit   

proc incl[A](s: var OrderedSet[A]; key: A)

Includes an element key in s.

This doesn't do anything if key is already in s.

See also:

	excl proc for excluding an element
	incl proc for including other set
	containsOrIncl proc

Example:

var values = initOrderedSet[int]()
values.incl(2)
values.incl(2)
assert values.len == 1

	Source   Edit   

proc init[A](s: var HashSet[A]; initialSize = defaultInitialSize)

Initializes a hash set.

Starting from Nim v0.20, sets are initialized by default and it is not necessary to call this function explicitly.

You can call this proc on a previously initialized hash set, which will discard all its values. This might be more convenient than iterating over existing values and calling excl() on them.

See also:

	initHashSet proc
	toHashSet proc

Example:

var a: HashSet[int]
init(a)

	Source   Edit   

proc init[A](s: var OrderedSet[A]; initialSize = defaultInitialSize)

Initializes an ordered hash set.

Starting from Nim v0.20, sets are initialized by default and it is not necessary to call this function explicitly.

You can call this proc on a previously initialized hash set, which will discard all its values. This might be more convenient than iterating over existing values and calling excl() on them.

See also:

	initOrderedSet proc
	toOrderedSet proc

Example:

var a: OrderedSet[int]
init(a)

	Source   Edit   

proc initHashSet[A](initialSize = defaultInitialSize): HashSet[A]

Wrapper around init proc for initialization of hash sets.

Returns an empty hash set you can assign directly in var blocks in a single line.

Starting from Nim v0.20, sets are initialized by default and it is not necessary to call this function explicitly.

See also:

	toHashSet proc

Example:

var a = initHashSet[int]()
a.incl(3)
assert len(a) == 1

	Source   Edit   

proc initOrderedSet[A](initialSize = defaultInitialSize): OrderedSet[A]

Wrapper around init proc for initialization of ordered hash sets.

Returns an empty ordered hash set you can assign directly in var blocks in a single line.

Starting from Nim v0.20, sets are initialized by default and it is not necessary to call this function explicitly.

See also:

	toOrderedSet proc

Example:

var a = initOrderedSet[int]()
a.incl(3)
assert len(a) == 1

	Source   Edit   

proc initSet[A](initialSize = defaultInitialSize): HashSet[A] {.
	....}

	Deprecated: Deprecated since v0.20, use 'initHashSet'
	Source   Edit   

proc intersection[A](s1, s2: HashSet[A]): HashSet[A]

Returns the intersection of the sets s1 and s2.

The same as s1 * s2.

The intersection of two sets is represented mathematically as A ∩ B and is the set of all objects that are members of s1 and s2 at the same time.

See also:

	union proc
	difference proc
	symmetricDifference proc

Example:

let
  a = toHashSet(["a", "b"])
  b = toHashSet(["b", "c"])
  c = intersection(a, b)
assert c == toHashSet(["b"])

	Source   Edit   

proc isValid[A](s: HashSet[A]): bool {.....}

Deprecated: Deprecated since v0.20; sets are initialized by default
Returns true if the set has been initialized (with initHashSet proc or init proc).

Example:

proc savePreferences(options: HashSet[string]) =
  assert options.isValid, "Pass an initialized set!"
  # Do stuff here, may crash in release builds!

	Source   Edit   

proc len[A](s: HashSet[A]): int

Returns the number of elements in s.

Due to an implementation detail you can call this proc on variables which have not been initialized yet. The proc will return zero as the length then.

Example:

var a: HashSet[string]
assert len(a) == 0
let s = toHashSet([3, 5, 7])
assert len(s) == 3

	Source   Edit   

proc len[A](s: OrderedSet[A]): int {.inline.}

Returns the number of elements in s.

Due to an implementation detail you can call this proc on variables which have not been initialized yet. The proc will return zero as the length then.

Example:

var a: OrderedSet[string]
assert len(a) == 0
let s = toHashSet([3, 5, 7])
assert len(s) == 3

	Source   Edit   

proc map[A, B](data: HashSet[A]; op: proc (x: A): B {.closure.}): HashSet[B] {.
	effectsOf: op.}

Returns a new set after applying op proc on each of the elements of data set.

You can use this proc to transform the elements from a set.

Example:

let
  a = toHashSet([1, 2, 3])
  b = a.map(proc (x: int): string = $x)
assert b == toHashSet(["1", "2", "3"])

	Source   Edit   

proc missingOrExcl[A](s: var HashSet[A]; key: A): bool

Excludes key in the set s and tells if key was already missing from s.

The difference with regards to the excl proc is that this proc returns true if key was missing from s. The proc will return false if key was in s and it was removed during this call.

See also:

	excl proc for excluding an element
	excl proc for excluding other set
	containsOrIncl proc

Example:

var s = toHashSet([2, 3, 6, 7])
assert s.missingOrExcl(4) == true
assert s.missingOrExcl(6) == false
assert s.missingOrExcl(6) == true

	Source   Edit   

proc missingOrExcl[A](s: var OrderedSet[A]; key: A): bool

Excludes key in the set s and tells if key was already missing from s. Efficiency: O(n).

The difference with regards to the excl proc is that this proc returns true if key was missing from s. The proc will return false if key was in s and it was removed during this call.

See also:

	excl proc
	containsOrIncl proc

Example:

var s = toOrderedSet([2, 3, 6, 7])
assert s.missingOrExcl(4) == true
assert s.missingOrExcl(6) == false
assert s.missingOrExcl(6) == true

	Source   Edit   

proc pop[A](s: var HashSet[A]): A

Removes and returns an arbitrary element from the set s.

Raises KeyError if the set s is empty.

See also:

	clear proc

Example:

var s = toHashSet([2, 1])
assert [s.pop, s.pop] in [[1, 2], [2,1]] # order unspecified
doAssertRaises(KeyError, echo s.pop)

	Source   Edit   

proc symmetricDifference[A](s1, s2: HashSet[A]): HashSet[A]

Returns the symmetric difference of the sets s1 and s2.

The same as s1 -+- s2.

The symmetric difference of two sets is represented mathematically as A △ B or A ⊖ B and is the set of all objects that are members of s1 or s2 but not both at the same time.

See also:

	union proc
	intersection proc
	difference proc

Example:

let
  a = toHashSet(["a", "b"])
  b = toHashSet(["b", "c"])
  c = symmetricDifference(a, b)
assert c == toHashSet(["a", "c"])

	Source   Edit   

proc toHashSet[A](keys: openArray[A]): HashSet[A]

Creates a new hash set that contains the members of the given collection (seq, array, or string) keys.

Duplicates are removed.

See also:

	initHashSet proc

Example:

let
  a = toHashSet([5, 3, 2])
  b = toHashSet("abracadabra")
assert len(a) == 3
## a == {2, 3, 5}
assert len(b) == 5
## b == {'a', 'b', 'c', 'd', 'r'}

	Source   Edit   

proc toOrderedSet[A](keys: openArray[A]): OrderedSet[A]

Creates a new hash set that contains the members of the given collection (seq, array, or string) keys.

Duplicates are removed.

See also:

	initOrderedSet proc

Example:

let
  a = toOrderedSet([5, 3, 2])
  b = toOrderedSet("abracadabra")
assert len(a) == 3
## a == {5, 3, 2} # different than in HashSet
assert len(b) == 5
## b == {'a', 'b', 'r', 'c', 'd'} # different than in HashSet

	Source   Edit   

proc toSet[A](keys: openArray[A]): HashSet[A] {.
	....}

	Deprecated: Deprecated since v0.20, use 'toHashSet'
	Source   Edit   

proc union[A](s1, s2: HashSet[A]): HashSet[A]

Returns the union of the sets s1 and s2.

The same as s1 + s2.

The union of two sets is represented mathematically as A ∪ B and is the set of all objects that are members of s1, s2 or both.

See also:

	intersection proc
	difference proc
	symmetricDifference proc

Example:

let
  a = toHashSet(["a", "b"])
  b = toHashSet(["b", "c"])
  c = union(a, b)
assert c == toHashSet(["a", "b", "c"])

	Source   Edit   

Iterators

iterator items[A](s: HashSet[A]): A

Iterates over elements of the set s.

If you need a sequence with the elements you can use sequtils.toSeq template.

type
  pair = tuple[a, b: int]
var
  a, b = initHashSet[pair]()
a.incl((2, 3))
a.incl((3, 2))
a.incl((2, 3))
for x, y in a.items:
  b.incl((x - 2, y + 1))
assert a.len == 2
echo b
# --> {(a: 1, b: 3), (a: 0, b: 4)}

	Source   Edit   

iterator items[A](s: OrderedSet[A]): A

Iterates over keys in the ordered set s in insertion order.

If you need a sequence with the elements you can use sequtils.toSeq template.

var a = initOrderedSet[int]()
for value in [9, 2, 1, 5, 1, 8, 4, 2]:
  a.incl(value)
for value in a.items:
  echo "Got ", value
# --> Got 9
# --> Got 2
# --> Got 1
# --> Got 5
# --> Got 8
# --> Got 4

	Source   Edit   

iterator pairs[A](s: OrderedSet[A]): tuple[a: int, b: A]

Iterates through (position, value) tuples of OrderedSet s.

Example:

let a = toOrderedSet("abracadabra")
var p = newSeq[(int, char)]()
for x in pairs(a):
  p.add(x)
assert p == @[(0, 'a'), (1, 'b'), (2, 'r'), (3, 'c'), (4, 'd')]

	Source   Edit   


std/strtabs


std/strtabs
Source   Edit  

The strtabs module implements an efficient hash table that is a mapping from strings to strings. Supports a case-sensitive, case-insensitive and style-insensitive mode.

Example:

import std/strtabs
var t = newStringTable()
t["name"] = "John"
t["city"] = "Monaco"
doAssert t.len == 2
doAssert t.hasKey "name"
doAssert "name" in t

String tables can be created from a table constructor:

Example:

import std/strtabs
var t = {"name": "John", "city": "Monaco"}.newStringTable

When using the style insensitive mode (modeStyleInsensitive), all letters are compared case insensitively within the ASCII range and underscores are ignored.

Example:

import std/strtabs
var x = newStringTable(modeStyleInsensitive)
x["first_name"] = "John"
x["LastName"] = "Doe"

doAssert x["firstName"] == "John"
doAssert x["last_name"] == "Doe"

An efficient string substitution operator % for the string table is also provided.

Example:

import std/strtabs
var t = {"name": "John", "city": "Monaco"}.newStringTable
doAssert "${name} lives in ${city}" % t == "John lives in Monaco"

See also:

	tables module for general hash tables
	sharedtables module for shared hash table support
	strutils module for common string functions
	json module for table-like structure which allows heterogeneous members

Imports

since, hashes, strutils, envvars

Types

FormatFlag = enum
  useEnvironment,       	## Use environment variable if the ``$key``
                         	## is not found in the table.
                         	## Does nothing when using `js` target.
  useEmpty,             	## Use the empty string as a default, thus it
                         	## won't throw an exception if ``$key`` is not
                         	## in the table.
  useKey                 	## Do not replace ``$key`` if it is not found
                         	## in the table (or in the environment).

	Flags for the % operator. Source   Edit   

StringTableMode = enum
  modeCaseSensitive,    	## the table is case sensitive
  modeCaseInsensitive,  	## the table is case insensitive
  modeStyleInsensitive   	## the table is style insensitive

	Describes the tables operation mode. Source   Edit   

StringTableObj = object of RootObj

	Source   Edit   

StringTableRef = ref StringTableObj

	Source   Edit   

Procs

proc `$`(t: StringTableRef): string {.....}

	The $ operator for string tables. Used internally when calling echo on a table. Source   Edit   

proc `%`(f: string; t: StringTableRef; flags: set[FormatFlag] = {}): string {.
	....}

The % operator for string tables.

Example:

var t = {"name": "John", "city": "Monaco"}.newStringTable
doAssert "${name} lives in ${city}" % t == "John lives in Monaco"

	Source   Edit   

proc `[]`(t: StringTableRef; key: string): var string {.....}

Retrieves the location at t[key].

If key is not in t, the KeyError exception is raised. One can check with hasKey proc whether the key exists.

See also:

	getOrDefault proc
	[]= proc for inserting a new (key, value) pair in the table
	hasKey proc for checking if a key is in the table

Example:

var t = {"name": "John", "city": "Monaco"}.newStringTable
doAssert t["name"] == "John"
doAssertRaises(KeyError):
  echo t["occupation"]

	Source   Edit   

proc `[]=`(t: StringTableRef; key, val: string) {.....}

Inserts a (key, value) pair into t.

See also:

	[] proc for retrieving a value of a key
	del proc for removing a key from the table

Example:

var t = {"name": "John", "city": "Monaco"}.newStringTable
t["occupation"] = "teacher"
doAssert t.hasKey("occupation")

	Source   Edit   

proc clear(s: StringTableRef) {.....}

	Resets a string table to be empty again without changing the mode. Source   Edit   

proc clear(s: StringTableRef; mode: StringTableMode) {.....}

Resets a string table to be empty again, perhaps altering the mode.

See also:

	del proc for removing a key from the table

Example:

var t = {"name": "John", "city": "Monaco"}.newStringTable
clear(t, modeCaseSensitive)
doAssert len(t) == 0
doAssert "name" notin t
doAssert "city" notin t

	Source   Edit   

proc contains(t: StringTableRef; key: string): bool {.....}

Alias of hasKey proc for use with the in operator.

Example:

var t = {"name": "John", "city": "Monaco"}.newStringTable
doAssert "name" in t
doAssert "occupation" notin t

	Source   Edit   

proc del(t: StringTableRef; key: string) {.....}

Removes key from t.

See also:

	clear proc for resetting a table to be empty
	[]= proc for inserting a new (key, value) pair in the table

Example:

var t = {"name": "John", "city": "Monaco"}.newStringTable
t.del("name")
doAssert len(t) == 1
doAssert "name" notin t
doAssert "city" in t

	Source   Edit   

proc getOrDefault(t: StringTableRef; key: string; default: string = ""): string {.
	....}

Retrieves the location at t[key].

If key is not in t, the default value is returned (if not specified, it is an empty string ("")).

See also:

	[] proc for retrieving a value of a key
	hasKey proc for checking if a key is in the table
	[]= proc for inserting a new (key, value) pair in the table

Example:

var t = {"name": "John", "city": "Monaco"}.newStringTable
doAssert t.getOrDefault("name") == "John"
doAssert t.getOrDefault("occupation") == ""
doAssert t.getOrDefault("occupation", "teacher") == "teacher"
doAssert t.getOrDefault("name", "Paul") == "John"

	Source   Edit   

proc hasKey(t: StringTableRef; key: string): bool {.....}

Returns true if key is in the table t.

See also:

	getOrDefault proc
	contains proc

Example:

var t = {"name": "John", "city": "Monaco"}.newStringTable
doAssert t.hasKey("name")
doAssert not t.hasKey("occupation")

	Source   Edit   

proc len(t: StringTableRef): int {.....}

	Returns the number of keys in t. Source   Edit   

proc mode(t: StringTableRef): StringTableMode {.inline, ....}

	Source   Edit   

proc newStringTable(keyValuePairs: varargs[string]; mode: StringTableMode): owned(
	StringTableRef) {....noSideEffect,
                  	....}

Creates a new string table with given key, value string pairs.

StringTableMode must be specified.

Example:

var mytab = newStringTable("key1", "val1", "key2", "val2",
                       	modeCaseInsensitive)

	Source   Edit   

proc newStringTable(keyValuePairs: varargs[tuple[key, val: string]];
                	mode: StringTableMode = modeCaseSensitive): owned(
	StringTableRef) {....noSideEffect,
                  	....}

Creates a new string table with given (key, value) tuple pairs.

The default mode is case sensitive.

Example:

var
  mytab1 = newStringTable({"key1": "val1", "key2": "val2"}, modeCaseInsensitive)
  mytab2 = newStringTable([("key3", "val3"), ("key4", "val4")])

	Source   Edit   

proc newStringTable(mode: StringTableMode): owned(StringTableRef) {....noSideEffect, ....}

	Creates a new empty string table.

	See also:

    	newStringTable(keyValuePairs) proc

	Source   Edit   

Iterators

iterator keys(t: StringTableRef): string {.....}

	Iterates over every key in the table t. Source   Edit   

iterator pairs(t: StringTableRef): tuple[key, value: string] {.....}

	Iterates over every (key, value) pair in the table t. Source   Edit   

iterator values(t: StringTableRef): string {.....}

	Iterates over every value in the table t. Source   Edit   


std/tables


std/tables
Source   Edit  

The tables module implements variants of an efficient hash table (also often named dictionary in other programming languages) that is a mapping from keys to values.

There are several different types of hash tables available:

	Table is the usual hash table,
	OrderedTable is like Table but remembers insertion order,
	CountTable is a mapping from a key to its number of occurrences

For consistency with every other data type in Nim these have value semantics, this means that = performs a copy of the hash table.

For ref semantics use their Ref variants: TableRef, OrderedTableRef, and CountTableRef.

To give an example, when a is a Table, then var b = a gives b as a new independent table. b is initialised with the contents of a. Changing b does not affect a and vice versa:

Example:

import std/tables
var
  a = {1: "one", 2: "two"}.toTable  # creates a Table
  b = a

assert a == b

b[3] = "three"
assert 3 notin a
assert 3 in b
assert a != b

On the other hand, when a is a TableRef instead, then changes to b also affect a. Both a and b ref the same data structure:

Example:

import std/tables
var
  a = {1: "one", 2: "two"}.newTable  # creates a TableRef
  b = a

assert a == b

b[3] = "three"

assert 3 in a
assert 3 in b
assert a == b

Basic usage
Table

Example:

import std/tables
from std/sequtils import zip

let
  names = ["John", "Paul", "George", "Ringo"]
  years = [1940, 1942, 1943, 1940]

var beatles = initTable[string, int]()

for pairs in zip(names, years):
  let (name, birthYear) = pairs
  beatles[name] = birthYear

assert beatles == {"George": 1943, "Ringo": 1940, "Paul": 1942, "John": 1940}.toTable


var beatlesByYear = initTable[int, seq[string]]()

for pairs in zip(years, names):
  let (birthYear, name) = pairs
  if not beatlesByYear.hasKey(birthYear):
	# if a key doesn't exist, we create one with an empty sequence
	# before we can add elements to it
	beatlesByYear[birthYear] = @[]
  beatlesByYear[birthYear].add(name)

assert beatlesByYear == {1940: @["John", "Ringo"], 1942: @["Paul"], 1943: @["George"]}.toTable

OrderedTable

OrderedTable is used when it is important to preserve the insertion order of keys.

Example:

import std/tables
let
  a = [('z', 1), ('y', 2), ('x', 3)]
  ot = a.toOrderedTable  # ordered tables

assert $ot == """{'z': 1, 'y': 2, 'x': 3}"""

CountTable

CountTable is useful for counting number of items of some container (e.g. string, sequence or array), as it is a mapping where the items are the keys, and their number of occurrences are the values. For that purpose toCountTable proc comes handy:

Example:

import std/tables
let myString = "abracadabra"
let letterFrequencies = toCountTable(myString)
assert $letterFrequencies == "{'a': 5, 'd': 1, 'b': 2, 'r': 2, 'c': 1}"

The same could have been achieved by manually iterating over a container and increasing each key's value with inc proc:

Example:

import std/tables
let myString = "abracadabra"
var letterFrequencies = initCountTable[char]()
for c in myString:
  letterFrequencies.inc(c)
assert $letterFrequencies == "{'d': 1, 'r': 2, 'c': 1, 'a': 5, 'b': 2}"

Hashing

If you are using simple standard types like int or string for the keys of the table you won't have any problems, but as soon as you try to use a more complex object as a key you will be greeted by a strange compiler error:

Error: type mismatch: got (Person)
but expected one of:
hashes.hash(x: openArray[A]): Hash
hashes.hash(x: int): Hash
hashes.hash(x: float): Hash
…

What is happening here is that the types used for table keys require to have a hash() proc which will convert them to a Hash value, and the compiler is listing all the hash functions it knows. Additionally there has to be a == operator that provides the same semantics as its corresponding hash proc.

After you add hash and == for your custom type everything will work. Currently, however, hash for objects is not defined, whereas system.== for objects does exist and performs a "deep" comparison (every field is compared) which is usually what you want. So in the following example implementing only hash suffices:

Example:

import std/tables
import std/hashes

type
  Person = object
	firstName, lastName: string

proc hash(x: Person): Hash =
  ## Piggyback on the already available string hash proc.
  ##
  ## Without this proc nothing works!
  result = x.firstName.hash !& x.lastName.hash
  result = !$result

var
  salaries = initTable[Person, int]()
  p1, p2: Person

p1.firstName = "Jon"
p1.lastName = "Ross"
salaries[p1] = 30_000

p2.firstName = "소진"
p2.lastName = "박"
salaries[p2] = 45_000

See also

	json module for table-like structure which allows heterogeneous members
	strtabs module for efficient hash tables mapping from strings to strings
	hashes module for helper functions for hashing

Imports

since, hashes, math, algorithm, outparams

Types

CountTable[A] = object

	Hash table that counts the number of each key.

	For creating an empty CountTable, use initCountTable proc.
	Source   Edit   

CountTableRef[A] = ref CountTable[A]

	Ref version of CountTable.

	For creating a new empty CountTableRef, use newCountTable proc.
	Source   Edit   

OrderedTable[A; B] = object

	Hash table that remembers insertion order.

	For creating an empty OrderedTable, use initOrderedTable proc.
	Source   Edit   

OrderedTableRef[A; B] = ref OrderedTable[A, B]

	Ref version of OrderedTable.

	For creating a new empty OrderedTableRef, use newOrderedTable proc.
	Source   Edit   

Table[A; B] = object

	Generic hash table, consisting of a key-value pair.

	data and counter are internal implementation details which can't be accessed.

	For creating an empty Table, use initTable proc.
	Source   Edit   

TableRef[A; B] = ref Table[A, B]

	Ref version of Table.

	For creating a new empty TableRef, use newTable proc.
	Source   Edit   

Consts

defaultInitialSize = 32

	Source   Edit   

Procs

proc `$`[A, B](t: OrderedTable[A, B]): string

	The $ operator for ordered hash tables. Used internally when calling echo on a table. Source   Edit   

proc `$`[A, B](t: OrderedTableRef[A, B]): string

	The $ operator for hash tables. Used internally when calling echo on a table. Source   Edit   

proc `$`[A, B](t: Table[A, B]): string

	The $ operator for hash tables. Used internally when calling echo on a table. Source   Edit   

proc `$`[A, B](t: TableRef[A, B]): string

	The $ operator for hash tables. Used internally when calling echo on a table. Source   Edit   

proc `$`[A](t: CountTable[A]): string

	The $ operator for count tables. Used internally when calling echo on a table. Source   Edit   

proc `$`[A](t: CountTableRef[A]): string

	The $ operator for count tables. Used internally when calling echo on a table. Source   Edit   

proc `==`[A, B](s, t: OrderedTable[A, B]): bool

The == operator for ordered hash tables. Returns true if both the content and the order are equal.

Example:

let
  a = {'a': 5, 'b': 9, 'c': 13}.toOrderedTable
  b = {'b': 9, 'c': 13, 'a': 5}.toOrderedTable
doAssert a != b

	Source   Edit   

proc `==`[A, B](s, t: OrderedTableRef[A, B]): bool

The == operator for ordered hash tables. Returns true if either both tables are nil, or neither is nil and the content and the order of both are equal.

Example:

let
  a = {'a': 5, 'b': 9, 'c': 13}.newOrderedTable
  b = {'b': 9, 'c': 13, 'a': 5}.newOrderedTable
doAssert a != b

	Source   Edit   

proc `==`[A, B](s, t: Table[A, B]): bool

The == operator for hash tables. Returns true if the content of both tables contains the same key-value pairs. Insert order does not matter.

Example:

let
  a = {'a': 5, 'b': 9, 'c': 13}.toTable
  b = {'b': 9, 'c': 13, 'a': 5}.toTable
doAssert a == b

	Source   Edit   

proc `==`[A, B](s, t: TableRef[A, B]): bool

The == operator for hash tables. Returns true if either both tables are nil, or neither is nil and the content of both tables contains the same key-value pairs. Insert order does not matter.

Example:

let
  a = {'a': 5, 'b': 9, 'c': 13}.newTable
  b = {'b': 9, 'c': 13, 'a': 5}.newTable
doAssert a == b

	Source   Edit   

proc `==`[A](s, t: CountTable[A]): bool

	The == operator for count tables. Returns true if both tables contain the same keys with the same count. Insert order does not matter. Source   Edit   

proc `==`[A](s, t: CountTableRef[A]): bool

	The == operator for count tables. Returns true if either both tables are nil, or neither is nil and both contain the same keys with the same count. Insert order does not matter. Source   Edit   

proc `[]`[A, B](t: OrderedTable[A, B]; key: A): lent B

Retrieves the value at t[key].

If key is not in t, the KeyError exception is raised. One can check with hasKey proc whether the key exists.

See also:

	getOrDefault proc to return a default value (e.g. zero for int) if the key doesn't exist
	getOrDefault proc to return a custom value if the key doesn't exist
	[]= proc for inserting a new (key, value) pair in the table
	hasKey proc for checking if a key is in the table

Example:

let a = {'a': 5, 'b': 9}.toOrderedTable
doAssert a['a'] == 5
doAssertRaises(KeyError):
  echo a['z']

	Source   Edit   

proc `[]`[A, B](t: OrderedTableRef[A, B]; key: A): var B

Retrieves the value at t[key].

If key is not in t, the KeyError exception is raised. One can check with hasKey proc whether the key exists.

See also:

	getOrDefault proc to return a default value (e.g. zero for int) if the key doesn't exist
	getOrDefault proc to return a custom value if the key doesn't exist
	[]= proc for inserting a new (key, value) pair in the table
	hasKey proc for checking if a key is in the table

Example:

let a = {'a': 5, 'b': 9}.newOrderedTable
doAssert a['a'] == 5
doAssertRaises(KeyError):
  echo a['z']

	Source   Edit   

proc `[]`[A, B](t: Table[A, B]; key: A): lent B

Retrieves the value at t[key].

If key is not in t, the KeyError exception is raised. One can check with hasKey proc whether the key exists.

See also:

	getOrDefault proc to return a default value (e.g. zero for int) if the key doesn't exist
	getOrDefault proc to return a custom value if the key doesn't exist
	[]= proc for inserting a new (key, value) pair in the table
	hasKey proc for checking if a key is in the table

Example:

let a = {'a': 5, 'b': 9}.toTable
doAssert a['a'] == 5
doAssertRaises(KeyError):
  echo a['z']

	Source   Edit   

proc `[]`[A, B](t: TableRef[A, B]; key: A): var B

Retrieves the value at t[key].

If key is not in t, the KeyError exception is raised. One can check with hasKey proc whether the key exists.

See also:

	getOrDefault proc to return a default value (e.g. zero for int) if the key doesn't exist
	getOrDefault proc to return a custom value if the key doesn't exist
	[]= proc for inserting a new (key, value) pair in the table
	hasKey proc for checking if a key is in the table

Example:

let a = {'a': 5, 'b': 9}.newTable
doAssert a['a'] == 5
doAssertRaises(KeyError):
  echo a['z']

	Source   Edit   

proc `[]`[A, B](t: var OrderedTable[A, B]; key: A): var B

	Retrieves the value at t[key]. The value can be modified.

	If key is not in t, the KeyError exception is raised.

	See also:

    	getOrDefault proc to return a default value (e.g. zero for int) if the key doesn't exist
    	getOrDefault proc to return a custom value if the key doesn't exist
    	[]= proc for inserting a new (key, value) pair in the table
    	hasKey proc for checking if a key is in the table

	Source   Edit   

proc `[]`[A, B](t: var Table[A, B]; key: A): var B

	Retrieves the value at t[key]. The value can be modified.

	If key is not in t, the KeyError exception is raised.

	See also:

    	getOrDefault proc to return a default value (e.g. zero for int) if the key doesn't exist
    	getOrDefault proc to return a custom value if the key doesn't exist
    	[]= proc for inserting a new (key, value) pair in the table
    	hasKey proc for checking if a key is in the table

	Source   Edit   

proc `[]`[A](t: CountTable[A]; key: A): int

	Retrieves the value at t[key] if key is in t. Otherwise 0 is returned.

	See also:

    	getOrDefault to return a custom value if the key doesn't exist
    	[]= proc for inserting a new (key, value) pair in the table
    	hasKey proc for checking if a key is in the table

	Source   Edit   

proc `[]`[A](t: CountTableRef[A]; key: A): int

	Retrieves the value at t[key] if key is in t. Otherwise 0 is returned.

	See also:

    	getOrDefault to return a custom value if the key doesn't exist
    	inc proc to inc even if missing
    	[]= proc for inserting a new (key, value) pair in the table
    	hasKey proc for checking if a key is in the table

	Source   Edit   

proc `[]=`[A, B](t: OrderedTableRef[A, B]; key: A; val: sink B)

Inserts a (key, value) pair into t.

See also:

	[] proc for retrieving a value of a key
	hasKeyOrPut proc
	mgetOrPut proc
	del proc for removing a key from the table

Example:

var a = newOrderedTable[char, int]()
a['x'] = 7
a['y'] = 33
doAssert a == {'x': 7, 'y': 33}.newOrderedTable

	Source   Edit   

proc `[]=`[A, B](t: TableRef[A, B]; key: A; val: sink B)

Inserts a (key, value) pair into t.

See also:

	[] proc for retrieving a value of a key
	hasKeyOrPut proc
	mgetOrPut proc
	del proc for removing a key from the table

Example:

var a = newTable[char, int]()
a['x'] = 7
a['y'] = 33
doAssert a == {'x': 7, 'y': 33}.newTable

	Source   Edit   

proc `[]=`[A, B](t: var OrderedTable[A, B]; key: A; val: sink B)

Inserts a (key, value) pair into t.

See also:

	[] proc for retrieving a value of a key
	hasKeyOrPut proc
	mgetOrPut proc
	del proc for removing a key from the table

Example:

var a = initOrderedTable[char, int]()
a['x'] = 7
a['y'] = 33
doAssert a == {'x': 7, 'y': 33}.toOrderedTable

	Source   Edit   

proc `[]=`[A, B](t: var Table[A, B]; key: A; val: sink B)

Inserts a (key, value) pair into t.

See also:

	[] proc for retrieving a value of a key
	hasKeyOrPut proc
	mgetOrPut proc
	del proc for removing a key from the table

Example:

var a = initTable[char, int]()
a['x'] = 7
a['y'] = 33
doAssert a == {'x': 7, 'y': 33}.toTable

	Source   Edit   

proc `[]=`[A](t: CountTableRef[A]; key: A; val: int)

	Inserts a (key, value) pair into t.

	See also:

    	[] proc for retrieving a value of a key
    	inc proc for incrementing a value of a key

	Source   Edit   

proc `[]=`[A](t: var CountTable[A]; key: A; val: int)

	Inserts a (key, value) pair into t.

	See also:

    	[] proc for retrieving a value of a key
    	inc proc for incrementing a value of a key

	Source   Edit   

proc add[A, B](t: OrderedTableRef[A, B]; key: A; val: sink B) {.....}

	Deprecated: Deprecated since v1.4; it was more confusing than useful, use `[]=`

	Puts a new (key, value) pair into t even if t[key] already exists.

	This can introduce duplicate keys into the table!

	Use []= proc for inserting a new (key, value) pair in the table without introducing duplicates.
	Source   Edit   

proc add[A, B](t: TableRef[A, B]; key: A; val: sink B) {.....}

	Deprecated: Deprecated since v1.4; it was more confusing than useful, use `[]=`

	Puts a new (key, value) pair into t even if t[key] already exists.

	This can introduce duplicate keys into the table!

	Use []= proc for inserting a new (key, value) pair in the table without introducing duplicates.
	Source   Edit   

proc add[A, B](t: var OrderedTable[A, B]; key: A; val: sink B) {.....}

	Deprecated: Deprecated since v1.4; it was more confusing than useful, use `[]=`

	Puts a new (key, value) pair into t even if t[key] already exists.

	This can introduce duplicate keys into the table!

	Use []= proc for inserting a new (key, value) pair in the table without introducing duplicates.
	Source   Edit   

proc add[A, B](t: var Table[A, B]; key: A; val: sink B) {.....}

	Deprecated: Deprecated since v1.4; it was more confusing than useful, use `[]=`

	Puts a new (key, value) pair into t even if t[key] already exists.

	This can introduce duplicate keys into the table!

	Use []= proc for inserting a new (key, value) pair in the table without introducing duplicates.
	Source   Edit   

proc clear[A, B](t: OrderedTableRef[A, B])

Resets the table so that it is empty.

See also:

	del proc

Example:

var a = {'a': 5, 'b': 9, 'c': 13}.newOrderedTable
doAssert len(a) == 3
clear(a)
doAssert len(a) == 0

	Source   Edit   

proc clear[A, B](t: TableRef[A, B])

Resets the table so that it is empty.

See also:

	del proc
	pop proc

Example:

var a = {'a': 5, 'b': 9, 'c': 13}.newTable
doAssert len(a) == 3
clear(a)
doAssert len(a) == 0

	Source   Edit   

proc clear[A, B](t: var OrderedTable[A, B])

Resets the table so that it is empty.

See also:

	del proc
	pop proc

Example:

var a = {'a': 5, 'b': 9, 'c': 13}.toOrderedTable
doAssert len(a) == 3
clear(a)
doAssert len(a) == 0

	Source   Edit   

proc clear[A, B](t: var Table[A, B])

Resets the table so that it is empty.

See also:

	del proc
	pop proc

Example:

var a = {'a': 5, 'b': 9, 'c': 13}.toTable
doAssert len(a) == 3
clear(a)
doAssert len(a) == 0

	Source   Edit   

proc clear[A](t: CountTableRef[A])

	Resets the table so that it is empty.

	See also:

    	del proc
    	pop proc

	Source   Edit   

proc clear[A](t: var CountTable[A])

	Resets the table so that it is empty.

	See also:

    	del proc
    	pop proc

	Source   Edit   

proc contains[A, B](t: OrderedTable[A, B]; key: A): bool

Alias of hasKey proc for use with the in operator.

Example:

let a = {'a': 5, 'b': 9}.toOrderedTable
doAssert 'b' in a == true
doAssert a.contains('z') == false

	Source   Edit   

proc contains[A, B](t: OrderedTableRef[A, B]; key: A): bool

Alias of hasKey proc for use with the in operator.

Example:

let a = {'a': 5, 'b': 9}.newOrderedTable
doAssert 'b' in a == true
doAssert a.contains('z') == false

	Source   Edit   

proc contains[A, B](t: Table[A, B]; key: A): bool

Alias of hasKey proc for use with the in operator.

Example:

let a = {'a': 5, 'b': 9}.toTable
doAssert 'b' in a == true
doAssert a.contains('z') == false

	Source   Edit   

proc contains[A, B](t: TableRef[A, B]; key: A): bool

Alias of hasKey proc for use with the in operator.

Example:

let a = {'a': 5, 'b': 9}.newTable
doAssert 'b' in a == true
doAssert a.contains('z') == false

	Source   Edit   

proc contains[A](t: CountTable[A]; key: A): bool

	Alias of hasKey proc for use with the in operator. Source   Edit   

proc contains[A](t: CountTableRef[A]; key: A): bool

	Alias of hasKey proc for use with the in operator. Source   Edit   

proc del[A, B](t: OrderedTableRef[A, B]; key: A)

Deletes key from hash table t. Does nothing if the key does not exist.

See also:

	clear proc to empty the whole table

Example:

var a = {'a': 5, 'b': 9, 'c': 13}.newOrderedTable
a.del('a')
doAssert a == {'b': 9, 'c': 13}.newOrderedTable
a.del('z')
doAssert a == {'b': 9, 'c': 13}.newOrderedTable

	Source   Edit   

proc del[A, B](t: TableRef[A, B]; key: A)

Deletes key from hash table t. Does nothing if the key does not exist.
Warning: If duplicate keys were added (via the now deprecated add proc), this may need to be called multiple times.

See also:

	pop proc
	clear proc to empty the whole table

Example:

var a = {'a': 5, 'b': 9, 'c': 13}.newTable
a.del('a')
doAssert a == {'b': 9, 'c': 13}.newTable
a.del('z')
doAssert a == {'b': 9, 'c': 13}.newTable

	Source   Edit   

proc del[A, B](t: var OrderedTable[A, B]; key: A)

Deletes key from hash table t. Does nothing if the key does not exist.

O(n) complexity.

See also:

	pop proc
	clear proc to empty the whole table

Example:

var a = {'a': 5, 'b': 9, 'c': 13}.toOrderedTable
a.del('a')
doAssert a == {'b': 9, 'c': 13}.toOrderedTable
a.del('z')
doAssert a == {'b': 9, 'c': 13}.toOrderedTable

	Source   Edit   

proc del[A, B](t: var Table[A, B]; key: A)

Deletes key from hash table t. Does nothing if the key does not exist.
Warning: If duplicate keys were added (via the now deprecated add proc), this may need to be called multiple times.

See also:

	pop proc
	clear proc to empty the whole table

Example:

var a = {'a': 5, 'b': 9, 'c': 13}.toTable
a.del('a')
doAssert a == {'b': 9, 'c': 13}.toTable
a.del('z')
doAssert a == {'b': 9, 'c': 13}.toTable

	Source   Edit   

proc del[A](t: CountTableRef[A]; key: A)

	Deletes key from table t. Does nothing if the key does not exist.

	See also:

    	pop proc
    	clear proc to empty the whole table

	Source   Edit   

proc del[A](t: var CountTable[A]; key: A)

Deletes key from table t. Does nothing if the key does not exist.

See also:

	pop proc
	clear proc to empty the whole table

Example:

var a = toCountTable("aabbbccccc")
a.del('b')
assert a == toCountTable("aaccccc")
a.del('b')
assert a == toCountTable("aaccccc")
a.del('c')
assert a == toCountTable("aa")

	Source   Edit   

proc getOrDefault[A, B](t: OrderedTable[A, B]; key: A): B

Retrieves the value at t[key] if key is in t. Otherwise, the default initialization value for type B is returned (e.g. 0 for any integer type).

See also:

	[] proc for retrieving a value of a key
	hasKey proc
	hasKeyOrPut proc
	mgetOrPut proc
	getOrDefault proc to return a custom value if the key doesn't exist

Example:

let a = {'a': 5, 'b': 9}.toOrderedTable
doAssert a.getOrDefault('a') == 5
doAssert a.getOrDefault('z') == 0

	Source   Edit   

proc getOrDefault[A, B](t: OrderedTable[A, B]; key: A; default: B): B

Retrieves the value at t[key] if key is in t. Otherwise, default is returned.

See also:

	[] proc for retrieving a value of a key
	hasKey proc
	hasKeyOrPut proc
	mgetOrPut proc
	getOrDefault proc to return a default value (e.g. zero for int) if the key doesn't exist

Example:

let a = {'a': 5, 'b': 9}.toOrderedTable
doAssert a.getOrDefault('a', 99) == 5
doAssert a.getOrDefault('z', 99) == 99

	Source   Edit   

proc getOrDefault[A, B](t: OrderedTableRef[A, B]; key: A): B

Retrieves the value at t[key] if key is in t. Otherwise, the default initialization value for type B is returned (e.g. 0 for any integer type).

See also:

	[] proc for retrieving a value of a key
	hasKey proc
	hasKeyOrPut proc
	mgetOrPut proc
	getOrDefault proc to return a custom value if the key doesn't exist

Example:

let a = {'a': 5, 'b': 9}.newOrderedTable
doAssert a.getOrDefault('a') == 5
doAssert a.getOrDefault('z') == 0

	Source   Edit   

proc getOrDefault[A, B](t: OrderedTableRef[A, B]; key: A; default: B): B

Retrieves the value at t[key] if key is in t. Otherwise, default is returned.

See also:

	[] proc for retrieving a value of a key
	hasKey proc
	hasKeyOrPut proc
	mgetOrPut proc
	getOrDefault proc to return a default value (e.g. zero for int) if the key doesn't exist

Example:

let a = {'a': 5, 'b': 9}.newOrderedTable
doAssert a.getOrDefault('a', 99) == 5
doAssert a.getOrDefault('z', 99) == 99

	Source   Edit   

proc getOrDefault[A, B](t: Table[A, B]; key: A): B

Retrieves the value at t[key] if key is in t. Otherwise, the default initialization value for type B is returned (e.g. 0 for any integer type).

See also:

	[] proc for retrieving a value of a key
	hasKey proc
	hasKeyOrPut proc
	mgetOrPut proc
	getOrDefault proc to return a custom value if the key doesn't exist

Example:

let a = {'a': 5, 'b': 9}.toTable
doAssert a.getOrDefault('a') == 5
doAssert a.getOrDefault('z') == 0

	Source   Edit   

proc getOrDefault[A, B](t: Table[A, B]; key: A; default: B): B

Retrieves the value at t[key] if key is in t. Otherwise, default is returned.

See also:

	[] proc for retrieving a value of a key
	hasKey proc
	hasKeyOrPut proc
	mgetOrPut proc
	getOrDefault proc to return a default value (e.g. zero for int) if the key doesn't exist

Example:

let a = {'a': 5, 'b': 9}.toTable
doAssert a.getOrDefault('a', 99) == 5
doAssert a.getOrDefault('z', 99) == 99

	Source   Edit   

proc getOrDefault[A, B](t: TableRef[A, B]; key: A): B

Retrieves the value at t[key] if key is in t. Otherwise, the default initialization value for type B is returned (e.g. 0 for any integer type).

See also:

	[] proc for retrieving a value of a key
	hasKey proc
	hasKeyOrPut proc
	mgetOrPut proc
	getOrDefault proc to return a custom value if the key doesn't exist

Example:

let a = {'a': 5, 'b': 9}.newTable
doAssert a.getOrDefault('a') == 5
doAssert a.getOrDefault('z') == 0

	Source   Edit   

proc getOrDefault[A, B](t: TableRef[A, B]; key: A; default: B): B

Retrieves the value at t[key] if key is in t. Otherwise, default is returned.

See also:

	[] proc for retrieving a value of a key
	hasKey proc
	hasKeyOrPut proc
	mgetOrPut proc
	getOrDefault proc to return a default value (e.g. zero for int) if the key doesn't exist

Example:

let a = {'a': 5, 'b': 9}.newTable
doAssert a.getOrDefault('a', 99) == 5
doAssert a.getOrDefault('z', 99) == 99

	Source   Edit   

proc getOrDefault[A](t: CountTable[A]; key: A; default: int = 0): int

	Retrieves the value at t[key] if key is in t. Otherwise, the integer value of default is returned.

	See also:

    	[] proc for retrieving a value of a key
    	hasKey proc for checking if a key is in the table

	Source   Edit   

proc getOrDefault[A](t: CountTableRef[A]; key: A; default: int): int

	Retrieves the value at t[key] if key is in t. Otherwise, the integer value of default is returned.

	See also:

    	[] proc for retrieving a value of a key
    	hasKey proc for checking if a key is in the table

	Source   Edit   

proc hash[K, V](s: OrderedTable[K, V]): Hash

	Source   Edit   

proc hash[K, V](s: Table[K, V]): Hash

	Source   Edit   

proc hash[V](s: CountTable[V]): Hash

	Source   Edit   

proc hasKey[A, B](t: OrderedTable[A, B]; key: A): bool

Returns true if key is in the table t.

See also:

	contains proc for use with the in operator
	[] proc for retrieving a value of a key
	getOrDefault proc to return a default value (e.g. zero for int) if the key doesn't exist
	getOrDefault proc to return a custom value if the key doesn't exist

Example:

let a = {'a': 5, 'b': 9}.toOrderedTable
doAssert a.hasKey('a') == true
doAssert a.hasKey('z') == false

	Source   Edit   

proc hasKey[A, B](t: OrderedTableRef[A, B]; key: A): bool

Returns true if key is in the table t.

See also:

	contains proc for use with the in operator
	[] proc for retrieving a value of a key
	getOrDefault proc to return a default value (e.g. zero for int) if the key doesn't exist
	getOrDefault proc to return a custom value if the key doesn't exist

Example:

let a = {'a': 5, 'b': 9}.newOrderedTable
doAssert a.hasKey('a') == true
doAssert a.hasKey('z') == false

	Source   Edit   

proc hasKey[A, B](t: Table[A, B]; key: A): bool

Returns true if key is in the table t.

See also:

	contains proc for use with the in operator
	[] proc for retrieving a value of a key
	getOrDefault proc to return a default value (e.g. zero for int) if the key doesn't exist
	getOrDefault proc to return a custom value if the key doesn't exist

Example:

let a = {'a': 5, 'b': 9}.toTable
doAssert a.hasKey('a') == true
doAssert a.hasKey('z') == false

	Source   Edit   

proc hasKey[A, B](t: TableRef[A, B]; key: A): bool

Returns true if key is in the table t.

See also:

	contains proc for use with the in operator
	[] proc for retrieving a value of a key
	getOrDefault proc to return a default value (e.g. zero for int) if the key doesn't exist
	getOrDefault proc to return a custom value if the key doesn't exist

Example:

let a = {'a': 5, 'b': 9}.newTable
doAssert a.hasKey('a') == true
doAssert a.hasKey('z') == false

	Source   Edit   

proc hasKey[A](t: CountTable[A]; key: A): bool

	Returns true if key is in the table t.

	See also:

    	contains proc for use with the in operator
    	[] proc for retrieving a value of a key
    	getOrDefault proc to return a custom value if the key doesn't exist

	Source   Edit   

proc hasKey[A](t: CountTableRef[A]; key: A): bool

	Returns true if key is in the table t.

	See also:

    	contains proc for use with the in operator
    	[] proc for retrieving a value of a key
    	getOrDefault proc to return a custom value if the key doesn't exist

	Source   Edit   

proc hasKeyOrPut[A, B](t: OrderedTableRef[A, B]; key: A; val: B): bool

Returns true if key is in the table, otherwise inserts value.

See also:

	hasKey proc
	[] proc for retrieving a value of a key
	getOrDefault proc to return a default value (e.g. zero for int) if the key doesn't exist
	getOrDefault proc to return a custom value if the key doesn't exist

Example:

var a = {'a': 5, 'b': 9}.newOrderedTable
if a.hasKeyOrPut('a', 50):
  a['a'] = 99
if a.hasKeyOrPut('z', 50):
  a['z'] = 99
doAssert a == {'a': 99, 'b': 9, 'z': 50}.newOrderedTable

	Source   Edit   

proc hasKeyOrPut[A, B](t: TableRef[A, B]; key: A; val: B): bool

Returns true if key is in the table, otherwise inserts value.

See also:

	hasKey proc
	[] proc for retrieving a value of a key
	getOrDefault proc to return a default value (e.g. zero for int) if the key doesn't exist
	getOrDefault proc to return a custom value if the key doesn't exist

Example:

var a = {'a': 5, 'b': 9}.newTable
if a.hasKeyOrPut('a', 50):
  a['a'] = 99
if a.hasKeyOrPut('z', 50):
  a['z'] = 99
doAssert a == {'a': 99, 'b': 9, 'z': 50}.newTable

	Source   Edit   

proc hasKeyOrPut[A, B](t: var OrderedTable[A, B]; key: A; val: B): bool

Returns true if key is in the table, otherwise inserts value.

See also:

	hasKey proc
	[] proc for retrieving a value of a key
	getOrDefault proc to return a default value (e.g. zero for int) if the key doesn't exist
	getOrDefault proc to return a custom value if the key doesn't exist

Example:

var a = {'a': 5, 'b': 9}.toOrderedTable
if a.hasKeyOrPut('a', 50):
  a['a'] = 99
if a.hasKeyOrPut('z', 50):
  a['z'] = 99
doAssert a == {'a': 99, 'b': 9, 'z': 50}.toOrderedTable

	Source   Edit   

proc hasKeyOrPut[A, B](t: var Table[A, B]; key: A; val: B): bool

Returns true if key is in the table, otherwise inserts value.

See also:

	hasKey proc
	[] proc for retrieving a value of a key
	getOrDefault proc to return a default value (e.g. zero for int) if the key doesn't exist
	getOrDefault proc to return a custom value if the key doesn't exist

Example:

var a = {'a': 5, 'b': 9}.toTable
if a.hasKeyOrPut('a', 50):
  a['a'] = 99
if a.hasKeyOrPut('z', 50):
  a['z'] = 99
doAssert a == {'a': 99, 'b': 9, 'z': 50}.toTable

	Source   Edit   

proc inc[A](t: CountTableRef[A]; key: A; val = 1)

	Source   Edit   

proc inc[A](t: var CountTable[A]; key: A; val = 1)

	Source   Edit   

proc indexBy[A, B, C](collection: A; index: proc (x: B): C): Table[C, B]

	Index the collection with the proc provided. Source   Edit   

proc initCountTable[A](initialSize = defaultInitialSize): CountTable[A]

	Creates a new count table that is empty.

	Starting from Nim v0.20, tables are initialized by default and it is not necessary to call this function explicitly.

	See also:

    	toCountTable proc
    	newCountTable proc for creating a CountTableRef

	Source   Edit   

proc initOrderedTable[A, B](initialSize = defaultInitialSize): OrderedTable[A, B]

Creates a new ordered hash table that is empty.

Starting from Nim v0.20, tables are initialized by default and it is not necessary to call this function explicitly.

See also:

	toOrderedTable proc
	newOrderedTable proc for creating an OrderedTableRef

Example:

let
  a = initOrderedTable[int, string]()
  b = initOrderedTable[char, seq[int]]()

	Source   Edit   

proc initTable[A, B](initialSize = defaultInitialSize): Table[A, B]

Creates a new hash table that is empty.

Starting from Nim v0.20, tables are initialized by default and it is not necessary to call this function explicitly.

See also:

	toTable proc
	newTable proc for creating a TableRef

Example:

let
  a = initTable[int, string]()
  b = initTable[char, seq[int]]()

	Source   Edit   

proc largest[A](t: CountTable[A]): tuple[key: A, val: int]

	Returns the (key, value) pair with the largest val. Efficiency: O(n)

	See also:

    	smallest proc

	Source   Edit   

proc largest[A](t: CountTableRef[A]): tuple[key: A, val: int]

	Returns the (key, value) pair with the largest val. Efficiency: O(n)

	See also:

    	smallest proc

	Source   Edit   

proc len[A, B](t: OrderedTable[A, B]): int {.inline.}

Returns the number of keys in t.

Example:

let a = {'a': 5, 'b': 9}.toOrderedTable
doAssert len(a) == 2

	Source   Edit   

proc len[A, B](t: OrderedTableRef[A, B]): int {.inline.}

Returns the number of keys in t.

Example:

let a = {'a': 5, 'b': 9}.newOrderedTable
doAssert len(a) == 2

	Source   Edit   

proc len[A, B](t: Table[A, B]): int

Returns the number of keys in t.

Example:

let a = {'a': 5, 'b': 9}.toTable
doAssert len(a) == 2

	Source   Edit   

proc len[A, B](t: TableRef[A, B]): int

Returns the number of keys in t.

Example:

let a = {'a': 5, 'b': 9}.newTable
doAssert len(a) == 2

	Source   Edit   

proc len[A](t: CountTable[A]): int

	Returns the number of keys in t. Source   Edit   

proc len[A](t: CountTableRef[A]): int

	Returns the number of keys in t. Source   Edit   

proc merge[A](s, t: CountTableRef[A])

Merges the second table into the first one.

Example:

let
  a = newCountTable("aaabbc")
  b = newCountTable("bcc")
a.merge(b)
doAssert a == newCountTable("aaabbbccc")

	Source   Edit   

proc merge[A](s: var CountTable[A]; t: CountTable[A])

Merges the second table into the first one (must be declared as var).

Example:

var a = toCountTable("aaabbc")
let b = toCountTable("bcc")
a.merge(b)
doAssert a == toCountTable("aaabbbccc")

	Source   Edit   

proc mgetOrPut[A, B](t: OrderedTableRef[A, B]; key: A; val: B): var B

Retrieves value at t[key] or puts val if not present, either way returning a value which can be modified.

See also:

	[] proc for retrieving a value of a key
	hasKey proc
	hasKeyOrPut proc
	getOrDefault proc to return a default value (e.g. zero for int) if the key doesn't exist
	getOrDefault proc to return a custom value if the key doesn't exist

Example:

var a = {'a': 5, 'b': 9}.newOrderedTable
doAssert a.mgetOrPut('a', 99) == 5
doAssert a.mgetOrPut('z', 99) == 99
doAssert a == {'a': 5, 'b': 9, 'z': 99}.newOrderedTable

	Source   Edit   

proc mgetOrPut[A, B](t: TableRef[A, B]; key: A; val: B): var B

Retrieves value at t[key] or puts val if not present, either way returning a value which can be modified.

Note that while the value returned is of type var B, it is easy to accidentally create an copy of the value at t[key]. Remember that seqs and strings are value types, and therefore cannot be copied into a separate variable for modification. See the example below.

See also:

	[] proc for retrieving a value of a key
	hasKey proc
	hasKeyOrPut proc
	getOrDefault proc to return a default value (e.g. zero for int) if the key doesn't exist
	getOrDefault proc to return a custom value if the key doesn't exist

Example:

var a = {'a': 5, 'b': 9}.newTable
doAssert a.mgetOrPut('a', 99) == 5
doAssert a.mgetOrPut('z', 99) == 99
doAssert a == {'a': 5, 'b': 9, 'z': 99}.newTable

# An example of accidentally creating a copy
var t = newTable[int, seq[int]]()
# In this example, we expect t[10] to be modified,
# but it is not.
var copiedSeq = t.mgetOrPut(10, @[10])
copiedSeq.add(20)
doAssert t[10] == @[10]
# Correct
t.mgetOrPut(25, @[25]).add(35)
doAssert t[25] == @[25, 35]

	Source   Edit   

proc mgetOrPut[A, B](t: var OrderedTable[A, B]; key: A; val: B): var B

Retrieves value at t[key] or puts val if not present, either way returning a value which can be modified.

See also:

	[] proc for retrieving a value of a key
	hasKey proc
	hasKeyOrPut proc
	getOrDefault proc to return a default value (e.g. zero for int) if the key doesn't exist
	getOrDefault proc to return a custom value if the key doesn't exist

Example:

var a = {'a': 5, 'b': 9}.toOrderedTable
doAssert a.mgetOrPut('a', 99) == 5
doAssert a.mgetOrPut('z', 99) == 99
doAssert a == {'a': 5, 'b': 9, 'z': 99}.toOrderedTable

	Source   Edit   

proc mgetOrPut[A, B](t: var Table[A, B]; key: A; val: B): var B

Retrieves value at t[key] or puts val if not present, either way returning a value which can be modified.

Note that while the value returned is of type var B, it is easy to accidentally create a copy of the value at t[key]. Remember that seqs and strings are value types, and therefore cannot be copied into a separate variable for modification. See the example below.

See also:

	[] proc for retrieving a value of a key
	hasKey proc
	hasKeyOrPut proc
	getOrDefault proc to return a default value (e.g. zero for int) if the key doesn't exist
	getOrDefault proc to return a custom value if the key doesn't exist

Example:

var a = {'a': 5, 'b': 9}.toTable
doAssert a.mgetOrPut('a', 99) == 5
doAssert a.mgetOrPut('z', 99) == 99
doAssert a == {'a': 5, 'b': 9, 'z': 99}.toTable

# An example of accidentally creating a copy
var t = initTable[int, seq[int]]()
# In this example, we expect t[10] to be modified,
# but it is not.
var copiedSeq = t.mgetOrPut(10, @[10])
copiedSeq.add(20)
doAssert t[10] == @[10]
# Correct
t.mgetOrPut(25, @[25]).add(35)
doAssert t[25] == @[25, 35]

	Source   Edit   

proc newCountTable[A](initialSize = defaultInitialSize): CountTableRef[A]

	Creates a new ref count table that is empty.

	See also:

    	newCountTable proc for creating a CountTableRef from a collection
    	initCountTable proc for creating a CountTable

	Source   Edit   

proc newCountTable[A](keys: openArray[A]): CountTableRef[A]

	Creates a new ref count table with every member of a container keys having a count of how many times it occurs in that container. Source   Edit   

proc newOrderedTable[A, B](initialSize = defaultInitialSize): OrderedTableRef[A,
	B]

Creates a new ordered ref hash table that is empty.

See also:

	newOrderedTable proc for creating an OrderedTableRef from a collection of (key, value) pairs
	initOrderedTable proc for creating an OrderedTable

Example:

let
  a = newOrderedTable[int, string]()
  b = newOrderedTable[char, seq[int]]()

	Source   Edit   

proc newOrderedTable[A, B](pairs: openArray[(A, B)]): OrderedTableRef[A, B]

Creates a new ordered ref hash table that contains the given pairs.

pairs is a container consisting of (key, value) tuples.

See also:

	newOrderedTable proc
	toOrderedTable proc for an OrderedTable version

Example:

let a = [('a', 5), ('b', 9)]
let b = newOrderedTable(a)
assert b == {'a': 5, 'b': 9}.newOrderedTable

	Source   Edit   

proc newTable[A, B](initialSize = defaultInitialSize): TableRef[A, B]

Creates a new ref hash table that is empty.

See also:

	newTable proc for creating a TableRef from a collection of (key, value) pairs
	initTable proc for creating a Table

Example:

let
  a = newTable[int, string]()
  b = newTable[char, seq[int]]()

	Source   Edit   

proc newTable[A, B](pairs: openArray[(A, B)]): TableRef[A, B]

Creates a new ref hash table that contains the given pairs.

pairs is a container consisting of (key, value) tuples.

See also:

	newTable proc
	toTable proc for a Table version

Example:

let a = [('a', 5), ('b', 9)]
let b = newTable(a)
assert b == {'a': 5, 'b': 9}.newTable

	Source   Edit   

proc newTableFrom[A, B, C](collection: A; index: proc (x: B): C): TableRef[C, B]

	Index the collection with the proc provided. Source   Edit   

proc pop[A, B](t: OrderedTableRef[A, B]; key: A; val: var B): bool

Deletes the key from the table. Returns true, if the key existed, and sets val to the mapping of the key. Otherwise, returns false, and the val is unchanged.

See also:

	del proc
	clear proc to empty the whole table

Example:

var
  a = {'c': 5, 'b': 9, 'a': 13}.newOrderedTable
  i: int
doAssert a.pop('b', i) == true
doAssert a == {'c': 5, 'a': 13}.newOrderedTable
doAssert i == 9
i = 0
doAssert a.pop('z', i) == false
doAssert a == {'c': 5, 'a': 13}.newOrderedTable
doAssert i == 0

	Source   Edit   

proc pop[A, B](t: TableRef[A, B]; key: A; val: var B): bool

Deletes the key from the table. Returns true, if the key existed, and sets val to the mapping of the key. Otherwise, returns false, and the val is unchanged.
Warning: If duplicate keys were added (via the now deprecated add proc), this may need to be called multiple times.

See also:

	del proc
	clear proc to empty the whole table

Example:

var
  a = {'a': 5, 'b': 9, 'c': 13}.newTable
  i: int
doAssert a.pop('b', i) == true
doAssert a == {'a': 5, 'c': 13}.newTable
doAssert i == 9
i = 0
doAssert a.pop('z', i) == false
doAssert a == {'a': 5, 'c': 13}.newTable
doAssert i == 0

	Source   Edit   

proc pop[A, B](t: var OrderedTable[A, B]; key: A; val: var B): bool

Deletes the key from the table. Returns true, if the key existed, and sets val to the mapping of the key. Otherwise, returns false, and the val is unchanged.

O(n) complexity.

See also:

	del proc
	clear proc to empty the whole table

Example:

var
  a = {'c': 5, 'b': 9, 'a': 13}.toOrderedTable
  i: int
doAssert a.pop('b', i) == true
doAssert a == {'c': 5, 'a': 13}.toOrderedTable
doAssert i == 9
i = 0
doAssert a.pop('z', i) == false
doAssert a == {'c': 5, 'a': 13}.toOrderedTable
doAssert i == 0

	Source   Edit   

proc pop[A, B](t: var Table[A, B]; key: A; val: var B): bool

Deletes the key from the table. Returns true, if the key existed, and sets val to the mapping of the key. Otherwise, returns false, and the val is unchanged.
Warning: If duplicate keys were added (via the now deprecated add proc), this may need to be called multiple times.

See also:

	del proc
	clear proc to empty the whole table

Example:

var
  a = {'a': 5, 'b': 9, 'c': 13}.toTable
  i: int
doAssert a.pop('b', i) == true
doAssert a == {'a': 5, 'c': 13}.toTable
doAssert i == 9
i = 0
doAssert a.pop('z', i) == false
doAssert a == {'a': 5, 'c': 13}.toTable
doAssert i == 0

	Source   Edit   

proc pop[A](t: CountTableRef[A]; key: A; val: var int): bool

	Deletes the key from the table. Returns true, if the key existed, and sets val to the mapping of the key. Otherwise, returns false, and the val is unchanged.

	See also:

    	del proc
    	clear proc to empty the whole table

	Source   Edit   

proc pop[A](t: var CountTable[A]; key: A; val: var int): bool

Deletes the key from the table. Returns true, if the key existed, and sets val to the mapping of the key. Otherwise, returns false, and the val is unchanged.

See also:

	del proc
	clear proc to empty the whole table

Example:

var a = toCountTable("aabbbccccc")
var i = 0
assert a.pop('b', i)
assert i == 3
i = 99
assert not a.pop('b', i)
assert i == 99

	Source   Edit   

proc smallest[A](t: CountTable[A]): tuple[key: A, val: int]

	Returns the (key, value) pair with the smallest val. Efficiency: O(n)

	See also:

    	largest proc

	Source   Edit   

proc smallest[A](t: CountTableRef[A]): tuple[key: A, val: int]

	Returns the (key, value) pair with the smallest val. Efficiency: O(n)

	See also:

    	largest proc

	Source   Edit   

proc sort[A, B](t: OrderedTableRef[A, B]; cmp: proc (x, y: (A, B)): int;
            	order = SortOrder.Ascending) {.effectsOf: cmp.}

Sorts t according to the function cmp.

This modifies the internal list that kept the insertion order, so insertion order is lost after this call but key lookup and insertions remain possible after sort (in contrast to the sort proc for count tables).

Example:

import std/[algorithm]
var a = newOrderedTable[char, int]()
for i, c in "cab":
  a[c] = 10*i
doAssert a == {'c': 0, 'a': 10, 'b': 20}.newOrderedTable
a.sort(system.cmp)
doAssert a == {'a': 10, 'b': 20, 'c': 0}.newOrderedTable
a.sort(system.cmp, order = SortOrder.Descending)
doAssert a == {'c': 0, 'b': 20, 'a': 10}.newOrderedTable

	Source   Edit   

proc sort[A, B](t: var OrderedTable[A, B]; cmp: proc (x, y: (A, B)): int;
            	order = SortOrder.Ascending) {.effectsOf: cmp.}

Sorts t according to the function cmp.

This modifies the internal list that kept the insertion order, so insertion order is lost after this call but key lookup and insertions remain possible after sort (in contrast to the sort proc for count tables).

Example:

import std/[algorithm]
var a = initOrderedTable[char, int]()
for i, c in "cab":
  a[c] = 10*i
doAssert a == {'c': 0, 'a': 10, 'b': 20}.toOrderedTable
a.sort(system.cmp)
doAssert a == {'a': 10, 'b': 20, 'c': 0}.toOrderedTable
a.sort(system.cmp, order = SortOrder.Descending)
doAssert a == {'c': 0, 'b': 20, 'a': 10}.toOrderedTable

	Source   Edit   

proc sort[A](t: CountTableRef[A]; order = SortOrder.Descending)

	Sorts the count table so that, by default, the entry with the highest counter comes first.

	This is destructive! You must not modify `t` afterwards!

	You can use the iterators pairs, keys, and values to iterate over t in the sorted order.
	Source   Edit   

proc sort[A](t: var CountTable[A]; order = SortOrder.Descending)

Sorts the count table so that, by default, the entry with the highest counter comes first.
Warning: This is destructive! Once sorted, you must not modify t afterwards!

You can use the iterators pairs, keys, and values to iterate over t in the sorted order.

Example:

import std/[algorithm, sequtils]
var a = toCountTable("abracadabra")
doAssert a == "aaaaabbrrcd".toCountTable
a.sort()
doAssert toSeq(a.values) == @[5, 2, 2, 1, 1]
a.sort(SortOrder.Ascending)
doAssert toSeq(a.values) == @[1, 1, 2, 2, 5]

	Source   Edit   

proc take[A, B](t: TableRef[A, B]; key: A; val: var B): bool {.inline.}

	Alias for:

    	pop proc

	Source   Edit   

proc take[A, B](t: var Table[A, B]; key: A; val: var B): bool {.inline.}

	Alias for:

    	pop proc

	Source   Edit   

proc toCountTable[A](keys: openArray[A]): CountTable[A]

	Creates a new count table with every member of a container keys having a count of how many times it occurs in that container. Source   Edit   

proc toOrderedTable[A, B](pairs: openArray[(A, B)]): OrderedTable[A, B]

Creates a new ordered hash table that contains the given pairs.

pairs is a container consisting of (key, value) tuples.

See also:

	initOrderedTable proc
	newOrderedTable proc for an OrderedTableRef version

Example:

let a = [('a', 5), ('b', 9)]
let b = toOrderedTable(a)
assert b == {'a': 5, 'b': 9}.toOrderedTable

	Source   Edit   

proc toTable[A, B](pairs: openArray[(A, B)]): Table[A, B]

Creates a new hash table that contains the given pairs.

pairs is a container consisting of (key, value) tuples.

See also:

	initTable proc
	newTable proc for a TableRef version

Example:

let a = [('a', 5), ('b', 9)]
let b = toTable(a)
assert b == {'a': 5, 'b': 9}.toTable

	Source   Edit   

Iterators

iterator allValues[A, B](t: Table[A, B]; key: A): B {.....}

Deprecated: Deprecated since v1.4; tables with duplicated keys are deprecated

Iterates over any value in the table t that belongs to the given key.

Used if you have a table with duplicate keys (as a result of using add proc).

Example:

import std/[sequtils, algorithm]

var a = {'a': 3, 'b': 5}.toTable
for i in 1..3: a.add('z', 10*i)
doAssert toSeq(a.pairs).sorted == @[('a', 3), ('b', 5), ('z', 10), ('z', 20), ('z', 30)]
doAssert sorted(toSeq(a.allValues('z'))) == @[10, 20, 30]

	Source   Edit   

iterator keys[A, B](t: OrderedTable[A, B]): lent A

Iterates over any key in the table t in insertion order.

See also:

	pairs iterator
	values iterator

Example:

var a = {
  'o': @[1, 5, 7, 9],
  'e': @[2, 4, 6, 8]
  }.toOrderedTable
for k in a.keys:
  a[k].add(99)
doAssert a == {'o': @[1, 5, 7, 9, 99],
           	'e': @[2, 4, 6, 8, 99]}.toOrderedTable

	Source   Edit   

iterator keys[A, B](t: OrderedTableRef[A, B]): lent A

Iterates over any key in the table t in insertion order.

See also:

	pairs iterator
	values iterator

Example:

let a = {
  'o': @[1, 5, 7, 9],
  'e': @[2, 4, 6, 8]
  }.newOrderedTable
for k in a.keys:
  a[k].add(99)
doAssert a == {'o': @[1, 5, 7, 9, 99], 'e': @[2, 4, 6, 8,
	99]}.newOrderedTable

	Source   Edit   

iterator keys[A, B](t: Table[A, B]): lent A

Iterates over any key in the table t.

See also:

	pairs iterator
	values iterator

Example:

var a = {
  'o': @[1, 5, 7, 9],
  'e': @[2, 4, 6, 8]
  }.toTable
for k in a.keys:
  a[k].add(99)
doAssert a == {'e': @[2, 4, 6, 8, 99], 'o': @[1, 5, 7, 9, 99]}.toTable

	Source   Edit   

iterator keys[A, B](t: TableRef[A, B]): lent A

Iterates over any key in the table t.

See also:

	pairs iterator
	values iterator

Example:

let a = {
  'o': @[1, 5, 7, 9],
  'e': @[2, 4, 6, 8]
  }.newTable
for k in a.keys:
  a[k].add(99)
doAssert a == {'e': @[2, 4, 6, 8, 99], 'o': @[1, 5, 7, 9, 99]}.newTable

	Source   Edit   

iterator keys[A](t: CountTable[A]): lent A

Iterates over any key in the table t.

See also:

	pairs iterator
	values iterator

Example:

var a = toCountTable("abracadabra")
for k in keys(a):
  a[k] = 2
doAssert a == toCountTable("aabbccddrr")

	Source   Edit   

iterator keys[A](t: CountTableRef[A]): A

Iterates over any key in the table t.

See also:

	pairs iterator
	values iterator

Example:

let a = newCountTable("abracadabra")
for k in keys(a):
  a[k] = 2
doAssert a == newCountTable("aabbccddrr")

	Source   Edit   

iterator mpairs[A, B](t: OrderedTableRef[A, B]): (A, var B)

Iterates over any (key, value) pair in the table t in insertion order. The values can be modified.

See also:

	pairs iterator
	mvalues iterator

Example:

let a = {
  'o': @[1, 5, 7, 9],
  'e': @[2, 4, 6, 8]
  }.newOrderedTable
for k, v in a.mpairs:
  v.add(v[0] + 10)
doAssert a == {'o': @[1, 5, 7, 9, 11],
           	'e': @[2, 4, 6, 8, 12]}.newOrderedTable

	Source   Edit   

iterator mpairs[A, B](t: TableRef[A, B]): (A, var B)

Iterates over any (key, value) pair in the table t. The values can be modified.

See also:

	pairs iterator
	mvalues iterator

Example:

let a = {
  'o': @[1, 5, 7, 9],
  'e': @[2, 4, 6, 8]
  }.newTable
for k, v in a.mpairs:
  v.add(v[0] + 10)
doAssert a == {'e': @[2, 4, 6, 8, 12], 'o': @[1, 5, 7, 9, 11]}.newTable

	Source   Edit   

iterator mpairs[A, B](t: var OrderedTable[A, B]): (A, var B)

Iterates over any (key, value) pair in the table t (must be declared as var) in insertion order. The values can be modified.

See also:

	pairs iterator
	mvalues iterator

Example:

var a = {
  'o': @[1, 5, 7, 9],
  'e': @[2, 4, 6, 8]
  }.toOrderedTable
for k, v in a.mpairs:
  v.add(v[0] + 10)
doAssert a == {'o': @[1, 5, 7, 9, 11],
           	'e': @[2, 4, 6, 8, 12]}.toOrderedTable

	Source   Edit   

iterator mpairs[A, B](t: var Table[A, B]): (A, var B)

Iterates over any (key, value) pair in the table t (must be declared as var). The values can be modified.

See also:

	pairs iterator
	mvalues iterator

Example:

var a = {
  'o': @[1, 5, 7, 9],
  'e': @[2, 4, 6, 8]
  }.toTable
for k, v in a.mpairs:
  v.add(v[0] + 10)
doAssert a == {'e': @[2, 4, 6, 8, 12], 'o': @[1, 5, 7, 9, 11]}.toTable

	Source   Edit   

iterator mpairs[A](t: CountTableRef[A]): (A, var int)

Iterates over any (key, value) pair in the table t. The values can be modified.

See also:

	pairs iterator
	mvalues iterator

Example:

let a = newCountTable("abracadabra")
for k, v in mpairs(a):
  v = 2
doAssert a == newCountTable("aabbccddrr")

	Source   Edit   

iterator mpairs[A](t: var CountTable[A]): (A, var int)

Iterates over any (key, value) pair in the table t (must be declared as var). The values can be modified.

See also:

	pairs iterator
	mvalues iterator

Example:

var a = toCountTable("abracadabra")
for k, v in mpairs(a):
  v = 2
doAssert a == toCountTable("aabbccddrr")

	Source   Edit   

iterator mvalues[A, B](t: OrderedTableRef[A, B]): var B

Iterates over any value in the table t in insertion order. The values can be modified.

See also:

	mpairs iterator
	values iterator

Example:

let a = {
  'o': @[1, 5, 7, 9],
  'e': @[2, 4, 6, 8]
  }.newOrderedTable
for v in a.mvalues:
  v.add(99)
doAssert a == {'o': @[1, 5, 7, 9, 99],
           	'e': @[2, 4, 6, 8, 99]}.newOrderedTable

	Source   Edit   

iterator mvalues[A, B](t: TableRef[A, B]): var B

Iterates over any value in the table t. The values can be modified.

See also:

	mpairs iterator
	values iterator

Example:

let a = {
  'o': @[1, 5, 7, 9],
  'e': @[2, 4, 6, 8]
  }.newTable
for v in a.mvalues:
  v.add(99)
doAssert a == {'e': @[2, 4, 6, 8, 99], 'o': @[1, 5, 7, 9, 99]}.newTable

	Source   Edit   

iterator mvalues[A, B](t: var OrderedTable[A, B]): var B

Iterates over any value in the table t (must be declared as var) in insertion order. The values can be modified.

See also:

	mpairs iterator
	values iterator

Example:

var a = {
  'o': @[1, 5, 7, 9],
  'e': @[2, 4, 6, 8]
  }.toOrderedTable
for v in a.mvalues:
  v.add(99)
doAssert a == {'o': @[1, 5, 7, 9, 99],
           	'e': @[2, 4, 6, 8, 99]}.toOrderedTable

	Source   Edit   

iterator mvalues[A, B](t: var Table[A, B]): var B

Iterates over any value in the table t (must be declared as var). The values can be modified.

See also:

	mpairs iterator
	values iterator

Example:

var a = {
  'o': @[1, 5, 7, 9],
  'e': @[2, 4, 6, 8]
  }.toTable
for v in a.mvalues:
  v.add(99)
doAssert a == {'e': @[2, 4, 6, 8, 99], 'o': @[1, 5, 7, 9, 99]}.toTable

	Source   Edit   

iterator mvalues[A](t: CountTableRef[A]): var int

Iterates over any value in the table t. The values can be modified.

See also:

	mpairs iterator
	values iterator

Example:

var a = newCountTable("abracadabra")
for v in mvalues(a):
  v = 2
doAssert a == newCountTable("aabbccddrr")

	Source   Edit   

iterator mvalues[A](t: var CountTable[A]): var int

Iterates over any value in the table t (must be declared as var). The values can be modified.

See also:

	mpairs iterator
	values iterator

Example:

var a = toCountTable("abracadabra")
for v in mvalues(a):
  v = 2
doAssert a == toCountTable("aabbccddrr")

	Source   Edit   

iterator pairs[A, B](t: OrderedTable[A, B]): (A, B)

Iterates over any (key, value) pair in the table t in insertion order.

See also:

	mpairs iterator
	keys iterator
	values iterator

Examples:

let a = {
  'o': [1, 5, 7, 9],
  'e': [2, 4, 6, 8]
  }.toOrderedTable

for k, v in a.pairs:
  echo "key: ", k
  echo "value: ", v

# key: o
# value: [1, 5, 7, 9]
# key: e
# value: [2, 4, 6, 8]

	Source   Edit   

iterator pairs[A, B](t: OrderedTableRef[A, B]): (A, B)

Iterates over any (key, value) pair in the table t in insertion order.

See also:

	mpairs iterator
	keys iterator
	values iterator

Examples:

let a = {
  'o': [1, 5, 7, 9],
  'e': [2, 4, 6, 8]
  }.newOrderedTable

for k, v in a.pairs:
  echo "key: ", k
  echo "value: ", v

# key: o
# value: [1, 5, 7, 9]
# key: e
# value: [2, 4, 6, 8]

	Source   Edit   

iterator pairs[A, B](t: Table[A, B]): (A, B)

Iterates over any (key, value) pair in the table t.

See also:

	mpairs iterator
	keys iterator
	values iterator

Examples:

let a = {
  'o': [1, 5, 7, 9],
  'e': [2, 4, 6, 8]
  }.toTable

for k, v in a.pairs:
  echo "key: ", k
  echo "value: ", v

# key: e
# value: [2, 4, 6, 8]
# key: o
# value: [1, 5, 7, 9]

	Source   Edit   

iterator pairs[A, B](t: TableRef[A, B]): (A, B)

Iterates over any (key, value) pair in the table t.

See also:

	mpairs iterator
	keys iterator
	values iterator

Examples:

let a = {
  'o': [1, 5, 7, 9],
  'e': [2, 4, 6, 8]
  }.newTable

for k, v in a.pairs:
  echo "key: ", k
  echo "value: ", v

# key: e
# value: [2, 4, 6, 8]
# key: o
# value: [1, 5, 7, 9]

	Source   Edit   

iterator pairs[A](t: CountTable[A]): (A, int)

Iterates over any (key, value) pair in the table t.

See also:

	mpairs iterator
	keys iterator
	values iterator

Examples:

let a = toCountTable("abracadabra")

for k, v in pairs(a):
  echo "key: ", k
  echo "value: ", v

# key: a
# value: 5
# key: b
# value: 2
# key: c
# value: 1
# key: d
# value: 1
# key: r
# value: 2

	Source   Edit   

iterator pairs[A](t: CountTableRef[A]): (A, int)

Iterates over any (key, value) pair in the table t.

See also:

	mpairs iterator
	keys iterator
	values iterator

Examples:

let a = newCountTable("abracadabra")

for k, v in pairs(a):
  echo "key: ", k
  echo "value: ", v

# key: a
# value: 5
# key: b
# value: 2
# key: c
# value: 1
# key: d
# value: 1
# key: r
# value: 2

	Source   Edit   

iterator values[A, B](t: OrderedTable[A, B]): lent B

Iterates over any value in the table t in insertion order.

See also:

	pairs iterator
	keys iterator
	mvalues iterator

Example:

let a = {
  'o': @[1, 5, 7, 9],
  'e': @[2, 4, 6, 8]
  }.toOrderedTable
for v in a.values:
  doAssert v.len == 4

	Source   Edit   

iterator values[A, B](t: OrderedTableRef[A, B]): lent B

Iterates over any value in the table t in insertion order.

See also:

	pairs iterator
	keys iterator
	mvalues iterator

Example:

let a = {
  'o': @[1, 5, 7, 9],
  'e': @[2, 4, 6, 8]
  }.newOrderedTable
for v in a.values:
  doAssert v.len == 4

	Source   Edit   

iterator values[A, B](t: Table[A, B]): lent B

Iterates over any value in the table t.

See also:

	pairs iterator
	keys iterator
	mvalues iterator

Example:

let a = {
  'o': @[1, 5, 7, 9],
  'e': @[2, 4, 6, 8]
  }.toTable
for v in a.values:
  doAssert v.len == 4

	Source   Edit   

iterator values[A, B](t: TableRef[A, B]): lent B

Iterates over any value in the table t.

See also:

	pairs iterator
	keys iterator
	mvalues iterator

Example:

let a = {
  'o': @[1, 5, 7, 9],
  'e': @[2, 4, 6, 8]
  }.newTable
for v in a.values:
  doAssert v.len == 4

	Source   Edit   

iterator values[A](t: CountTable[A]): int

Iterates over any value in the table t.

See also:

	pairs iterator
	keys iterator
	mvalues iterator

Example:

let a = toCountTable("abracadabra")
for v in values(a):
  assert v < 10

	Source   Edit   

iterator values[A](t: CountTableRef[A]): int

Iterates over any value in the table t.

See also:

	pairs iterator
	keys iterator
	mvalues iterator

Example:

let a = newCountTable("abracadabra")
for v in values(a):
  assert v < 10

	Source   Edit   

Templates

template withValue[A, B](t: var Table[A, B]; key: A;
                     	value, body1, body2: untyped)

Retrieves the value at t[key].

value can be modified in the scope of the withValue call.

Example:

type
  User = object
	name: string
	uid: int

var t = initTable[int, User]()
let u = User(name: "Hello", uid: 99)
t[1] = u

t.withValue(1, value):
  # block is executed only if `key` in `t`
  value.name = "Nim"
  value.uid = 1314

t.withValue(521, value):
  doAssert false
do:
  # block is executed when `key` not in `t`
  t[1314] = User(name: "exist", uid: 521)

assert t[1].name == "Nim"
assert t[1].uid == 1314
assert t[1314].name == "exist"
assert t[1314].uid == 521

	Source   Edit   

template withValue[A, B](t: var Table[A, B]; key: A; value, body: untyped)

Retrieves the value at t[key].

value can be modified in the scope of the withValue call.

Example:

type
  User = object
	name: string
	uid: int

var t = initTable[int, User]()
let u = User(name: "Hello", uid: 99)
t[1] = u

t.withValue(1, value):
  # block is executed only if `key` in `t`
  value.name = "Nim"
  value.uid = 1314

t.withValue(2, value):
  value.name = "No"
  value.uid = 521

assert t[1].name == "Nim"
assert t[1].uid == 1314

String handling

std/cstrutils



std/cstrutils
Source   Edit  

This module supports helper routines for working with cstring without having to convert cstring to string, in order to save allocations.
See also

	strutils module for working with string

Imports

strimpl

Procs

func cmpIgnoreCase(a, b: cstring): int {.....}

Compares two strings in a case insensitive manner. Returns:

	0 if a == b
	< 0 if a < b
	> 0 if a > b

Example:

assert cmpIgnoreCase(cstring"hello", cstring"HeLLo") == 0
assert cmpIgnoreCase(cstring"echo", cstring"hello") < 0
assert cmpIgnoreCase(cstring"yellow", cstring"hello") > 0

	Source   Edit   

func cmpIgnoreStyle(a, b: cstring): int {.....}

Semantically the same as cmp(normalize($a), normalize($b)). It is just optimized to not allocate temporary strings. This should NOT be used to compare Nim identifier names, use macros.eqIdent for that. Returns:

	0 if a == b
	< 0 if a < b
	> 0 if a > b

Example:

assert cmpIgnoreStyle(cstring"hello", cstring"H_e_L_Lo") == 0

	Source   Edit   

func endsWith(s, suffix: cstring): bool {.....}

Returns true if s ends with suffix.

The JS backend uses the native String.prototype.endsWith function.

Example:

assert endsWith(cstring"Hello, Nimion", cstring"Nimion")
assert not endsWith(cstring"Hello, Nimion", cstring"Hello")
assert endsWith(cstring"Hello", cstring"")

	Source   Edit   

func startsWith(s, prefix: cstring): bool {.....}

Returns true if s starts with prefix.

The JS backend uses the native String.prototype.startsWith function.

Example:

assert startsWith(cstring"Hello, Nimion", cstring"Hello")
assert not startsWith(cstring"Hello, Nimion", cstring"Nimion")
assert startsWith(cstring"Hello", cstring"")

std/editdistance


std/editdistance
Source   Edit  

This module implements an algorithm to compute the edit distance between two Unicode strings.
Imports

unicode

Procs

proc editDistance(a, b: string): int {.noSideEffect, ....}

Returns the unicode-rune edit distance between a and b.

This uses the Levenshtein distance algorithm with only a linear memory overhead.

Example:

static: doAssert editdistance("Kitten", "Bitten") == 1

	Source   Edit   

proc editDistanceAscii(a, b: string): int {.noSideEffect, ....}

Returns the edit distance between a and b.

This uses the Levenshtein distance algorithm with only a linear memory overhead.

Example:

static: doAssert editDistanceAscii("Kitten", "Bitten") == 1


std/encodings


std/encodings
Source   Edit  

Routines for converting between different character encodings. On UNIX, this uses the iconv library, on Windows the Windows API.

The following example shows how to change character encodings.

Example:

import std/encodings
when defined(windows):
  let
	orig = "öäüß"
	# convert `orig` from "UTF-8" to "CP1252"
	cp1252 = convert(orig, "CP1252", "UTF-8")
	# convert `cp1252` from "CP1252" to "ibm850"
	ibm850 = convert(cp1252, "ibm850", "CP1252")
	current = getCurrentEncoding()
  assert orig == "\195\182\195\164\195\188\195\159"
  assert ibm850 == "\148\132\129\225"
  assert convert(ibm850, current, "ibm850") == orig

The example below uses a reuseable EncodingConverter object which is created by open with destEncoding and srcEncoding specified. You can use convert on this object multiple times.

Example:

import std/encodings
when defined(windows):
  var fromGB2312 = open("utf-8", "gb2312")
  let first = "\203\173\197\194\163\191\210\187" &
  	"\203\242\209\204\211\234\200\206\198\189\201\250"
  assert fromGB2312.convert(first) == "谁怕？一蓑烟雨任平生"

  let second = "\211\208\176\215\205\183\200\231" &
  	"\208\194\163\172\199\227\184\199\200\231\185\202"
  assert fromGB2312.convert(second) == "有白头如新，倾盖如故"

Imports

os, parseutils, strutils

Types

EncodingConverter = object

	Source   Edit   

EncodingError = object of ValueError

	Exception that is raised for encoding errors. Source   Edit   

Procs

proc close(c: EncodingConverter) {.....}

	Frees the resources the converter c holds. Source   Edit   

proc codePageToName(c: CodePage): string {.....}

	Source   Edit   

proc convert(c: EncodingConverter; s: string): string {.
	....}

	Source   Edit   

proc convert(s: string; destEncoding = "UTF-8"; srcEncoding = "CP1252"): string {.
	....}

	Converts s to destEncoding. It assumed that s is in srcEncoding. This opens a converter, uses it and closes it again and is thus more convenient but also likely less efficient than re-using a converter.
	Warning: UTF-16BE and UTF-32 conversions are not supported on Windows.
	Source   Edit   

proc getCurrentEncoding(uiApp = false): string {.....}

	Retrieves the current encoding. On Unix, "UTF-8" is always returned. The uiApp parameter is Windows specific. If true, the UI's code-page is returned, if false, the Console's code-page is returned. Source   Edit   

proc nameToCodePage(name: string): CodePage {.....}

	Source   Edit   

proc open(destEncoding = "UTF-8"; srcEncoding = "CP1252"): EncodingConverter {.
	....}

	Opens a converter that can convert from srcEncoding to destEncoding. Raises EncodingError if it cannot fulfill the request. Source   Edit   


std/formatfloat


std/formatfloat
Source   Edit  

This module implements formatting floats as strings.
Imports

dragonbox, schubfach

Procs

proc addFloat(result: var string; x: float | float32) {.inline.}

Converts float to its string representation and appends it to result.

Example:

var
  s = "foo:"
  b = 45.67
s.addFloat(45.67)
assert s == "foo:45.67"

	Source   Edit   

proc addFloatRoundtrip(result: var string; x: float | float32)

	Source   Edit   

proc addFloatSprintf(result: var string; x: float) {.....}

	Source   Edit   

proc writeFloatToBuffer(buf: var array[65, char]; value: BiggestFloat | float32): int {.
	inline.}

	Source   Edit   

proc writeFloatToBufferRoundtrip(buf: var array[65, char]; value: BiggestFloat): int {.
	....}

	This is the implementation to format floats.

	returns the amount of bytes written to buf not counting the terminating '0' character.
	Source   Edit   

proc writeFloatToBufferRoundtrip(buf: var array[65, char]; value: float32): int {.
	....}

	Source   Edit   

proc writeFloatToBufferSprintf(buf: var array[65, char]; value: BiggestFloat): int {.
	....}

	This is the implementation to format floats.

	returns the amount of bytes written to buf not counting the terminating '0' character.
	Source   Edit   


std/objectdollar


std/objectdollar
Source   Edit  

This module implements a generic $ operator to convert objects to strings.
Imports

miscdollars

Procs

proc `$`[T: object](x: T): string

Generic $ operator for objects with similar output to $ for named tuples.

Example:

type Foo = object
  a, b: int
let x = Foo(a: 23, b: 45)
assert $x == "(a: 23, b: 45)"

src/punycode



Note: In order to use this module, run nimble install punycode.

Implements a representation of Unicode with the limited ASCII character subset.

Example:

import src/punycode
static:
  block:
	doAssert encode("") == ""
	doAssert encode("a") == "a-"
	doAssert encode("A") == "A-"
	doAssert encode("3") == "3-"
	doAssert encode("-") == "--"
	doAssert encode("--") == "---"
	doAssert encode("abc") == "abc-"
	doAssert encode("London") == "London-"
	doAssert encode("Lloyd-Atkinson") == "Lloyd-Atkinson-"
	doAssert encode("This has spaces") == "This has spaces-"
	doAssert encode("ü") == "tda"
	doAssert encode("München") == "Mnchen-3ya"
	doAssert encode("Mnchen-3ya") == "Mnchen-3ya-"
	doAssert encode("München-Ost") == "Mnchen-Ost-9db"
	doAssert encode("Bahnhof München-Ost") == "Bahnhof Mnchen-Ost-u6b"
  block:
	doAssert decode("") == ""
	doAssert decode("a-") ==  "a"
	doAssert decode("A-") == "A"
	doAssert decode("3-") == "3"
	doAssert decode("--") == "-"
	doAssert decode("---") == "--"
	doAssert decode("abc-") == "abc"
	doAssert decode("London-") == "London"
	doAssert decode("Lloyd-Atkinson-") == "Lloyd-Atkinson"
	doAssert decode("This has spaces-") == "This has spaces"
	doAssert decode("tda") == "ü"
	doAssert decode("Mnchen-3ya") == "München"
	doAssert decode("Mnchen-3ya-") == "Mnchen-3ya"
	doAssert decode("Mnchen-Ost-9db") == "München-Ost"
	doAssert decode("Bahnhof Mnchen-Ost-u6b") == "Bahnhof München-Ost"

Types

PunyError = object of ValueError

Procs

func decode(encoded: string): string {.....}

	Decode a Punycode-encoded string

func encode(prefix, s: string): string {.....}

	Encode a string that may contain Unicode. Prepend prefix to the result

func encode(s: string): string {.....}

	Encode a string that may contain Unicode. Prefix is empty.

std/strbasics


std/strbasics
Source   Edit  

This module provides some high performance string operations.

Experimental API, subject to change.

Procs

proc add(x: var string; y: openArray[char]) {.....}

	Concatenates x and y in place. y must not overlap with x to allow future memcpy optimizations. Source   Edit   

func setSlice(s: var string; slice: Slice[int]) {.....}

Inplace version of substr.

Example:

import std/sugar

var a = "Hello, Nim!"
doAssert a.dup(setSlice(7 .. 9)) == "Nim"
doAssert a.dup(setSlice(0 .. 0)) == "H"
doAssert a.dup(setSlice(0 .. 1)) == "He"
doAssert a.dup(setSlice(0 .. 10)) == a
doAssert a.dup(setSlice(1 .. 0)).len == 0
doAssert a.dup(setSlice(20 .. -1)).len == 0


doAssertRaises(AssertionDefect):
  discard a.dup(setSlice(-1 .. 1))

doAssertRaises(AssertionDefect):
  discard a.dup(setSlice(1 .. 11))

	Source   Edit   

func strip(a: var string; leading = true; trailing = true;
       	chars: set[char] = whitespaces) {.inline, ....}

Inplace version of strip. Strips leading or trailing chars (default: whitespace characters).

If leading is true (default), leading chars are stripped. If trailing is true (default), trailing chars are stripped. If both are false, the string is unchanged.

Example:

var a = "  vhellov   "
strip(a)
assert a == "vhellov"

a = "  vhellov   "
a.strip(leading = false)
assert a == "  vhellov"

a = "  vhellov   "
a.strip(trailing = false)
assert a == "vhellov   "

var c = "blaXbla"
c.strip(chars = {'b', 'a'})
assert c == "laXbl"
c = "blaXbla"
c.strip(chars = {'b', 'a', 'l'})
assert c == "X"

std/strformat


std/strformat
Source   Edit  

String interpolation / format inspired by Python's f-strings.
fmt vs. &

You can use either fmt or the unary & operator for formatting. The difference between them is subtle but important.

The fmt"{expr}" syntax is more aesthetically pleasing, but it hides a small gotcha. The string is a generalized raw string literal. This has some surprising effects:

Example:

import std/strformat
let msg = "hello"
assert fmt"{msg}\n" == "hello\\n"

Because the literal is a raw string literal, the \n is not interpreted as an escape sequence.

There are multiple ways to get around this, including the use of the & operator:

Example:

import std/strformat
let msg = "hello"

assert &"{msg}\n" == "hello\n"

assert fmt"{msg}{'\n'}" == "hello\n"
assert fmt("{msg}\n") == "hello\n"
assert "{msg}\n".fmt == "hello\n"

The choice of style is up to you.
Formatting strings

Example:

import std/strformat
assert &"""{"abc":>4}""" == " abc"
assert &"""{"abc":<4}""" == "abc "

Formatting floats

Example:

import std/strformat
assert fmt"{-12345:08}" == "-0012345"
assert fmt"{-1:3}" == " -1"
assert fmt"{-1:03}" == "-01"
assert fmt"{16:#X}" == "0x10"

assert fmt"{123.456}" == "123.456"
assert fmt"{123.456:>9.3f}" == "  123.456"
assert fmt"{123.456:9.3f}" == "  123.456"
assert fmt"{123.456:9.4f}" == " 123.4560"
assert fmt"{123.456:>9.0f}" == " 	123."
assert fmt"{123.456:<9.4f}" == "123.4560 "

assert fmt"{123.456:e}" == "1.234560e+02"
assert fmt"{123.456:>13e}" == " 1.234560e+02"
assert fmt"{123.456:13e}" == " 1.234560e+02"

Expressions

Example:

import std/strformat
let x = 3.14
assert fmt"{(if x!=0: 1.0/x else: 0):.5}" == "0.31847"
assert fmt"""{(block:
	var res: string
	for i in 1..15:
  	res.add (if i mod 15 == 0: "FizzBuzz"
    	elif i mod 5 == 0: "Buzz"
    	elif i mod 3 == 0: "Fizz"
    	else: $i) & " "
	res)}""" == "1 2 Fizz 4 Buzz Fizz 7 8 Fizz Buzz 11 Fizz 13 14 FizzBuzz "

Debugging strings

fmt"{expr=}" expands to fmt"expr={expr}" namely the text of the expression, an equal sign and the results of evaluated expression.

Example:

import std/strformat
assert fmt"{123.456=}" == "123.456=123.456"
assert fmt"{123.456=:>9.3f}" == "123.456=  123.456"

let x = "hello"
assert fmt"{x=}" == "x=hello"
assert fmt"{x =}" == "x =hello"

let y = 3.1415926
assert fmt"{y=:.2f}" == fmt"y={y:.2f}"
assert fmt"{y=}" == fmt"y={y}"
assert fmt"{y = : <8}" == fmt"y = 3.14159 "

proc hello(a: string, b: float): int = 12
assert fmt"{hello(x, y) = }" == "hello(x, y) = 12"
assert fmt"{x.hello(y) = }" == "x.hello(y) = 12"
assert fmt"{hello x, y = }" == "hello x, y = 12"

Note that it is space sensitive:

Example:

import std/strformat
let x = "12"
assert fmt"{x=}" == "x=12"
assert fmt"{x =:}" == "x =12"
assert fmt"{x =}" == "x =12"
assert fmt"{x= :}" == "x= 12"
assert fmt"{x= }" == "x= 12"
assert fmt"{x = :}" == "x = 12"
assert fmt"{x = }" == "x = 12"
assert fmt"{x   =  :}" == "x   =  12"
assert fmt"{x   =  }" == "x   =  12"

Implementation details

An expression like &"{key} is {value:arg} {{z}}" is transformed into:

var temp = newStringOfCap(educatedCapGuess)
temp.formatValue(key, "")
temp.add(" is ")
temp.formatValue(value, arg)
temp.add(" {z}")
temp

Parts of the string that are enclosed in the curly braces are interpreted as Nim code. To escape a { or }, double it.

Within a curly expression, however, {, }, must be escaped with a backslash.

To enable evaluating Nim expressions within curlies, colons inside parentheses do not need to be escaped.

Example:

import std/strformat
let x = "hello"
assert fmt"""{ "\{(" & x & ")\}" }""" == "{(hello)}"
assert fmt"""{{({ x })}}""" == "{(hello)}"
assert fmt"""{ $(\{x:1,"world":2\}) }""" == """[("hello", 1), ("world", 2)]"""

& delegates most of the work to an open overloaded set of formatValue procs. The required signature for a type T that supports formatting is usually proc formatValue(result: var string; x: T; specifier: string).

The subexpression after the colon (arg in &"{key} is {value:arg} {{z}}") is optional. It will be passed as the last argument to formatValue. When the colon with the subexpression it is left out, an empty string will be taken instead.

For strings and numeric types the optional argument is a so-called "standard format specifier".
Standard format specifiers for strings, integers and floats

The general form of a standard format specifier is:

[[fill]align][sign][#][0][minimumwidth][.precision][type]

The square brackets [] indicate an optional element.

The optional align flag can be one of the following:

<
	Forces the field to be left-aligned within the available space. (This is the default for strings.)
>
	Forces the field to be right-aligned within the available space. (This is the default for numbers.)
^
	Forces the field to be centered within the available space.

Note that unless a minimum field width is defined, the field width will always be the same size as the data to fill it, so that the alignment option has no meaning in this case.

The optional fill character defines the character to be used to pad the field to the minimum width. The fill character, if present, must be followed by an alignment flag.

The sign option is only valid for numeric types, and can be one of the following:
Sign	Meaning
+	Indicates that a sign should be used for both positive as well as negative numbers.
-	Indicates that a sign should be used only for negative numbers (this is the default behavior).
(space)	Indicates that a leading space should be used on positive numbers.

If the # character is present, integers use the 'alternate form' for formatting. This means that binary, octal and hexadecimal output will be prefixed with 0b, 0o and 0x, respectively.

width is a decimal integer defining the minimum field width. If not specified, then the field width will be determined by the content.

If the width field is preceded by a zero (0) character, this enables zero-padding.

The precision is a decimal number indicating how many digits should be displayed after the decimal point in a floating point conversion. For non-numeric types the field indicates the maximum field size - in other words, how many characters will be used from the field content. The precision is ignored for integer conversions.

Finally, the type determines how the data should be presented.

The available integer presentation types are:
Type	Result
b	Binary. Outputs the number in base 2.
d	Decimal Integer. Outputs the number in base 10.
o	Octal format. Outputs the number in base 8.
x	Hex format. Outputs the number in base 16, using lower-case letters for the digits above 9.
X	Hex format. Outputs the number in base 16, using uppercase letters for the digits above 9.
(None)	The same as d.

The available floating point presentation types are:
Type	Result
e	Exponent notation. Prints the number in scientific notation using the letter e to indicate the exponent.
E	Exponent notation. Same as e except it converts the number to uppercase.
f	Fixed point. Displays the number as a fixed-point number.
F	Fixed point. Same as f except it converts the number to uppercase.
g	General format. This prints the number as a fixed-point number, unless the number is too large, in which case it switches to e exponent notation.
G	General format. Same as g except it switches to E if the number gets to large.
(None)	Similar to g, except that it prints at least one digit after the decimal point.
Limitations

Because of the well defined order how templates and macros are expanded, strformat cannot expand template arguments:

template myTemplate(arg: untyped): untyped =
  echo "arg is: ", arg
  echo &"--- {arg} ---"

let x = "abc"
myTemplate(x)

First the template myTemplate is expanded, where every identifier arg is substituted with its argument. The arg inside the format string is not seen by this process, because it is part of a quoted string literal. It is not an identifier yet. Then the strformat macro creates the arg identifier from the string literal, an identifier that cannot be resolved anymore.

The workaround for this is to bind the template argument to a new local variable.

template myTemplate(arg: untyped): untyped =
  block:
	let arg1 {.inject.} = arg
	echo "arg is: ", arg1
	echo &"--- {arg1} ---"

The use of {.inject.} here is necessary again because of template expansion order and hygienic templates. But since we generally want to keep the hygiene of myTemplate, and we do not want arg1 to be injected into the context where myTemplate is expanded, everything is wrapped in a block.
Future directions

A curly expression with commas in it like {x, argA, argB} could be transformed to formatValue(result, x, argA, argB) in order to support formatters that do not need to parse a custom language within a custom language but instead prefer to use Nim's existing syntax. This would also help with readability, since there is only so much you can cram into single letter DSLs.

Imports

macros, parseutils, unicode, strutils

Types

StandardFormatSpecifier = object
  fill*, align*: char    	## Desired fill and alignment.
  sign*: char            	## Desired sign.
  alternateForm*: bool   	## Whether to prefix binary, octal and hex numbers
                         	## with `0b`, `0o`, `0x`.
  padWithZero*: bool     	## Whether to pad with zeros rather than spaces.
  minimumWidth*, precision*: int ## Desired minimum width and precision.
  typ*: char             	## Type like 'f', 'g' or 'd'.
  endPosition*: int      	## End position in the format specifier after
                         	## `parseStandardFormatSpecifier` returned.

	Type that describes "standard format specifiers". Source   Edit   

Procs

proc alignString(s: string; minimumWidth: int; align = '\x00'; fill = ' '): string {.
	....}

	Aligns s using the fill char. This is only of interest if you want to write a custom format proc that should support the standard format specifiers. Source   Edit   

proc formatValue(result: var string; value: SomeFloat; specifier: static string)

	Standard format implementation for SomeFloat. It makes little sense to call this directly, but it is required to exist by the & macro. Source   Edit   

proc formatValue(result: var string; value: SomeFloat; specifier: string)

	Standard format implementation for SomeFloat. It makes little sense to call this directly, but it is required to exist by the & macro. Source   Edit   

proc formatValue(result: var string; value: string; specifier: static string)

	Standard format implementation for string. It makes little sense to call this directly, but it is required to exist by the & macro. Source   Edit   

proc formatValue(result: var string; value: string; specifier: string) {.
	....}

	Standard format implementation for string. It makes little sense to call this directly, but it is required to exist by the & macro. Source   Edit   

proc formatValue[T: SomeInteger](result: var string; value: T;
                             	specifier: static string)

	Standard format implementation for SomeInteger. It makes little sense to call this directly, but it is required to exist by the & macro. Source   Edit   

proc formatValue[T: SomeInteger](result: var string; value: T; specifier: string)

	Standard format implementation for SomeInteger. It makes little sense to call this directly, but it is required to exist by the & macro. Source   Edit   

proc parseStandardFormatSpecifier(s: string; start = 0;
                              	ignoreUnknownSuffix = false): StandardFormatSpecifier {.
	....}

An exported helper proc that parses the "standard format specifiers", as specified by the grammar:

[[fill]align][sign][#][0][minimumwidth][.precision][type]

	This is only of interest if you want to write a custom format proc that should support the standard format specifiers. If ignoreUnknownSuffix is true, an unknown suffix after the type field is not an error.
	Source   Edit   

Templates

template `&`(pattern: string{lit}): string {.callsite.}

&pattern is the same as pattern.fmt. For a specification of the & macro, see the module level documentation.

Example:

let x = 7
assert &"{x}\n" == "7\n" # regular string literal
assert &"{x}\n" == "{x}\n".fmt # `fmt` can be used instead
assert &"{x}\n" != fmt"{x}\n" # see `fmt` docs, this would use a raw string literal

	Source   Edit   

template fmt(pattern: static string): untyped {.callsite.}

	Alias for fmt(pattern, '{', '}'). Source   Edit   

template fmt(pattern: static string; openChar: static char;
         	closeChar: static char): string {.callsite.}

Interpolates pattern using symbols in scope.

Example:

let x = 7
assert "var is {x * 2}".fmt == "var is 14"
assert "var is {{x}}".fmt == "var is {x}" # escape via doubling
const s = "foo: {x}"
assert s.fmt == "foo: 7" # also works with const strings

assert fmt"\n" == r"\n" # raw string literal
assert "\n".fmt == "\n" # regular literal (likewise with `fmt("\n")` or `fmt "\n"`)

Example:

# custom `openChar`, `closeChar`
let x = 7
assert "<x>".fmt('<', '>') == "7"
assert "<<<x>>>".fmt('<', '>') == "<7>"
assert "`x`".fmt('`', '`') == "7"

std/strmisc


std/strmisc
Source   Edit  

This module contains various string utility routines that are uncommonly used in comparison to the ones in strutils.
Imports

strutils

Procs

func expandTabs(s: string; tabSize: int = 8): string {.....}

Expands tab characters in s, replacing them by spaces.

The amount of inserted spaces for each tab character is the difference between the current column number and the next tab position. Tab positions occur every tabSize characters. The column number starts at 0 and is increased with every single character and inserted space, except for newline, which resets the column number back to 0.

Example:

doAssert expandTabs("\t", 4) == "	"
doAssert expandTabs("\tfoo\t", 4) == "	foo "
doAssert expandTabs("a\tb\n\txy\t", 3) == "a  b\n   xy "

	Source   Edit   

func partition(s: string; sep: string; right: bool = false): (string, string,
	string) {.....}

Splits the string at the first (if right is false) or last (if right is true) occurrence of sep into a 3-tuple.

Returns a 3-tuple of strings, (beforeSep, sep, afterSep) or (s, "", "") if sep is not found and right is false or ("", "", s) if sep is not found and right is true.

See also:

	rpartition proc

Example:

doAssert partition("foo:bar:baz", ":") == ("foo", ":", "bar:baz")
doAssert partition("foo:bar:baz", ":", right = true) == ("foo:bar", ":", "baz")
doAssert partition("foobar", ":") == ("foobar", "", "")
doAssert partition("foobar", ":", right = true) == ("", "", "foobar")

	Source   Edit   

func rpartition(s: string; sep: string): (string, string, string) {.....}

Splits the string at the last occurrence of sep into a 3-tuple.

Returns a 3-tuple of strings, (beforeSep, sep, afterSep) or ("", "", s) if sep is not found. This is the same as partition(s, sep, right = true).

See also:

	partition proc

Example:

doAssert rpartition("foo:bar:baz", ":") == ("foo:bar", ":", "baz")
doAssert rpartition("foobar", ":") == ("", "", "foobar")

std/strscans


std/strscans
Source   Edit  

This module contains a scanf macro that can be used for extracting substrings from an input string. This is often easier than regular expressions. Some examples as an appetizer:

# check if input string matches a triple of integers:
const input = "(1,2,4)"
var x, y, z: int
if scanf(input, "($i,$i,$i)", x, y, z):
  echo "matches and x is ", x, " y is ", y, " z is ", z

# check if input string matches an ISO date followed by an identifier followed
# by whitespace and a floating point number:
var year, month, day: int
var identifier: string
var myfloat: float
if scanf(input, "$i-$i-$i $w$s$f", year, month, day, identifier, myfloat):
  echo "yes, we have a match!"

As can be seen from the examples, strings are matched verbatim except for substrings starting with $. These constructions are available:
$b	Matches a binary integer. This uses parseutils.parseBin.
$o	Matches an octal integer. This uses parseutils.parseOct.
$i	Matches a decimal integer. This uses parseutils.parseInt.
$h	Matches a hex integer. This uses parseutils.parseHex.
$f	Matches a floating-point number. Uses parseFloat.
$w	Matches an ASCII identifier: [A-Za-z_][A-Za-z_0-9]*.
$c	Matches a single ASCII character.
$s	Skips optional whitespace.
$$	Matches a single dollar sign.
$.	Matches if the end of the input string has been reached.
$*	Matches until the token following the $* was found. The match is allowed to be of 0 length.
$+	Matches until the token following the $+ was found. The match must consist of at least one char.
${foo}	User defined matcher. Uses the proc foo to perform the match. See below for more details.
$[foo]	Call user defined proc foo to skip some optional parts in the input string. See below for more details.

Even though $* and $+ look similar to the regular expressions .* and .+, they work quite differently. There is no non-deterministic state machine involved and the matches are non-greedy. [$*] matches [xyz] via parseutils.parseUntil.

Furthermore no backtracking is performed, if parsing fails after a value has already been bound to a matched subexpression this value is not restored to its original value. This rarely causes problems in practice and if it does for you, it's easy enough to bind to a temporary variable first.
Startswith vs full match

scanf returns true if the input string starts with the specified pattern. If instead it should only return true if there is also nothing left in the input, append $. to your pattern.
User definable matchers

One very nice advantage over regular expressions is that scanf is extensible with ordinary Nim procs. The proc is either enclosed in ${} or in $[]. ${} matches and binds the result to a variable (that was passed to the scanf macro) while $[] merely matches optional tokens without any result binding.

In this example, we define a helper proc someSep that skips some separators which we then use in our scanf pattern to help us in the matching process:

proc someSep(input: string; start: int; seps: set[char] = {':','-','.'}): int =
  # Note: The parameters and return value must match to what ``scanf`` requires
  result = 0
  while start+result < input.len and input[start+result] in seps: inc result

if scanf(input, "$w$[someSep]$w", key, value):
  ...

It also possible to pass arguments to a user definable matcher:

proc ndigits(input: string; intVal: var int; start: int; n: int): int =
  # matches exactly ``n`` digits. Matchers need to return 0 if nothing
  # matched or otherwise the number of processed chars.
  var x = 0
  var i = 0
  while i < n and i+start < input.len and input[i+start] in {'0'..'9'}:
	x = x * 10 + input[i+start].ord - '0'.ord
	inc i
  # only overwrite if we had a match
  if i == n:
	result = n
	intVal = x

# match an ISO date extracting year, month, day at the same time.
# Also ensure the input ends after the ISO date:
var year, month, day: int
if scanf("2013-01-03", "${ndigits(4)}-${ndigits(2)}-${ndigits(2)}$.", year, month, day):
  ...

The scanp macro

This module also implements a scanp macro, which syntax somewhat resembles an EBNF or PEG grammar, except that it uses Nim's expression syntax and so has to use prefix instead of postfix operators.
(E)	Grouping
*E	Zero or more
+E	One or more
?E	Zero or One
E{n,m}	From n up to m times E
~E	Not predicate
a ^* b	Shortcut for ?(a *(b a)). Usually used for separators.
a ^+ b	Shortcut for ?(a +(b a)). Usually used for separators.
'a'	Matches a single character
{'a'..'b'}	Matches a character set
"s"	Matches a string
E -> a	Bind matching to some action
$_	Access the currently matched character

Note that unordered or ordered choice operators (/, |) are not implemented.

Simple example that parses the /etc/passwd file line by line:

const
  etc_passwd = """root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/bin/sh
bin:x:2:2:bin:/bin:/bin/sh
sys:x:3:3:sys:/dev:/bin/sh
nobody:x:65534:65534:nobody:/nonexistent:/bin/sh
messagebus:x:103:107::/var/run/dbus:/bin/false
"""

proc parsePasswd(content: string): seq[string] =
  result = @[]
  var idx = 0
  while true:
	var entry = ""
	if scanp(content, idx, +(~{'\L', '\0'} -> entry.add($_)), '\L'):
  	result.add entry
	else:
  	break

The scanp maps the grammar code into Nim code that performs the parsing. The parsing is performed with the help of 3 helper templates that that can be implemented for a custom type.

These templates need to be named atom and nxt. atom should be overloaded to handle both single characters and sets of character.

import std/streams

template atom(input: Stream; idx: int; c: char): bool =
  ## Used in scanp for the matching of atoms (usually chars).
  peekChar(input) == c

template atom(input: Stream; idx: int; s: set[char]): bool =
  peekChar(input) in s

template nxt(input: Stream; idx, step: int = 1) =
  inc(idx, step)
  setPosition(input, idx)

if scanp(content, idx, +( ~{'\L', '\0'} -> entry.add(peekChar($input))), '\L'):
  result.add entry

Calling ordinary Nim procs inside the macro is possible:

proc digits(s: string; intVal: var int; start: int): int =
  var x = 0
  while result+start < s.len and s[result+start] in {'0'..'9'} and s[result+start] != ':':
	x = x * 10 + s[result+start].ord - '0'.ord
	inc result
  intVal = x

proc extractUsers(content: string): seq[string] =
  # Extracts the username and home directory
  # of each entry (with UID greater than 1000)
  const
	digits = {'0'..'9'}
  result = @[]
  var idx = 0
  while true:
	var login = ""
	var uid = 0
	var homedir = ""
	if scanp(content, idx, *(~ {':', '\0'}) -> login.add($_), ':', * ~ ':', ':',
        	digits($input, uid, $index), ':', *`digits`, ':', * ~ ':', ':',
        	*('/', * ~{':', '/'}) -> homedir.add($_), ':', *('/', * ~{'\L', '/'}), '\L'):
  	if uid >= 1000:
    	result.add login & " " & homedir
	else:
  	break

When used for matching, keep in mind that likewise scanf, no backtracking is performed.

proc skipUntil(s: string; until: string; unless = '\0'; start: int): int =
  # Skips all characters until the string `until` is found. Returns 0
  # if the char `unless` is found first or the end is reached.
  var i = start
  var u = 0
  while true:
	if i >= s.len or s[i] == unless:
  	return 0
	elif s[i] == until[0]:
  	u = 1
  	while i+u < s.len and u < until.len and s[i+u] == until[u]:
    	inc u
  	if u >= until.len: break
	inc(i)
  result = i+u-start

iterator collectLinks(s: string): string =
  const quote = {'\'', '"'}
  var idx, old = 0
  var res = ""
  while idx < s.len:
	old = idx
	if scanp(s, idx, "<a", skipUntil($input, "href=", '>', $index),
        	`quote`, *( ~`quote`) -> res.add($_)):
  	yield res
  	res = ""
	idx = old + 1

for r in collectLinks(body):
  echo r

In this example both macros are combined seamlessly in order to maximise efficiency and perform different checks.

iterator parseIps*(soup: string): string =
  ## ipv4 only!
  const digits = {'0'..'9'}
  var a, b, c, d: int
  var buf = ""
  var idx = 0
  while idx < soup.len:
	if scanp(soup, idx, (`digits`{1,3}, '.', `digits`{1,3}, '.',
         	`digits`{1,3}, '.', `digits`{1,3}) -> buf.add($_)):
  	discard buf.scanf("$i.$i.$i.$i", a, b, c, d)
  	if (a >= 0 and a <= 254) and
     	(b >= 0 and b <= 254) and
     	(c >= 0 and c <= 254) and
     	(d >= 0 and d <= 254):
    	yield buf
	buf.setLen(0) # need to clear `buf` each time, cause it might contain garbage
	idx.inc

Imports

macros, parseutils, since

Macros

macro scanf(input: string; pattern: static[string]; results: varargs[typed]): bool

	See top level documentation of this module about how scanf works. Source   Edit   

macro scanp(input, idx: typed; pattern: varargs[untyped]): bool

	See top level documentation of this module about how scanp works. Source   Edit   

macro scanTuple(input: untyped; pattern: static[string];
            	matcherTypes: varargs[untyped]): untyped

Works identically as scanf, but instead of predeclaring variables it returns a tuple. Tuple is started with a bool which indicates if the scan was successful followed by the requested data. If using a user defined matcher, provide the types in order they appear after pattern: line.scanTuple("${yourMatcher()}", int)

Example:

let (success, year, month, day, time) = scanTuple("1000-01-01 00:00:00", "$i-$i-$i$s$+")
if success:
  assert year == 1000
  assert month == 1
  assert day == 1
  assert time == "00:00:00"

	Source   Edit   

Templates

template atom(input: string; idx: int; c: char): bool

	Used in scanp for the matching of atoms (usually chars). EOF is matched as '\0'. Source   Edit   

template atom(input: string; idx: int; s: set[char]): bool

	Source   Edit   

template hasNxt(input: string; idx: int): bool

	Source   Edit   

template nxt(input: string; idx, step: int = 1)

	Source   Edit   

template success(x: int): bool


std/strutils



std/strutils
Source   Edit  

The system module defines several common functions for working with strings, such as:

	$ for converting other data-types to strings
	& for string concatenation
	add for adding a new character or a string to the existing one
	in (alias for contains) and notin for checking if a character is in a string

This module builds upon that, providing additional functionality in form of procedures, iterators and templates for strings.

Example:

import std/strutils
let
  numbers = @[867, 5309]
  multiLineString = "first line\nsecond line\nthird line"

let jenny = numbers.join("-")
assert jenny == "867-5309"

assert splitLines(multiLineString) ==
   	@["first line", "second line", "third line"]
assert split(multiLineString) == @["first", "line", "second",
                               	"line", "third", "line"]
assert indent(multiLineString, 4) ==
   	"	first line\n	second line\n	third line"
assert 'z'.repeat(5) == "zzzzz"

The chaining of functions is possible thanks to the method call syntax:

Example:

import std/strutils
from std/sequtils import map

let jenny = "867-5309"
assert jenny.split('-').map(parseInt) == @[867, 5309]

assert "Beetlejuice".indent(1).repeat(3).strip ==
   	"Beetlejuice Beetlejuice Beetlejuice"

This module is available for the JavaScript target.

See also:

	strformat module for string interpolation and formatting
	unicode module for Unicode UTF-8 handling
	sequtils module for operations on container types (including strings)
	parsecsv module for a high-performance CSV parser
	parseutils module for lower-level parsing of tokens, numbers, identifiers, etc.
	parseopt module for command-line parsing
	pegs module for PEG (Parsing Expression Grammar) support
	strtabs module for efficient hash tables (dictionaries, in some programming languages) mapping from strings to strings
	ropes module for rope data type, which can represent very long strings efficiently
	re module for regular expression (regex) support
	strscans for scanf and scanp macros, which offer easier substring extraction than regular expressions

Imports

parseutils, math, algorithm, enumutils, unicode, since, jsutils, strimpl

Types

BinaryPrefixMode = enum
  bpIEC, bpColloquial

	The different names for binary prefixes. Source   Edit   

FloatFormatMode = enum
  ffDefault,            	## use the shorter floating point notation
  ffDecimal,            	## use decimal floating point notation
  ffScientific           	## use scientific notation (using `e` character)

	The different modes of floating point formatting. Source   Edit   

SkipTable = array[char, int]

	Character table for efficient substring search. Source   Edit   

Consts

AllChars = {'\x00'..'\xFF'}

A set with all the possible characters.

Not very useful by its own, you can use it to create inverted sets to make the find func find invalid characters in strings. Example:

let invalid = AllChars - Digits
doAssert "01234".find(invalid) == -1
doAssert "01A34".find(invalid) == 2

	Source   Edit   

Digits = {'0'..'9'}

	The set of digits. Source   Edit   

HexDigits = {'0'..'9', 'A'..'F', 'a'..'f'}

	The set of hexadecimal digits. Source   Edit   

IdentChars = {'a'..'z', 'A'..'Z', '0'..'9', '_'}

	The set of characters an identifier can consist of. Source   Edit   

IdentStartChars = {'a'..'z', 'A'..'Z', '_'}

	The set of characters an identifier can start with. Source   Edit   

Letters = {'A'..'Z', 'a'..'z'}

	The set of letters. Source   Edit   

LowercaseLetters = {'a'..'z'}

	The set of lowercase ASCII letters. Source   Edit   

Newlines = {'\r', '\n'}

	The set of characters a newline terminator can start with (carriage return, line feed). Source   Edit   

PrintableChars = {'\t'..'\r', ' '..'~'}

	The set of all printable ASCII characters (letters, digits, whitespace, and punctuation characters). Source   Edit   

PunctuationChars = {'!'..'/', ':'..'@', '['..'`', '{'..'~'}

	The set of all ASCII punctuation characters. Source   Edit   

UppercaseLetters = {'A'..'Z'}

	The set of uppercase ASCII letters. Source   Edit   

Whitespace = {' ', '\t', '\v', '\r', '\n', '\f'}

	All the characters that count as whitespace (space, tab, vertical tab, carriage return, new line, form feed). Source   Edit   

Procs

func `%`(formatstr, a: string): string {.....}

	This is the same as formatstr % [a] (see % func). Source   Edit   

func `%`(formatstr: string; a: openArray[string]): string {.....}

Interpolates a format string with the values from a.

The substitution operator performs string substitutions in formatstr and returns a modified formatstr. This is often called string interpolation.

This is best explained by an example:

"$1 eats $2." % ["The cat", "fish"]

Results in:

"The cat eats fish."

The substitution variables (the thing after the $) are enumerated from 1 to a.len. To produce a verbatim $, use $$. The notation $# can be used to refer to the next substitution variable:

"$# eats $#." % ["The cat", "fish"]

Substitution variables can also be words (that is [A-Za-z_]+[A-Za-z0-9_]*) in which case the arguments in a with even indices are keys and with odd indices are the corresponding values. An example:

"$animal eats $food." % ["animal", "The cat", "food", "fish"]

Results in:

"The cat eats fish."

	The variables are compared with cmpIgnoreStyle. ValueError is raised if an ill-formed format string has been passed to the % operator.

	See also:

    	strformat module for string interpolation and formatting

	Source   Edit   

func abbrev(s: string; possibilities: openArray[string]): int {.....}

Returns the index of the first item in possibilities which starts with s, if not ambiguous.

Returns -1 if no item has been found and -2 if multiple items match.

Example:

doAssert abbrev("fac", ["college", "faculty", "industry"]) == 1
doAssert abbrev("foo", ["college", "faculty", "industry"]) == -1 # Not found
doAssert abbrev("fac", ["college", "faculty", "faculties"]) == -2 # Ambiguous
doAssert abbrev("college", ["college", "colleges", "industry"]) == 0

	Source   Edit   

func addf(s: var string; formatstr: string; a: varargs[string, `$`]) {.....}

	The same as add(s, formatstr % a), but more efficient. Source   Edit   

func addSep(dest: var string; sep = ", "; startLen: Natural = 0) {.inline,
	....}

Adds a separator to dest only if its length is bigger than startLen.

A shorthand for:

if dest.len > startLen: add(dest, sep)

This is often useful for generating some code where the items need to be separated by sep. sep is only added if dest is longer than startLen. The following example creates a string describing an array of integers.

Example:

var arr = "["
for x in items([2, 3, 5, 7, 11]):
  addSep(arr, startLen = len("["))
  add(arr, $x)
add(arr, "]")
doAssert arr == "[2, 3, 5, 7, 11]"

	Source   Edit   

func align(s: string; count: Natural; padding = ' '): string {.....}

Aligns a string s with padding, so that it is of length count.

padding characters (by default spaces) are added before s resulting in right alignment. If s.len >= count, no spaces are added and s is returned unchanged. If you need to left align a string use the alignLeft func.

See also:

	alignLeft func
	spaces func
	indent func
	center func

Example:

assert align("abc", 4) == " abc"
assert align("a", 0) == "a"
assert align("1232", 6) == "  1232"
assert align("1232", 6, '#') == "##1232"

	Source   Edit   

func alignLeft(s: string; count: Natural; padding = ' '): string {.....}

Left-Aligns a string s with padding, so that it is of length count.

padding characters (by default spaces) are added after s resulting in left alignment. If s.len >= count, no spaces are added and s is returned unchanged. If you need to right align a string use the align func.

See also:

	align func
	spaces func
	indent func
	center func

Example:

assert alignLeft("abc", 4) == "abc "
assert alignLeft("a", 0) == "a"
assert alignLeft("1232", 6) == "1232  "
assert alignLeft("1232", 6, '#') == "1232##"

	Source   Edit   

func allCharsInSet(s: string; theSet: set[char]): bool {.....}

Returns true if every character of s is in the set theSet.

Example:

doAssert allCharsInSet("aeea", {'a', 'e'}) == true
doAssert allCharsInSet("", {'a', 'e'}) == true

	Source   Edit   

func capitalizeAscii(s: string): string {.....}

Converts the first character of string s into upper case.

This works only for the letters A-Z. Use Unicode module for UTF-8 support.

See also:

	toUpperAscii func

Example:

doAssert capitalizeAscii("foo") == "Foo"
doAssert capitalizeAscii("-bar") == "-bar"

	Source   Edit   

func center(s: string; width: int; fillChar: char = ' '): string {.....}

Return the contents of s centered in a string width long using fillChar (default: space) as padding.

The original string is returned if width is less than or equal to s.len.

See also:

	align func
	alignLeft func
	spaces func
	indent func

Example:

let a = "foo"
doAssert a.center(2) == "foo"
doAssert a.center(5) == " foo "
doAssert a.center(6) == " foo  "

	Source   Edit   

func cmpIgnoreCase(a, b: string): int {.....}

Compares two strings in a case insensitive manner. Returns:

0 if a == b
< 0 if a < b
> 0 if a > b

Example:

doAssert cmpIgnoreCase("FooBar", "foobar") == 0
doAssert cmpIgnoreCase("bar", "Foo") < 0
doAssert cmpIgnoreCase("Foo5", "foo4") > 0

	Source   Edit   

func cmpIgnoreStyle(a, b: string): int {.....}

Semantically the same as cmp(normalize(a), normalize(b)). It is just optimized to not allocate temporary strings. This should NOT be used to compare Nim identifier names. Use macros.eqIdent for that.

Returns:

0 if a == b
< 0 if a < b
> 0 if a > b

Example:

doAssert cmpIgnoreStyle("foo_bar", "FooBar") == 0
doAssert cmpIgnoreStyle("foo_bar_5", "FooBar4") > 0

	Source   Edit   

func contains(s, sub: string): bool {.....}

	Same as find(s, sub) >= 0.

	See also:

    	find func

	Source   Edit   

func contains(s: string; chars: set[char]): bool {.....}

	Same as find(s, chars) >= 0.

	See also:

    	find func

	Source   Edit   

func continuesWith(s, substr: string; start: Natural): bool {.....}

Returns true if s continues with substr at position start.

If substr == "" true is returned.

See also:

	startsWith func
	endsWith func

Example:

let a = "abracadabra"
doAssert a.continuesWith("ca", 4) == true
doAssert a.continuesWith("ca", 5) == false
doAssert a.continuesWith("dab", 6) == true

	Source   Edit   

func count(s: string; sub: char): int {.....}

	Counts the occurrences of the character sub in the string s.

	See also:

    	countLines func

	Source   Edit   

func count(s: string; sub: string; overlapping: bool = false): int {.....}

	Counts the occurrences of a substring sub in the string s. Overlapping occurrences of sub only count when overlapping is set to true (default: false).

	See also:

    	countLines func

	Source   Edit   

func count(s: string; subs: set[char]): int {.....}

	Counts the occurrences of the group of character subs in the string s.

	See also:

    	countLines func

	Source   Edit   

func countLines(s: string): int {.....}

Returns the number of lines in the string s.

This is the same as len(splitLines(s)), but much more efficient because it doesn't modify the string creating temporary objects. Every character literal newline combination (CR, LF, CR-LF) is supported.

In this context, a line is any string separated by a newline combination. A line can be an empty string.

See also:

	splitLines func

Example:

doAssert countLines("First line\l and second line.") == 2

	Source   Edit   

func dedent(s: string; count: Natural = indentation(s)): string {.....}

Unindents each line in s by count amount of padding. The only difference between this and the unindent func is that this by default only cuts off the amount of indentation that all lines of s share as opposed to all indentation. It only supports spaces as padding.

Note: This does not preserve the new line characters used in s.

See also:

	unindent func
	align func
	alignLeft func
	spaces func
	indent func

Example:

let x = """
  	Hello
    	There
	""".dedent()

doAssert x == "Hello\n  There\n"

	Source   Edit   

func delete(s: var string; first, last: int) {.....}

Deprecated: use `delete(s, first..last)`
Deletes in s the characters at positions first .. last (both ends included).

Example: cmd: --warning:deprecated:off

var a = "abracadabra"

a.delete(4, 5)
doAssert a == "abradabra"

a.delete(1, 6)
doAssert a == "ara"

a.delete(2, 999)
doAssert a == "ar"

	Source   Edit   

func delete(s: var string; slice: Slice[int]) {.....}

Deletes the items s[slice], raising IndexDefect if the slice contains elements out of range.

This operation moves all elements after s[slice] in linear time, and is the string analog to sequtils.delete.

Example:

var a = "abcde"
doAssertRaises(IndexDefect): a.delete(4..5)
assert a == "abcde"
a.delete(4..4)
assert a == "abcd"
a.delete(1..2)
assert a == "ad"
a.delete(1..<1) # empty slice
assert a == "ad"

	Source   Edit   

func endsWith(s, suffix: string): bool {.....}

Returns true if s ends with suffix.

If suffix == "" true is returned.

See also:

	startsWith func
	continuesWith func
	removeSuffix func

Example:

let a = "abracadabra"
doAssert a.endsWith("abra") == true
doAssert a.endsWith("dab") == false

	Source   Edit   

func endsWith(s: string; suffix: char): bool {.inline, ....}

Returns true if s ends with suffix.

See also:

	startsWith func
	continuesWith func
	removeSuffix func

Example:

let a = "abracadabra"
doAssert a.endsWith('a') == true
doAssert a.endsWith('b') == false

	Source   Edit   

func escape(s: string; prefix = "\""; suffix = "\""): string {.....}

	Escapes a string s.
	Note: The escaping scheme is different from system.addEscapedChar.

    	replaces '\0'..'\31' and '\127'..'\255' by \xHH where HH is its hexadecimal value
    	replaces \ by \\
    	replaces ' by \'
    	replaces " by \"

	The resulting string is prefixed with prefix and suffixed with suffix. Both may be empty strings.

	See also:

    	addEscapedChar proc
    	unescape func for the opposite operation

	Source   Edit   

func find(a: SkipTable; s, sub: string; start: Natural = 0; last = -1): int {.
	....}

	Searches for sub in s inside range start..last using preprocessed table a. If last is unspecified, it defaults to s.high (the last element).

	Searching is case-sensitive. If sub is not in s, -1 is returned.

	See also:

    	initSkipTable func
    	initSkipTable func

	Source   Edit   

func find(s, sub: string; start: Natural = 0; last = -1): int {.....}

	Searches for sub in s inside range start..last (both ends included). If last is unspecified or negative, it defaults to s.high (the last element).

	Searching is case-sensitive. If sub is not in s, -1 is returned. Otherwise the index returned is relative to s[0], not start. Subtract start from the result for a start-origin index.

	See also:

    	rfind func
    	replace func

	Source   Edit   

func find(s: string; chars: set[char]; start: Natural = 0; last = -1): int {.
	....}

	Searches for chars in s inside range start..last (both ends included). If last is unspecified or negative, it defaults to s.high (the last element).

	If s contains none of the characters in chars, -1 is returned. Otherwise the index returned is relative to s[0], not start. Subtract start from the result for a start-origin index.

	See also:

    	rfind func
    	multiReplace func

	Source   Edit   

func find(s: string; sub: char; start: Natural = 0; last = -1): int {.....}

	Searches for sub in s inside range start..last (both ends included). If last is unspecified or negative, it defaults to s.high (the last element).

	Searching is case-sensitive. If sub is not in s, -1 is returned. Otherwise the index returned is relative to s[0], not start. Subtract start from the result for a start-origin index.

	See also:

    	rfind func
    	replace func

	Source   Edit   

func format(formatstr: string; a: varargs[string, `$`]): string {.....}

	This is the same as formatstr % a (see % func) except that it supports auto stringification.

	See also:

    	strformat module for string interpolation and formatting

	Source   Edit   

func formatBiggestFloat(f: BiggestFloat; format: FloatFormatMode = ffDefault;
                    	precision: range[-1 .. 32] = 16; decimalSep = '.'): string {.
	....}

Converts a floating point value f to a string.

If format == ffDecimal then precision is the number of digits to be printed after the decimal point. If format == ffScientific then precision is the maximum number of significant digits to be printed. precision's default value is the maximum number of meaningful digits after the decimal point for Nim's biggestFloat type.

If precision == -1, it tries to format it nicely.

Example:

let x = 123.456
doAssert x.formatBiggestFloat() == "123.4560000000000"
doAssert x.formatBiggestFloat(ffDecimal, 4) == "123.4560"
doAssert x.formatBiggestFloat(ffScientific, 2) == "1.23e+02"

	Source   Edit   

func formatEng(f: BiggestFloat; precision: range[0 .. 32] = 10;
           	trim: bool = true; siPrefix: bool = false; unit: string = "";
           	decimalSep = '.'; useUnitSpace = false): string {.....}

Converts a floating point value f to a string using engineering notation.

Numbers in of the range -1000.0<f<1000.0 will be formatted without an exponent. Numbers outside of this range will be formatted as a significand in the range -1000.0<f<1000.0 and an exponent that will always be an integer multiple of 3, corresponding with the SI prefix scale k, M, G, T etc for numbers with an absolute value greater than 1 and m, μ, n, p etc for numbers with an absolute value less than 1.

The default configuration (trim=true and precision=10) shows the shortest form that precisely (up to a maximum of 10 decimal places) displays the value. For example, 4.100000 will be displayed as 4.1 (which is mathematically identical) whereas 4.1000003 will be displayed as 4.1000003.

If trim is set to true, trailing zeros will be removed; if false, the number of digits specified by precision will always be shown.

precision can be used to set the number of digits to be shown after the decimal point or (if trim is true) the maximum number of digits to be shown.

formatEng(0, 2, trim=false) == "0.00"
formatEng(0, 2) == "0"
formatEng(0.053, 0) == "53e-3"
formatEng(52731234, 2) == "52.73e6"
formatEng(-52731234, 2) == "-52.73e6"

If siPrefix is set to true, the number will be displayed with the SI prefix corresponding to the exponent. For example 4100 will be displayed as "4.1 k" instead of "4.1e3". Note that u is used for micro- in place of the greek letter mu (μ) as per ISO 2955. Numbers with an absolute value outside of the range 1e-18<f<1000e18 (1a<f<1000E) will be displayed with an exponent rather than an SI prefix, regardless of whether siPrefix is true.

If useUnitSpace is true, the provided unit will be appended to the string (with a space as required by the SI standard). This behaviour is slightly different to appending the unit to the result as the location of the space is altered depending on whether there is an exponent.

formatEng(4100, siPrefix=true, unit="V") == "4.1 kV"
formatEng(4.1, siPrefix=true, unit="V") == "4.1 V"
formatEng(4.1, siPrefix=true) == "4.1" # Note lack of space
formatEng(4100, siPrefix=true) == "4.1 k"
formatEng(4.1, siPrefix=true, unit="") == "4.1 " # Space with unit=""
formatEng(4100, siPrefix=true, unit="") == "4.1 k"
formatEng(4100) == "4.1e3"
formatEng(4100, unit="V") == "4.1e3 V"
formatEng(4100, unit="", useUnitSpace=true) == "4.1e3 " # Space with useUnitSpace=true

	decimalSep is used as the decimal separator.

	See also:

    	strformat module for string interpolation and formatting

	Source   Edit   

func formatFloat(f: float; format: FloatFormatMode = ffDefault;
             	precision: range[-1 .. 32] = 16; decimalSep = '.'): string {.
	....}

Converts a floating point value f to a string.

If format == ffDecimal then precision is the number of digits to be printed after the decimal point. If format == ffScientific then precision is the maximum number of significant digits to be printed. precision's default value is the maximum number of meaningful digits after the decimal point for Nim's float type.

If precision == -1, it tries to format it nicely.

Example:

let x = 123.456
doAssert x.formatFloat() == "123.4560000000000"
doAssert x.formatFloat(ffDecimal, 4) == "123.4560"
doAssert x.formatFloat(ffScientific, 2) == "1.23e+02"

	Source   Edit   

func formatSize(bytes: int64; decimalSep = '.'; prefix = bpIEC;
            	includeSpace = false): string {.....}

Rounds and formats bytes.

By default, uses the IEC/ISO standard binary prefixes, so 1024 will be formatted as 1KiB. Set prefix to bpColloquial to use the colloquial names from the SI standard (e.g. k for 1000 being reused as 1024).

includeSpace can be set to true to include the (SI preferred) space between the number and the unit (e.g. 1 KiB).

See also:

	strformat module for string interpolation and formatting

Example:

doAssert formatSize((1'i64 shl 31) + (300'i64 shl 20)) == "2.293GiB"
doAssert formatSize((2.234*1024*1024).int) == "2.234MiB"
doAssert formatSize(4096, includeSpace = true) == "4 KiB"
doAssert formatSize(4096, prefix = bpColloquial, includeSpace = true) == "4 kB"
doAssert formatSize(4096) == "4KiB"
doAssert formatSize(5_378_934, prefix = bpColloquial, decimalSep = ',') == "5,13MB"

	Source   Edit   

func fromBin[T: SomeInteger](s: string): T

Parses a binary integer value from a string s.

If s is not a valid binary integer, ValueError is raised. s can have one of the following optional prefixes: 0b, 0B. Underscores within s are ignored.

Does not check for overflow. If the value represented by s is too big to fit into a return type, only the value of the rightmost binary digits of s is returned without producing an error.

Example:

let s = "0b_0100_1000_1000_1000_1110_1110_1001_1001"
doAssert fromBin[int](s) == 1216933529
doAssert fromBin[int8](s) == 0b1001_1001'i8
doAssert fromBin[int8](s) == -103'i8
doAssert fromBin[uint8](s) == 153
doAssert s.fromBin[:int16] == 0b1110_1110_1001_1001'i16
doAssert s.fromBin[:uint64] == 1216933529'u64

	Source   Edit   

func fromHex[T: SomeInteger](s: string): T

Parses a hex integer value from a string s.

If s is not a valid hex integer, ValueError is raised. s can have one of the following optional prefixes: 0x, 0X, #. Underscores within s are ignored.

Does not check for overflow. If the value represented by s is too big to fit into a return type, only the value of the rightmost hex digits of s is returned without producing an error.

Example:

let s = "0x_1235_8df6"
doAssert fromHex[int](s) == 305499638
doAssert fromHex[int8](s) == 0xf6'i8
doAssert fromHex[int8](s) == -10'i8
doAssert fromHex[uint8](s) == 246'u8
doAssert s.fromHex[:int16] == -29194'i16
doAssert s.fromHex[:uint64] == 305499638'u64

	Source   Edit   

func fromOct[T: SomeInteger](s: string): T

Parses an octal integer value from a string s.

If s is not a valid octal integer, ValueError is raised. s can have one of the following optional prefixes: 0o, 0O. Underscores within s are ignored.

Does not check for overflow. If the value represented by s is too big to fit into a return type, only the value of the rightmost octal digits of s is returned without producing an error.

Example:

let s = "0o_123_456_777"
doAssert fromOct[int](s) == 21913087
doAssert fromOct[int8](s) == 0o377'i8
doAssert fromOct[int8](s) == -1'i8
doAssert fromOct[uint8](s) == 255'u8
doAssert s.fromOct[:int16] == 24063'i16
doAssert s.fromOct[:uint64] == 21913087'u64

	Source   Edit   

func indent(s: string; count: Natural; padding: string = " "): string {.....}

Indents each line in s by count amount of padding.

Note: This does not preserve the new line characters used in s.

See also:

	align func
	alignLeft func
	spaces func
	unindent func
	dedent func

Example:

doAssert indent("First line\c\l and second line.", 2) ==
     	"  First line\l   and second line."

	Source   Edit   

func indentation(s: string): Natural {.....}

	Returns the amount of indentation all lines of s have in common, ignoring lines that consist only of whitespace. Source   Edit   

func initSkipTable(a: var SkipTable; sub: string) {.....}

	Initializes table a for efficient search of substring sub.

	See also:

    	initSkipTable func
    	find func

	Source   Edit   

func initSkipTable(sub: string): SkipTable {.noinit, ....}

	Returns a new table initialized for sub.

	See also:

    	initSkipTable func
    	find func

	Source   Edit   

func insertSep(s: string; sep = '_'; digits = 3): string {.....}

Inserts the separator sep after digits characters (default: 3) from right to left.

Even though the algorithm works with any string s, it is only useful if s contains a number.

Example:

doAssert insertSep("1000000") == "1_000_000"

	Source   Edit   

func intToStr(x: int; minchars: Positive = 1): string {.....}

Converts x to its decimal representation.

The resulting string will be minimally minchars characters long. This is achieved by adding leading zeros.

Example:

doAssert intToStr(1984) == "1984"
doAssert intToStr(1984, 6) == "001984"

	Source   Edit   

func isAlphaAscii(c: char): bool {.....}

Checks whether or not character c is alphabetical.

This checks a-z, A-Z ASCII characters only. Use Unicode module for UTF-8 support.

Example:

doAssert isAlphaAscii('e') == true
doAssert isAlphaAscii('E') == true
doAssert isAlphaAscii('8') == false

	Source   Edit   

func isAlphaNumeric(c: char): bool {.....}

Checks whether or not c is alphanumeric.

This checks a-z, A-Z, 0-9 ASCII characters only.

Example:

doAssert isAlphaNumeric('n') == true
doAssert isAlphaNumeric('8') == true
doAssert isAlphaNumeric(' ') == false

	Source   Edit   

func isDigit(c: char): bool {.....}

Checks whether or not c is a number.

This checks 0-9 ASCII characters only.

Example:

doAssert isDigit('n') == false
doAssert isDigit('8') == true

	Source   Edit   

func isEmptyOrWhitespace(s: string): bool {.....}

	Checks if s is empty or consists entirely of whitespace characters. Source   Edit   

func isLowerAscii(c: char): bool {.....}

Checks whether or not c is a lower case character.

This checks ASCII characters only. Use Unicode module for UTF-8 support.

See also:

	toLowerAscii func

Example:

doAssert isLowerAscii('e') == true
doAssert isLowerAscii('E') == false
doAssert isLowerAscii('7') == false

	Source   Edit   

func isSpaceAscii(c: char): bool {.....}

Checks whether or not c is a whitespace character.

Example:

doAssert isSpaceAscii('n') == false
doAssert isSpaceAscii(' ') == true
doAssert isSpaceAscii('\t') == true

	Source   Edit   

func isUpperAscii(c: char): bool {.....}

Checks whether or not c is an upper case character.

This checks ASCII characters only. Use Unicode module for UTF-8 support.

See also:

	toUpperAscii func

Example:

doAssert isUpperAscii('e') == false
doAssert isUpperAscii('E') == true
doAssert isUpperAscii('7') == false

	Source   Edit   

func join(a: openArray[string]; sep: string = ""): string {.....}

Concatenates all strings in the container a, separating them with sep.

Example:

doAssert join(["A", "B", "Conclusion"], " -> ") == "A -> B -> Conclusion"

	Source   Edit   

proc join[T: not string](a: openArray[T]; sep: string = ""): string

Converts all elements in the container a to strings using $, and concatenates them with sep.

Example:

doAssert join([1, 2, 3], " -> ") == "1 -> 2 -> 3"

	Source   Edit   

func multiReplace(s: string; replacements: varargs[(string, string)]): string {.
	....}

	Same as replace, but specialized for doing multiple replacements in a single pass through the input string.

	multiReplace performs all replacements in a single pass, this means it can be used to swap the occurrences of "a" and "b", for instance.

	If the resulting string is not longer than the original input string, only a single memory allocation is required.

	The order of the replacements does matter. Earlier replacements are preferred over later replacements in the argument list.
	Source   Edit   

func nimIdentNormalize(s: string): string {.....}

Normalizes the string s as a Nim identifier.

That means to convert to lower case and remove any '_' on all characters except first one.
Warning: Backticks (`) are not handled: they remain as is and spaces are preserved. See nimIdentBackticksNormalize for an alternative approach.

Example:

doAssert nimIdentNormalize("Foo_bar") == "Foobar"

	Source   Edit   

func normalize(s: string): string {.....}

Normalizes the string s.

That means to convert it to lower case and remove any '_'. This should NOT be used to normalize Nim identifier names.

See also:

	toLowerAscii func

Example:

doAssert normalize("Foo_bar") == "foobar"
doAssert normalize("Foo Bar") == "foo bar"

	Source   Edit   

func parseBiggestInt(s: string): BiggestInt {.....}

	Parses a decimal integer value contained in s.

	If s is not a valid integer, ValueError is raised.
	Source   Edit   

func parseBiggestUInt(s: string): BiggestUInt {.....}

	Parses a decimal unsigned integer value contained in s.

	If s is not a valid integer, ValueError is raised.
	Source   Edit   

func parseBinInt(s: string): int {.....}

Parses a binary integer value contained in s.

If s is not a valid binary integer, ValueError is raised. s can have one of the following optional prefixes: 0b, 0B. Underscores within s are ignored.

Example:

let
  a = "0b11_0101"
  b = "111"
doAssert a.parseBinInt() == 53
doAssert b.parseBinInt() == 7

	Source   Edit   

func parseBool(s: string): bool {.....}

Parses a value into a bool.

If s is one of the following values: y, yes, true, 1, on, then returns true. If s is one of the following values: n, no, false, 0, off, then returns false. If s is something else a ValueError exception is raised.

Example:

let a = "n"
doAssert parseBool(a) == false

	Source   Edit   

func parseEnum[T: enum](s: string): T

Parses an enum T. This errors at compile time, if the given enum type contains multiple fields with the same string value.

Raises ValueError for an invalid value in s. The comparison is done in a style insensitive way.

Example:

type
  MyEnum = enum
	first = "1st",
	second,
	third = "3rd"

doAssert parseEnum[MyEnum]("1_st") == first
doAssert parseEnum[MyEnum]("second") == second
doAssertRaises(ValueError):
  echo parseEnum[MyEnum]("third")

	Source   Edit   

func parseEnum[T: enum](s: string; default: T): T

Parses an enum T. This errors at compile time, if the given enum type contains multiple fields with the same string value.

Uses default for an invalid value in s. The comparison is done in a style insensitive way.

Example:

type
  MyEnum = enum
	first = "1st",
	second,
	third = "3rd"

doAssert parseEnum[MyEnum]("1_st") == first
doAssert parseEnum[MyEnum]("second") == second
doAssert parseEnum[MyEnum]("last", third) == third

	Source   Edit   

func parseFloat(s: string): float {.....}

Parses a decimal floating point value contained in s.

If s is not a valid floating point number, ValueError is raised. NAN, INF, -INF are also supported (case insensitive comparison).

Example:

doAssert parseFloat("3.14") == 3.14
doAssert parseFloat("inf") == 1.0/0

	Source   Edit   

func parseHexInt(s: string): int {.....}

	Parses a hexadecimal integer value contained in s.

	If s is not a valid hex integer, ValueError is raised. s can have one of the following optional prefixes: 0x, 0X, #. Underscores within s are ignored.
	Source   Edit   

func parseHexStr(s: string): string {.....}

Converts hex-encoded string to byte string, e.g.:

Raises ValueError for an invalid hex values. The comparison is case-insensitive.

See also:

	toHex func for the reverse operation

Example:

let
  a = "41"
  b = "3161"
  c = "00ff"
doAssert parseHexStr(a) == "A"
doAssert parseHexStr(b) == "1a"
doAssert parseHexStr(c) == "\0\255"

	Source   Edit   

func parseInt(s: string): int {.....}

Parses a decimal integer value contained in s.

If s is not a valid integer, ValueError is raised.

Example:

doAssert parseInt("-0042") == -42

	Source   Edit   

func parseOctInt(s: string): int {.....}

	Parses an octal integer value contained in s.

	If s is not a valid oct integer, ValueError is raised. s can have one of the following optional prefixes: 0o, 0O. Underscores within s are ignored.
	Source   Edit   

func parseUInt(s: string): uint {.....}

	Parses a decimal unsigned integer value contained in s.

	If s is not a valid integer, ValueError is raised.
	Source   Edit   

func removePrefix(s: var string; c: char) {.....}

Removes all occurrences of a single character (in-place) from the start of a string.

See also:

	removeSuffix func
	startsWith func

Example:

var ident = "pControl"
ident.removePrefix('p')
doAssert ident == "Control"

	Source   Edit   

func removePrefix(s: var string; chars: set[char] = Newlines) {.....}

Removes all characters from chars from the start of the string s (in-place).

See also:

	removeSuffix func

Example:

var userInput = "\r\n*~Hello World!"
userInput.removePrefix
doAssert userInput == "*~Hello World!"
userInput.removePrefix({'~', '*'})
doAssert userInput == "Hello World!"

var otherInput = "?!?Hello!?!"
otherInput.removePrefix({'!', '?'})
doAssert otherInput == "Hello!?!"

	Source   Edit   

func removePrefix(s: var string; prefix: string) {.....}

Remove the first matching prefix (in-place) from a string.

See also:

	removeSuffix func
	startsWith func

Example:

var answers = "yesyes"
answers.removePrefix("yes")
doAssert answers == "yes"

	Source   Edit   

func removeSuffix(s: var string; c: char) {.....}

Removes all occurrences of a single character (in-place) from the end of a string.

See also:

	removePrefix func
	endsWith func

Example:

var table = "users"
table.removeSuffix('s')
doAssert table == "user"

var dots = "Trailing dots......."
dots.removeSuffix('.')
doAssert dots == "Trailing dots"

	Source   Edit   

func removeSuffix(s: var string; chars: set[char] = Newlines) {.....}

Removes all characters from chars from the end of the string s (in-place).

See also:

	removePrefix func

Example:

var userInput = "Hello World!*~\r\n"
userInput.removeSuffix
doAssert userInput == "Hello World!*~"
userInput.removeSuffix({'~', '*'})
doAssert userInput == "Hello World!"

var otherInput = "Hello!?!"
otherInput.removeSuffix({'!', '?'})
doAssert otherInput == "Hello"

	Source   Edit   

func removeSuffix(s: var string; suffix: string) {.....}

Remove the first matching suffix (in-place) from a string.

See also:

	removePrefix func
	endsWith func

Example:

var answers = "yeses"
answers.removeSuffix("es")
doAssert answers == "yes"

	Source   Edit   

func repeat(c: char; count: Natural): string {.....}

Returns a string of length count consisting only of the character c.

Example:

let a = 'z'
doAssert a.repeat(5) == "zzzzz"

	Source   Edit   

func repeat(s: string; n: Natural): string {.....}

Returns string s concatenated n times.

Example:

doAssert "+ foo +".repeat(3) == "+ foo ++ foo ++ foo +"

	Source   Edit   

func replace(s, sub: string; by = ""): string {.....}

	Replaces every occurrence of the string sub in s with the string by.

	See also:

    	find func
    	replace func for replacing single characters
    	replaceWord func
    	multiReplace func

	Source   Edit   

func replace(s: string; sub, by: char): string {.....}

	Replaces every occurrence of the character sub in s with the character by.

	Optimized version of replace for characters.

	See also:

    	find func
    	replaceWord func
    	multiReplace func

	Source   Edit   

func replaceWord(s, sub: string; by = ""): string {.....}

	Replaces every occurrence of the string sub in s with the string by.

	Each occurrence of sub has to be surrounded by word boundaries (comparable to \b in regular expressions), otherwise it is not replaced.
	Source   Edit   

func rfind(s, sub: string; start: Natural = 0; last = -1): int {.....}

	Searches for sub in s inside range start..last (both ends included) included) in reverse -- starting at high indexes and moving lower to the first character or start. If last is unspecified, it defaults to s.high (the last element).

	Searching is case-sensitive. If sub is not in s, -1 is returned. Otherwise the index returned is relative to s[0], not start. Subtract start from the result for a start-origin index.

	See also:

    	find func

	Source   Edit   

func rfind(s: string; chars: set[char]; start: Natural = 0; last = -1): int {.
	....}

	Searches for chars in s inside range start..last (both ends included) in reverse -- starting at high indexes and moving lower to the first character or start. If last is unspecified, it defaults to s.high (the last element).

	If s contains none of the characters in chars, -1 is returned. Otherwise the index returned is relative to s[0], not start. Subtract start from the result for a start-origin index.

	See also:

    	find func

	Source   Edit   

func rfind(s: string; sub: char; start: Natural = 0; last = -1): int {.....}

	Searches for sub in s inside range start..last (both ends included) in reverse -- starting at high indexes and moving lower to the first character or start. If last is unspecified, it defaults to s.high (the last element).

	Searching is case-sensitive. If sub is not in s, -1 is returned. Otherwise the index returned is relative to s[0], not start. Subtract start from the result for a start-origin index.

	See also:

    	find func

	Source   Edit   

func rsplit(s: string; sep: char; maxsplit: int = -1): seq[string] {.....}

The same as the rsplit iterator, but is a func that returns a sequence of substrings in original order.

A possible common use case for rsplit is path manipulation, particularly on systems that don't use a common delimiter.

For example, if a system had # as a delimiter, you could do the following to get the tail of the path:

var tailSplit = rsplit("Root#Object#Method#Index", '#', maxsplit=1)

Results in tailSplit containing:

@["Root#Object#Method", "Index"]

	See also:

    	rsplit iterator
    	split func
    	splitLines func
    	splitWhitespace func

	Source   Edit   

func rsplit(s: string; sep: string; maxsplit: int = -1): seq[string] {.....}

The same as the rsplit iterator, but is a func that returns a sequence of substrings in original order.

A possible common use case for rsplit is path manipulation, particularly on systems that don't use a common delimiter.

For example, if a system had # as a delimiter, you could do the following to get the tail of the path:

var tailSplit = rsplit("Root#Object#Method#Index", "#", maxsplit=1)

Results in tailSplit containing:

@["Root#Object#Method", "Index"]

Note: Empty separator string results in returning an original string, following the interpretation "split by no element".

See also:

	rsplit iterator
	split func
	splitLines func
	splitWhitespace func

Example:

doAssert "a  largely	spaced sentence".rsplit(" ", maxsplit = 1) == @[
	"a  largely	spaced", "sentence"]
doAssert "a,b,c".rsplit(",") == @["a", "b", "c"]
doAssert "a man a plan a canal panama".rsplit("a ") == @["", "man ",
	"plan ", "canal panama"]
doAssert "".rsplit("Elon Musk") == @[""]
doAssert "a  largely	spaced sentence".rsplit(" ") == @["a", "",
	"largely", "", "", "", "spaced", "sentence"]
doAssert "empty sep returns unsplit s".rsplit("") == @["empty sep returns unsplit s"]

	Source   Edit   

func rsplit(s: string; seps: set[char] = Whitespace; maxsplit: int = -1): seq[
	string] {.....}

The same as the rsplit iterator, but is a func that returns a sequence of substrings in original order.

A possible common use case for rsplit is path manipulation, particularly on systems that don't use a common delimiter.

For example, if a system had # as a delimiter, you could do the following to get the tail of the path:

var tailSplit = rsplit("Root#Object#Method#Index", {'#'}, maxsplit=1)

Results in tailSplit containing:

@["Root#Object#Method", "Index"]

	Note: Empty separator set results in returning an original string, following the interpretation "split by no element".

	See also:

    	rsplit iterator
    	split func
    	splitLines func
    	splitWhitespace func

	Source   Edit   

func spaces(n: Natural): string {.inline, ....}

Returns a string with n space characters. You can use this func to left align strings.

See also:

	align func
	alignLeft func
	indent func
	center func

Example:

let
  width = 15
  text1 = "Hello user!"
  text2 = "This is a very long string"
doAssert text1 & spaces(max(0, width - text1.len)) & "|" ==
     	"Hello user!	|"
doAssert text2 & spaces(max(0, width - text2.len)) & "|" ==
     	"This is a very long string|"

	Source   Edit   

func split(s: string; sep: char; maxsplit: int = -1): seq[string] {.....}

The same as the split iterator (see its documentation), but is a func that returns a sequence of substrings.

See also:

	split iterator
	rsplit func
	splitLines func
	splitWhitespace func

Example:

doAssert "a,b,c".split(',') == @["a", "b", "c"]
doAssert "".split(' ') == @[""]

	Source   Edit   

func split(s: string; sep: string; maxsplit: int = -1): seq[string] {.....}

Splits the string s into substrings using a string separator.

Substrings are separated by the string sep. This is a wrapper around the split iterator.
Note: Empty separator string results in returning an original string, following the interpretation "split by no element".

See also:

	split iterator
	rsplit func
	splitLines func
	splitWhitespace func

Example:

doAssert "a,b,c".split(",") == @["a", "b", "c"]
doAssert "a man a plan a canal panama".split("a ") == @["", "man ", "plan ", "canal panama"]
doAssert "".split("Elon Musk") == @[""]
doAssert "a  largely	spaced sentence".split(" ") == @["a", "", "largely",
	"", "", "", "spaced", "sentence"]
doAssert "a  largely	spaced sentence".split(" ", maxsplit = 1) == @["a", " largely	spaced sentence"]
doAssert "empty sep returns unsplit s".split("") == @["empty sep returns unsplit s"]

	Source   Edit   

func split(s: string; seps: set[char] = Whitespace; maxsplit: int = -1): seq[
	string] {.....}

The same as the split iterator (see its documentation), but is a func that returns a sequence of substrings.
Note: Empty separator set results in returning an original string, following the interpretation "split by no element".

See also:

	split iterator
	rsplit func
	splitLines func
	splitWhitespace func

Example:

doAssert "a,b;c".split({',', ';'}) == @["a", "b", "c"]
doAssert "".split({' '}) == @[""]
doAssert "empty seps return unsplit s".split({}) == @["empty seps return unsplit s"]

	Source   Edit   

func splitLines(s: string; keepEol = false): seq[string] {.....}

	The same as the splitLines iterator (see its documentation), but is a func that returns a sequence of substrings.

	See also:

    	splitLines iterator
    	splitWhitespace func
    	countLines func

	Source   Edit   

func splitWhitespace(s: string; maxsplit: int = -1): seq[string] {.....}

	The same as the splitWhitespace iterator (see its documentation), but is a func that returns a sequence of substrings.

	See also:

    	splitWhitespace iterator
    	splitLines func

	Source   Edit   

func startsWith(s, prefix: string): bool {.....}

Returns true if s starts with string prefix.

If prefix == "" true is returned.

See also:

	endsWith func
	continuesWith func
	removePrefix func

Example:

let a = "abracadabra"
doAssert a.startsWith("abra") == true
doAssert a.startsWith("bra") == false

	Source   Edit   

func startsWith(s: string; prefix: char): bool {.inline, ....}

Returns true if s starts with character prefix.

See also:

	endsWith func
	continuesWith func
	removePrefix func

Example:

let a = "abracadabra"
doAssert a.startsWith('a') == true
doAssert a.startsWith('b') == false

	Source   Edit   

func strip(s: string; leading = true; trailing = true;
       	chars: set[char] = Whitespace): string {.....}

Strips leading or trailing chars (default: whitespace characters) from s and returns the resulting string.

If leading is true (default), leading chars are stripped. If trailing is true (default), trailing chars are stripped. If both are false, the string is returned unchanged.

See also:

	strip proc Inplace version.
	stripLineEnd func

Example:

let a = "  vhellov   "
let b = strip(a)
doAssert b == "vhellov"

doAssert a.strip(leading = false) == "  vhellov"
doAssert a.strip(trailing = false) == "vhellov   "

doAssert b.strip(chars = {'v'}) == "hello"
doAssert b.strip(leading = false, chars = {'v'}) == "vhello"

let c = "blaXbla"
doAssert c.strip(chars = {'b', 'a'}) == "laXbl"
doAssert c.strip(chars = {'b', 'a', 'l'}) == "X"

	Source   Edit   

func stripLineEnd(s: var string) {.....}

Strips one of these suffixes from s in-place: \r, \n, \r\n, \f, \v (at most once instance). For example, can be useful in conjunction with osproc.execCmdEx. aka: chomp

Example:

var s = "foo\n\n"
s.stripLineEnd
doAssert s == "foo\n"
s = "foo\r\n"
s.stripLineEnd
doAssert s == "foo"

	Source   Edit   

func toBin(x: BiggestInt; len: Positive): string {.....}

Converts x into its binary representation.

The resulting string is always len characters long. No leading 0b prefix is generated.

Example:

let
  a = 29
  b = 257
doAssert a.toBin(8) == "00011101"
doAssert b.toBin(8) == "00000001"
doAssert b.toBin(9) == "100000001"

	Source   Edit   

func toHex(s: string): string {.....}

Converts a bytes string to its hexadecimal representation.

The output is twice the input long. No prefix like 0x is generated.

See also:

	parseHexStr func for the reverse operation

Example:

let
  a = "1"
  b = "A"
  c = "\0\255"
doAssert a.toHex() == "31"
doAssert b.toHex() == "41"
doAssert c.toHex() == "00FF"

	Source   Edit   

func toHex[T: SomeInteger](x: T): string

Shortcut for toHex(x, T.sizeof * 2)

Example:

doAssert toHex(1984'i64) == "00000000000007C0"
doAssert toHex(1984'i16) == "07C0"

	Source   Edit   

func toHex[T: SomeInteger](x: T; len: Positive): string

Converts x to its hexadecimal representation.

The resulting string will be exactly len characters long. No prefix like 0x is generated. x is treated as an unsigned value.

Example:

let
  a = 62'u64
  b = 4097'u64
doAssert a.toHex(3) == "03E"
doAssert b.toHex(3) == "001"
doAssert b.toHex(4) == "1001"
doAssert toHex(62, 3) == "03E"
doAssert toHex(-8, 6) == "FFFFF8"

	Source   Edit   

func toLowerAscii(c: char): char {.....}

Returns the lower case version of character c.

This works only for the letters A-Z. See unicode.toLower for a version that works for any Unicode character.

See also:

	isLowerAscii func
	toLowerAscii func for converting a string

Example:

doAssert toLowerAscii('A') == 'a'
doAssert toLowerAscii('e') == 'e'

	Source   Edit   

func toLowerAscii(s: string): string {.....}

Converts string s into lower case.

This works only for the letters A-Z. See unicode.toLower for a version that works for any Unicode character.

See also:

	normalize func

Example:

doAssert toLowerAscii("FooBar!") == "foobar!"

	Source   Edit   

func toOct(x: BiggestInt; len: Positive): string {.....}

Converts x into its octal representation.

The resulting string is always len characters long. No leading 0o prefix is generated.

Do not confuse it with toOctal func.

Example:

let
  a = 62
  b = 513
doAssert a.toOct(3) == "076"
doAssert b.toOct(3) == "001"
doAssert b.toOct(5) == "01001"

	Source   Edit   

func toOctal(c: char): string {.....}

Converts a character c to its octal representation.

The resulting string may not have a leading zero. Its length is always exactly 3.

Do not confuse it with toOct func.

Example:

doAssert toOctal('1') == "061"
doAssert toOctal('A') == "101"
doAssert toOctal('a') == "141"
doAssert toOctal('!') == "041"

	Source   Edit   

func toUpperAscii(c: char): char {.....}

Converts character c into upper case.

This works only for the letters A-Z. See unicode.toUpper for a version that works for any Unicode character.

See also:

	isUpperAscii func
	toUpperAscii func for converting a string
	capitalizeAscii func

Example:

doAssert toUpperAscii('a') == 'A'
doAssert toUpperAscii('E') == 'E'

	Source   Edit   

func toUpperAscii(s: string): string {.....}

Converts string s into upper case.

This works only for the letters A-Z. See unicode.toUpper for a version that works for any Unicode character.

See also:

	capitalizeAscii func

Example:

doAssert toUpperAscii("FooBar!") == "FOOBAR!"

	Source   Edit   

func trimZeros(x: var string; decimalSep = '.') {.....}

Trim trailing zeros from a formatted floating point value x (must be declared as var).

This modifies x itself, it does not return a copy.

Example:

var x = "123.456000000"
x.trimZeros()
doAssert x == "123.456"

	Source   Edit   

func unescape(s: string; prefix = "\""; suffix = "\""): string {.....}

	Unescapes a string s.

	This complements escape func as it performs the opposite operations.

	If s does not begin with prefix and end with suffix a ValueError exception will be raised.
	Source   Edit   

func unindent(s: string; count: Natural = int.high; padding: string = " "): string {.
	....}

Unindents each line in s by count amount of padding.

Note: This does not preserve the new line characters used in s.

See also:

	dedent func
	align func
	alignLeft func
	spaces func
	indent func

Example:

let x = """
  	Hello
    	There
	""".unindent()

doAssert x == "Hello\nThere\n"

	Source   Edit   

func validIdentifier(s: string): bool {.....}

Returns true if s is a valid identifier.

A valid identifier starts with a character of the set IdentStartChars and is followed by any number of characters of the set IdentChars.

Example:

doAssert "abc_def08".validIdentifier

	Source   Edit   

Iterators

iterator rsplit(s: string; sep: char; maxsplit: int = -1): string {.....}

Splits the string s into substrings from the right using a string separator. Works exactly the same as split iterator except in reverse order.

for piece in "foo:bar".rsplit(':'):
  echo piece

Results in:

"bar"
"foo"

	Substrings are separated from the right by the char sep.

	See also:

    	split iterator
    	splitLines iterator
    	splitWhitespace iterator
    	rsplit func

	Source   Edit   

iterator rsplit(s: string; sep: string; maxsplit: int = -1;
            	keepSeparators: bool = false): string {.....}

Splits the string s into substrings from the right using a string separator. Works exactly the same as split iterator except in reverse order.

for piece in "foothebar".rsplit("the"):
  echo piece

Results in:

"bar"
"foo"

	Substrings are separated from the right by the string sep
	Note: Empty separator string results in returning an original string, following the interpretation "split by no element".

	See also:

    	split iterator
    	splitLines iterator
    	splitWhitespace iterator
    	rsplit func

	Source   Edit   

iterator rsplit(s: string; seps: set[char] = Whitespace; maxsplit: int = -1): string {.
	....}

Splits the string s into substrings from the right using a string separator. Works exactly the same as split iterator except in reverse order.

for piece in "foo bar".rsplit(WhiteSpace):
  echo piece

Results in:

"bar"
"foo"

	Substrings are separated from the right by the set of chars seps
	Note: Empty separator set results in returning an original string, following the interpretation "split by no element".

	See also:

    	split iterator
    	splitLines iterator
    	splitWhitespace iterator
    	rsplit func

	Source   Edit   

iterator split(s: string; sep: char; maxsplit: int = -1): string {.....}

Splits the string s into substrings using a single separator.

Substrings are separated by the character sep. The code:

for word in split(";;this;is;an;;example;;;", ';'):
  writeLine(stdout, word)

Results in:

""
""
"this"
"is"
"an"
""
"example"
""
""
""

	See also:

    	rsplit iterator
    	splitLines iterator
    	splitWhitespace iterator
    	split func

	Source   Edit   

iterator split(s: string; sep: string; maxsplit: int = -1): string {.....}

Splits the string s into substrings using a string separator.

Substrings are separated by the string sep. The code:

for word in split("thisDATAisDATAcorrupted", "DATA"):
  writeLine(stdout, word)

Results in:

"this"
"is"
"corrupted"

	Note: Empty separator string results in returning an original string, following the interpretation "split by no element".

	See also:

    	rsplit iterator
    	splitLines iterator
    	splitWhitespace iterator
    	split func

	Source   Edit   

iterator split(s: string; seps: set[char] = Whitespace; maxsplit: int = -1): string {.
	....}

Splits the string s into substrings using a group of separators.

Substrings are separated by a substring containing only seps.

for word in split("this\lis an\texample"):
  writeLine(stdout, word)

...generates this output:

"this"
"is"
"an"
"example"

And the following code:

for word in split("this:is;an$example", {';', ':', '$'}):
  writeLine(stdout, word)

...produces the same output as the first example. The code:

let date = "2012-11-20T22:08:08.398990"
let separators = {' ', '-', ':', 'T'}
for number in split(date, separators):
  writeLine(stdout, number)

...results in:

"2012"
"11"
"20"
"22"
"08"
"08.398990"

	Note: Empty separator set results in returning an original string, following the interpretation "split by no element".

	See also:

    	rsplit iterator
    	splitLines iterator
    	splitWhitespace iterator
    	split func

	Source   Edit   

iterator splitLines(s: string; keepEol = false): string {.....}

Splits the string s into its containing lines.

Every character literal newline combination (CR, LF, CR-LF) is supported. The result strings contain no trailing end of line characters unless the parameter keepEol is set to true.

Example:

for line in splitLines("\nthis\nis\nan\n\nexample\n"):
  writeLine(stdout, line)

Results in:

""
"this"
"is"
"an"
""
"example"
""

	See also:

    	splitWhitespace iterator
    	splitLines func

	Source   Edit   

iterator splitWhitespace(s: string; maxsplit: int = -1): string {.....}

Splits the string s at whitespace stripping leading and trailing whitespace if necessary. If maxsplit is specified and is positive, no more than maxsplit splits is made.

The following code:

let s = "  foo \t bar  baz  "
for ms in [-1, 1, 2, 3]:
  echo "------ maxsplit = ", ms, ":"
  for item in s.splitWhitespace(maxsplit=ms):
	echo '"', item, '"'

...results in:

------ maxsplit = -1:
"foo"
"bar"
"baz"
------ maxsplit = 1:
"foo"
"bar  baz  "
------ maxsplit = 2:
"foo"
"bar"
"baz  "
------ maxsplit = 3:
"foo"
"bar"
"baz"

	See also:

    	splitLines iterator
    	splitWhitespace func

	Source   Edit   

iterator tokenize(s: string; seps: set[char] = Whitespace): tuple[token: string,
	isSep: bool] {.....}

Tokenizes the string s into substrings.

Substrings are separated by a substring containing only seps. Example:

for word in tokenize("  this is an  example  "):
  writeLine(stdout, word)

Results in:

("  ", true)
("this", false)
(" ", true)
("is", false)
(" ", true)
("an", false)
("  ", true)
("example", false)
("  ", true)

	Source   Edit   

Exports

toLower, toLower, toLower, toUpper, toUpper, toUpper


std/unicode


std/unicode
Source   Edit  

This module provides support to handle the Unicode UTF-8 encoding.

There are no specialized insert, delete, add and contains procedures for seq[Rune] in this module because the generic variants of these procedures in the system module already work with it.

The current version is compatible with Unicode v12.0.0.

See also:

	strutils module
	unidecode module
	encodings module

Imports

strbasics

Types

Rune = distinct RuneImpl

	Type that can hold a single Unicode code point.

	A Rune may be composed with other Runes to a character on the screen. RuneImpl is the underlying type used to store Runes, currently int32.
	Source   Edit   

Procs

proc `$`(rune: Rune): string {.....}

	An alias for toUTF8.

	See also:

    	validateUtf8 proc
    	fastToUTF8Copy template

	Source   Edit   

proc `$`(runes: seq[Rune]): string {.....}

Converts a sequence of Runes to a string.

See also:

	toRunes for a reverse operation

Example:

let
  someString = "öÑ"
  someRunes = toRunes(someString)
doAssert $someRunes == someString

	Source   Edit   

proc `<%`(a, b: Rune): bool {.....}

Checks if code point of a is smaller than code point of b.

Example:

let
  a = "ú".runeAt(0)
  b = "ü".runeAt(0)
doAssert a <% b

	Source   Edit   

proc `<=%`(a, b: Rune): bool {.....}

Checks if code point of a is smaller or equal to code point of b.

Example:

let
  a = "ú".runeAt(0)
  b = "ü".runeAt(0)
doAssert a <=% b

	Source   Edit   

proc `==`(a, b: Rune): bool {.....}

	Checks if two runes are equal. Source   Edit   

proc add(s: var string; c: Rune) {.....}

Adds a rune c to a string s.

Example:

var s = "abc"
let c = "ä".runeAt(0)
s.add(c)
doAssert s == "abcä"

	Source   Edit   

proc align(s: openArray[char]; count: Natural; padding = ' '.Rune): string {.
	noSideEffect, ....}

Aligns a unicode string s with padding, so that it has a rune-length of count.

padding characters (by default spaces) are added before s resulting in right alignment. If s.runelen >= count, no spaces are added and s is returned unchanged. If you need to left align a string use the alignLeft proc.

Example:

assert align("abc", 4) == " abc"
assert align("a", 0) == "a"
assert align("1232", 6) == "  1232"
assert align("1232", 6, '#'.Rune) == "##1232"
assert align("Åge", 5) == "  Åge"
assert align("×", 4, '_'.Rune) == "___×"

	Source   Edit   

proc align(s: string; count: Natural; padding = ' '.Rune): string {.
	noSideEffect, inline, ....}

Aligns a unicode string s with padding, so that it has a rune-length of count.

padding characters (by default spaces) are added before s resulting in right alignment. If s.runelen >= count, no spaces are added and s is returned unchanged. If you need to left align a string use the alignLeft proc.

Example:

assert align("abc", 4) == " abc"
assert align("a", 0) == "a"
assert align("1232", 6) == "  1232"
assert align("1232", 6, '#'.Rune) == "##1232"
assert align("Åge", 5) == "  Åge"
assert align("×", 4, '_'.Rune) == "___×"

	Source   Edit   

proc alignLeft(s: openArray[char]; count: Natural; padding = ' '.Rune): string {.
	noSideEffect, ....}

Left-aligns a unicode string s with padding, so that it has a rune-length of count.

padding characters (by default spaces) are added after s resulting in left alignment. If s.runelen >= count, no spaces are added and s is returned unchanged. If you need to right align a string use the align proc.

Example:

assert alignLeft("abc", 4) == "abc "
assert alignLeft("a", 0) == "a"
assert alignLeft("1232", 6) == "1232  "
assert alignLeft("1232", 6, '#'.Rune) == "1232##"
assert alignLeft("Åge", 5) == "Åge  "
assert alignLeft("×", 4, '_'.Rune) == "×___"

	Source   Edit   

proc alignLeft(s: string; count: Natural; padding = ' '.Rune): string {.
	noSideEffect, inline, ....}

Left-aligns a unicode string s with padding, so that it has a rune-length of count.

padding characters (by default spaces) are added after s resulting in left alignment. If s.runelen >= count, no spaces are added and s is returned unchanged. If you need to right align a string use the align proc.

Example:

assert alignLeft("abc", 4) == "abc "
assert alignLeft("a", 0) == "a"
assert alignLeft("1232", 6) == "1232  "
assert alignLeft("1232", 6, '#'.Rune) == "1232##"
assert alignLeft("Åge", 5) == "Åge  "
assert alignLeft("×", 4, '_'.Rune) == "×___"

	Source   Edit   

proc capitalize(s: openArray[char]): string {.noSideEffect, ....}

Converts the first character of s into an upper-case rune.

Example:

doAssert capitalize("βeta") == "Βeta"

	Source   Edit   

proc capitalize(s: string): string {.noSideEffect, ....}

Converts the first character of s into an upper-case rune.

Example:

doAssert capitalize("βeta") == "Βeta"

	Source   Edit   

proc cmpRunesIgnoreCase(a, b: openArray[char]): int {.....}

	Compares two UTF-8 strings and ignores the case. Returns:

	0 if a == b
	< 0 if a < b
	> 0 if a > b
	Source   Edit   

proc cmpRunesIgnoreCase(a, b: string): int {.inline, ....}

	Compares two UTF-8 strings and ignores the case. Returns:

	0 if a == b
	< 0 if a < b
	> 0 if a > b
	Source   Edit   

proc graphemeLen(s: openArray[char]; i: Natural): Natural {.....}

The number of bytes belonging to byte index s[i], including following combining code units.

Example:

let a = "añyóng"
doAssert a.graphemeLen(1) == 2 ## ñ
doAssert a.graphemeLen(2) == 1
doAssert a.graphemeLen(4) == 2 ## ó

	Source   Edit   

proc graphemeLen(s: string; i: Natural): Natural {.inline, ....}

The number of bytes belonging to byte index s[i], including following combining code unit.

Example:

let a = "añyóng"
doAssert a.graphemeLen(1) == 2 ## ñ
doAssert a.graphemeLen(2) == 1
doAssert a.graphemeLen(4) == 2 ## ó

	Source   Edit   

proc isAlpha(c: Rune): bool {.....}

	Returns true if c is an alpha rune (i.e., a letter).

	See also:

    	isLower proc
    	isTitle proc
    	isAlpha proc
    	isWhiteSpace proc
    	isCombining proc

	Source   Edit   

proc isAlpha(s: openArray[char]): bool {.noSideEffect, ....}

Returns true if s contains all alphabetic runes.

Example:

let a = "añyóng"
doAssert a.isAlpha

	Source   Edit   

proc isAlpha(s: string): bool {.noSideEffect, inline, ....}

Returns true if s contains all alphabetic runes.

Example:

let a = "añyóng"
doAssert a.isAlpha

	Source   Edit   

proc isCombining(c: Rune): bool {.....}

	Returns true if c is a Unicode combining code unit.

	See also:

    	isLower proc
    	isUpper proc
    	isTitle proc
    	isAlpha proc

	Source   Edit   

proc isLower(c: Rune): bool {.....}

	Returns true if c is a lower case rune.

	If possible, prefer isLower over isUpper.

	See also:

    	toLower proc
    	isUpper proc
    	isTitle proc

	Source   Edit   

proc isSpace(s: openArray[char]): bool {.noSideEffect, ....}

Returns true if s contains all whitespace runes.

Example:

let a = "\t\l \v\r\f"
doAssert a.isSpace

	Source   Edit   

proc isSpace(s: string): bool {.noSideEffect, inline, ....}

Returns true if s contains all whitespace runes.

Example:

let a = "\t\l \v\r\f"
doAssert a.isSpace

	Source   Edit   

proc isTitle(c: Rune): bool {.....}

	Returns true if c is a Unicode titlecase code point.

	See also:

    	toTitle proc
    	isLower proc
    	isUpper proc
    	isAlpha proc
    	isWhiteSpace proc

	Source   Edit   

proc isUpper(c: Rune): bool {.....}

	Returns true if c is a upper case rune.

	If possible, prefer isLower over isUpper.

	See also:

    	toUpper proc
    	isLower proc
    	isTitle proc
    	isAlpha proc
    	isWhiteSpace proc

	Source   Edit   

proc isWhiteSpace(c: Rune): bool {.....}

	Returns true if c is a Unicode whitespace code point.

	See also:

    	isLower proc
    	isUpper proc
    	isTitle proc
    	isAlpha proc

	Source   Edit   

proc lastRune(s: openArray[char]; last: int): (Rune, int) {.....}

	Length of the last rune in s[0..last]. Returns the rune and its length in bytes. Source   Edit   

proc lastRune(s: string; last: int): (Rune, int) {.inline, ....}

	Length of the last rune in s[0..last]. Returns the rune and its length in bytes. Source   Edit   

proc repeat(c: Rune; count: Natural): string {.noSideEffect, ....}

Returns a string of count Runes c.

The returned string will have a rune-length of count.

Example:

let a = "ñ".runeAt(0)
doAssert a.repeat(5) == "ñññññ"

	Source   Edit   

proc reversed(s: openArray[char]): string {.....}

Returns the reverse of s, interpreting it as runes.

Unicode combining characters are correctly interpreted as well.

Example:

assert reversed("Reverse this!") == "!siht esreveR"
assert reversed("先秦兩漢") == "漢兩秦先"
assert reversed("as⃝df̅") == "f̅ds⃝a"
assert reversed("a⃞b⃞c⃞") == "c⃞b⃞a⃞"

	Source   Edit   

proc reversed(s: string): string {.inline, ....}

Returns the reverse of s, interpreting it as runes.

Unicode combining characters are correctly interpreted as well.

Example:

assert reversed("Reverse this!") == "!siht esreveR"
assert reversed("先秦兩漢") == "漢兩秦先"
assert reversed("as⃝df̅") == "f̅ds⃝a"
assert reversed("a⃞b⃞c⃞") == "c⃞b⃞a⃞"

	Source   Edit   

proc runeAt(s: openArray[char]; i: Natural): Rune {.....}

Returns the rune in s at byte index i.

See also:

	runeAtPos proc
	runeStrAtPos proc
	fastRuneAt template

Example:

let a = "añyóng"
doAssert a.runeAt(1) == "ñ".runeAt(0)
doAssert a.runeAt(2) == "ñ".runeAt(1)
doAssert a.runeAt(3) == "y".runeAt(0)

	Source   Edit   

proc runeAt(s: string; i: Natural): Rune {.inline, ....}

Returns the rune in s at byte index i.

See also:

	runeAtPos proc
	runeStrAtPos proc
	fastRuneAt template

Example:

let a = "añyóng"
doAssert a.runeAt(1) == "ñ".runeAt(0)
doAssert a.runeAt(2) == "ñ".runeAt(1)
doAssert a.runeAt(3) == "y".runeAt(0)

	Source   Edit   

proc runeAtPos(s: openArray[char]; pos: int): Rune {.....}

	Returns the rune at position pos.

	Beware: This can lead to unoptimized code and slow execution! Most problems can be solved more efficiently by using an iterator or conversion to a seq of Rune.

	See also:

    	runeAt proc
    	runeStrAtPos proc
    	fastRuneAt template

	Source   Edit   

proc runeAtPos(s: string; pos: int): Rune {.inline, ....}

	Returns the rune at position pos.

	Beware: This can lead to unoptimized code and slow execution! Most problems can be solved more efficiently by using an iterator or conversion to a seq of Rune.

	See also:

    	runeAt proc
    	runeStrAtPos proc
    	fastRuneAt template

	Source   Edit   

proc runeLen(s: openArray[char]): int {.....}

Returns the number of runes of the string s.

Example:

let a = "añyóng"
doAssert a.runeLen == 6
## note: a.len == 8

	Source   Edit   

proc runeLen(s: string): int {.inline, ....}

Returns the number of runes of the string s.

Example:

let a = "añyóng"
doAssert a.runeLen == 6
## note: a.len == 8

	Source   Edit   

proc runeLenAt(s: openArray[char]; i: Natural): int {.....}

Returns the number of bytes the rune starting at s[i] takes.

See also:

	fastRuneAt template

Example:

let a = "añyóng"
doAssert a.runeLenAt(0) == 1
doAssert a.runeLenAt(1) == 2

	Source   Edit   

proc runeLenAt(s: string; i: Natural): int {.inline, ....}

Returns the number of bytes the rune starting at s[i] takes.

See also:

	fastRuneAt template

Example:

let a = "añyóng"
doAssert a.runeLenAt(0) == 1
doAssert a.runeLenAt(1) == 2

	Source   Edit   

proc runeOffset(s: openArray[char]; pos: Natural; start: Natural = 0): int {.
	....}

Returns the byte position of rune at position pos in s with an optional start byte position. Returns the special value -1 if it runs out of the string.

Beware: This can lead to unoptimized code and slow execution! Most problems can be solved more efficiently by using an iterator or conversion to a seq of Rune.

See also:

	runeReverseOffset proc

Example:

let a = "añyóng"
doAssert a.runeOffset(1) == 1
doAssert a.runeOffset(3) == 4
doAssert a.runeOffset(4) == 6

	Source   Edit   

proc runeOffset(s: string; pos: Natural; start: Natural = 0): int {.inline,
	....}

Returns the byte position of rune at position pos in s with an optional start byte position. Returns the special value -1 if it runs out of the string.

Beware: This can lead to unoptimized code and slow execution! Most problems can be solved more efficiently by using an iterator or conversion to a seq of Rune.

See also:

	runeReverseOffset proc

Example:

let a = "añyóng"
doAssert a.runeOffset(1) == 1
doAssert a.runeOffset(3) == 4
doAssert a.runeOffset(4) == 6

	Source   Edit   

proc runeReverseOffset(s: openArray[char]; rev: Positive): (int, int) {.
	....}

	Returns a tuple with the byte offset of the rune at position rev in s, counting from the end (starting with 1) and the total number of runes in the string.

	Returns a negative value for offset if there are too few runes in the string to satisfy the request.

	Beware: This can lead to unoptimized code and slow execution! Most problems can be solved more efficiently by using an iterator or conversion to a seq of Rune.

	See also:

    	runeOffset proc

	Source   Edit   

proc runeReverseOffset(s: string; rev: Positive): (int, int) {.inline,
	....}

	Returns a tuple with the byte offset of the rune at position rev in s, counting from the end (starting with 1) and the total number of runes in the string.

	Returns a negative value for offset if there are too few runes in the string to satisfy the request.

	Beware: This can lead to unoptimized code and slow execution! Most problems can be solved more efficiently by using an iterator or conversion to a seq of Rune.

	See also:

    	runeOffset proc

	Source   Edit   

proc runeStrAtPos(s: openArray[char]; pos: Natural): string {.....}

	Returns the rune at position pos as UTF8 String.

	Beware: This can lead to unoptimized code and slow execution! Most problems can be solved more efficiently by using an iterator or conversion to a seq of Rune.

	See also:

    	runeAt proc
    	runeAtPos proc
    	fastRuneAt template

	Source   Edit   

proc runeStrAtPos(s: string; pos: Natural): string {.inline, ....}

	Returns the rune at position pos as UTF8 String.

	Beware: This can lead to unoptimized code and slow execution! Most problems can be solved more efficiently by using an iterator or conversion to a seq of Rune.

	See also:

    	runeAt proc
    	runeAtPos proc
    	fastRuneAt template

	Source   Edit   

proc runeSubStr(s: openArray[char]; pos: int; len: int = int.high): string {.
	....}

Returns the UTF-8 substring starting at code point pos with len code points.

If pos or len is negative they count from the end of the string. If len is not given it means the longest possible string.

Example:

let s = "Hänsel  ««: 10,00€"
doAssert(runeSubStr(s, 0, 2) == "Hä")
doAssert(runeSubStr(s, 10, 1) == ":")
doAssert(runeSubStr(s, -6) == "10,00€")
doAssert(runeSubStr(s, 10) == ": 10,00€")
doAssert(runeSubStr(s, 12, 5) == "10,00")
doAssert(runeSubStr(s, -6, 3) == "10,")

	Source   Edit   

proc runeSubStr(s: string; pos: int; len: int = int.high): string {.inline,
	....}

Returns the UTF-8 substring starting at code point pos with len code points.

If pos or len is negative they count from the end of the string. If len is not given it means the longest possible string.

Example:

let s = "Hänsel  ««: 10,00€"
doAssert(runeSubStr(s, 0, 2) == "Hä")
doAssert(runeSubStr(s, 10, 1) == ":")
doAssert(runeSubStr(s, -6) == "10,00€")
doAssert(runeSubStr(s, 10) == ": 10,00€")
doAssert(runeSubStr(s, 12, 5) == "10,00")
doAssert(runeSubStr(s, -6, 3) == "10,")

	Source   Edit   

proc size(r: Rune): int {.noSideEffect, ....}

Returns the number of bytes the rune r takes.

Example:

let a = toRunes "aá"
doAssert size(a[0]) == 1
doAssert size(a[1]) == 2

	Source   Edit   

proc split(s: openArray[char]; sep: Rune; maxsplit: int = -1): seq[string] {.
	noSideEffect, ....}

	The same as the split iterator, but is a proc that returns a sequence of substrings. Source   Edit   

proc split(s: openArray[char]; seps: openArray[Rune] = unicodeSpaces;
       	maxsplit: int = -1): seq[string] {.noSideEffect, ....}

	The same as the split iterator, but is a proc that returns a sequence of substrings. Source   Edit   

proc split(s: string; sep: Rune; maxsplit: int = -1): seq[string] {.
	noSideEffect, inline, ....}

	The same as the split iterator, but is a proc that returns a sequence of substrings. Source   Edit   

proc split(s: string; seps: openArray[Rune] = unicodeSpaces; maxsplit: int = -1): seq[
	string] {.noSideEffect, inline, ....}

	The same as the split iterator, but is a proc that returns a sequence of substrings. Source   Edit   

proc splitWhitespace(s: openArray[char]): seq[string] {.noSideEffect, ....}

	The same as the splitWhitespace iterator, but is a proc that returns a sequence of substrings. Source   Edit   

proc splitWhitespace(s: string): seq[string] {.noSideEffect, inline, ....}

	The same as the splitWhitespace iterator, but is a proc that returns a sequence of substrings. Source   Edit   

proc strip(s: openArray[char]; leading = true; trailing = true;
       	runes: openArray[Rune] = unicodeSpaces): string {.noSideEffect,
	....}

Strips leading or trailing runes from s and returns the resulting string.

If leading is true (default), leading runes are stripped. If trailing is true (default), trailing runes are stripped. If both are false, the string is returned unchanged.

Example:

let a = "\táñyóng   "
doAssert a.strip == "áñyóng"
doAssert a.strip(leading = false) == "\táñyóng"
doAssert a.strip(trailing = false) == "áñyóng   "

	Source   Edit   

proc strip(s: string; leading = true; trailing = true;
       	runes: openArray[Rune] = unicodeSpaces): string {.noSideEffect,
	inline, ....}

Strips leading or trailing runes from s and returns the resulting string.

If leading is true (default), leading runes are stripped. If trailing is true (default), trailing runes are stripped. If both are false, the string is returned unchanged.

Example:

let a = "\táñyóng   "
doAssert a.strip == "áñyóng"
doAssert a.strip(leading = false) == "\táñyóng"
doAssert a.strip(trailing = false) == "áñyóng   "

	Source   Edit   

proc swapCase(s: openArray[char]): string {.noSideEffect, ....}

Swaps the case of runes in s.

Returns a new string such that the cases of all runes are swapped if possible.

Example:

doAssert swapCase("Αlpha Βeta Γamma") == "αLPHA βETA γAMMA"

	Source   Edit   

proc swapCase(s: string): string {.noSideEffect, inline, ....}

Swaps the case of runes in s.

Returns a new string such that the cases of all runes are swapped if possible.

Example:

doAssert swapCase("Αlpha Βeta Γamma") == "αLPHA βETA γAMMA"

	Source   Edit   

proc title(s: openArray[char]): string {.noSideEffect, ....}

Converts s to a unicode title.

Returns a new string such that the first character in each word inside s is capitalized.

Example:

doAssert title("αlpha βeta γamma") == "Αlpha Βeta Γamma"

	Source   Edit   

proc title(s: string): string {.noSideEffect, inline, ....}

Converts s to a unicode title.

Returns a new string such that the first character in each word inside s is capitalized.

Example:

doAssert title("αlpha βeta γamma") == "Αlpha Βeta Γamma"

	Source   Edit   

proc toLower(c: Rune): Rune {.....}

	Converts c into lower case. This works for any rune.

	If possible, prefer toLower over toUpper.

	See also:

    	toUpper proc
    	toTitle proc
    	isLower proc

	Source   Edit   

proc toLower(s: openArray[char]): string {.noSideEffect, ....}

Converts s into lower-case runes.

Example:

doAssert toLower("ABΓ") == "abγ"

	Source   Edit   

proc toLower(s: string): string {.noSideEffect, inline, ....}

Converts s into lower-case runes.

Example:

doAssert toLower("ABΓ") == "abγ"

	Source   Edit   

proc toRunes(s: openArray[char]): seq[Rune] {.....}

Obtains a sequence containing the Runes in s.

See also:

	$ proc for a reverse operation

Example:

let a = toRunes("aáä")
doAssert a == @["a".runeAt(0), "á".runeAt(0), "ä".runeAt(0)]

	Source   Edit   

proc toRunes(s: string): seq[Rune] {.inline, ....}

Obtains a sequence containing the Runes in s.

See also:

	$ proc for a reverse operation

Example:

let a = toRunes("aáä")
doAssert a == @["a".runeAt(0), "á".runeAt(0), "ä".runeAt(0)]

	Source   Edit   

proc toTitle(c: Rune): Rune {.....}

	Converts c to title case.

	See also:

    	toLower proc
    	toUpper proc
    	isTitle proc

	Source   Edit   

proc toUpper(c: Rune): Rune {.....}

	Converts c into upper case. This works for any rune.

	If possible, prefer toLower over toUpper.

	See also:

    	toLower proc
    	toTitle proc
    	isUpper proc

	Source   Edit   

proc toUpper(s: openArray[char]): string {.noSideEffect, ....}

Converts s into upper-case runes.

Example:

doAssert toUpper("abγ") == "ABΓ"

	Source   Edit   

proc toUpper(s: string): string {.noSideEffect, inline, ....}

Converts s into upper-case runes.

Example:

doAssert toUpper("abγ") == "ABΓ"

	Source   Edit   

proc toUTF8(c: Rune): string {.....}

Converts a rune into its UTF-8 representation.

See also:

	validateUtf8 proc
	$ proc alias for toUTF8
	utf8 iterator
	fastToUTF8Copy template

Example:

let a = "añyóng"
doAssert a.runeAt(1).toUTF8 == "ñ"

	Source   Edit   

proc translate(s: openArray[char]; replacements: proc (key: string): string): string {.
	...effectsOf: replacements, ....}

Translates words in a string using the replacements proc to substitute words inside s with their replacements.

replacements is any proc that takes a word and returns a new word to fill it's place.

Example:

proc wordToNumber(s: string): string =
  case s
  of "one": "1"
  of "two": "2"
  else: s
let a = "one two three four"
doAssert a.translate(wordToNumber) == "1 2 three four"

	Source   Edit   

proc translate(s: string; replacements: proc (key: string): string): string {.
	effectsOf: replacements, inline, ....}

Translates words in a string using the replacements proc to substitute words inside s with their replacements.

replacements is any proc that takes a word and returns a new word to fill it's place.

Example:

proc wordToNumber(s: string): string =
  case s
  of "one": "1"
  of "two": "2"
  else: s
let a = "one two three four"
doAssert a.translate(wordToNumber) == "1 2 three four"

	Source   Edit   

proc validateUtf8(s: openArray[char]): int {.....}

	Returns the position of the invalid byte in s if the string s does not hold valid UTF-8 data. Otherwise -1 is returned.

	See also:

    	toUTF8 proc
    	$ proc alias for toUTF8
    	fastToUTF8Copy template

	Source   Edit   

proc validateUtf8(s: string): int {.inline, ....}

	Returns the position of the invalid byte in s if the string s does not hold valid UTF-8 data. Otherwise -1 is returned.

	See also:

    	toUTF8 proc
    	$ proc alias for toUTF8
    	fastToUTF8Copy template

	Source   Edit   

Iterators

iterator runes(s: openArray[char]): Rune {.....}

	Iterates over any rune of the string s returning runes. Source   Edit   

iterator runes(s: string): Rune {.....}

	Iterates over any rune of the string s returning runes. Source   Edit   

iterator split(s: openArray[char]; sep: Rune; maxsplit: int = -1): string {.
	....}

Splits the unicode string s into substrings using a single separator. Substrings are separated by the rune sep.

Example:

import std/sequtils

assert toSeq(split(";;hÃllo;this;is;an;;example;;;是", ";".runeAt(0))) ==
  @["", "", "hÃllo", "this", "is", "an", "", "example", "", "", "是"]

	Source   Edit   

iterator split(s: openArray[char]; seps: openArray[Rune] = unicodeSpaces;
           	maxsplit: int = -1): string {.....}

Splits the unicode string s into substrings using a group of separators.

Substrings are separated by a substring containing only seps.

Example:

import std/sequtils

assert toSeq("hÃllo\lthis\lis an\texample\l是".split) ==
  @["hÃllo", "this", "is", "an", "example", "是"]

# And the following code splits the same string using a sequence of Runes.
assert toSeq(split("añyóng:hÃllo;是$example", ";:$".toRunes)) ==
  @["añyóng", "hÃllo", "是", "example"]

# example with a `Rune` separator and unused one `;`:
assert toSeq(split("ab是de:f:", ";:是".toRunes)) == @["ab", "de", "f", ""]

# Another example that splits a string containing a date.
let date = "2012-11-20T22:08:08.398990"

assert toSeq(split(date, " -:T".toRunes)) ==
  @["2012", "11", "20", "22", "08", "08.398990"]

	Source   Edit   

iterator split(s: string; sep: Rune; maxsplit: int = -1): string {.....}

Splits the unicode string s into substrings using a single separator. Substrings are separated by the rune sep.

Example:

import std/sequtils

assert toSeq(split(";;hÃllo;this;is;an;;example;;;是", ";".runeAt(0))) ==
  @["", "", "hÃllo", "this", "is", "an", "", "example", "", "", "是"]

	Source   Edit   

iterator split(s: string; seps: openArray[Rune] = unicodeSpaces;
           	maxsplit: int = -1): string {.....}

Splits the unicode string s into substrings using a group of separators.

Substrings are separated by a substring containing only seps.

Example:

import std/sequtils

assert toSeq("hÃllo\lthis\lis an\texample\l是".split) ==
  @["hÃllo", "this", "is", "an", "example", "是"]

# And the following code splits the same string using a sequence of Runes.
assert toSeq(split("añyóng:hÃllo;是$example", ";:$".toRunes)) ==
  @["añyóng", "hÃllo", "是", "example"]

# example with a `Rune` separator and unused one `;`:
assert toSeq(split("ab是de:f:", ";:是".toRunes)) == @["ab", "de", "f", ""]

# Another example that splits a string containing a date.
let date = "2012-11-20T22:08:08.398990"

assert toSeq(split(date, " -:T".toRunes)) ==
  @["2012", "11", "20", "22", "08", "08.398990"]

	Source   Edit   

iterator splitWhitespace(s: openArray[char]): string {.....}

	Splits a unicode string at whitespace runes. Source   Edit   

iterator splitWhitespace(s: string): string {.....}

	Splits a unicode string at whitespace runes. Source   Edit   

iterator utf8(s: openArray[char]): string {.....}

	Iterates over any rune of the string s returning utf8 values.

	See also:

    	validateUtf8 proc
    	toUTF8 proc
    	$ proc alias for toUTF8
    	fastToUTF8Copy template

	Source   Edit   

iterator utf8(s: string): string {.....}

	Iterates over any rune of the string s returning utf8 values.

	See also:

    	validateUtf8 proc
    	toUTF8 proc
    	$ proc alias for toUTF8
    	fastToUTF8Copy template

	Source   Edit   

Templates

template fastRuneAt(s: openArray[char] or string; i: int; result: untyped;
                	doInc = true)

	Returns the rune s[i] in result.

	If doInc == true (default), i is incremented by the number of bytes that have been processed.
	Source   Edit   

template fastToUTF8Copy(c: Rune; s: var string; pos: int; doInc = true)

	Copies UTF-8 representation of c into the preallocated string s starting at position pos.

	If doInc == true (default), pos is incremented by the number of bytes that have been processed.

	To be the most efficient, make sure s is preallocated with an additional amount equal to the byte length of c.

	See also:

    	validateUtf8 proc
    	toUTF8 proc
    	$ proc alias for toUTF8

	Source   Edit   


std/unidecode


std/unidecode
Source   Edit  

This module is based on Python's Unidecode module by Tomaz Solc, which in turn is based on the Text::Unidecode Perl module by Sean M. Burke.

It provides a unidecode proc that does Unicode to ASCII transliterations: It finds the sequence of ASCII characters that is the closest approximation to the Unicode string.

For example, the closest to string "Äußerst" in ASCII is "Ausserst". Some information is lost in this transformation, of course, since several Unicode strings can be transformed to the same ASCII representation. So this is a strictly one-way transformation. However, a human reader will probably still be able to guess from the context, what the original string was.

This module needs the data file unidecode.dat to work: This file is embedded as a resource into your application by default. You can also define the symbol --define:noUnidecodeTable during compile time and use the loadUnidecodeTable proc to initialize this module.

Imports

unicode, strutils

Procs

proc loadUnidecodeTable(datafile = "unidecode.dat") {.....}

	Loads the datafile that unidecode needs to work. This is only required if the module was compiled with the --define:noUnidecodeTable switch. This needs to be called by the main thread before any thread can make a call to unidecode. Source   Edit   

proc unidecode(s: string): string {.....}

Finds the sequence of ASCII characters that is the closest approximation to the UTF-8 string s.

Example:

doAssert unidecode("北京") == "Bei Jing "
doAssert unidecode("Äußerst") == "Ausserst"

	Source   Edit   

std/widestrs


std/widestrs
Source   Edit  

Nim support for C/C++'s wide strings.
Types

Utf16Char = distinct int16

	Source   Edit   

WideCString = ref UncheckedArray[Utf16Char]

	Source   Edit   

WideCStringObj = WideCString

	Source   Edit   

Procs

proc `$`(s: WideCString): string {.....}

	Source   Edit   

proc `$`(w: WideCString; estimate: int; replacement: int = 0x0000FFFD): string {.
	....}

	Source   Edit   

proc len(w: WideCString): int {.....}

	returns the length of a widestring. This traverses the whole string to find the binary zero end marker! Source   Edit   

proc newWideCString(s: cstring): WideCStringObj {.....}

	Source   Edit   

proc newWideCString(s: string): WideCStringObj {.....}

	Source   Edit   

proc newWideCString(size: int): WideCStringObj {.....}

	Source   Edit   

proc newWideCString(source: cstring; L: int): WideCStringObj {.....}

	Source   Edit   


std/wordwrap


std/wordwrap
Source   Edit  

This module contains an algorithm to wordwrap a Unicode string.
Imports

strutils, unicode

Procs

proc wrapWords(s: string; maxLineWidth = 80; splitLongWords = true;
           	seps: set[char] = Whitespace; newLine = "\n"): string {.
	noSideEffect, ....}

Word wraps s.

Example:

doAssert "12345678901234567890".wrapWords() == "12345678901234567890"
doAssert "123456789012345678901234567890".wrapWords(20) == "12345678901234567890\n1234567890"
doAssert "Hello Bob. Hello John.".wrapWords(13, false) == "Hello Bob.\nHello John."
doAssert "Hello Bob. Hello John.".wrapWords(13, true, {';'}) == "Hello Bob. He\nllo John."


Time handling

std/monotimes


std/monotimes
Source   Edit  

The std/monotimes module implements monotonic timestamps. A monotonic timestamp represents the time that has passed since some system defined point in time. The monotonic timestamps are guaranteed not to decrease, meaning that that the following is guaranteed to work:

Example:

import std/monotimes
let a = getMonoTime()
let b = getMonoTime()
assert a <= b

This is not guaranteed for the times.Time type! This means that the MonoTime should be used when measuring durations of time with high precision.

However, since MonoTime represents the time that has passed since some unknown time origin, it cannot be converted to a human readable timestamp. If this is required, the times.Time type should be used instead.

The MonoTime type stores the timestamp in nanosecond resolution, but note that the actual supported time resolution differs for different systems.
See also

	times module

Imports

times

Types

MonoTime = object

	Represents a monotonic timestamp. Source   Edit   

Procs

proc `$`(t: MonoTime): string {.....}

	Source   Edit   

proc `+`(a: MonoTime; b: Duration): MonoTime {.....}

	Increases a by b. Source   Edit   

proc `-`(a, b: MonoTime): Duration {.....}

	Returns the difference between two MonoTime timestamps as a Duration. Source   Edit   

proc `-`(a: MonoTime; b: Duration): MonoTime {.....}

	Reduces a by b. Source   Edit   

proc `<`(a, b: MonoTime): bool {.....}

	Returns true if a happened before b. Source   Edit   

proc `<=`(a, b: MonoTime): bool {.....}

	Returns true if a happened before b or if they happened simultaneous. Source   Edit   

proc `==`(a, b: MonoTime): bool {.....}

	Returns true if a and b happened simultaneous. Source   Edit   

proc getMonoTime(): MonoTime {.....}

	Returns the current MonoTime timestamp.

	When compiled with the JS backend and executed in a browser, this proc calls window.performance.now(). See MDN for more information.
	Source   Edit   

proc high(typ: typedesc[MonoTime]): MonoTime

	Returns the highest representable MonoTime. Source   Edit   

proc low(typ: typedesc[MonoTime]): MonoTime

	Returns the lowest representable MonoTime. Source   Edit   

proc ticks(t: MonoTime): int64 {.....}

	Returns the raw ticks value from a MonoTime. This value always uses nanosecond time resolution. Source   Edit   


std/times


std/times
Source   Edit  

The times module contains routines and types for dealing with time using the proleptic Gregorian calendar. It's also available for the JavaScript target.

Although the times module supports nanosecond time resolution, the resolution used by getTime() depends on the platform and backend (JS is limited to millisecond precision).
Examples

import std/[times, os]
# Simple benchmarking
let time = cpuTime()
sleep(100) # Replace this with something to be timed
echo "Time taken: ", cpuTime() - time

# Current date & time
let now1 = now() 	# Current timestamp as a DateTime in local time
let now2 = now().utc # Current timestamp as a DateTime in UTC
let now3 = getTime() # Current timestamp as a Time

# Arithmetic using Duration
echo "One hour from now  	: ", now() + initDuration(hours = 1)
# Arithmetic using TimeInterval
echo "One year from now  	: ", now() + 1.years
echo "One month from now 	: ", now() + 1.months

Parsing and Formatting Dates

The DateTime type can be parsed and formatted using the different parse and format procedures.

let dt = parse("2000-01-01", "yyyy-MM-dd")
echo dt.format("yyyy-MM-dd")

The different format patterns that are supported are documented below.
Pattern	Description	Example
d	Numeric value representing the day of the month, it will be either one or two digits long.    

1/04/2012 -> 1
21/04/2012 -> 21
dd	Same as above, but is always two digits.	 

1/04/2012 -> 01
21/04/2012 -> 21
ddd	Three letter string which indicates the day of the week.	 

Saturday -> Sat
Monday -> Mon
dddd	Full string for the day of the week.	 

Saturday -> Saturday
Monday -> Monday
GG	The last two digits of the Iso Week-Year    

30/12/2012 -> 13
GGGG	The Iso week-calendar year padded to four digits    

30/12/2012 -> 2013
h	The hours in one digit if possible. Ranging from 1-12.	 

5pm -> 5
2am -> 2
hh	The hours in two digits always. If the hour is one digit, 0 is prepended.	 

5pm -> 05
11am -> 11
H	The hours in one digit if possible, ranging from 0-23.	 

5pm -> 17
2am -> 2
HH	The hours in two digits always. 0 is prepended if the hour is one digit.	 

5pm -> 17
2am -> 02
m	The minutes in one digit if possible.	 

5:30 -> 30
2:01 -> 1
mm	Same as above but always two digits, 0 is prepended if the minute is one digit.	 

5:30 -> 30
2:01 -> 01
M	The month in one digit if possible.	 

September -> 9
December -> 12
MM	The month in two digits always. 0 is prepended if the month value is one digit.	 

September -> 09
December -> 12
MMM	Abbreviated three-letter form of the month.	 

September -> Sep
December -> Dec
MMMM	Full month string, properly capitalized.    

September -> September
s	Seconds as one digit if possible.    

00:00:06 -> 6
ss	Same as above but always two digits. 0 is prepended if the second is one digit.    

00:00:06 -> 06
t	A when time is in the AM. P when time is in the PM.	 

5pm -> P
2am -> A
tt	Same as above, but AM and PM instead of A and P respectively.	 

5pm -> PM
2am -> AM
yy	The last two digits of the year. When parsing, the current century is assumed.    

2012 AD -> 12
yyyy	The year, padded to at least four digits. Is always positive, even when the year is BC. When the year is more than four digits, '+' is prepended.	 

2012 AD -> 2012
24 AD -> 0024
24 BC -> 00024
12345 AD -> +12345
YYYY	The year without any padding. Is always positive, even when the year is BC.    

2012 AD -> 2012
24 AD -> 24
24 BC -> 24
12345 AD -> 12345
uuuu	The year, padded to at least four digits. Will be negative when the year is BC. When the year is more than four digits, '+' is prepended unless the year is BC.    

2012 AD -> 2012
24 AD -> 0024
24 BC -> -0023
12345 AD -> +12345
UUUU	The year without any padding. Will be negative when the year is BC.    

2012 AD -> 2012
24 AD -> 24
24 BC -> -23
12345 AD -> 12345
V	The Iso Week-Number as one or two digits	 

3/2/2012 -> 5
1/4/2012 -> 13
VV	The Iso Week-Number as two digits always. 0 is prepended if one digit.	 

3/2/2012 -> 05
1/4/2012 -> 13
z	Displays the timezone offset from UTC.	 

UTC+7 -> +7
UTC-5 -> -5
zz	Same as above but with leading 0.	 

UTC+7 -> +07
UTC-5 -> -05
zzz	Same as above but with :mm where mm represents minutes.	 

UTC+7 -> +07:00
UTC-5 -> -05:00
ZZZ	Same as above but with mm where mm represents minutes.	 

UTC+7 -> +0700
UTC-5 -> -0500
zzzz	Same as above but with :ss where ss represents seconds.	 

UTC+7 -> +07:00:00
UTC-5 -> -05:00:00
ZZZZ	Same as above but with ss where ss represents seconds.	 

UTC+7 -> +070000
UTC-5 -> -050000
g	Era: AD or BC	 

300 AD -> AD
300 BC -> BC
fff	Milliseconds display    

1000000 nanoseconds -> 1
ffffff	Microseconds display    

1000000 nanoseconds -> 1000
fffffffff	Nanoseconds display    

1000000 nanoseconds -> 1000000

Other strings can be inserted by putting them in ''. For example hh'->'mm will give 01->56. The following characters can be inserted without quoting them: : - ( ) / [ ] ,. A literal ' can be specified with ''.

However you don't need to necessarily separate format patterns, as an unambiguous format string like yyyyMMddhhmmss is also valid (although only for years in the range 1..9999).
Duration vs TimeInterval

The times module exports two similar types that are both used to represent some amount of time: Duration and TimeInterval. This section explains how they differ and when one should be preferred over the other (short answer: use Duration unless support for months and years is needed).
Duration

A Duration represents a duration of time stored as seconds and nanoseconds. A Duration is always fully normalized, so initDuration(hours = 1) and initDuration(minutes = 60) are equivalent.

Arithmetic with a Duration is very fast, especially when used with the Time type, since it only involves basic arithmetic. Because Duration is more performant and easier to understand it should generally preferred.
TimeInterval

A TimeInterval represents an amount of time expressed in calendar units, for example "1 year and 2 days". Since some units cannot be normalized (the length of a year is different for leap years for example), the TimeInterval type uses separate fields for every unit. The TimeInterval's returned from this module generally don't normalize anything, so even units that could be normalized (like seconds, milliseconds and so on) are left untouched.

Arithmetic with a TimeInterval can be very slow, because it requires timezone information.

Since it's slower and more complex, the TimeInterval type should be avoided unless the program explicitly needs the features it offers that Duration doesn't have.
How long is a day?

It should be especially noted that the handling of days differs between TimeInterval and Duration. The Duration type always treats a day as exactly 86400 seconds. For TimeInterval, it's more complex.

As an example, consider the amount of time between these two timestamps, both in the same timezone:

	2018-03-25T12:00+02:00
	2018-03-26T12:00+01:00

If only the date & time is considered, it appears that exactly one day has passed. However, the UTC offsets are different, which means that the UTC offset was changed somewhere in between. This happens twice each year for timezones that use daylight savings time. Because of this change, the amount of time that has passed is actually 25 hours.

The TimeInterval type uses calendar units, and will say that exactly one day has passed. The Duration type on the other hand normalizes everything to seconds, and will therefore say that 90000 seconds has passed, which is the same as 25 hours.
See also

	monotimes module

Imports

strutils, math, options, since, winlean, time_t

Types

DateTime = object of RootObj

	Represents a time in different parts. Although this type can represent leap seconds, they are generally not supported in this module. They are not ignored, but the DateTime's returned by procedures in this module will never have a leap second. Source   Edit   

DateTimeLocale = object
  MMM*: array[mJan .. mDec, string]
  MMMM*: array[mJan .. mDec, string]
  ddd*: array[dMon .. dSun, string]
  dddd*: array[dMon .. dSun, string]

	Source   Edit   

Duration = object

	Represents a fixed duration of time, meaning a duration that has constant length independent of the context.

	To create a new Duration, use initDuration. Instead of trying to access the private attributes, use inSeconds for converting to seconds and inNanoseconds for converting to nanoseconds.
	Source   Edit   

DurationParts = array[FixedTimeUnit, int64]

	Source   Edit   

FixedTimeUnit = range[Nanoseconds .. Weeks]

	Subrange of TimeUnit that only includes units of fixed duration. These are the units that can be represented by a Duration. Source   Edit   

HourRange = range[0 .. 23]

	Source   Edit   

IsoWeekRange = range[1 .. 53]

	An ISO 8601 calendar week number. Source   Edit   

IsoYear = distinct int

	An ISO 8601 calendar year number.
	Warning: The ISO week-based year can correspond to the following or previous year from 29 December to January 3.
	Source   Edit   

MinuteRange = range[0 .. 59]

	Source   Edit   

Month = enum
  mJan = (1, "January"), mFeb = "February", mMar = "March", mApr = "April",
  mMay = "May", mJun = "June", mJul = "July", mAug = "August",
  mSep = "September", mOct = "October", mNov = "November", mDec = "December"

	Represents a month. Note that the enum starts at 1, so ord(month) will give the month number in the range 1..12. Source   Edit   

MonthdayRange = range[1 .. 31]

	Source   Edit   

NanosecondRange = range[0 .. 999999999]

	Source   Edit   

SecondRange = range[0 .. 60]

	Includes the value 60 to allow for a leap second. Note however that the second of a DateTime will never be a leap second. Source   Edit   

Time = object

	Represents a point in time. Source   Edit   

TimeFormat = object
  ## \
  ## Contains the patterns encoded as bytes.
  ## Literal values are encoded in a special way.
  ## They start with `Lit.byte`, then the length of the literal, then the
  ## raw char values of the literal. For example, the literal `foo` would
  ## be encoded as `@[Lit.byte, 3.byte, 'f'.byte, 'o'.byte, 'o'.byte]`.

	Represents a format for parsing and printing time types.

	To create a new TimeFormat use initTimeFormat proc.
	Source   Edit   

TimeFormatParseError = object of ValueError

	Raised when parsing a TimeFormat string fails. Source   Edit   

TimeInterval = object
  nanoseconds*: int      	## The number of nanoseconds
  microseconds*: int     	## The number of microseconds
  milliseconds*: int     	## The number of milliseconds
  seconds*: int          	## The number of seconds
  minutes*: int          	## The number of minutes
  hours*: int            	## The number of hours
  days*: int             	## The number of days
  weeks*: int            	## The number of weeks
  months*: int           	## The number of months
  years*: int            	## The number of years

	Represents a non-fixed duration of time. Can be used to add and subtract non-fixed time units from a DateTime or Time.

	Create a new TimeInterval with initTimeInterval proc.

	Note that TimeInterval doesn't represent a fixed duration of time, since the duration of some units depend on the context (e.g a year can be either 365 or 366 days long). The non-fixed time units are years, months, days and week.

	Note that TimeInterval's returned from the times module are never normalized. If you want to normalize a time unit, Duration should be used instead.
	Source   Edit   

TimeIntervalParts = array[TimeUnit, int]

	Source   Edit   

TimeParseError = object of ValueError

	Raised when parsing input using a TimeFormat fails. Source   Edit   

TimeUnit = enum
  Nanoseconds, Microseconds, Milliseconds, Seconds, Minutes, Hours, Days, Weeks,
  Months, Years

	Different units of time. Source   Edit   

Timezone = ref object

	Timezone interface for supporting DateTimes of arbitrary timezones. The times module only supplies implementations for the system's local time and UTC. Source   Edit   

WeekDay = enum
  dMon = "Monday", dTue = "Tuesday", dWed = "Wednesday", dThu = "Thursday",
  dFri = "Friday", dSat = "Saturday", dSun = "Sunday"

	Represents a weekday. Source   Edit   

YeardayRange = range[0 .. 365]

	Source   Edit   

ZonedTime = object
  time*: Time            	## The point in time being represented.
  utcOffset*: int        	## The offset in seconds west of UTC,
                         	## including any offset due to DST.
  isDst*: bool           	## Determines whether DST is in effect.

	Represents a point in time with an associated UTC offset and DST flag. This type is only used for implementing timezones. Source   Edit   

Consts

DefaultLocale = (MMM: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug",
                   	"Sep", "Oct", "Nov", "Dec"], MMMM: ["January",
	"February", "March", "April", "May", "June", "July", "August", "September",
	"October", "November", "December"],
             	ddd: ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"], dddd: [
	"Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"])

	Source   Edit   

DurationZero = (seconds: 0, nanosecond: 0)

Zero value for durations. Useful for comparisons.

doAssert initDuration(seconds = 1) > DurationZero
doAssert initDuration(seconds = 0) == DurationZero

	Source   Edit   

Procs

proc `$`(dt: DateTime): string {.....}

Converts a DateTime object to a string representation. It uses the format yyyy-MM-dd'T'HH:mm:sszzz.

Example:

let dt = dateTime(2000, mJan, 01, 12, 00, 00, 00, utc())
doAssert $dt == "2000-01-01T12:00:00Z"
doAssert $default(DateTime) == "Uninitialized DateTime"

	Source   Edit   

proc `$`(dur: Duration): string {.....}

Human friendly string representation of a Duration.

Example:

doAssert $initDuration(seconds = 2) == "2 seconds"
doAssert $initDuration(weeks = 1, days = 2) == "1 week and 2 days"
doAssert $initDuration(hours = 1, minutes = 2, seconds = 3) ==
  "1 hour, 2 minutes, and 3 seconds"
doAssert $initDuration(milliseconds = -1500) ==
  "-1 second and -500 milliseconds"

	Source   Edit   

proc `$`(f: TimeFormat): string {.....}

Returns the format string that was used to construct f.

Example:

let f = initTimeFormat("yyyy-MM-dd")
doAssert $f == "yyyy-MM-dd"

	Source   Edit   

proc `$`(p: IsoYear): string {.borrow, ....}

	Source   Edit   

proc `$`(ti: TimeInterval): string {.....}

Get string representation of TimeInterval.

Example:

doAssert $initTimeInterval(years = 1, nanoseconds = 123) ==
  "1 year and 123 nanoseconds"
doAssert $initTimeInterval() == "0 nanoseconds"

	Source   Edit   

proc `$`(time: Time): string {.....}

Converts a Time value to a string representation. It will use the local time zone and use the format yyyy-MM-dd'T'HH:mm:sszzz.

Example:

let dt = dateTime(1970, mJan, 01, 00, 00, 00, 00, local())
let tm = dt.toTime()
doAssert $tm == "1970-01-01T00:00:00" & format(dt, "zzz")

	Source   Edit   

proc `$`(zone: Timezone): string {.....}

	Returns the name of the timezone. Source   Edit   

proc `*`(a: Duration; b: int64): Duration {....noSideEffect, ....}

Multiply a duration by some scalar.

Example:

doAssert initDuration(seconds = 1) * 5 == initDuration(seconds = 5)
doAssert initDuration(minutes = 45) * 3 == initDuration(hours = 2, minutes = 15)

	Source   Edit   

proc `*`(a: int64; b: Duration): Duration {....noSideEffect, ....}

Multiply a duration by some scalar.

Example:

doAssert 5 * initDuration(seconds = 1) == initDuration(seconds = 5)
doAssert 3 * initDuration(minutes = 45) == initDuration(hours = 2, minutes = 15)

	Source   Edit   

proc `*=`(a: var Duration; b: int) {.....}

	Source   Edit   

proc `+`(a, b: Duration): Duration {....noSideEffect, ....}

Add two durations together.

Example:

doAssert initDuration(seconds = 1) + initDuration(days = 1) ==
  initDuration(seconds = 1, days = 1)

	Source   Edit   

proc `+`(a: Time; b: Duration): Time {....noSideEffect, ....}

Add a duration of time to a Time.

Example:

doAssert (fromUnix(0) + initDuration(seconds = 1)) == fromUnix(1)

	Source   Edit   

proc `+`(dt: DateTime; dur: Duration): DateTime {.....}

Example:

let dt = dateTime(2017, mMar, 30, 00, 00, 00, 00, utc())
let dur = initDuration(hours = 5)
doAssert $(dt + dur) == "2017-03-30T05:00:00Z"

	Source   Edit   

proc `+`(dt: DateTime; interval: TimeInterval): DateTime {.....}

Adds interval to dt. Components from interval are added in the order of their size, i.e. first the years component, then the months component and so on. The returned DateTime will have the same timezone as the input.

Note that when adding months, monthday overflow is allowed. This means that if the resulting month doesn't have enough days it, the month will be incremented and the monthday will be set to the number of days overflowed. So adding one month to 31 October will result in 31 November, which will overflow and result in 1 December.

Example:

let dt = dateTime(2017, mMar, 30, 00, 00, 00, 00, utc())
doAssert $(dt + 1.months) == "2017-04-30T00:00:00Z"
# This is correct and happens due to monthday overflow.
doAssert $(dt - 1.months) == "2017-03-02T00:00:00Z"

	Source   Edit   

proc `+`(ti1, ti2: TimeInterval): TimeInterval {.....}

	Adds two TimeInterval objects together. Source   Edit   

proc `+`(time: Time; interval: TimeInterval): Time {.....}

Adds interval to time. If interval contains any years, months, weeks or days the operation is performed in the local timezone.

Example:

let tm = fromUnix(0)
doAssert tm + 5.seconds == fromUnix(5)

	Source   Edit   

proc `+=`(a: var DateTime; b: Duration) {.....}

	Source   Edit   

proc `+=`(a: var DateTime; b: TimeInterval) {.....}

	Source   Edit   

proc `+=`(a: var TimeInterval; b: TimeInterval) {.....}

	Source   Edit   

proc `+=`(d1: var Duration; d2: Duration) {.....}

	Source   Edit   

proc `+=`(t: var Time; b: Duration) {.....}

	Source   Edit   

proc `+=`(t: var Time; b: TimeInterval) {.....}

	Source   Edit   

proc `-`(a, b: Duration): Duration {....noSideEffect, ....}

Subtract a duration from another.

Example:

doAssert initDuration(seconds = 1, days = 1) - initDuration(seconds = 1) ==
  initDuration(days = 1)

	Source   Edit   

proc `-`(a, b: Time): Duration {....noSideEffect, ....}

Computes the duration between two points in time.

Example:

doAssert initTime(1000, 100) - initTime(500, 20) ==
  initDuration(minutes = 8, seconds = 20, nanoseconds = 80)

	Source   Edit   

proc `-`(a: Duration): Duration {....noSideEffect, ....}

Reverse a duration.

Example:

doAssert -initDuration(seconds = 1) == initDuration(seconds = -1)

	Source   Edit   

proc `-`(a: Time; b: Duration): Time {....noSideEffect, ....}

Subtracts a duration of time from a Time.

Example:

doAssert (fromUnix(0) - initDuration(seconds = 1)) == fromUnix(-1)

	Source   Edit   

proc `-`(dt1, dt2: DateTime): Duration {.....}

Compute the duration between dt1 and dt2.

Example:

let dt1 = dateTime(2017, mMar, 30, 00, 00, 00, 00, utc())
let dt2 = dateTime(2017, mMar, 25, 00, 00, 00, 00, utc())

doAssert dt1 - dt2 == initDuration(days = 5)

	Source   Edit   

proc `-`(dt: DateTime; dur: Duration): DateTime {.....}

Example:

let dt = dateTime(2017, mMar, 30, 00, 00, 00, 00, utc())
let dur = initDuration(days = 5)
doAssert $(dt - dur) == "2017-03-25T00:00:00Z"

	Source   Edit   

proc `-`(dt: DateTime; interval: TimeInterval): DateTime {.....}

Subtract interval from dt. Components from interval are subtracted in the order of their size, i.e. first the years component, then the months component and so on. The returned DateTime will have the same timezone as the input.

Example:

let dt = dateTime(2017, mMar, 30, 00, 00, 00, 00, utc())
doAssert $(dt - 5.days) == "2017-03-25T00:00:00Z"

	Source   Edit   

proc `-`(ti1, ti2: TimeInterval): TimeInterval {.....}

Subtracts TimeInterval ti1 from ti2.

Time components are subtracted one-by-one, see output:

Example:

let ti1 = initTimeInterval(hours = 24)
let ti2 = initTimeInterval(hours = 4)
doAssert (ti1 - ti2) == initTimeInterval(hours = 20)

	Source   Edit   

proc `-`(ti: TimeInterval): TimeInterval {.....}

Reverses a time interval

Example:

let day = -initTimeInterval(hours = 24)
doAssert day.hours == -24

	Source   Edit   

proc `-`(time: Time; interval: TimeInterval): Time {.....}

Subtracts interval from Time time. If interval contains any years, months, weeks or days the operation is performed in the local timezone.

Example:

let tm = fromUnix(5)
doAssert tm - 5.seconds == fromUnix(0)

	Source   Edit   

proc `-=`(a: var DateTime; b: Duration) {.....}

	Source   Edit   

proc `-=`(a: var DateTime; b: TimeInterval) {.....}

	Source   Edit   

proc `-=`(a: var TimeInterval; b: TimeInterval) {.....}

	Source   Edit   

proc `-=`(dt: var Duration; ti: Duration) {.....}

	Source   Edit   

proc `-=`(t: var Time; b: Duration) {.....}

	Source   Edit   

proc `-=`(t: var Time; b: TimeInterval) {.....}

	Source   Edit   

proc `<`(a, b: DateTime): bool {.....}

	Returns true if a happened before b. Source   Edit   

proc `<`(a, b: Duration): bool {....noSideEffect, ....}

Note that a duration can be negative, so even if a < b is true a might represent a larger absolute duration. Use abs(a) < abs(b) to compare the absolute duration.

Example:

doAssert initDuration(seconds = 1) < initDuration(seconds = 2)
doAssert initDuration(seconds = -2) < initDuration(seconds = 1)
doAssert initDuration(seconds = -2).abs < initDuration(seconds = 1).abs == false

	Source   Edit   

proc `<`(a, b: Time): bool {....noSideEffect, ....}

Returns true if a < b, that is if a happened before b.

Example:

doAssert initTime(50, 0) < initTime(99, 0)

	Source   Edit   

proc `<=`(a, b: DateTime): bool {.....}

	Returns true if a happened before or at the same time as b. Source   Edit   

proc `<=`(a, b: Duration): bool {....noSideEffect, ....}

	Source   Edit   

proc `<=`(a, b: Time): bool {....noSideEffect, ....}

	Returns true if a <= b. Source   Edit   

proc `==`(a, b: DateTime): bool {.....}

	Returns true if a and b represent the same point in time. Source   Edit   

proc `==`(a, b: Duration): bool {....noSideEffect, ....}

Example:

let
  d1 = initDuration(weeks = 1)
  d2 = initDuration(days = 7)
doAssert d1 == d2

	Source   Edit   

proc `==`(a, b: IsoYear): bool {.borrow, ....}

	Source   Edit   

proc `==`(a, b: Time): bool {....noSideEffect, ....}

	Returns true if a == b, that is if both times represent the same point in time. Source   Edit   

proc `==`(zone1, zone2: Timezone): bool {.....}

Two Timezone's are considered equal if their name is equal.

Example:

doAssert local() == local()
doAssert local() != utc()

	Source   Edit   

proc abs(a: Duration): Duration {.....}

Example:

doAssert initDuration(milliseconds = -1500).abs ==
  initDuration(milliseconds = 1500)

	Source   Edit   

proc between(startDt, endDt: DateTime): TimeInterval {.....}

Gives the difference between startDt and endDt as a TimeInterval. The following guarantees about the result is given:

	All fields will have the same sign.
	If startDt.timezone == endDt.timezone, it is guaranteed that startDt + between(startDt, endDt) == endDt.
	If startDt.timezone != endDt.timezone, then the result will be equivalent to between(startDt.utc, endDt.utc).

Example:

var a = dateTime(2015, mMar, 25, 12, 0, 0, 00, utc())
var b = dateTime(2017, mApr, 1, 15, 0, 15, 00, utc())
var ti = initTimeInterval(years = 2, weeks = 1, hours = 3, seconds = 15)
doAssert between(a, b) == ti
doAssert between(a, b) == -between(b, a)

	Source   Edit   

proc convert[T: SomeInteger](unitFrom, unitTo: FixedTimeUnit; quantity: T): T {.
	inline.}

Convert a quantity of some duration unit to another duration unit. This proc only deals with integers, so the result might be truncated.

Example:

doAssert convert(Days, Hours, 2) == 48
doAssert convert(Days, Weeks, 13) == 1 # Truncated
doAssert convert(Seconds, Milliseconds, -1) == -1000

	Source   Edit   

proc cpuTime(): float {.....}

Gets time spent that the CPU spent to run the current process in seconds. This may be more useful for benchmarking than epochTime. However, it may measure the real time instead (depending on the OS). The value of the result has no meaning. To generate useful timing values, take the difference between the results of two cpuTime calls:

Example:

var t0 = cpuTime()
# some useless work here (calculate fibonacci)
var fib = @[0, 1, 1]
for i in 1..10:
  fib.add(fib[^1] + fib[^2])
echo "CPU time [s] ", cpuTime() - t0
echo "Fib is [s] ", fib

	When the flag --benchmarkVM is passed to the compiler, this proc is also available at compile time Source   Edit   

proc dateTime(year: int; month: Month; monthday: MonthdayRange;
          	hour: HourRange = 0; minute: MinuteRange = 0;
          	second: SecondRange = 0; nanosecond: NanosecondRange = 0;
          	zone: Timezone = local()): DateTime {.....}

Create a new DateTime in the specified timezone.

Example:

assert $dateTime(2017, mMar, 30, zone = utc()) == "2017-03-30T00:00:00Z"

	Source   Edit   

proc days(d: int): TimeInterval {.inline, ....}

	TimeInterval of d days.

	echo getTime() + 2.days
	Source   Edit   

proc `div`(a: Duration; b: int64): Duration {....noSideEffect, ....}

Integer division for durations.

Example:

doAssert initDuration(seconds = 3) div 2 ==
  initDuration(milliseconds = 1500)
doAssert initDuration(minutes = 45) div 30 ==
  initDuration(minutes = 1, seconds = 30)
doAssert initDuration(nanoseconds = 3) div 2 ==
  initDuration(nanoseconds = 1)

	Source   Edit   

proc epochTime(): float {.....}

	Gets time after the UNIX epoch (1970) in seconds. It is a float because sub-second resolution is likely to be supported (depending on the hardware/OS).

	getTime should generally be preferred over this proc.
	Warning: Unsuitable for benchmarking (but still better than now), use monotimes.getMonoTime or cpuTime instead, depending on the use case.
	Source   Edit   

proc format(dt: DateTime; f: static[string]): string {.....}

	Overload that validates format at compile time. Source   Edit   

proc format(dt: DateTime; f: string; loc: DateTimeLocale = DefaultLocale): string {.
	....}

Shorthand for constructing a TimeFormat and using it to format dt.

See Parsing and formatting dates for documentation of the format argument.

Example:

let dt = dateTime(2000, mJan, 01, 00, 00, 00, 00, utc())
doAssert "2000-01-01" == format(dt, "yyyy-MM-dd")

	Source   Edit   

proc format(dt: DateTime; f: TimeFormat; loc: DateTimeLocale = DefaultLocale): string {.
	....}

Format dt using the format specified by f.

Example:

let f = initTimeFormat("yyyy-MM-dd")
let dt = dateTime(2000, mJan, 01, 00, 00, 00, 00, utc())
doAssert "2000-01-01" == dt.format(f)

	Source   Edit   

proc format(time: Time; f: static[string]; zone: Timezone = local()): string {.
	....}

	Overload that validates f at compile time. Source   Edit   

proc format(time: Time; f: string; zone: Timezone = local()): string {.
	....}

Shorthand for constructing a TimeFormat and using it to format time. Will use the timezone specified by zone.

See Parsing and formatting dates for documentation of the f argument.

Example:

var dt = dateTime(1970, mJan, 01, 00, 00, 00, 00, utc())
var tm = dt.toTime()
doAssert format(tm, "yyyy-MM-dd'T'HH:mm:ss", utc()) == "1970-01-01T00:00:00"

	Source   Edit   

proc formatValue(result: var string; value: DateTime | Time; specifier: string)

	adapter for strformat. Not intended to be called directly. Source   Edit   

proc fromUnix(unix: int64): Time {....noSideEffect,
                               	....}

Convert a unix timestamp (seconds since 1970-01-01T00:00:00Z) to a Time.

Example:

doAssert $fromUnix(0).utc == "1970-01-01T00:00:00Z"

	Source   Edit   

proc fromUnixFloat(seconds: float): Time {....noSideEffect, ....}

Convert a unix timestamp in seconds to a Time; same as fromUnix but with subsecond resolution.

Example:

doAssert fromUnixFloat(123456.0) == fromUnixFloat(123456)
doAssert fromUnixFloat(-123456.0) == fromUnixFloat(-123456)

	Source   Edit   

proc fromWinTime(win: int64): Time {.....}

	Convert a Windows file time (100-nanosecond intervals since 1601-01-01T00:00:00Z) to a Time. Source   Edit   

proc getClockStr(dt = now()): string {.....}

Gets the current local clock time as a string of the format HH:mm:ss.

Example:

echo getClockStr(now() - 1.hours)

	Source   Edit   

proc getDateStr(dt = now()): string {.....}

Gets the current local date as a string of the format YYYY-MM-DD.

Example:

echo getDateStr(now() - 1.months)

	Source   Edit   

proc getDayOfWeek(monthday: MonthdayRange; month: Month; year: int): WeekDay {.
	....}

Returns the day of the week enum from day, month and year. Equivalent with dateTime(year, month, monthday, 0, 0, 0, 0).weekday.

Example:

doAssert getDayOfWeek(13, mJun, 1990) == dWed
doAssert $getDayOfWeek(13, mJun, 1990) == "Wednesday"

	Source   Edit   

proc getDayOfYear(monthday: MonthdayRange; month: Month; year: int): YeardayRange {.
	....}

Returns the day of the year. Equivalent with dateTime(year, month, monthday, 0, 0, 0, 0).yearday.

Example:

doAssert getDayOfYear(1, mJan, 2000) == 0
doAssert getDayOfYear(10, mJan, 2000) == 9
doAssert getDayOfYear(10, mFeb, 2000) == 40

	Source   Edit   

proc getDaysInMonth(month: Month; year: int): int {.....}

Get the number of days in month of year.

Example:

doAssert getDaysInMonth(mFeb, 2000) == 29
doAssert getDaysInMonth(mFeb, 2001) == 28

	Source   Edit   

proc getDaysInYear(year: int): int {.....}

Get the number of days in a year

Example:

doAssert getDaysInYear(2000) == 366
doAssert getDaysInYear(2001) == 365

	Source   Edit   

proc getIsoWeekAndYear(dt: DateTime): tuple[isoweek: IsoWeekRange,
	isoyear: IsoYear] {.....}

Returns the ISO 8601 week and year.
Warning: The ISO week-based year can correspond to the following or previous year from 29 December to January 3.

Example:

assert getIsoWeekAndYear(initDateTime(21, mApr, 2018, 00, 00, 00)) == (isoweek: 16.IsoWeekRange, isoyear: 2018.IsoYear)
block:
  let (w, y) = getIsoWeekAndYear(initDateTime(30, mDec, 2019, 00, 00, 00))
  assert w == 01.IsoWeekRange
  assert y == 2020.IsoYear
assert getIsoWeekAndYear(initDateTime(13, mSep, 2020, 00, 00, 00)) == (isoweek: 37.IsoWeekRange, isoyear: 2020.IsoYear)
block:
  let (w, y) = getIsoWeekAndYear(initDateTime(2, mJan, 2021, 00, 00, 00))
  assert w.int > 52
  assert w.int < 54
  assert y.int mod 100 == 20

	Source   Edit   

proc getTime(): Time {.....}

	Gets the current time as a Time with up to nanosecond resolution. Source   Edit   

proc getWeeksInIsoYear(y: IsoYear): IsoWeekRange {.....}

Returns the number of weeks in the specified ISO 8601 week-based year, which can be either 53 or 52.

Example:

assert getWeeksInIsoYear(IsoYear(2019)) == 52
assert getWeeksInIsoYear(IsoYear(2020)) == 53

	Source   Edit   

proc high(typ: typedesc[Duration]): Duration

	Get the longest representable duration. Source   Edit   

proc high(typ: typedesc[Time]): Time

	Source   Edit   

proc hour(dt: DateTime): HourRange {.inline, ....}

	The number of hours past midnight, in the range 0 to 23. Source   Edit   

proc hour=(dt: var DateTime; value: HourRange) {.
	....}

	Deprecated: Deprecated since v1.3.1
	Source   Edit   

proc hours(h: int): TimeInterval {.inline, ....}

	TimeInterval of h hours.

	echo getTime() + 2.hours
	Source   Edit   

proc inDays(dur: Duration): int64 {.....}

Converts the duration to the number of whole days.

Example:

let dur = initDuration(hours = -50)
doAssert dur.inDays == -2

	Source   Edit   

proc inHours(dur: Duration): int64 {.....}

Converts the duration to the number of whole hours.

Example:

let dur = initDuration(minutes = 60, days = 2)
doAssert dur.inHours == 49

	Source   Edit   

proc initDateTime(monthday: MonthdayRange; month: Month; year: int;
              	hour: HourRange; minute: MinuteRange; second: SecondRange;
              	nanosecond: NanosecondRange; zone: Timezone = local()): DateTime {.
	....}

Deprecated: use `dateTime`
Create a new DateTime in the specified timezone.

Example: cmd: --warning:deprecated:off

assert $initDateTime(30, mMar, 2017, 00, 00, 00, 00, utc()) == "2017-03-30T00:00:00Z"

	Source   Edit   

proc initDateTime(monthday: MonthdayRange; month: Month; year: int;
              	hour: HourRange; minute: MinuteRange; second: SecondRange;
              	zone: Timezone = local()): DateTime {.
	....}

Deprecated: use `dateTime`
Create a new DateTime in the specified timezone.

Example: cmd: --warning:deprecated:off

assert $initDateTime(30, mMar, 2017, 00, 00, 00, utc()) == "2017-03-30T00:00:00Z"

	Source   Edit   

proc initDateTime(weekday: WeekDay; isoweek: IsoWeekRange; isoyear: IsoYear;
              	hour: HourRange; minute: MinuteRange; second: SecondRange;
              	nanosecond: NanosecondRange; zone: Timezone = local()): DateTime {.
	....}

	Source   Edit   

proc initDateTime(weekday: WeekDay; isoweek: IsoWeekRange; isoyear: IsoYear;
              	hour: HourRange; minute: MinuteRange; second: SecondRange;
              	zone: Timezone = local()): DateTime {.....}

	Source   Edit   

proc initDuration(nanoseconds, microseconds, milliseconds, seconds, minutes,
              	hours, days, weeks: int64 = 0): Duration {.....}

Create a new Duration.

Example:

let dur = initDuration(seconds = 1, milliseconds = 1)
doAssert dur.inMilliseconds == 1001
doAssert dur.inSeconds == 1

	Source   Edit   

proc initTime(unix: int64; nanosecond: NanosecondRange): Time {.....}

	Create a Time from a unix timestamp and a nanosecond part. Source   Edit   

proc initTimeFormat(format: string): TimeFormat {.
	....}

Construct a new time format for parsing & formatting time types.

See Parsing and formatting dates for documentation of the format argument.

Example:

let f = initTimeFormat("yyyy-MM-dd")
doAssert "2000-01-01" == "2000-01-01".parse(f).format(f)

	Source   Edit   

proc initTimeInterval(nanoseconds, microseconds, milliseconds, seconds, minutes,
                  	hours, days, weeks, months, years: int = 0): TimeInterval {.
	....}

Creates a new TimeInterval.

This proc doesn't perform any normalization! For example, initTimeInterval(hours = 24) and initTimeInterval(days = 1) are not equal.

You can also use the convenience procedures called milliseconds, seconds, minutes, hours, days, months, and years.

Example:

let day = initTimeInterval(hours = 24)
let dt = dateTime(2000, mJan, 01, 12, 00, 00, 00, utc())
doAssert $(dt + day) == "2000-01-02T12:00:00Z"
doAssert initTimeInterval(hours = 24) != initTimeInterval(days = 1)

	Source   Edit   

proc inMicroseconds(dur: Duration): int64 {.....}

Converts the duration to the number of whole microseconds.

Example:

let dur = initDuration(seconds = -2)
doAssert dur.inMicroseconds == -2000000

	Source   Edit   

proc inMilliseconds(dur: Duration): int64 {.....}

Converts the duration to the number of whole milliseconds.

Example:

let dur = initDuration(seconds = -2)
doAssert dur.inMilliseconds == -2000

	Source   Edit   

proc inMinutes(dur: Duration): int64 {.....}

Converts the duration to the number of whole minutes.

Example:

let dur = initDuration(hours = 2, seconds = 10)
doAssert dur.inMinutes == 120

	Source   Edit   

proc inNanoseconds(dur: Duration): int64 {.....}

Converts the duration to the number of whole nanoseconds.

Example:

let dur = initDuration(seconds = -2)
doAssert dur.inNanoseconds == -2000000000

	Source   Edit   

proc inSeconds(dur: Duration): int64 {.....}

Converts the duration to the number of whole seconds.

Example:

let dur = initDuration(hours = 2, milliseconds = 10)
doAssert dur.inSeconds == 2 * 60 * 60

	Source   Edit   

proc inWeeks(dur: Duration): int64 {.....}

Converts the duration to the number of whole weeks.

Example:

let dur = initDuration(days = 8)
doAssert dur.inWeeks == 1

	Source   Edit   

proc inZone(dt: DateTime; zone: Timezone): DateTime {.....}

	Returns a DateTime representing the same point in time as dt but using zone as the timezone. Source   Edit   

proc inZone(time: Time; zone: Timezone): DateTime {.....}

	Convert time into a DateTime using zone as the timezone. Source   Edit   

proc isDst(dt: DateTime): bool {.inline, ....}

	Determines whether DST is in effect. Always false for the JavaScript backend. Source   Edit   

proc isDst=(dt: var DateTime; value: bool) {.
	....}

	Deprecated: Deprecated since v1.3.1
	Source   Edit   

proc isInitialized(dt: DateTime): bool {.....}

Example:

doAssert now().isInitialized
doAssert not default(DateTime).isInitialized

	Source   Edit   

proc isLeapDay(dt: DateTime): bool {.....}

Returns whether t is a leap day, i.e. Feb 29 in a leap year. This matters as it affects time offset calculations.

Example:

let dt = dateTime(2020, mFeb, 29, 00, 00, 00, 00, utc())
doAssert dt.isLeapDay
doAssert dt+1.years-1.years != dt
let dt2 = dateTime(2020, mFeb, 28, 00, 00, 00, 00, utc())
doAssert not dt2.isLeapDay
doAssert dt2+1.years-1.years == dt2
doAssertRaises(Exception): discard dateTime(2021, mFeb, 29, 00, 00, 00, 00, utc())

	Source   Edit   

proc isLeapYear(year: int): bool {.....}

Returns true if year is a leap year.

Example:

doAssert isLeapYear(2000)
doAssert not isLeapYear(1900)

	Source   Edit   

proc local(): Timezone {.....}

Get the Timezone implementation for the local timezone.

Example:

doAssert now().timezone == local()
doAssert local().name == "LOCAL"

	Source   Edit   

proc local(dt: DateTime): DateTime {.....}

	Shorthand for dt.inZone(local()). Source   Edit   

proc local(t: Time): DateTime {.....}

	Shorthand for t.inZone(local()). Source   Edit   

proc low(typ: typedesc[Duration]): Duration

	Get the longest representable duration of negative direction. Source   Edit   

proc low(typ: typedesc[Time]): Time

	Source   Edit   

proc microseconds(micros: int): TimeInterval {.inline, ....}

	TimeInterval of micros microseconds. Source   Edit   

proc milliseconds(ms: int): TimeInterval {.inline, ....}

	TimeInterval of ms milliseconds. Source   Edit   

proc minute(dt: DateTime): MinuteRange {.inline, ....}

	The number of minutes after the hour, in the range 0 to 59. Source   Edit   

proc minute=(dt: var DateTime; value: MinuteRange) {.
	....}

	Deprecated: Deprecated since v1.3.1
	Source   Edit   

proc minutes(m: int): TimeInterval {.inline, ....}

	TimeInterval of m minutes.

	echo getTime() + 5.minutes
	Source   Edit   

proc month(dt: DateTime): Month {.....}

	The month as an enum, the ordinal value is in the range 1 to 12. Source   Edit   

proc monthday(dt: DateTime): MonthdayRange {.inline, ....}

	The day of the month, in the range 1 to 31. Source   Edit   

proc monthdayZero=(dt: var DateTime; value: int) {.
	....}

	Deprecated: Deprecated since v1.3.1
	Source   Edit   

proc months(m: int): TimeInterval {.inline, ....}

	TimeInterval of m months.

	echo getTime() + 2.months
	Source   Edit   

proc monthZero=(dt: var DateTime; value: int) {.
	....}

	Deprecated: Deprecated since v1.3.1
	Source   Edit   

proc name(zone: Timezone): string {.....}

	The name of the timezone.

	If possible, the name will be the name used in the tz database. If the timezone doesn't exist in the tz database, or if the timezone name is unknown, then any string that describes the timezone unambiguously might be used. For example, the string "LOCAL" is used for the system's local timezone.

	See also: https://en.wikipedia.org/wiki/Tz_database
	Source   Edit   

proc nanosecond(dt: DateTime): NanosecondRange {.inline, ....}

	The number of nanoseconds after the second, in the range 0 to 999_999_999. Source   Edit   

proc nanosecond(time: Time): NanosecondRange {.....}

	Get the fractional part of a Time as the number of nanoseconds of the second. Source   Edit   

proc nanosecond=(dt: var DateTime; value: NanosecondRange) {.
	....}

	Deprecated: Deprecated since v1.3.1
	Source   Edit   

proc nanoseconds(nanos: int): TimeInterval {.inline, ....}

	TimeInterval of nanos nanoseconds. Source   Edit   

proc newTimezone(name: string; zonedTimeFromTimeImpl: proc (time: Time): ZonedTime {.
	....}; zonedTimeFromAdjTimeImpl: proc (
	adjTime: Time): ZonedTime {.....}): owned Timezone {.
	....}

Create a new Timezone.

zonedTimeFromTimeImpl and zonedTimeFromAdjTimeImpl is used as the underlying implementations for zonedTimeFromTime and zonedTimeFromAdjTime.

If possible, the name parameter should match the name used in the tz database. If the timezone doesn't exist in the tz database, or if the timezone name is unknown, then any string that describes the timezone unambiguously can be used. Note that the timezones name is used for checking equality!

Example:

proc utcTzInfo(time: Time): ZonedTime =
  ZonedTime(utcOffset: 0, isDst: false, time: time)
let utc = newTimezone("Etc/UTC", utcTzInfo, utcTzInfo)

	Source   Edit   

proc now(): DateTime {.....}

	Get the current time as a DateTime in the local timezone. Shorthand for getTime().local.
	Warning: Unsuitable for benchmarking, use monotimes.getMonoTime or cpuTime instead, depending on the use case.
	Source   Edit   

proc parse(input, f: string; tz: Timezone = local();
       	loc: DateTimeLocale = DefaultLocale): DateTime {.
	....}

Shorthand for constructing a TimeFormat and using it to parse input as a DateTime.

See Parsing and formatting dates for documentation of the f argument.

Example:

let dt = dateTime(2000, mJan, 01, 00, 00, 00, 00, utc())
doAssert dt == parse("2000-01-01", "yyyy-MM-dd", utc())

	Source   Edit   

proc parse(input: string; f: static[string]; zone: Timezone = local();
       	loc: DateTimeLocale = DefaultLocale): DateTime {.
	....}

	Overload that validates f at compile time. Source   Edit   

proc parse(input: string; f: TimeFormat; zone: Timezone = local();
       	loc: DateTimeLocale = DefaultLocale): DateTime {.
	....}

Parses input as a DateTime using the format specified by f. If no UTC offset was parsed, then input is assumed to be specified in the zone timezone. If a UTC offset was parsed, the result will be converted to the zone timezone.

Month and day names from the passed in loc are used.

Example:

let f = initTimeFormat("yyyy-MM-dd")
let dt = dateTime(2000, mJan, 01, 00, 00, 00, 00, utc())
doAssert dt == "2000-01-01".parse(f, utc())

	Source   Edit   

proc parseTime(input, f: string; zone: Timezone): Time {.
	....}

Shorthand for constructing a TimeFormat and using it to parse input as a DateTime, then converting it a Time.

See Parsing and formatting dates for documentation of the format argument.

Example:

let tStr = "1970-01-01T00:00:00+00:00"
doAssert parseTime(tStr, "yyyy-MM-dd'T'HH:mm:sszzz", utc()) == fromUnix(0)

	Source   Edit   

proc parseTime(input: string; f: static[string]; zone: Timezone): Time {.
	....}

	Overload that validates format at compile time. Source   Edit   

proc second(dt: DateTime): SecondRange {.inline, ....}

	The number of seconds after the minute, in the range 0 to 59. Source   Edit   

proc second=(dt: var DateTime; value: SecondRange) {.
	....}

	Deprecated: Deprecated since v1.3.1
	Source   Edit   

proc seconds(s: int): TimeInterval {.inline, ....}

	TimeInterval of s seconds.

	echo getTime() + 5.seconds
	Source   Edit   

proc timezone(dt: DateTime): Timezone {.inline, ....}

	The timezone represented as an implementation of Timezone. Source   Edit   

proc timezone=(dt: var DateTime; value: Timezone) {.
	....}

	Deprecated: Deprecated since v1.3.1
	Source   Edit   

proc toParts(dur: Duration): DurationParts {.....}

Converts a duration into an array consisting of fixed time units.

Each value in the array gives information about a specific unit of time, for example result[Days] gives a count of days.

This procedure is useful for converting Duration values to strings.

Example:

var dp = toParts(initDuration(weeks = 2, days = 1))
doAssert dp[Days] == 1
doAssert dp[Weeks] == 2
doAssert dp[Minutes] == 0
dp = toParts(initDuration(days = -1))
doAssert dp[Days] == -1

	Source   Edit   

proc toParts(ti: TimeInterval): TimeIntervalParts {.....}

Converts a TimeInterval into an array consisting of its time units, starting with nanoseconds and ending with years.

This procedure is useful for converting TimeInterval values to strings. E.g. then you need to implement custom interval printing

Example:

var tp = toParts(initTimeInterval(years = 1, nanoseconds = 123))
doAssert tp[Years] == 1
doAssert tp[Nanoseconds] == 123

	Source   Edit   

proc toTime(dt: DateTime): Time {.....}

	Converts a DateTime to a Time representing the same point in time. Source   Edit   

proc toUnix(t: Time): int64 {....noSideEffect,
                          	....}

Convert t to a unix timestamp (seconds since 1970-01-01T00:00:00Z). See also toUnixFloat for subsecond resolution.

Example:

doAssert fromUnix(0).toUnix() == 0

	Source   Edit   

proc toUnixFloat(t: Time): float {.....}

Same as toUnix but using subsecond resolution.

Example:

let t = getTime()
# `<` because of rounding errors
doAssert abs(t.toUnixFloat().fromUnixFloat - t) < initDuration(nanoseconds = 1000)

	Source   Edit   

proc toWinTime(t: Time): int64 {.....}

	Convert t to a Windows file time (100-nanosecond intervals since 1601-01-01T00:00:00Z). Source   Edit   

proc utc(): Timezone {.....}

Get the Timezone implementation for the UTC timezone.

Example:

doAssert now().utc.timezone == utc()
doAssert utc().name == "Etc/UTC"

	Source   Edit   

proc utc(dt: DateTime): DateTime {.....}

	Shorthand for dt.inZone(utc()). Source   Edit   

proc utc(t: Time): DateTime {.....}

	Shorthand for t.inZone(utc()). Source   Edit   

proc utcOffset(dt: DateTime): int {.inline, ....}

	The offset in seconds west of UTC, including any offset due to DST. Note that the sign of this number is the opposite of the one in a formatted offset string like +01:00 (which would be equivalent to the UTC offset -3600). Source   Edit   

proc utcOffset=(dt: var DateTime; value: int) {.
	....}

	Deprecated: Deprecated since v1.3.1
	Source   Edit   

proc weekday(dt: DateTime): WeekDay {.inline, ....}

	The day of the week as an enum, the ordinal value is in the range 0 (monday) to 6 (sunday). Source   Edit   

proc weekday=(dt: var DateTime; value: WeekDay) {.
	....}

	Deprecated: Deprecated since v1.3.1
	Source   Edit   

proc weeks(w: int): TimeInterval {.inline, ....}

	TimeInterval of w weeks.

	echo getTime() + 2.weeks
	Source   Edit   

proc year(dt: DateTime): int {.inline, ....}

	The year, using astronomical year numbering (meaning that before year 1 is year 0, then year -1 and so on). Source   Edit   

proc year=(dt: var DateTime; value: int) {.
	....}

	Deprecated: Deprecated since v1.3.1
	Source   Edit   

proc yearday(dt: DateTime): YeardayRange {.inline, ....}

	The number of days since January 1, in the range 0 to 365. Source   Edit   

proc yearday=(dt: var DateTime; value: YeardayRange) {.
	....}

	Deprecated: Deprecated since v1.3.1
	Source   Edit   

proc years(y: int): TimeInterval {.inline, ....}

	TimeInterval of y years.

	echo getTime() + 2.years
	Source   Edit   

proc zonedTimeFromAdjTime(zone: Timezone; adjTime: Time): ZonedTime {.
	....}

	Returns the ZonedTime for some local time.

	Note that the Time argument does not represent a point in time, it represent a local time! E.g if adjTime is fromUnix(0), it should be interpreted as 1970-01-01T00:00:00 in the zone timezone, not in UTC.
	Source   Edit   

proc zonedTimeFromTime(zone: Timezone; time: Time): ZonedTime {.....}

	Returns the ZonedTime for some point in time. Source   Edit   


Generic Operating System Services

std/appdirs


std/appdirs
Source   Edit  

This module implements helpers for determining special directories used by apps.
Imports

osappdirs, paths, envvars

Procs

proc getCacheDir(): Path {.inline, ....}

	Returns the cache directory of the current user for applications.

	This makes use of the following environment variables:

    	On Windows: getEnv("LOCALAPPDATA")
    	On macOS: getEnv("XDG_CACHE_HOME", getEnv("HOME") / "Library/Caches")
    	On other platforms: getEnv("XDG_CACHE_HOME", getEnv("HOME") / ".cache")

	See also:

    	getHomeDir proc
    	getTempDir proc
    	getConfigDir proc

	Source   Edit   

proc getCacheDir(app: Path): Path {.inline, ....}

	Returns the cache directory for an application app.

    	On Windows, this uses: getCacheDir() / app / "cache"
    	On other platforms, this uses: getCacheDir() / app

	Source   Edit   

proc getConfigDir(): Path {.inline, ....}

	Returns the config directory of the current user for applications.

	On non-Windows OSs, this proc conforms to the XDG Base Directory spec. Thus, this proc returns the value of the XDG_CONFIG_HOME environment variable if it is set, otherwise it returns the default configuration directory ("~/.config/").

	An OS-dependent trailing slash is always present at the end of the returned string: \\ on Windows and / on all other OSs.

	See also:

    	getHomeDir proc
    	getTempDir proc

	Source   Edit   

proc getDataDir(): Path {.inline, ....}

	Returns the data directory of the current user for applications.

	On non-Windows OSs, this proc conforms to the XDG Base Directory spec. Thus, this proc returns the value of the XDG_DATA_HOME environment variable if it is set, otherwise it returns the default configuration directory ("~/.local/share" or "~/Library/Application Support" on macOS).

	See also:

    	getHomeDir proc
    	getConfigDir proc
    	getTempDir proc
    	paths: expandTilde proc
    	paths: getCurrentDir proc
    	setCurrentDir

	Source   Edit   

proc getHomeDir(): Path {.inline, ....}

	Returns the home directory of the current user.

	This proc is wrapped by the paths: expandTilde proc for the convenience of processing paths coming from user configuration files.

	See also:

    	getConfigDir proc
    	getTempDir proc

	Source   Edit   

proc getTempDir(): Path {.inline, ....}

	Returns the temporary directory of the current user for applications to save temporary files in.

	On Windows, it calls GetTempPath. On Posix based platforms, it will check TMPDIR, TEMP, TMP and TEMPDIR environment variables in order. On all platforms, /tmp will be returned if the procs fails.

	You can override this implementation by adding -d:tempDir=mytempname to your compiler invocation.
	Note: This proc does not check whether the returned path exists.

	See also:

    	getHomeDir proc
    	getConfigDir proc

	Source   Edit   


std/cmdline


std/cmdline
Source   Edit  

This module contains system facilities for reading command line parameters.See also:

	parseopt module for command-line parser beyond parseCmdLine proc

Imports

winlean

Procs

proc commandLineParams(): seq[string] {.....}

Convenience proc which returns the command line parameters.

This returns only the parameters. If you want to get the application executable filename, call getAppFilename.

Availability: On Posix there is no portable way to get the command line from a DLL and thus the proc isn't defined in this environment. You can test for its availability with declared().

See also:

	parseopt module
	parseCmdLine proc
	paramCount proc
	paramStr proc
	getAppFilename

Examples:

when declared(commandLineParams):
  # Use commandLineParams() here
else:
  # Do something else!

	Source   Edit   

proc paramCount(): int {.....}

Returns the number of command line arguments given to the application.

Unlike argc in C, if your binary was called without parameters this will return zero. You can query each individual parameter with paramStr proc or retrieve all of them in one go with commandLineParams proc.

Availability: When generating a dynamic library (see --app:lib) on Posix this proc is not defined. Test for availability using declared().

See also:

	parseopt module
	parseCmdLine proc
	paramStr proc
	commandLineParams proc

Examples:

when declared(paramCount):
  # Use paramCount() here
else:
  # Do something else!

	Source   Edit   

proc paramStr(i: int): string {.....}

Returns the i-th command line argument given to the application.

i should be in the range 1..paramCount(), the IndexDefect exception will be raised for invalid values. Instead of iterating over paramCount() with this proc you can call the convenience commandLineParams().

Similarly to argv in C, it is possible to call paramStr(0) but this will return OS specific contents (usually the name of the invoked executable). You should avoid this and call getAppFilename instead.

Availability: When generating a dynamic library (see --app:lib) on Posix this proc is not defined. Test for availability using declared().

See also:

	parseopt module
	parseCmdLine proc
	paramCount proc
	commandLineParams proc
	getAppFilename

Examples:

when declared(paramStr):
  # Use paramStr() here
else:
  # Do something else!

	Source   Edit   

proc parseCmdLine(c: string): seq[string] {.noSideEffect, ....}

	Splits a command line into several components.

	Note: This proc is only occasionally useful, better use the parseopt module.

	On Windows, it uses the following parsing rules:

    	Arguments are delimited by white space, which is either a space or a tab.
    	The caret character (^) is not recognized as an escape character or delimiter. The character is handled completely by the command-line parser in the operating system before being passed to the argv array in the program.
    	A string surrounded by double quotation marks ("string") is interpreted as a single argument, regardless of white space contained within. A quoted string can be embedded in an argument.
    	A double quotation mark preceded by a backslash (") is interpreted as a literal double quotation mark character (").
    	Backslashes are interpreted literally, unless they immediately precede a double quotation mark.
    	If an even number of backslashes is followed by a double quotation mark, one backslash is placed in the argv array for every pair of backslashes, and the double quotation mark is interpreted as a string delimiter.
    	If an odd number of backslashes is followed by a double quotation mark, one backslash is placed in the argv array for every pair of backslashes, and the double quotation mark is "escaped" by the remaining backslash, causing a literal double quotation mark (") to be placed in argv.

	On Posix systems, it uses the following parsing rules: Components are separated by whitespace unless the whitespace occurs within " or ' quotes.

	See also:

    	parseopt module
    	paramCount proc
    	paramStr proc
    	commandLineParams proc

	Source   Edit   

Templates

template getCommandLine(): untyped

	Source   Edit   


std/dirs


std/dirs
Source   Edit  

This module implements directory handling.
Imports

paths, osdirs

Procs

proc createDir(dir: Path) {.inline, ....}

	Creates the directory dir.

	The directory may contain several subdirectories that do not exist yet. The full path is created. If this fails, OSError is raised.

	It does not fail if the directory already exists because for most usages this does not indicate an error.

	See also:

    	removeDir proc
    	existsOrCreateDir proc
    	moveDir proc

	Source   Edit   

proc dirExists(dir: Path): bool {.inline, ...sideEffect,
                              	....}

	Returns true if the directory dir exists. If dir is a file, false is returned. Follows symlinks. Source   Edit   

proc existsOrCreateDir(dir: Path): bool {.inline,
	....}

	Checks if a directory dir exists, and creates it otherwise.

	Does not create parent directories (raises OSError if parent directories do not exist). Returns true if the directory already exists, and false otherwise.

	See also:

    	removeDir proc
    	createDir proc
    	moveDir proc

	Source   Edit   

proc moveDir(source, dest: Path) {.inline, ....}

	Moves a directory from source to dest.

	Symlinks are not followed: if source contains symlinks, they themself are moved, not their target.

	If this fails, OSError is raised.

	See also:

    	moveFile proc
    	removeDir proc
    	existsOrCreateDir proc
    	createDir proc

	Source   Edit   

proc removeDir(dir: Path; checkDir = false) {.inline,
	....}

	Removes the directory dir including all subdirectories and files in dir (recursively).

	If this fails, OSError is raised. This does not fail if the directory never existed in the first place, unless checkDir = true.

	See also:

    	removeFile proc
    	existsOrCreateDir proc
    	createDir proc
    	moveDir proc

	Source   Edit   

proc setCurrentDir(newDir: Path) {.inline, ....}

	Sets the current working directory; OSError is raised if newDir cannot been set.

	See also:

    	getCurrentDir proc

	Source   Edit   

Iterators

iterator walkDir(dir: Path; relative = false; checkDir = false;
             	skipSpecial = false): tuple[kind: PathComponent, path: Path] {.
	....}

	Walks over the directory dir and yields for each directory or file in dir. The component type and full path for each item are returned.

	Walking is not recursive.

    	If relative is true (default: false) the resulting path is shortened to be relative to dir, otherwise the full path is returned.
    	If checkDir is true, OSError is raised when dir doesn't exist.
    	If skipSpecial is true, then (besides all directories) only regular files (without special "file" objects like FIFOs, device files, etc) will be yielded on Unix.

	Source   Edit   

iterator walkDirRec(dir: Path; yieldFilter = {pcFile}; followFilter = {pcDir};
                	relative = false; checkDir = false; skipSpecial = false): Path {.
	....}

	Recursively walks over the directory dir and yields for each file or directory in dir.

	Options relative, checkdir, skipSpecial are explained in walkDir iterator description.
	Warning: Modifying the directory structure while the iterator is traversing may result in undefined behavior!

	Walking is recursive. followFilter controls the behaviour of the iterator:
	yieldFilter	meaning
	pcFile	yield real files (default)
	pcLinkToFile	yield symbolic links to files
	pcDir	yield real directories
	pcLinkToDir	yield symbolic links to directories
	followFilter	meaning
	pcDir	follow real directories (default)
	pcLinkToDir	follow symbolic links to directories

	See also:

    	walkDir iterator

	Source   Edit   

Exports

PathComponent


std/distros


std/distros
Source   Edit  

This module implements the basics for Linux distribution ("distro") detection and the OS's native package manager. Its primary purpose is to produce output for Nimble packages, like:

To complete the installation, run:

sudo apt-get install libblas-dev
sudo apt-get install libvoodoo

The above output could be the result of a code snippet like:

if detectOs(Ubuntu):
  foreignDep "lbiblas-dev"
  foreignDep "libvoodoo"

See packaging for hints on distributing Nim using OS packages.

Imports

strutils, osproc, envvars

Types

Distribution {.pure.} = enum
  Windows,              	## some version of Windows
  Posix,                	## some POSIX system
  MacOSX,               	## some version of OSX
  Linux,                	## some version of Linux
  Ubuntu, Debian, Gentoo, Fedora, RedHat, OpenSUSE, Manjaro, Elementary, Zorin,
  CentOS, Deepin, ArchLinux, Artix, Antergos, PCLinuxOS, Mageia, LXLE, Solus,
  Lite, Slackware, Androidx86, Puppy, Peppermint, Tails, AntiX, Kali,
  SparkyLinux, Apricity, BlackLab, Bodhi, TrueOS, ArchBang, KaOS, WattOS,
  Korora, Simplicity, RemixOS, OpenMandriva, Netrunner, Alpine, BlackArch,
  Ultimate, Gecko, Parrot, KNOPPIX, GhostBSD, Sabayon, Salix, Q4OS, ClearOS,
  Container, ROSA, Zenwalk, Parabola, ChaletOS, BackBox, MXLinux, Vector, Maui,
  Qubes, RancherOS, Oracle, TinyCore, Robolinux, Trisquel, Voyager, Clonezilla,
  SteamOS, Absolute, NixOS, ## NixOS or a Nix build environment
  AUSTRUMI, Arya, Porteus, AVLinux, Elive, Bluestar, SliTaz, Solaris, Chakra,
  Wifislax, Scientific, ExTiX, Rockstor, GoboLinux, Void, BSD, FreeBSD, NetBSD,
  OpenBSD, DragonFlyBSD, Haiku

	the list of known distributions Source   Edit   

Vars

foreignDeps: seq[string] = @[]

	Registered foreign deps. Source   Edit   

Consts

LacksDevPackages = {Distribution.Gentoo, Distribution.Slackware,
                	Distribution.ArchLinux, Distribution.Artix,
                	Distribution.Antergos, Distribution.BlackArch,
                	Distribution.ArchBang}

	Source   Edit   

Procs

proc echoForeignDeps() {.....}

	Writes the list of registered foreign deps to stdout. Source   Edit   

proc foreignCmd(cmd: string; requiresSudo = false) {.....}

	Registers a foreign command to the internal list of commands that can be queried later. Source   Edit   

proc foreignDep(foreignPackageName: string) {.....}

	Registers foreignPackageName to the internal list of foreign deps. It is your job to ensure that the package name is correct. Source   Edit   

proc foreignDepInstallCmd(foreignPackageName: string): (string, bool) {.
	....}

	Returns the distro's native command to install foreignPackageName and whether it requires root/admin rights. Source   Edit   

Templates

template detectOs(d: untyped): bool

	Distro/OS detection. For convenience, the required Distribution. qualifier is added to the enum value. Source   Edit   


std/dynlib


std/dynlib
Source   Edit  

This module implements the ability to access symbols from shared libraries. On POSIX this uses the dlsym mechanism, on Windows LoadLibrary.
Examples
Loading a simple C function

The following example demonstrates loading a function called greet from a library that is determined at runtime based upon a language choice. If the library fails to load or the function greet is not found, it quits with a failure error code.

Example:

import std/dynlib
type
  GreetFunction = proc (): cstring {.gcsafe, stdcall.}

proc loadGreet(lang: string) =
  let lib =
	case lang
	of "french":
  	loadLib("french.dll")
	else:
  	loadLib("english.dll")
  assert lib != nil, "Error loading library"

  let greet = cast[GreetFunction](lib.symAddr("greet"))
  assert greet != nil, "Error loading 'greet' function from library"

  echo greet()

  unloadLib(lib)

Imports

strutils

Types

LibHandle = pointer

	A handle to a dynamically loaded library. Source   Edit   

Procs

proc checkedSymAddr(lib: LibHandle; name: cstring): pointer {.
	....}

	Retrieves the address of a procedure/variable from lib. Raises LibraryError if the symbol could not be found. Source   Edit   

proc libCandidates(s: string; dest: var seq[string]) {.....}

	Given a library name pattern s, write possible library names to dest. Source   Edit   

proc loadLib(): LibHandle {.....}

	Gets the handle from the current executable. Returns nil if the library could not be loaded. Source   Edit   

proc loadLib(path: string; globalSymbols = false): LibHandle {.....}

	Loads a library from path. Returns nil if the library could not be loaded. Source   Edit   

proc loadLibPattern(pattern: string; globalSymbols = false): LibHandle {.
	....}

	Loads a library with name matching pattern, similar to what the dynlib pragma does. Returns nil if the library could not be loaded.
	Warning: this proc uses the GC and so cannot be used to load the GC.
	Source   Edit   

proc raiseInvalidLibrary(name: cstring) {.noinline, noreturn,
	....}

	Raises a LibraryError exception. Source   Edit   

proc symAddr(lib: LibHandle; name: cstring): pointer {.....}

	Retrieves the address of a procedure/variable from lib. Returns nil if the symbol could not be found. Source   Edit   

proc unloadLib(lib: LibHandle) {.....}

	Unloads the library lib. Source   Edit   


std/envvars


std/envvars
Source   Edit  

The std/envvars module implements environment variable handling.
Imports

oserrors, win_setenv, winlean

Types

ReadEnvEffect = object of ReadIOEffect

	Effect that denotes a read from an environment variable. Source   Edit   

WriteEnvEffect = object of WriteIOEffect

	Effect that denotes a write to an environment variable. Source   Edit   

Procs

proc delEnv(key: string) {.....}

	Deletes the environment variable named key. If an error occurs, OSError is raised.

	See also:ven

    	getEnv proc
    	existsEnv proc
    	putEnv proc
    	envPairs iterator

	Source   Edit   

proc existsEnv(key: string): bool {.....}

Checks whether the environment variable named key exists. Returns true if it exists, false otherwise.

See also:

	getEnv proc
	putEnv proc
	delEnv proc
	envPairs iterator

Example:

assert not existsEnv("unknownEnv")

	Source   Edit   

proc getEnv(key: string; default = ""): string {.....}

Returns the value of the environment variable named key.

If the variable does not exist, "" is returned. To distinguish whether a variable exists or it's value is just "", call existsEnv(key) proc.

See also:

	existsEnv proc
	putEnv proc
	delEnv proc
	envPairs iterator

Example:

assert getEnv("unknownEnv") == ""
assert getEnv("unknownEnv", "doesn't exist") == "doesn't exist"

	Source   Edit   

proc putEnv(key, val: string) {.....}

	Sets the value of the environment variable named key to val. If an error occurs, OSError is raised.

	See also:

    	getEnv proc
    	existsEnv proc
    	delEnv proc
    	envPairs iterator

	Source   Edit   

Iterators

iterator envPairs(): tuple[key, value: string] {.....}

	Iterate over all environments variables.

	In the first component of the tuple is the name of the current variable stored, in the second its value.

	Works in native backends, nodejs and vm, like the following APIs:

    	getEnv proc
    	existsEnv proc
    	putEnv proc
    	delEnv proc

	Source   Edit   


std/exitprocs


std/exitprocs
Source   Edit  

This module allows adding hooks to program exit.
Imports

locks

Procs

proc addExitProc(cl: proc () {.closure.}) {.....}

	Adds/registers a quit procedure. Each call to addExitProc registers another quit procedure. They are executed on a last-in, first-out basis. Source   Edit   

proc addExitProc(cl: proc () {.noconv.}) {.....}

	overload for noconv procs. Source   Edit   

proc getProgramResult(): int {.....}

	Source   Edit   

proc setProgramResult(a: int) {.....}

	Source   Edit   


std/files


std/files
Source   Edit  

This module implements file handling.

See also:

	paths module for path manipulation

Imports

paths, osfiles

Procs

proc fileExists(filename: Path): bool {.inline, ...sideEffect, ....}

	Returns true if filename exists and is a regular file or symlink.

	Directories, device files, named pipes and sockets return false.
	Source   Edit   

proc moveFile(source, dest: Path) {.inline, ....}

	Moves a file from source to dest.

	Symlinks are not followed: if source is a symlink, it is itself moved, not its target.

	If this fails, OSError is raised. If dest already exists, it will be overwritten.

	Can be used to rename files.

	See also:

    	moveDir proc
    	removeFile proc

	Source   Edit   

proc removeFile(file: Path) {.inline, ....}

	Removes the file.

	If this fails, OSError is raised. This does not fail if the file never existed in the first place.

	On Windows, ignores the read-only attribute.

	See also:

    	removeDir proc
    	moveFile proc

	Source   Edit   


std/memfiles


std/memfiles
Source   Edit  

Authors:	Zahary Karadjov, Andreas Rumpf

This module provides support for memory mapped files (Posix's mmap) on the different operating systems.

It also provides some fast iterators over lines in text files (or other "line-like", variable length, delimited records).

Imports

winlean, streams, oserrors

Types

MemFile = object
  mem*: pointer          	## a pointer to the memory mapped file. The pointer
                         	## can be used directly to change the contents of the
                         	## file, if it was opened with write access.
  size*: int             	## size of the memory mapped file
  when defined(windows):
	fHandle*: Handle ## **Caution**: Windows specific public field to allow
                 	## even more low level trickery.
	mapHandle*: Handle   	## **Caution**: Windows specific public field.
	wasOpened*: bool     	## **Caution**: Windows specific public field.
  else:
	handle*: cint        	## **Caution**: Posix specific public field.
	## **Caution**: Platform specific private field.

	represents a memory mapped file Source   Edit   

MemMapFileStream = ref MemMapFileStreamObj

	a stream that encapsulates a MemFile Source   Edit   

MemMapFileStreamObj = object of Stream

	Source   Edit   

MemSlice = object
  data*: pointer
  size*: int

	represent slice of a MemFile for iteration over delimited lines/records Source   Edit   

Procs

proc `$`(ms: MemSlice): string {.inline, ....}

	Return a Nim string built from a MemSlice. Source   Edit   

proc `==`(x, y: MemSlice): bool {.....}

	Compare a pair of MemSlice for strict equality. Source   Edit   

proc close(f: var MemFile) {.....}

	closes the memory mapped file f. All changes are written back to the file system, if f was opened with write access. Source   Edit   

proc flush(f: var MemFile; attempts: Natural = 3) {.....}

	Flushes f's buffer for the number of attempts equal to attempts. If were errors an exception OSError will be raised. Source   Edit   

proc mapMem(m: var MemFile; mode: FileMode = fmRead; mappedSize = -1;
        	offset = 0; mapFlags = cint(-1)): pointer {.
	....}

	returns a pointer to a mapped portion of MemFile m

	mappedSize of -1 maps to the whole file, and offset must be multiples of the PAGE SIZE of your OS
	Source   Edit   

proc newMemMapFileStream(filename: string; mode: FileMode = fmRead;
                     	fileSize: int = -1): MemMapFileStream {.
	....}

	creates a new stream from the file named filename with the mode mode. Raises ## OSError if the file cannot be opened. See the system module for a list of available FileMode enums. fileSize can only be set if the file does not exist and is opened with write access (e.g., with fmReadWrite). Source   Edit   

proc open(filename: string; mode: FileMode = fmRead; mappedSize = -1;
      	offset = 0; newFileSize = -1; allowRemap = false; mapFlags = cint(-1)): MemFile {.
	....}

opens a memory mapped file. If this fails, OSError is raised.

newFileSize can only be set if the file does not exist and is opened with write access (e.g., with fmReadWrite).

mappedSize and offset can be used to map only a slice of the file.

offset must be multiples of the PAGE SIZE of your OS (usually 4K or 8K but is unique to your OS)

allowRemap only needs to be true if you want to call mapMem on the resulting MemFile; else file handles are not kept open.

mapFlags allows callers to override default choices for memory mapping flags with a bitwise mask of a variety of likely platform-specific flags which may be ignored or even cause open to fail if misspecified.

Example:

var
  mm, mm_full, mm_half: MemFile

mm = memfiles.open("/tmp/test.mmap", mode = fmWrite, newFileSize = 1024)	# Create a new file
mm.close()

# Read the whole file, would fail if newFileSize was set
mm_full = memfiles.open("/tmp/test.mmap", mode = fmReadWrite, mappedSize = -1)

# Read the first 512 bytes
mm_half = memfiles.open("/tmp/test.mmap", mode = fmReadWrite, mappedSize = 512)

	Source   Edit   

proc resize(f: var MemFile; newFileSize: int) {.....}

	Resize & re-map the file underlying an allowRemap MemFile. If the OS/FS supports it, file space is reserved to ensure room for new virtual pages. Caller should wait often enough for flush to finish to limit use of system RAM for write buffering, perhaps just prior to this call. Note: this assumes the entire file is mapped read-write at offset 0. Also, the value of .mem will probably change. Source   Edit   

proc unmapMem(f: var MemFile; p: pointer; size: int) {.....}

	unmaps the memory region (p, <p+size) of the mapped file f. All changes are written back to the file system, if f was opened with write access.

	size must be of exactly the size that was requested via mapMem.
	Source   Edit   

Iterators

iterator lines(mfile: MemFile; buf: var string; delim = '\n'; eat = '\r'): string {.
	inline, ....}

Replace contents of passed buffer with each new line, like readLine(File). delim, eat, and delimiting logic is exactly as for memSlices, but Nim strings are returned.

Example:

var buffer: string = ""
for line in lines(memfiles.open("foo"), buffer):
  echo line

	Source   Edit   

iterator lines(mfile: MemFile; delim = '\n'; eat = '\r'): string {.inline,
	....}

Return each line in a file as a Nim string, like lines(File). delim, eat, and delimiting logic is exactly as for memSlices, but Nim strings are returned.

Example:

for line in lines(memfiles.open("foo")):
  echo line

	Source   Edit   

iterator memSlices(mfile: MemFile; delim = '\n'; eat = '\r'): MemSlice {.inline,
	....}

Iterates over [optional eat] delim-delimited slices in MemFile mfile.

Default parameters parse lines ending in either Unix(\l) or Windows(\r\l) style on on a line-by-line basis. I.e., not every line needs the same ending. Unlike readLine(File) & lines(File), archaic MacOS9 \r-delimited lines are not supported as a third option for each line. Such archaic MacOS9 files can be handled by passing delim='\r', eat='\0', though.

Delimiters are not part of the returned slice. A final, unterminated line or record is returned just like any other.

Non-default delimiters can be passed to allow iteration over other sorts of "line-like" variable length records. Pass eat='\0' to be strictly delim-delimited. (Eating an optional prefix equal to '\0' is not supported.)

This zero copy, memchr-limited interface is probably the fastest way to iterate over line-like records in a file. However, returned (data,size) objects are not Nim strings, bounds checked Nim arrays, or even terminated C strings. So, care is required to access the data (e.g., think C mem* functions, not str* functions).

Example:

var count = 0
for slice in memSlices(memfiles.open("foo")):
  if slice.size > 0 and cast[cstring](slice.data)[0] != '#':
	inc(count)
echo count

	Source   Edit   


std/os


std/os
Source   Edit  

This module contains basic operating system facilities like retrieving environment variables, working with directories, running shell commands, etc.

Example:

import std/os
let myFile = "/path/to/my/file.nim"
assert splitPath(myFile) == (head: "/path/to/my", tail: "file.nim")
when defined(posix):
  assert parentDir(myFile) == "/path/to/my"
assert splitFile(myFile) == (dir: "/path/to/my", name: "file", ext: ".nim")
assert myFile.changeFileExt("c") == "/path/to/my/file.c"

See also:

	paths and files modules for high-level file manipulation
	osproc module for process communication beyond execShellCmd proc
	uri module
	distros module
	dynlib module
	streams module

Imports

ospaths2, osfiles, osdirs, ossymlinks, osappdirs, oscommon, since, cmdline, strutils, pathnorm, winlean, times, oserrors, envvars, osseps

Types

DeviceId = int32

	Source   Edit   

FileId = int64

	Source   Edit   

FileInfo = object
  id*: tuple[device: DeviceId, file: FileId] ## Device and file id.
  kind*: PathComponent   	## Kind of file object - directory, symlink, etc.
  size*: BiggestInt      	## Size of file.
  permissions*: set[FilePermission] ## File permissions
  linkCount*: BiggestInt 	## Number of hard links the file object has.
  lastAccessTime*: times.Time ## Time file was last accessed.
  lastWriteTime*: times.Time ## Time file was last modified/written to.
  creationTime*: times.Time  ## Time file was created. Not supported on all systems!
  blockSize*: int        	## Preferred I/O block size for this object.
                         	## In some filesystems, this may vary from file to file.
  isSpecial*: bool       	## Is file special? (on Unix some "files"
                         	## can be special=non-regular like FIFOs,
                         	## devices); for directories `isSpecial`
                         	## is always `false`, for symlinks it is
                         	## the same as for the link's target.

	Contains information associated with a file object.

	See also:

    	getFileInfo(handle) proc
    	getFileInfo(file) proc
    	getFileInfo(path, followSymlink) proc

	Source   Edit   

Consts

ExeExts = ["exe", "cmd", "bat"]

	Platform specific file extension for executables. On Windows ["exe", "cmd", "bat"], on Posix [""]. Source   Edit   

invalidFilenameChars = {'/', '\\', ':', '*', '?', '\"', '<', '>', '|', '^',
                    	'\x00'}

	Characters that may produce invalid filenames across Linux, Windows and Mac. You can check if your filename contains any of these chars and strip them for safety. Mac bans ':', Linux bans '/', Windows bans all others. Source   Edit   

invalidFilenames = ["CON", "PRN", "AUX", "NUL", "COM0", "COM1", "COM2", "COM3",
                	"COM4", "COM5", "COM6", "COM7", "COM8", "COM9", "LPT0",
                	"LPT1", "LPT2", "LPT3", "LPT4", "LPT5", "LPT6", "LPT7",
                	"LPT8", "LPT9"]

	Filenames that may be invalid across Linux, Windows, Mac, etc. You can check if your filename match these and rename it for safety (Currently all invalid filenames are from Windows only). Source   Edit   

Procs

proc createHardlink(src, dest: string) {.....}

	Create a hard link at dest which points to the item specified by src.
	Warning: Some OS's restrict the creation of hard links to root users (administrators).

	See also:

    	symlinks: createSymlink proc

	Source   Edit   

proc exclFilePermissions(filename: string; permissions: set[FilePermission]) {.
	....}

A convenience proc for:

setFilePermissions(filename, getFilePermissions(filename)-permissions)

	Source   Edit   

proc execShellCmd(command: string): int {.....}

Executes a shell command.

Command has the form 'program args' where args are the command line arguments given to program. The proc returns the error code of the shell when it has finished (zero if there is no error). The proc does not return until the process has finished.

To execute a program without having a shell involved, use osproc.execProcess proc.

Examples:

discard execShellCmd("ls -la")

	Source   Edit   

proc exitStatusLikeShell(status: cint): cint {.....}

	Converts exit code from c_system into a shell exit code. Source   Edit   

proc expandFilename(filename: string): string {.....}

	Returns the full (absolute) path of an existing file filename.

	Raises OSError in case of an error. Follows symlinks.
	Source   Edit   

proc expandTilde(path: string): string {.....}

Expands ~ or a path starting with ~/ to a full path, replacing ~ with appdirs: getHomeDir() (otherwise returns path unmodified).

Windows: this is still supported despite the Windows platform not having this convention; also, both ~/ and ~\ are handled.

See also:

	appdirs: getHomeDir proc
	appdirs: getConfigDir proc
	appdirs: getTempDir proc
	ospaths2: getCurrentDir proc
	dirs: setCurrentDir proc

Example:

assert expandTilde("~" / "appname.cfg") == getHomeDir() / "appname.cfg"
assert expandTilde("~/foo/bar") == getHomeDir() / "foo/bar"
assert expandTilde("/foo/bar") == "/foo/bar"

	Source   Edit   

proc fileNewer(a, b: string): bool {.....}

	Returns true if the file a is newer than file b, i.e. if a's modification time is later than b's.

	See also:

    	getLastModificationTime proc
    	getLastAccessTime proc
    	getCreationTime proc

	Source   Edit   

proc findExe(exe: string; followSymlinks: bool = true;
         	extensions: openArray[string] = ExeExts): string {.
	....}

	Searches for exe in the current working directory and then in directories listed in the PATH environment variable.

	Returns "" if the exe cannot be found. exe is added the ExeExts file extensions if it has none.

	If the system supports symlinks it also resolves them until it meets the actual file. This behavior can be disabled if desired by setting followSymlinks = false.
	Source   Edit   

proc getAppDir(): string {.....}

	Returns the directory of the application's executable.

	See also:

    	getAppFilename proc

	Source   Edit   

proc getAppFilename(): string {.....}

	Returns the filename of the application's executable. This proc will resolve symlinks.

	Returns empty string when name is unavailable

	See also:

    	getAppDir proc
    	getCurrentCompilerExe proc

	Source   Edit   

proc getCreationTime(file: string): times.Time {.....}

	Returns the file's creation time.

	Note: Under POSIX OS's, the returned time may actually be the time at which the file's attribute's were last modified. See here for details.

	See also:

    	getLastModificationTime proc
    	getLastAccessTime proc
    	fileNewer proc

	Source   Edit   

proc getCurrentCompilerExe(): string {.compileTime, ....}

	This is getAppFilename() at compile time.

	Can be used to retrieve the currently executing Nim compiler from a Nim or nimscript program, or the nimble binary inside a nimble program (likewise with other binaries built from compiler API).
	Source   Edit   

proc getCurrentProcessId(): int {.....}

	Return current process ID.

	See also:

    	osproc.processID(p: Process)

	Source   Edit   

proc getFileInfo(file: File): FileInfo {.....}

	Retrieves file information for the file object.

	See also:

    	getFileInfo(handle) proc
    	getFileInfo(path, followSymlink) proc

	Source   Edit   

proc getFileInfo(handle: FileHandle): FileInfo {.....}

	Retrieves file information for the file object represented by the given handle.

	If the information cannot be retrieved, such as when the file handle is invalid, OSError is raised.

	See also:

    	getFileInfo(file) proc
    	getFileInfo(path, followSymlink) proc

	Source   Edit   

proc getFileInfo(path: string; followSymlink = true): FileInfo {.
	....}

	Retrieves file information for the file object pointed to by path.

	Due to intrinsic differences between operating systems, the information contained by the returned FileInfo object will be slightly different across platforms, and in some cases, incomplete or inaccurate.

	When followSymlink is true (default), symlinks are followed and the information retrieved is information related to the symlink's target. Otherwise, information on the symlink itself is retrieved (however, field isSpecial is still determined from the target on Unix).

	If the information cannot be retrieved, such as when the path doesn't exist, or when permission restrictions prevent the program from retrieving file information, OSError is raised.

	See also:

    	getFileInfo(handle) proc
    	getFileInfo(file) proc

	Source   Edit   

proc getFileSize(file: string): BiggestInt {.....}

	Returns the file size of file (in bytes). OSError is raised in case of an error. Source   Edit   

proc getLastAccessTime(file: string): times.Time {.....}

	Returns the file's last read or write access time.

	See also:

    	getLastModificationTime proc
    	getCreationTime proc
    	fileNewer proc

	Source   Edit   

proc getLastModificationTime(file: string): times.Time {.....}

	Returns the file's last modification time.

	See also:

    	getLastAccessTime proc
    	getCreationTime proc
    	fileNewer proc

	Source   Edit   

proc inclFilePermissions(filename: string; permissions: set[FilePermission]) {.
	....}

A convenience proc for:

setFilePermissions(filename, getFilePermissions(filename)+permissions)

	Source   Edit   

proc isAdmin(): bool {.....}

	Returns whether the caller's process is a member of the Administrators local group (on Windows) or a root (on POSIX), via geteuid() == 0. Source   Edit   

proc isHidden(path: string): bool {.....}

Determines whether path is hidden or not, using this reference.

On Windows: returns true if it exists and its "hidden" attribute is set.

On posix: returns true if lastPathPart(path) starts with . and is not . or ...

Note: paths are not normalized to determine isHidden.

Example:

when defined(posix):
  assert ".foo".isHidden
  assert not ".foo/bar".isHidden
  assert not ".".isHidden
  assert not "..".isHidden
  assert not "".isHidden
  assert ".foo/".isHidden

	Source   Edit   

func isValidFilename(filename: string; maxLen = 259.Positive): bool {.
	....}

Returns true if filename is valid for crossplatform use.

This is useful if you want to copy or save files across Windows, Linux, Mac, etc. It uses invalidFilenameChars, invalidFilenames and maxLen to verify the specified filename.

See also:

	https://docs.microsoft.com/en-us/dotnet/api/system.io.pathtoolongexception
	https://docs.microsoft.com/en-us/windows/win32/fileio/naming-a-file
	https://msdn.microsoft.com/en-us/library/windows/desktop/aa365247%28v=vs.85%29.aspx

Warning: This only checks filenames, not whole paths (because basically you can mount anything as a path on Linux).

Example:

assert not isValidFilename(" foo") 	# Leading white space
assert not isValidFilename("foo ") 	# Trailing white space
assert not isValidFilename("foo.") 	# Ends with dot
assert not isValidFilename("con.txt")  # "CON" is invalid (Windows)
assert not isValidFilename("OwO:UwU")  # ":" is invalid (Mac)
assert not isValidFilename("aux.bat")  # "AUX" is invalid (Windows)
assert not isValidFilename("")     	# Empty string
assert not isValidFilename("foo/") 	# Filename is empty

	Source   Edit   

proc quoteShell(s: string): string {.noSideEffect, ....}

	Quote s, so it can be safely passed to shell.

	When on Windows, it calls quoteShellWindows proc. Otherwise, calls quoteShellPosix proc.
	Source   Edit   

proc quoteShellCommand(args: openArray[string]): string {.....}

Concatenates and quotes shell arguments args.

Example:

when defined(posix):
  assert quoteShellCommand(["aaa", "", "c d"]) == "aaa '' 'c d'"
when defined(windows):
  assert quoteShellCommand(["aaa", "", "c d"]) == "aaa \"\" \"c d\""

	Source   Edit   

proc quoteShellPosix(s: string): string {.noSideEffect, ....}

	Quote s, so it can be safely passed to POSIX shell. Source   Edit   

proc quoteShellWindows(s: string): string {.noSideEffect, ....}

	Quote s, so it can be safely passed to Windows API.

	Based on Python's subprocess.list2cmdline. See this link for more details.
	Source   Edit   

proc sameFileContent(path1, path2: string): bool {.....}

	Returns true if both pathname arguments refer to files with identical binary content.

	See also:

    	ospaths2: sameFile proc

	Source   Edit   

proc setLastModificationTime(file: string; t: times.Time) {.....}

	Sets the file's last modification time. OSError is raised in case of an error. Source   Edit   

proc sleep(milsecs: int) {.....}

	Sleeps milsecs milliseconds. Source   Edit   

Templates

template existsDir(args: varargs[untyped]): untyped {.
	....}

	Deprecated: use dirExists
	Source   Edit   

template existsFile(args: varargs[untyped]): untyped {.
	....}

	Deprecated: use fileExists
	Source   Edit   

Exports

changeFileExt, /, splitFile, normalizeExe, normalizePath, cmpPaths, WriteDirEffect, ScriptExt, lastPathPart, isRelativeTo, absolutePath, isAbsolute, parentDir, unixToNativePath, /../, DirSep, normalizePathEnd, PathSep, normalizedPath, DynlibFormat, normalizePathEnd, addFileExt, joinPath, extractFilename, relativePath, FileSystemCaseSensitive, sameFile, ReadDirEffect, joinPath, CurDir, ExtSep, splitPath, tailDir, getCurrentDir, searchExtPos, parentDirs, AltSep, doslikeFileSystem, ExeExt, isRootDir, ParDir, tryRemoveFile, removeFile, copyFileToDir, moveFile, fileExists, FilePermission, getFilePermissions, CopyFlag, setFilePermissions, copyFileWithPermissions, copyFile, walkFiles, dirExists, existsOrCreateDir, walkDirRec, removeDir, walkDir, PathComponent, walkDirs, moveDir, createDir, copyDirWithPermissions, copyDir, walkPattern, setCurrentDir, symlinkExists, expandSymlink, createSymlink, getConfigDir, getCacheDir, getDataDir, getTempDir, getHomeDir, getCacheDir, parseCmdLine, paramCount, commandLineParams, paramStr, getCommandLine, $, ==, newOSError, osErrorMsg, raiseOSError, osLastError, OSErrorCode, putEnv, envPairs, delEnv, getEnv, WriteEnvEffect, ReadEnvEffect, existsEnv, ExtSep, FileSystemCaseSensitive, DynlibFormat, DirSep, AltSep, PathSep, ScriptExt, doslikeFileSystem, ExeExt, CurDir, ParDir


std/oserrors


std/oserrors
Source   Edit  

The std/oserrors module implements OS error reporting.
Imports

winlean

Types

OSErrorCode = distinct int32

	Specifies an OS Error Code. Source   Edit   

Procs

proc `$`(err: OSErrorCode): string {.borrow, ....}

	Source   Edit   

proc `==`(err1, err2: OSErrorCode): bool {.borrow, ....}

	Source   Edit   

proc newOSError(errorCode: OSErrorCode; additionalInfo = ""): owned(ref OSError) {.
	noinline, ....}

	Creates a new OSError exception.

	The errorCode will determine the message, osErrorMsg proc will be used to get this message.

	The error code can be retrieved using the osLastError proc.

	If the error code is 0 or an error message could not be retrieved, the message unknown OS error will be used.

	See also:

    	osErrorMsg proc
    	osLastError proc

	Source   Edit   

proc osErrorMsg(errorCode: OSErrorCode): string {.....}

Converts an OS error code into a human readable string.

The error code can be retrieved using the osLastError proc.

If conversion fails, or errorCode is 0 then "" will be returned.

See also:

	raiseOSError proc
	osLastError proc

Example:

when defined(linux):
  assert osErrorMsg(OSErrorCode(0)) == ""
  assert osErrorMsg(OSErrorCode(1)) == "Operation not permitted"
  assert osErrorMsg(OSErrorCode(2)) == "No such file or directory"

	Source   Edit   

proc osLastError(): OSErrorCode {.sideEffect, ....}

	Retrieves the last operating system error code.

	This procedure is useful in the event when an OS call fails. In that case this procedure will return the error code describing the reason why the OS call failed. The OSErrorMsg procedure can then be used to convert this code into a string.
	Warning: The behaviour of this procedure varies between Windows and POSIX systems. On Windows some OS calls can reset the error code to 0 causing this procedure to return 0. It is therefore advised to call this procedure immediately after an OS call fails. On POSIX systems this is not a problem.

	See also:

    	osErrorMsg proc
    	raiseOSError proc

	Source   Edit   

proc raiseOSError(errorCode: OSErrorCode; additionalInfo = "") {.noinline,
	....}

	Raises an OSError exception.

	Read the description of the newOSError proc to learn how the exception object is created.
	Source   Edit   


std/osproc


std/osproc
Source   Edit  

This module implements an advanced facility for executing OS processes and process communication.

See also:

	os module
	streams module
	memfiles module

Imports

strutils, os, strtabs, streams, cpuinfo, streamwrapper, since, winlean

Types

Process = ref ProcessObj

	Represents an operating system process. Source   Edit   

ProcessOption = enum
  poEchoCmd,            	## Echo the command before execution.
  poUsePath, ## Asks system to search for executable using PATH environment
          	## variable.
          	## On Windows, this is the default.
  poEvalCommand, ## Pass `command` directly to the shell, without quoting.
              	## Use it only if `command` comes from trusted source.
  poStdErrToStdOut,     	## Merge stdout and stderr to the stdout stream.
  poParentStreams,      	## Use the parent's streams.
  poInteractive, ## Optimize the buffer handling for responsiveness for
              	## UI applications. Currently this only affects
              	## Windows: Named pipes are used so that you can peek
              	## at the process' output streams.
  poDaemon               	## Windows: The program creates no Window.
                         	## Unix: Start the program as a daemon. This is still
                         	## work in progress!

	Options that can be passed to startProcess proc. Source   Edit   

Procs

proc close(p: Process) {.....}

	When the process has finished executing, cleanup related handles.
	Warning: If the process has not finished executing, this will forcibly terminate the process. Doing so may result in zombie processes and pty leaks.
	Source   Edit   

proc countProcessors(): int {.....}

	Returns the number of the processors/cores the machine has. Returns 0 if it cannot be detected. It is implemented just calling cpuinfo.countProcessors. Source   Edit   

proc errorHandle(p: Process): FileHandle {.....}

	Returns p's error file handle for reading from.
	Warning: The returned FileHandle should not be closed manually as it is closed when closing the Process p.

	See also:

    	inputHandle proc
    	outputHandle proc

	Source   Edit   

proc errorStream(p: Process): Stream {.....}

	Returns p's error stream for reading from.

	You cannot perform peek/write/setOption operations to this stream. Use peekableErrorStream proc if you need to peek stream.
	Warning: The returned Stream should not be closed manually as it is closed when closing the Process p.

	See also:

    	inputStream proc
    	outputStream proc

	Source   Edit   

proc execCmd(command: string): int {.....}

Executes command and returns its error code.

Standard input, output, error streams are inherited from the calling process. This operation is also often called system.

See also:

	execCmdEx proc
	startProcess proc
	execProcess proc

Example:

let errC = execCmd("nim c -r mytestfile.nim")

	Source   Edit   

proc execCmdEx(command: string;
           	options: set[ProcessOption] = {poStdErrToStdOut, poUsePath};
           	env: StringTableRef = nil; workingDir = ""; input = ""): tuple[
	output: string, exitCode: int] {.....}

A convenience proc that runs the command, and returns its output and exitCode. env and workingDir params behave as for startProcess. If input.len > 0, it is passed as stdin.

Note: this could block if input.len is greater than your OS's maximum pipe buffer size.

See also:

	execCmd proc
	startProcess proc
	execProcess proc

Example:

var result = execCmdEx("nim r --hints:off -", options = {}, input = "echo 3*4")
import std/[strutils, strtabs]
stripLineEnd(result[0]) ## portable way to remove trailing newline, if any
doAssert result == ("12", 0)
doAssert execCmdEx("ls --nonexistent").exitCode != 0
when defined(posix):
  assert execCmdEx("echo $FO", env = newStringTable({"FO": "B"})) == ("B\n", 0)
  assert execCmdEx("echo $PWD", workingDir = "/") == ("/\n", 0)

	Source   Edit   

proc execProcess(command: string; workingDir: string = "";
             	args: openArray[string] = []; env: StringTableRef = nil;
	options: set[ProcessOption] = {poStdErrToStdOut, poUsePath, poEvalCommand}): string {.
	....}

A convenience procedure that executes command with startProcess and returns its output as a string.
Warning: This function uses poEvalCommand by default for backwards compatibility. Make sure to pass options explicitly.

See also:

	startProcess proc
	execProcesses proc
	execCmd proc

Example:

let outp = execProcess("nim", args=["c", "-r", "mytestfile.nim"], options={poUsePath})
let outp_shell = execProcess("nim c -r mytestfile.nim")
# Note: outp may have an interleave of text from the nim compile
# and any output from mytestfile when it runs

	Source   Edit   

proc execProcesses(cmds: openArray[string];
               	options = {poStdErrToStdOut, poParentStreams};
               	n = countProcessors(); beforeRunEvent: proc (idx: int) = nil;
               	afterRunEvent: proc (idx: int; p: Process) = nil): int {.
	...effectsOf: [beforeRunEvent, afterRunEvent], ....}

	Executes the commands cmds in parallel. Creates n processes that execute in parallel.

	The highest (absolute) return value of all processes is returned. Runs beforeRunEvent before running each command.
	Source   Edit   

proc hasData(p: Process): bool {.....}

	Source   Edit   

proc inputHandle(p: Process): FileHandle {.....}

	Returns p's input file handle for writing to.
	Warning: The returned FileHandle should not be closed manually as it is closed when closing the Process p.

	See also:

    	outputHandle proc
    	errorHandle proc

	Source   Edit   

proc inputStream(p: Process): Stream {.....}

	Returns p's input stream for writing to.
	Warning: The returned Stream should not be closed manually as it is closed when closing the Process p.

	See also:

    	outputStream proc
    	errorStream proc

	Source   Edit   

proc kill(p: Process) {.....}

	Kill the process p.

	On Posix OSes the procedure sends SIGKILL to the process. On Windows kill is simply an alias for terminate().

	See also:

    	suspend proc
    	resume proc
    	terminate proc
    	posix_utils.sendSignal(pid: Pid, signal: int)

	Source   Edit   

proc outputHandle(p: Process): FileHandle {.....}

	Returns p's output file handle for reading from.
	Warning: The returned FileHandle should not be closed manually as it is closed when closing the Process p.

	See also:

    	inputHandle proc
    	errorHandle proc

	Source   Edit   

proc outputStream(p: Process): Stream {.....}

	Returns p's output stream for reading from.

	You cannot perform peek/write/setOption operations to this stream. Use peekableOutputStream proc if you need to peek stream.
	Warning: The returned Stream should not be closed manually as it is closed when closing the Process p.

	See also:

    	inputStream proc
    	errorStream proc

	Source   Edit   

proc peekableErrorStream(p: Process): Stream {.....}

	Returns p's error stream for reading from.

	You can run peek operation to returned stream.
	Warning: The returned Stream should not be closed manually as it is closed when closing the Process p.

	See also:

    	errorStream proc
    	peekableOutputStream proc

	Source   Edit   

proc peekableOutputStream(p: Process): Stream {.....}

	Returns p's output stream for reading from.

	You can peek returned stream.
	Warning: The returned Stream should not be closed manually as it is closed when closing the Process p.

	See also:

    	outputStream proc
    	peekableErrorStream proc

	Source   Edit   

proc peekExitCode(p: Process): int {.....}

	Return -1 if the process is still running. Otherwise the process' exit code.

	On posix, if the process has exited because of a signal, 128 + signal number will be returned.
	Source   Edit   

proc processID(p: Process): int {.....}

	Returns p's process ID.

	See also:

    	os.getCurrentProcessId proc

	Source   Edit   

proc readLines(p: Process): (seq[string], int) {.
	....}

Convenience function for working with startProcess to read data from a background process.

See also:

	lines iterator

Example:

const opts = {poUsePath, poDaemon, poStdErrToStdOut}
var ps: seq[Process]
for prog in ["a", "b"]: # run 2 progs in parallel
  ps.add startProcess("nim", "", ["r", prog], nil, opts)
for p in ps:
  let (lines, exCode) = p.readLines
  if exCode != 0:
	for line in lines: echo line
  p.close

	Source   Edit   

proc resume(p: Process) {.....}

	Resumes the process p.

	See also:

    	suspend proc
    	terminate proc
    	kill proc

	Source   Edit   

proc running(p: Process): bool {.....}

	Returns true if the process p is still running. Returns immediately. Source   Edit   

proc startProcess(command: string; workingDir: string = "";
              	args: openArray[string] = []; env: StringTableRef = nil;
              	options: set[ProcessOption] = {poStdErrToStdOut}): owned(
	Process) {.....}

	Starts a process. Command is the executable file, workingDir is the process's working directory. If workingDir == "" the current directory is used (default). args are the command line arguments that are passed to the process. On many operating systems, the first command line argument is the name of the executable. args should not contain this argument! env is the environment that will be passed to the process. If env == nil (default) the environment is inherited of the parent process. options are additional flags that may be passed to startProcess. See the documentation of ProcessOption for the meaning of these flags.

	You need to close the process when done.

	Note that you can't pass any args if you use the option poEvalCommand, which invokes the system shell to run the specified command. In this situation you have to concatenate manually the contents of args to command carefully escaping/quoting any special characters, since it will be passed as is to the system shell. Each system/shell may feature different escaping rules, so try to avoid this kind of shell invocation if possible as it leads to non portable software.

	Return value: The newly created process object. Nil is never returned, but OSError is raised in case of an error.

	See also:

    	execProcesses proc
    	execProcess proc
    	execCmd proc

	Source   Edit   

proc suspend(p: Process) {.....}

	Suspends the process p.

	See also:

    	resume proc
    	terminate proc
    	kill proc

	Source   Edit   

proc terminate(p: Process) {.....}

	Stop the process p.

	On Posix OSes the procedure sends SIGTERM to the process. On Windows the Win32 API function TerminateProcess() is called to stop the process.

	See also:

    	suspend proc
    	resume proc
    	kill proc
    	posix_utils.sendSignal(pid: Pid, signal: int)

	Source   Edit   

proc waitForExit(p: Process; timeout: int = -1): int {.....}

	Waits for the process to finish and returns p's error code.
	Warning: Be careful when using waitForExit for processes created without poParentStreams because they may fill output buffers, causing deadlock.

	On posix, if the process has exited because of a signal, 128 + signal number will be returned.
	Warning: When working with timeout parameters, remember that the value is typically expressed in milliseconds, and ensure that the correct unit of time is used to avoid unexpected behavior.
	Source   Edit   

Iterators

iterator lines(p: Process; keepNewLines = false): string {.
	....}

Convenience iterator for working with startProcess to read data from a background process.

See also:

	readLines proc

Example:

const opts = {poUsePath, poDaemon, poStdErrToStdOut}
var ps: seq[Process]
for prog in ["a", "b"]: # run 2 progs in parallel
  ps.add startProcess("nim", "", ["r", prog], nil, opts)
for p in ps:
  var i = 0
  for line in p.lines:
	echo line
	i.inc
	if i > 100: break
  p.close

	Source   Edit   

Exports

quoteShell, quoteShellWindows, quoteShellPosix

std/paths


std/paths
Source   Edit  

This module implements path handling.

See also:

	files module for file access

Imports

osseps, envvars, osappdirs, pathnorm, ospaths2

Types

Path = distinct string

	Source   Edit   

Procs

func `/`(head, tail: Path): Path {.inline, ....}

	Joins two directory names to one.

	returns normalized path concatenation of head and tail, preserving whether or not tail has a trailing slash (or, if tail if empty, whether head has one).

	See also:

    	splitPath proc
    	uri.combine proc
    	uri./ proc

	Source   Edit   

func `/../`(head, tail: Path): Path {.inline, ....}

	The same as parentDir(head) / tail, unless there is no parent directory. Then head / tail is performed instead.

	See also:

    	/ proc
    	parentDir proc

	Source   Edit   

func `==`(x, y: Path): bool {.inline, ....}

	Compares two paths.

	On a case-sensitive filesystem this is done case-sensitively otherwise case-insensitively.
	Source   Edit   

proc absolutePath(path: Path; root = getCurrentDir()): Path {.
	....}

	Returns the absolute path of path, rooted at root (which must be absolute; default: current directory). If path is absolute, return it, ignoring root.

	See also:

    	normalizePath proc

	Source   Edit   

func add(x: var Path; y: Path) {.borrow, ....}

	Source   Edit   

func addFileExt(filename: Path; ext: string): Path {.inline, ....}

	Adds the file extension ext to filename, unless filename already has an extension.

	Ext should be given without the leading '.', because some filesystems may use a different character. (Although I know of none such beast.)

	See also:

    	splitFile proc
    	extractFilename proc
    	lastPathPart proc
    	changeFileExt proc

	Source   Edit   

func changeFileExt(filename: Path; ext: string): Path {.inline, ....}

	Changes the file extension to ext.

	If the filename has no extension, ext will be added. If ext == "" then any extension is removed.

	Ext should be given without the leading '.', because some filesystems may use a different character. (Although I know of none such beast.)

	See also:

    	splitFile proc
    	extractFilename proc
    	lastPathPart proc
    	addFileExt proc

	Source   Edit   

proc expandTilde(path: Path): Path {.inline,
                                 	....}

Expands ~ or a path starting with ~/ to a full path, replacing ~ with getHomeDir() (otherwise returns path unmodified).

Windows: this is still supported despite the Windows platform not having this convention; also, both ~/ and ~\ are handled.

Example:

import std/appdirs
assert expandTilde(Path("~") / Path("appname.cfg")) == getHomeDir() / Path("appname.cfg")
assert expandTilde(Path("~/foo/bar")) == getHomeDir() / Path("foo/bar")
assert expandTilde(Path("/foo/bar")) == Path("/foo/bar")

	Source   Edit   

func extractFilename(path: Path): Path {.inline, ....}

	Extracts the filename of a given path.

	This is the same as name & ext from splitFile(path) proc.

	See also:

    	splitFile proc
    	lastPathPart proc
    	changeFileExt proc
    	addFileExt proc

	Source   Edit   

proc getCurrentDir(): Path {.inline, ....}

	Returns the current working directory i.e. where the built binary is run.

	So the path returned by this proc is determined at run time.

	See also:

    	getHomeDir proc
    	getConfigDir proc
    	getTempDir proc
    	setCurrentDir proc
    	currentSourcePath template
    	getProjectPath proc

	Source   Edit   

func isAbsolute(path: Path): bool {.inline, ....}

	Checks whether a given path is absolute.

	On Windows, network paths are considered absolute too.
	Source   Edit   

proc isRelativeTo(path: Path; base: Path): bool {.inline, ....}

	Returns true if path is relative to base. Source   Edit   

func isRootDir(path: Path): bool {.inline, ....}

	Checks whether a given path is a root directory. Source   Edit   

func lastPathPart(path: Path): Path {.inline, ....}

	Like extractFilename proc, but ignores trailing dir separator; aka: baseName in some other languages.

	See also:

    	splitFile proc
    	extractFilename proc
    	changeFileExt proc
    	addFileExt proc

	Source   Edit   

proc normalizeExe(file: var Path) {.borrow, ....}

	Source   Edit   

proc normalizePath(path: var Path) {.borrow, ....}

	Source   Edit   

proc normalizePathEnd(path: var Path; trailingSep = false) {.borrow, ....}

	Source   Edit   

func parentDir(path: Path): Path {.inline, ....}

	Returns the parent directory of path.

	This is similar to splitPath(path).head when path doesn't end in a dir separator, but also takes care of path normalizations. The remainder can be obtained with lastPathPart(path) proc.

	See also:

    	relativePath proc
    	splitPath proc
    	tailDir proc
    	parentDirs iterator

	Source   Edit   

proc relativePath(path, base: Path; sep = DirSep): Path {.inline,
	....}

	Converts path to a path relative to base.

	The sep (default: DirSep) is used for the path normalizations, this can be useful to ensure the relative path only contains '/' so that it can be used for URL constructions.

	On Windows, if a root of path and a root of base are different, returns path as is because it is impossible to make a relative path. That means an absolute path can be returned.

	See also:

    	splitPath proc
    	parentDir proc
    	tailDir proc

	Source   Edit   

func splitFile(path: Path): tuple[dir, name: Path, ext: string] {.inline,
	....}

	Splits a filename into (dir, name, extension) tuple.

	dir does not end in DirSep unless it's /. extension includes the leading dot.

	If path has no extension, ext is the empty string. If path has no directory component, dir is the empty string. If path has no filename component, name and ext are empty strings.

	See also:

    	extractFilename proc
    	lastPathPart proc
    	changeFileExt proc
    	addFileExt proc

	Source   Edit   

func splitPath(path: Path): tuple[head, tail: Path] {.inline, ....}

	Splits a directory into (head, tail) tuple, so that head / tail == path (except for edge cases like "/usr").

	See also:

    	add proc
    	/ proc
    	/../ proc
    	relativePath proc

	Source   Edit   

func tailDir(path: Path): Path {.inline, ....}

	Returns the tail part of path.

	See also:

    	relativePath proc
    	splitPath proc
    	parentDir proc

	Source   Edit   

func unixToNativePath(path: Path; drive = Path("")): Path {.inline, ....}

	Converts an UNIX-like path to a native one.

	On an UNIX system this does nothing. Else it converts '/', '.', '..' to the appropriate things.

	On systems with a concept of "drives", drive is used to determine which drive label to use during absolute path conversion. drive defaults to the drive of the current working directory, and is ignored on systems that do not have a concept of "drives".
	Source   Edit   

Iterators

iterator parentDirs(path: Path; fromRoot = false; inclusive = true): Path {.
	....}

	Walks over all parent directories of a given path.

	If fromRoot is true (default: false), the traversal will start from the file system root directory. If inclusive is true (default), the original argument will be included in the traversal.

	Relative paths won't be expanded by this iterator. Instead, it will traverse only the directories appearing in the relative path.

	See also:

    	parentDir proc

	Source   Edit   

Exports

ExtSep, FileSystemCaseSensitive, DynlibFormat, DirSep, AltSep, PathSep, ScriptExt, doslikeFileSystem, ExeExt, CurDir, ParDir, ReadDirEffect, WriteDirEffect

std/reservedmem


std/reservedmem
Source   Edit  

Authors:	Zahary Karadjov

This module provides utilities for reserving portions of the address space of a program without consuming physical memory. It can be used to implement a dynamically resizable buffer that is guaranteed to remain in the same memory location. The buffer will be able to grow up to the size of the initially reserved portion of the address space.

Unstable API.

Imports

oserrors, winlean, win_getsysteminfo

Types

MemAccessFlags = int

	Source   Edit   

ReservedMem = object

	Source   Edit   

ReservedMemSeq[T] = object

	Source   Edit   

Consts

memExec = 16

	Source   Edit   

memExecRead = 32

	Source   Edit   

memExecReadWrite = 64

	Source   Edit   

memRead = 2

	Source   Edit   

memReadWrite = 4

	Source   Edit   

Procs

func `[]`[T](s: ReservedMemSeq[T]; pos: Natural): lent T

	Source   Edit   

func `[]`[T](s: ReservedMemSeq[T]; rpos: BackwardsIndex): lent T

	Source   Edit   

func `[]`[T](s: var ReservedMemSeq[T]; pos: Natural): var T

	Source   Edit   

func `[]`[T](s: var ReservedMemSeq[T]; rpos: BackwardsIndex): var T

	Source   Edit   

proc add[T](s: var ReservedMemSeq[T]; val: T)

	Source   Edit   

func commitedLen(m: ReservedMem): int {.....}

	Source   Edit   

func commitedLen[T](s: ReservedMemSeq[T]): int

	Source   Edit   

proc init(SeqType: type ReservedMemSeq; maxLen: Natural; initLen: Natural = 0;
      	initCommitLen: Natural = 0; memStart = pointer(nil);
      	accessFlags = memReadWrite; maxCommittedAndUnusedPages = 3): SeqType:type

	Source   Edit   

proc init(T: type ReservedMem; maxLen: Natural; initLen: Natural = 0;
      	initCommitLen = initLen; memStart = pointer(nil);
      	accessFlags = memReadWrite; maxCommittedAndUnusedPages = 3): ReservedMem

	Source   Edit   

func len(m: ReservedMem): int {.....}

	Source   Edit   

func len[T](s: ReservedMemSeq[T]): int

	Source   Edit   

func maxLen(m: ReservedMem): int {.....}

	Source   Edit   

func maxLen[T](s: ReservedMemSeq[T]): int

	Source   Edit   

proc pop[T](s: var ReservedMemSeq[T]): T

	Source   Edit   

proc setLen(m: var ReservedMem; newLen: int) {.....}

	Source   Edit   

proc setLen[T](s: var ReservedMemSeq[T]; newLen: int)

	Source   Edit   

Templates

template distance(lhs, rhs: pointer): int

	Source   Edit   

template shift(p: pointer; distance: int): pointer

	Source   Edit   

std/streams


std/streams
Source   Edit  

This module provides a stream interface and two implementations thereof: the FileStream and the StringStream which implement the stream interface for Nim file objects (File) and strings.

Other modules may provide other implementations for this standard stream interface.
Basic usage

The basic flow of using this module is:

	Open input stream
	Read or write stream
	Close stream

StringStream example

import std/streams

var strm = newStringStream("""The first line
the second line
the third line""")

var line = ""

while strm.readLine(line):
  echo line

# Output:
# The first line
# the second line
# the third line

strm.close()

FileStream example

Write file stream example:

import std/streams

var strm = newFileStream("somefile.txt", fmWrite)
var line = ""

if not isNil(strm):
  strm.writeLine("The first line")
  strm.writeLine("the second line")
  strm.writeLine("the third line")
  strm.close()

# Output (somefile.txt):
# The first line
# the second line
# the third line

Read file stream example:

import std/streams

var strm = newFileStream("somefile.txt", fmRead)
var line = ""

if not isNil(strm):
  while strm.readLine(line):
	echo line
  strm.close()

# Output:
# The first line
# the second line
# the third line

See also

	asyncstreams module
	io module for FileMode enum

Imports

since

Types

FileStream = ref FileStreamObj

	A stream that encapsulates a File.

	Note: Not available for JS backend.
	Source   Edit   

FileStreamObj = object of Stream

	A file stream object.

	Note: Not available for JS backend.
	Source   Edit   

Stream = ref StreamObj

	All procedures of this module use this type. Procedures don't directly use StreamObj. Source   Edit   

StreamObj = object of RootObj
  closeImpl*: proc (s: Stream) {.nimcall, ....}
  atEndImpl*: proc (s: Stream): bool {.nimcall,
                                   	....}
  setPositionImpl*: proc (s: Stream; pos: int) {.nimcall,
  	....}
  getPositionImpl*: proc (s: Stream): int {.nimcall,
  	....}
  readDataStrImpl*: proc (s: Stream; buffer: var string; slice: Slice[int]): int {.
  	nimcall, ....}
  readLineImpl*: proc (s: Stream; line: var string): bool {.nimcall,
  	....}
  readDataImpl*: proc (s: Stream; buffer: pointer; bufLen: int): int {.nimcall,
  	....}
  peekDataImpl*: proc (s: Stream; buffer: pointer; bufLen: int): int {.nimcall,
  	....}
  writeDataImpl*: proc (s: Stream; buffer: pointer; bufLen: int) {.nimcall,
  	....}
  flushImpl*: proc (s: Stream) {.nimcall, ....}

	Stream interface that supports writing or reading.

	Note:

    	That these fields here shouldn't be used directly. They are accessible so that a stream implementation can override them.

	Source   Edit   

StringStream = ref StringStreamObj

	A stream that encapsulates a string. Source   Edit   

StringStreamObj = object of StreamObj
  data*: string          	## A string data.
                         	## This is updated when called `writeLine` etc.

	A string stream object. Source   Edit   

Procs

proc atEnd(s: Stream): bool {.....}

Checks if more data can be read from s. Returns true if all data has been read.

Example:

var strm = newStringStream("The first line\nthe second line\nthe third line")
var line = ""
doAssert strm.atEnd() == false
while strm.readLine(line):
  discard
doAssert strm.atEnd() == true
strm.close()

	Source   Edit   

proc close(s: Stream) {.....}

Closes the stream s.

See also:

	flush proc

Example:

block:
  let strm = newStringStream("The first line\nthe second line\nthe third line")
  ## do something...
  strm.close()
 
block:
  let strm = newFileStream("amissingfile.txt")
  # deferring works even if newFileStream fails
  defer: strm.close()
  if not isNil(strm):
	## do something...

	Source   Edit   

proc flush(s: Stream) {.....}

Flushes the buffers that the stream s might use.

This procedure causes any unwritten data for that stream to be delivered to the host environment to be written to the file.

See also:

	close proc

Example:

from std/os import removeFile

var strm = newFileStream("somefile.txt", fmWrite)

doAssert "Before write:" & readFile("somefile.txt") == "Before write:"
strm.write("hello")
doAssert "After  write:" & readFile("somefile.txt") == "After  write:"

strm.flush()
doAssert "After  flush:" & readFile("somefile.txt") == "After  flush:hello"
strm.write("HELLO")
strm.flush()
doAssert "After  flush:" & readFile("somefile.txt") == "After  flush:helloHELLO"

strm.close()
doAssert "After  close:" & readFile("somefile.txt") == "After  close:helloHELLO"
removeFile("somefile.txt")

	Source   Edit   

proc getPosition(s: Stream): int {.....}

Retrieves the current position in the stream s.

Example:

var strm = newStringStream("The first line\nthe second line\nthe third line")
doAssert strm.getPosition() == 0
discard strm.readLine()
doAssert strm.getPosition() == 15
strm.close()

	Source   Edit   

proc newFileStream(f: File): owned FileStream {.....}

Creates a new stream from the file f.

Note: Not available for JS backend.

See also:

	newStringStream proc creates a new stream from string.
	newFileStream proc is the same as using open proc on Examples.
	openFileStream proc creates a file stream from the file name and the mode.

Example:

## Input (somefile.txt):
## The first line
## the second line
## the third line
var f: File
if open(f, "somefile.txt", fmRead, -1):
  var strm = newFileStream(f)
  var line = ""
  while strm.readLine(line):
	echo line
  ## Output:
  ## The first line
  ## the second line
  ## the third line
  strm.close()

	Source   Edit   

proc newFileStream(filename: string; mode: FileMode = fmRead; bufSize: int = -1): owned
	FileStream {.....}

Creates a new stream from the file named filename with the mode mode.

If the file cannot be opened, nil is returned. See the io module for a list of available FileMode enums.

Note:

	This function returns nil in case of failure. To prevent unexpected behavior and ensure proper error handling, use openFileStream proc instead.
	Not available for JS backend.

See also:

	newStringStream proc creates a new stream from string.
	newFileStream proc creates a file stream from opened File.
	openFileStream proc creates a file stream from the file name and the mode.

Example:

from std/os import removeFile
var strm = newFileStream("somefile.txt", fmWrite)
if not isNil(strm):
  strm.writeLine("The first line")
  strm.writeLine("the second line")
  strm.writeLine("the third line")
  strm.close()
  ## Output (somefile.txt)
  ## The first line
  ## the second line
  ## the third line
  removeFile("somefile.txt")

	Source   Edit   

proc newStringStream(s: sink string = ""): owned StringStream {.....}

Creates a new stream from the string s.

See also:

	newFileStream proc creates a file stream from opened File.
	newFileStream proc creates a file stream from the file name and the mode.
	openFileStream proc creates a file stream from the file name and the mode.

Example:

var strm = newStringStream("The first line\nthe second line\nthe third line")
doAssert strm.readLine() == "The first line"
doAssert strm.readLine() == "the second line"
doAssert strm.readLine() == "the third line"
strm.close()

	Source   Edit   

proc openFileStream(filename: string; mode: FileMode = fmRead; bufSize: int = -1): owned
	FileStream {.....}

Creates a new stream from the file named filename with the mode mode. If the file cannot be opened, an IO exception is raised.

Note: Not available for JS backend.

See also:

	newStringStream proc creates a new stream from string.
	newFileStream proc creates a file stream from opened File.
	newFileStream proc creates a file stream from the file name and the mode.

Example:

try:
  ## Input (somefile.txt):
  ## The first line
  ## the second line
  ## the third line
  var strm = openFileStream("somefile.txt")
  echo strm.readLine()
  ## Output:
  ## The first line
  strm.close()
except:
  stderr.write getCurrentExceptionMsg()

	Source   Edit   

proc peek[T](s: Stream; result: var T)

Generic peek procedure. Peeks result from the stream s.

Note: Not available for JS backend. Use peekStr for now.

Example:

var strm = newStringStream("012")
## peekInt
var i: int8
strm.peek(i)
doAssert i == 48
## peekData
var buffer: array[2, char]
strm.peek(buffer)
doAssert buffer == ['0', '1']
strm.close()

	Source   Edit   

proc peekBool(s: Stream): bool {.....}

Peeks a bool from the stream s.

A bool is one byte long and it is true for every non-zero (0000_0000) value. Raises IOError if an error occurred.

Note: Not available for JS backend. Use peekStr for now.

Example:

var strm = newStringStream()
## setup for reading data
strm.write(true)
strm.write(false)
strm.flush()
strm.setPosition(0)
## get data
doAssert strm.peekBool() == true
## not false
doAssert strm.peekBool() == true
doAssert strm.readBool() == true
doAssert strm.peekBool() == false
strm.close()

	Source   Edit   

proc peekChar(s: Stream): char {.....}

Peeks a char from the stream s. Raises IOError if an error occurred. Returns '\0' as an EOF marker.

Example:

var strm = newStringStream("12\n3")
doAssert strm.peekChar() == '1'
doAssert strm.peekChar() == '1'
discard strm.readAll()
doAssert strm.peekChar() == '\x00'
strm.close()

	Source   Edit   

proc peekData(s: Stream; buffer: pointer; bufLen: int): int {.
	....}

Low level proc that reads data into an untyped buffer of bufLen size without moving stream position.

JS note: buffer is treated as a ptr string and written to between 0..<bufLen.

Example:

var strm = newStringStream("abcde")
var buffer: array[6, char]
doAssert strm.peekData(addr(buffer), 1024) == 5
doAssert buffer == ['a', 'b', 'c', 'd', 'e', '\x00']
doAssert strm.atEnd() == false
strm.close()

	Source   Edit   

proc peekFloat32(s: Stream): float32 {.....}

Peeks a float32 from the stream s. Raises IOError if an error occurred.

Note: Not available for JS backend. Use peekStr for now.

Example:

var strm = newStringStream()
## setup for reading data
strm.write(1'f32)
strm.write(2'f32)
strm.flush()
strm.setPosition(0)
## get data
doAssert strm.peekFloat32() == 1'f32
## not 2'f32
doAssert strm.peekFloat32() == 1'f32
doAssert strm.readFloat32() == 1'f32
doAssert strm.peekFloat32() == 2'f32
strm.close()

	Source   Edit   

proc peekFloat64(s: Stream): float64 {.....}

Peeks a float64 from the stream s. Raises IOError if an error occurred.

Note: Not available for JS backend. Use peekStr for now.

Example:

var strm = newStringStream()
## setup for reading data
strm.write(1'f64)
strm.write(2'f64)
strm.flush()
strm.setPosition(0)
## get data
doAssert strm.peekFloat64() == 1'f64
## not 2'f64
doAssert strm.peekFloat64() == 1'f64
doAssert strm.readFloat64() == 1'f64
doAssert strm.peekFloat64() == 2'f64
strm.close()

	Source   Edit   

proc peekInt8(s: Stream): int8 {.....}

Peeks an int8 from the stream s. Raises IOError if an error occurred.

Note: Not available for JS backend. Use peekStr for now.

Example:

var strm = newStringStream()
## setup for reading data
strm.write(1'i8)
strm.write(2'i8)
strm.flush()
strm.setPosition(0)
## get data
doAssert strm.peekInt8() == 1'i8
## not 2'i8
doAssert strm.peekInt8() == 1'i8
doAssert strm.readInt8() == 1'i8
doAssert strm.peekInt8() == 2'i8
strm.close()

	Source   Edit   

proc peekInt16(s: Stream): int16 {.....}

Peeks an int16 from the stream s. Raises IOError if an error occurred.

Note: Not available for JS backend. Use peekStr for now.

Example:

var strm = newStringStream()
## setup for reading data
strm.write(1'i16)
strm.write(2'i16)
strm.flush()
strm.setPosition(0)
## get data
doAssert strm.peekInt16() == 1'i16
## not 2'i16
doAssert strm.peekInt16() == 1'i16
doAssert strm.readInt16() == 1'i16
doAssert strm.peekInt16() == 2'i16
strm.close()

	Source   Edit   

proc peekInt32(s: Stream): int32 {.....}

Peeks an int32 from the stream s. Raises IOError if an error occurred.

Note: Not available for JS backend. Use peekStr for now.

Example:

var strm = newStringStream()
## setup for reading data
strm.write(1'i32)
strm.write(2'i32)
strm.flush()
strm.setPosition(0)
## get data
doAssert strm.peekInt32() == 1'i32
## not 2'i32
doAssert strm.peekInt32() == 1'i32
doAssert strm.readInt32() == 1'i32
doAssert strm.peekInt32() == 2'i32
strm.close()

	Source   Edit   

proc peekInt64(s: Stream): int64 {.....}

Peeks an int64 from the stream s. Raises IOError if an error occurred.

Note: Not available for JS backend. Use peekStr for now.

Example:

var strm = newStringStream()
## setup for reading data
strm.write(1'i64)
strm.write(2'i64)
strm.flush()
strm.setPosition(0)
## get data
doAssert strm.peekInt64() == 1'i64
## not 2'i64
doAssert strm.peekInt64() == 1'i64
doAssert strm.readInt64() == 1'i64
doAssert strm.peekInt64() == 2'i64
strm.close()

	Source   Edit   

proc peekLine(s: Stream): string {.....}

Peeks a line from a stream s. Raises IOError if an error occurred.

Note: This is not very efficient.

See also:

	readLine(Stream) proc
	readLine(Stream, string) proc
	peekLine(Stream, string) proc

Example:

var strm = newStringStream("The first line\nthe second line\nthe third line")
doAssert strm.peekLine() == "The first line"
## not "the second line"
doAssert strm.peekLine() == "The first line"
doAssert strm.readLine() == "The first line"
doAssert strm.peekLine() == "the second line"
strm.close()

	Source   Edit   

proc peekLine(s: Stream; line: var string): bool {.....}

Peeks a line of text from the stream s into line. line must not be nil! May throw an IO exception.

A line of text may be delimited by CR, LF or CRLF. The newline character(s) are not part of the returned string. Returns false if the end of the file has been reached, true otherwise. If false is returned line contains no new data.

See also:

	readLine(Stream) proc
	readLine(Stream, string) proc
	peekLine(Stream) proc

Example:

var strm = newStringStream("The first line\nthe second line\nthe third line")
var line = ""
doAssert strm.peekLine(line) == true
doAssert line == "The first line"
doAssert strm.peekLine(line) == true
## not "the second line"
doAssert line == "The first line"
doAssert strm.readLine(line) == true
doAssert line == "The first line"
doAssert strm.peekLine(line) == true
doAssert line == "the second line"
strm.close()

	Source   Edit   

proc peekStr(s: Stream; length: int): string {.....}

Peeks a string of length length from the stream s. Raises IOError if an error occurred.

Example:

var strm = newStringStream("abcde")
doAssert strm.peekStr(2) == "ab"
## not "cd
doAssert strm.peekStr(2) == "ab"
doAssert strm.readStr(2) == "ab"
doAssert strm.peekStr(2) == "cd"
strm.close()

	Source   Edit   

proc peekStr(s: Stream; length: int; str: var string) {.
	....}

	Peeks a string of length length from the stream s. Raises IOError if an error occurred. Source   Edit   

proc peekUint8(s: Stream): uint8 {.....}

Peeks an uint8 from the stream s. Raises IOError if an error occurred.

Note: Not available for JS backend. Use peekStr for now.

Example:

var strm = newStringStream()
## setup for reading data
strm.write(1'u8)
strm.write(2'u8)
strm.flush()
strm.setPosition(0)
## get data
doAssert strm.peekUint8() == 1'u8
## not 2'u8
doAssert strm.peekUint8() == 1'u8
doAssert strm.readUint8() == 1'u8
doAssert strm.peekUint8() == 2'u8
strm.close()

	Source   Edit   

proc peekUint16(s: Stream): uint16 {.....}

Peeks an uint16 from the stream s. Raises IOError if an error occurred.

Note: Not available for JS backend. Use peekStr for now.

Example:

var strm = newStringStream()
## setup for reading data
strm.write(1'u16)
strm.write(2'u16)
strm.flush()
strm.setPosition(0)
## get data
doAssert strm.peekUint16() == 1'u16
## not 2'u16
doAssert strm.peekUint16() == 1'u16
doAssert strm.readUint16() == 1'u16
doAssert strm.peekUint16() == 2'u16
strm.close()

	Source   Edit   

proc peekUint32(s: Stream): uint32 {.....}

Peeks an uint32 from the stream s. Raises IOError if an error occurred.

Note: Not available for JS backend. Use peekStr for now.

Example:

var strm = newStringStream()
## setup for reading data
strm.write(1'u32)
strm.write(2'u32)
strm.flush()
strm.setPosition(0)
## get data
doAssert strm.peekUint32() == 1'u32
## not 2'u32
doAssert strm.peekUint32() == 1'u32
doAssert strm.readUint32() == 1'u32
doAssert strm.peekUint32() == 2'u32
strm.close()

	Source   Edit   

proc peekUint64(s: Stream): uint64 {.....}

Peeks an uint64 from the stream s. Raises IOError if an error occurred.

Note: Not available for JS backend. Use peekStr for now.

Example:

var strm = newStringStream()
## setup for reading data
strm.write(1'u64)
strm.write(2'u64)
strm.flush()
strm.setPosition(0)
## get data
doAssert strm.peekUint64() == 1'u64
## not 2'u64
doAssert strm.peekUint64() == 1'u64
doAssert strm.readUint64() == 1'u64
doAssert strm.peekUint64() == 2'u64
strm.close()

	Source   Edit   

proc read[T](s: Stream; result: var T)

Generic read procedure. Reads result from the stream s.

Note: Not available for JS backend. Use readStr for now.

Example:

var strm = newStringStream("012")
## readInt
var i: int8
strm.read(i)
doAssert i == 48
## readData
var buffer: array[2, char]
strm.read(buffer)
doAssert buffer == ['1', '2']
strm.close()

	Source   Edit   

proc readAll(s: Stream): string {.....}

Reads all available data.

Example:

var strm = newStringStream("The first line\nthe second line\nthe third line")
doAssert strm.readAll() == "The first line\nthe second line\nthe third line"
doAssert strm.atEnd() == true
strm.close()

	Source   Edit   

proc readBool(s: Stream): bool {.....}

Reads a bool from the stream s.

A bool is one byte long and it is true for every non-zero (0000_0000) value. Raises IOError if an error occurred.

Note: Not available for JS backend. Use readStr for now.

Example:

var strm = newStringStream()
## setup for reading data
strm.write(true)
strm.write(false)
strm.flush()
strm.setPosition(0)
## get data
doAssert strm.readBool() == true
doAssert strm.readBool() == false
doAssertRaises(IOError): discard strm.readBool()
strm.close()

	Source   Edit   

proc readChar(s: Stream): char {.....}

Reads a char from the stream s.

Raises IOError if an error occurred. Returns '\0' as an EOF marker.

Example:

var strm = newStringStream("12\n3")
doAssert strm.readChar() == '1'
doAssert strm.readChar() == '2'
doAssert strm.readChar() == '\n'
doAssert strm.readChar() == '3'
doAssert strm.readChar() == '\x00'
strm.close()

	Source   Edit   

proc readData(s: Stream; buffer: pointer; bufLen: int): int {.
	....}

Low level proc that reads data into an untyped buffer of bufLen size.

JS note: buffer is treated as a ptr string and written to between 0..<bufLen.

Example:

var strm = newStringStream("abcde")
var buffer: array[6, char]
doAssert strm.readData(addr(buffer), 1024) == 5
doAssert buffer == ['a', 'b', 'c', 'd', 'e', '\x00']
doAssert strm.atEnd() == true
strm.close()

	Source   Edit   

proc readDataStr(s: Stream; buffer: var string; slice: Slice[int]): int {.
	....}

Low level proc that reads data into a string buffer at slice.

Example:

var strm = newStringStream("abcde")
var buffer = "12345"
doAssert strm.readDataStr(buffer, 0..3) == 4
doAssert buffer == "abcd5"
strm.close()

	Source   Edit   

proc readFloat32(s: Stream): float32 {.....}

Reads a float32 from the stream s. Raises IOError if an error occurred.

Note: Not available for JS backend. Use readStr for now.

Example:

var strm = newStringStream()
## setup for reading data
strm.write(1'f32)
strm.write(2'f32)
strm.flush()
strm.setPosition(0)
## get data
doAssert strm.readFloat32() == 1'f32
doAssert strm.readFloat32() == 2'f32
doAssertRaises(IOError): discard strm.readFloat32()
strm.close()

	Source   Edit   

proc readFloat64(s: Stream): float64 {.....}

Reads a float64 from the stream s. Raises IOError if an error occurred.

Note: Not available for JS backend. Use readStr for now.

Example:

var strm = newStringStream()
## setup for reading data
strm.write(1'f64)
strm.write(2'f64)
strm.flush()
strm.setPosition(0)
## get data
doAssert strm.readFloat64() == 1'f64
doAssert strm.readFloat64() == 2'f64
doAssertRaises(IOError): discard strm.readFloat64()
strm.close()

	Source   Edit   

proc readInt8(s: Stream): int8 {.....}

Reads an int8 from the stream s. Raises IOError if an error occurred.

Note: Not available for JS backend. Use readStr for now.

Example:

var strm = newStringStream()
## setup for reading data
strm.write(1'i8)
strm.write(2'i8)
strm.flush()
strm.setPosition(0)
## get data
doAssert strm.readInt8() == 1'i8
doAssert strm.readInt8() == 2'i8
doAssertRaises(IOError): discard strm.readInt8()
strm.close()

	Source   Edit   

proc readInt16(s: Stream): int16 {.....}

Reads an int16 from the stream s. Raises IOError if an error occurred.

Note: Not available for JS backend. Use readStr for now.

Example:

var strm = newStringStream()
## setup for reading data
strm.write(1'i16)
strm.write(2'i16)
strm.flush()
strm.setPosition(0)
## get data
doAssert strm.readInt16() == 1'i16
doAssert strm.readInt16() == 2'i16
doAssertRaises(IOError): discard strm.readInt16()
strm.close()

	Source   Edit   

proc readInt32(s: Stream): int32 {.....}

Reads an int32 from the stream s. Raises IOError if an error occurred.

Note: Not available for JS backend. Use readStr for now.

Example:

var strm = newStringStream()
## setup for reading data
strm.write(1'i32)
strm.write(2'i32)
strm.flush()
strm.setPosition(0)
## get data
doAssert strm.readInt32() == 1'i32
doAssert strm.readInt32() == 2'i32
doAssertRaises(IOError): discard strm.readInt32()
strm.close()

	Source   Edit   

proc readInt64(s: Stream): int64 {.....}

Reads an int64 from the stream s. Raises IOError if an error occurred.

Note: Not available for JS backend. Use readStr for now.

Example:

var strm = newStringStream()
## setup for reading data
strm.write(1'i64)
strm.write(2'i64)
strm.flush()
strm.setPosition(0)
## get data
doAssert strm.readInt64() == 1'i64
doAssert strm.readInt64() == 2'i64
doAssertRaises(IOError): discard strm.readInt64()
strm.close()

	Source   Edit   

proc readLine(s: Stream): string {.....}

Reads a line from a stream s. Raises IOError if an error occurred.

Note: This is not very efficient.

See also:

	readLine(Stream, string) proc
	peekLine(Stream) proc
	peekLine(Stream, string) proc

Example:

var strm = newStringStream("The first line\nthe second line\nthe third line")
doAssert strm.readLine() == "The first line"
doAssert strm.readLine() == "the second line"
doAssert strm.readLine() == "the third line"
doAssertRaises(IOError): discard strm.readLine()
strm.close()

	Source   Edit   

proc readLine(s: Stream; line: var string): bool {.....}

Reads a line of text from the stream s into line. line must not be nil! May throw an IO exception.

A line of text may be delimited by LF or CRLF. The newline character(s) are not part of the returned string. Returns false if the end of the file has been reached, true otherwise. If false is returned line contains no new data.

See also:

	readLine(Stream) proc
	peekLine(Stream) proc
	peekLine(Stream, string) proc

Example:

var strm = newStringStream("The first line\nthe second line\nthe third line")
var line = ""
doAssert strm.readLine(line) == true
doAssert line == "The first line"
doAssert strm.readLine(line) == true
doAssert line == "the second line"
doAssert strm.readLine(line) == true
doAssert line == "the third line"
doAssert strm.readLine(line) == false
doAssert line == ""
strm.close()

	Source   Edit   

proc readStr(s: Stream; length: int): string {.....}

Reads a string of length length from the stream s. Raises IOError if an error occurred.

Example:

var strm = newStringStream("abcde")
doAssert strm.readStr(2) == "ab"
doAssert strm.readStr(2) == "cd"
doAssert strm.readStr(2) == "e"
doAssert strm.readStr(2) == ""
strm.close()

	Source   Edit   

proc readStr(s: Stream; length: int; str: var string) {.
	....}

	Reads a string of length length from the stream s. Raises IOError if an error occurred. Source   Edit   

proc readUint8(s: Stream): uint8 {.....}

Reads an uint8 from the stream s. Raises IOError if an error occurred.

Note: Not available for JS backend. Use readStr for now.

Example:

var strm = newStringStream()
## setup for reading data
strm.write(1'u8)
strm.write(2'u8)
strm.flush()
strm.setPosition(0)
## get data
doAssert strm.readUint8() == 1'u8
doAssert strm.readUint8() == 2'u8
doAssertRaises(IOError): discard strm.readUint8()
strm.close()

	Source   Edit   

proc readUint16(s: Stream): uint16 {.....}

Reads an uint16 from the stream s. Raises IOError if an error occurred.

Note: Not available for JS backend. Use readStr for now.

Example:

var strm = newStringStream()
## setup for reading data
strm.write(1'u16)
strm.write(2'u16)
strm.flush()
strm.setPosition(0)
## get data
doAssert strm.readUint16() == 1'u16
doAssert strm.readUint16() == 2'u16
doAssertRaises(IOError): discard strm.readUint16()
strm.close()

	Source   Edit   

proc readUint32(s: Stream): uint32 {.....}

Reads an uint32 from the stream s. Raises IOError if an error occurred.

Note: Not available for JS backend. Use readStr for now.

Example:

var strm = newStringStream()
## setup for reading data
strm.write(1'u32)
strm.write(2'u32)
strm.flush()
strm.setPosition(0)

## get data
doAssert strm.readUint32() == 1'u32
doAssert strm.readUint32() == 2'u32
doAssertRaises(IOError): discard strm.readUint32()
strm.close()

	Source   Edit   

proc readUint64(s: Stream): uint64 {.....}

Reads an uint64 from the stream s. Raises IOError if an error occurred.

Note: Not available for JS backend. Use readStr for now.

Example:

var strm = newStringStream()
## setup for reading data
strm.write(1'u64)
strm.write(2'u64)
strm.flush()
strm.setPosition(0)
## get data
doAssert strm.readUint64() == 1'u64
doAssert strm.readUint64() == 2'u64
doAssertRaises(IOError): discard strm.readUint64()
strm.close()

	Source   Edit   

proc setPosition(s: Stream; pos: int) {.....}

Sets the position pos of the stream s.

Example:

var strm = newStringStream("The first line\nthe second line\nthe third line")
strm.setPosition(4)
doAssert strm.readLine() == "first line"
strm.setPosition(0)
doAssert strm.readLine() == "The first line"
strm.close()

	Source   Edit   

proc write(s: Stream; args: varargs[string, `$`]) {.....}

Writes one or more strings to the the stream. No length fields or terminating zeros are written.

Example:

var strm = newStringStream("")
strm.write(1, 2, 3, 4)
strm.setPosition(0)
doAssert strm.readLine() == "1234"
strm.close()

	Source   Edit   

proc write(s: Stream; x: string) {.....}

Writes the string x to the stream s. No length field or terminating zero is written.

Example:

var strm = newStringStream("")
strm.write("THE FIRST LINE")
strm.setPosition(0)
doAssert strm.readLine() == "THE FIRST LINE"
strm.close()

	Source   Edit   

proc write[T](s: Stream; x: T)

Generic write procedure. Writes x to the stream s. Implementation:

Note: Not available for JS backend. Use write(Stream, string) for now.

s.writeData(s, unsafeAddr(x), sizeof(x))

Example:

var strm = newStringStream("")
strm.write("abcde")
strm.setPosition(0)
doAssert strm.readAll() == "abcde"
strm.close()

	Source   Edit   

proc writeData(s: Stream; buffer: pointer; bufLen: int) {.
	....}

Low level proc that writes an untyped buffer of bufLen size to the stream s.

JS note: buffer is treated as a ptr string and read between 0..<bufLen.

Example:

## writeData
var strm = newStringStream("")
var buffer = ['a', 'b', 'c', 'd', 'e']
strm.writeData(addr(buffer), sizeof(buffer))
doAssert strm.atEnd() == true
## readData
strm.setPosition(0)
var buffer2: array[6, char]
doAssert strm.readData(addr(buffer2), sizeof(buffer2)) == 5
doAssert buffer2 == ['a', 'b', 'c', 'd', 'e', '\x00']
strm.close()

	Source   Edit   

proc writeLine(s: Stream; args: varargs[string, `$`]) {.
	....}

Writes one or more strings to the the stream s followed by a new line. No length field or terminating zero is written.

Example:

var strm = newStringStream("")
strm.writeLine(1, 2)
strm.writeLine(3, 4)
strm.setPosition(0)
doAssert strm.readAll() == "12\n34\n"
strm.close()

	Source   Edit   

Iterators

iterator lines(s: Stream): string {.....}

Iterates over every line in the stream. The iteration is based on readLine.

See also:

	readLine(Stream) proc
	readLine(Stream, string) proc

Example:

var strm = newStringStream("The first line\nthe second line\nthe third line")
var lines: seq[string]
for line in strm.lines():
  lines.add line
doAssert lines == @["The first line", "the second line", "the third line"]
strm.close()

	Source   Edit   

std/symlinks


std/symlinks
Source   Edit  

This module implements symlink (symbolic link) handling.
Imports

paths, ossymlinks

Procs

proc createSymlink(src, dest: Path) {.inline, ....}

	Create a symbolic link at dest which points to the item specified by src. On most operating systems, will fail if a link already exists.
	Warning: Some OS's (such as Microsoft Windows) restrict the creation of symlinks to root users (administrators) or users with developer mode enabled.

	See also:

    	os: createHardlink proc
    	expandSymlink proc

	Source   Edit   

proc expandSymlink(symlinkPath: Path): Path {.inline, ....}

	Returns a string representing the path to which the symbolic link points.

	On Windows this is a noop, symlinkPath is simply returned.

	See also:

    	createSymlink proc

	Source   Edit   

proc symlinkExists(link: Path): bool {.inline, ...sideEffect, ....}

	Returns true if the symlink link exists. Will return true regardless of whether the link points to a directory or file. Source   Edit   

std/syncio


std/syncio
Source   Edit  

This module implements various synchronized I/O operations.
Imports

since, formatfloat, widestrs, exitprocs

Types

File = ptr CFile

	The type representing a file handle. Source   Edit   

FileHandle = cint

	type that represents an OS file handle; this is useful for low-level file access Source   Edit   

FileMode = enum
  fmRead,               	## Open the file for read access only.
                         	## If the file does not exist, it will not
                         	## be created.
  fmWrite,              	## Open the file for write access only.
                         	## If the file does not exist, it will be
                         	## created. Existing files will be cleared!
  fmReadWrite,          	## Open the file for read and write access.
                         	## If the file does not exist, it will be
                         	## created. Existing files will be cleared!
  fmReadWriteExisting,  	## Open the file for read and write access.
                         	## If the file does not exist, it will not be
                         	## created. The existing file will not be cleared.
  fmAppend               	## Open the file for writing only; append data
                         	## at the end. If the file does not exist, it
                         	## will be created.

	The file mode when opening a file. Source   Edit   

FileSeekPos = enum
  fspSet,               	## Seek to absolute value
  fspCur,               	## Seek relative to current position
  fspEnd                 	## Seek relative to end

	Position relative to which seek should happen. Source   Edit   

Vars

stderr {.importc: "stderr", header: "<stdio.h>".}: File

	The standard error stream. Source   Edit   

stdin {.importc: "stdin", header: "<stdio.h>".}: File

	The standard input stream. Source   Edit   

stdout {.importc: "stdout", header: "<stdio.h>".}: File

	The standard output stream. Source   Edit   

Procs

proc close(f: File) {....sideEffect, ....}

	Closes the file. Source   Edit   

proc endOfFile(f: File): bool {.....}

	Returns true if f is at the end. Source   Edit   

proc flushFile(f: File) {.....}

	Flushes f's buffer. Source   Edit   

proc getFileHandle(f: File): FileHandle {.....}

	Returns the file handle of the file f. This is only useful for platform specific programming. Note that on Windows this doesn't return the Windows-specific handle, but the C library's notion of a handle, whatever that means. Use getOsFileHandle instead. Source   Edit   

proc getFilePos(f: File): int64 {.....}

	Retrieves the current position of the file pointer that is used to read from the file f. The file's first byte has the index zero. Source   Edit   

proc getFileSize(f: File): int64 {.....}

	Retrieves the file size (in bytes) of f. Source   Edit   

proc getOsFileHandle(f: File): FileHandle {.....}

	Returns the OS file handle of the file f. This is only useful for platform specific programming. Source   Edit   

proc open(f: var File; filehandle: FileHandle; mode: FileMode = fmRead): bool {.
	....}

	Creates a File from a filehandle with given mode.

	Default mode is readonly. Returns true if the file could be opened.

	The passed file handle will no longer be inheritable.
	Source   Edit   

proc open(f: var File; filename: string; mode: FileMode = fmRead;
      	bufSize: int = -1): bool {.....}

	Opens a file named filename with given mode.

	Default mode is readonly. Returns true if the file could be opened. This throws no exception if the file could not be opened.

	The file handle associated with the resulting File is not inheritable.
	Source   Edit   

proc open(filename: string; mode: FileMode = fmRead; bufSize: int = -1): File {.
	....}

	Opens a file named filename with given mode.

	Default mode is readonly. Raises an IOError if the file could not be opened.

	The file handle associated with the resulting File is not inheritable.
	Source   Edit   

proc readAll(file: File): string {.....}

	Reads all data from the stream file.

	Raises an IO exception in case of an error. It is an error if the current file position is not at the beginning of the file.
	Source   Edit   

proc readBuffer(f: File; buffer: pointer; len: Natural): int {.
	....}

	Reads len bytes into the buffer pointed to by buffer. Returns the actual number of bytes that have been read which may be less than len (if not as many bytes are remaining), but not greater. Source   Edit   

proc readBytes(f: File; a: var openArray[int8 | uint8]; start, len: Natural): int {.
	....}

	Reads len bytes into the buffer a starting at a[start]. Returns the actual number of bytes that have been read which may be less than len (if not as many bytes are remaining), but not greater. Source   Edit   

proc readChar(f: File): char {.....}

	Reads a single character from the stream f. Should not be used in performance sensitive code. Source   Edit   

proc readChars(f: File; a: var openArray[char]): int {.....}

	Reads up to a.len bytes into the buffer a. Returns the actual number of bytes that have been read which may be less than a.len (if not as many bytes are remaining), but not greater. Source   Edit   

proc readChars(f: File; a: var openArray[char]; start, len: Natural): int {.
	....}

	Deprecated: use other `readChars` overload, possibly via: readChars(toOpenArray(buf, start, len-1))
	Reads len bytes into the buffer a starting at a[start]. Returns the actual number of bytes that have been read which may be less than len (if not as many bytes are remaining), but not greater. Source   Edit   

proc readFile(filename: string): string {.....}

	Opens a file named filename for reading, calls readAll and closes the file afterwards. Returns the string. Raises an IO exception in case of an error. If you need to call this inside a compile time macro you can use staticRead. Source   Edit   

proc readLine(f: File): string {.....}

	Reads a line of text from the file f. May throw an IO exception. A line of text may be delimited by LF or CRLF. The newline character(s) are not part of the returned string. Source   Edit   

proc readLine(f: File; line: var string): bool {.....}

	Reads a line of text from the file f into line. May throw an IO exception. A line of text may be delimited by LF or CRLF. The newline character(s) are not part of the returned string. Returns false if the end of the file has been reached, true otherwise. If false is returned line contains no new data. Source   Edit   

proc readLines(filename: string; n: Natural): seq[string] {.
	....}

	Reads n lines from the file named filename. Raises an IO exception in case of an error. Raises EOF if file does not contain at least n lines. Available at compile time. A line of text may be delimited by LF or CRLF. The newline character(s) are not part of the returned strings. Source   Edit   

proc reopen(f: File; filename: string; mode: FileMode = fmRead): bool {.
	....}

	Reopens the file f with given filename and mode. This is often used to redirect the stdin, stdout or stderr file variables.

	Default mode is readonly. Returns true if the file could be reopened.

	The file handle associated with f won't be inheritable.
	Source   Edit   

proc setFilePos(f: File; pos: int64; relativeTo: FileSeekPos = fspSet) {....sideEffect, ....}

	Sets the position of the file pointer that is used for read/write operations. The file's first byte has the index zero. Source   Edit   

proc setInheritable(f: FileHandle; inheritable: bool): bool {.....}

	control whether a file handle can be inherited by child processes. Returns true on success. This requires the OS file handle, which can be retrieved via getOsFileHandle.

	This procedure is not guaranteed to be available for all platforms. Test for availability with declared() <system.html#declared,untyped>.
	Source   Edit   

proc setStdIoUnbuffered() {.....}

	Configures stdin, stdout and stderr to be unbuffered. Source   Edit   

proc write(f: File; a: varargs[string, `$`]) {.....}

	Source   Edit   

proc write(f: File; b: bool) {.....}

	Source   Edit   

proc write(f: File; c: char) {.....}

	Source   Edit   

proc write(f: File; c: cstring) {.....}

	Writes a value to the file f. May throw an IO exception. Source   Edit   

proc write(f: File; i: BiggestInt) {.....}

	Source   Edit   

proc write(f: File; i: int) {.....}

	Source   Edit   

proc write(f: File; r: BiggestFloat) {.....}

	Source   Edit   

proc write(f: File; r: float32) {.....}

	Source   Edit   

proc write(f: File; s: string) {.....}

	Source   Edit   

proc writeBuffer(f: File; buffer: pointer; len: Natural): int {.
	....}

	Writes the bytes of buffer pointed to by the parameter buffer to the file f. Returns the number of actual written bytes, which may be less than len in case of an error. Source   Edit   

proc writeBytes(f: File; a: openArray[int8 | uint8]; start, len: Natural): int {.
	....}

	Writes the bytes of a[start..start+len-1] to the file f. Returns the number of actual written bytes, which may be less than len in case of an error. Source   Edit   

proc writeChars(f: File; a: openArray[char]; start, len: Natural): int {.
	....}

	Writes the bytes of a[start..start+len-1] to the file f. Returns the number of actual written bytes, which may be less than len in case of an error. Source   Edit   

proc writeFile(filename, content: string) {.....}

	Opens a file named filename for writing. Then writes the content completely to the file and closes the file afterwards. Raises an IO exception in case of an error. Source   Edit   

proc writeFile(filename: string; content: openArray[byte]) {.....}

	Opens a file named filename for writing. Then writes the content completely to the file and closes the file afterwards. Raises an IO exception in case of an error. Source   Edit   

proc writeLine[Ty](f: File; x: varargs[Ty, `$`]) {.inline,
	....}

	Writes the values x to f and then writes "\n". May throw an IO exception. Source   Edit   

Iterators

iterator lines(f: File): string {.....}

Iterates over any line in the file f.

The trailing newline character(s) are removed from the iterated lines.

Example:

proc countZeros(filename: File): tuple[lines, zeros: int] =
  for line in filename.lines:
	for letter in line:
  	if letter == '0':
    	result.zeros += 1
	result.lines += 1

	Source   Edit   

iterator lines(filename: string): string {.....}

Iterates over any line in the file named filename.

If the file does not exist IOError is raised. The trailing newline character(s) are removed from the iterated lines. Example:

Example:

import std/strutils

proc transformLetters(filename: string) =
  var buffer = ""
  for line in filename.lines:
	buffer.add(line.replace("a", "0") & '\n')
  writeFile(filename, buffer)

	Source   Edit   

Templates

template `&=`(f: File; x: typed)

	An alias for write. Source   Edit   

template readLines(filename: string): seq[string] {.
	....}

	Deprecated: use readLines with two arguments
	Source   Edit   

template stdmsg(): File

	Template which expands to either stdout or stderr depending on useStdoutAsStdmsg compile-time switch. Source   Edit   

std/terminal


std/terminal
Source   Edit  

This module contains a few procedures to control the terminal (also called console). On UNIX, the implementation simply uses ANSI escape sequences and does not depend on any other module, on Windows it uses the Windows API. Changing the style is permanent even after program termination! Use the code exitprocs.addExitProc(resetAttributes) to restore the defaults. Similarly, if you hide the cursor, make sure to unhide it with showCursor before quitting.
Progress bar

Basic progress bar example:

Example: cmd: -r:off

import std/terminal
import std/[os, strutils]

for i in 0..100:
  stdout.styledWriteLine(fgRed, "0% ", fgWhite, '#'.repeat i, if i > 50: fgGreen else: fgYellow, "\t", $i , "%")
  sleep 42
  cursorUp 1
  eraseLine()

stdout.resetAttributes()

Playing with colorful and styled text
Procs like styledWriteLine, styledEcho etc. have a temporary effect on text parameters. Style parameters only affect the text parameter right after them. After being called, these procs will reset the default style of the terminal. While setBackGroundColor, setForeGroundColor etc. have a lasting influence on the terminal, you can use resetAttributes to reset the default style of the terminal.

Example: cmd: -r:off

import std/terminal
stdout.styledWriteLine({styleBright, styleBlink, styleUnderscore}, "styled text ")
stdout.styledWriteLine(fgRed, "red text ")
stdout.styledWriteLine(fgWhite, bgRed, "white text in red background")
stdout.styledWriteLine(" ordinary text without style ")

stdout.setBackGroundColor(bgCyan, true)
stdout.setForeGroundColor(fgBlue)
stdout.write("blue text in cyan background")
stdout.resetAttributes()

# You can specify multiple text parameters. Style parameters
# only affect the text parameter right after them.
styledEcho styleBright, fgGreen, "[PASS]", resetStyle, fgGreen, " Yay!"

stdout.styledWriteLine(fgRed, "red text ", styleBright, "bold red", fgDefault, " bold text")

Imports

macros, strformat, strutils, colors, winlean, winlean, os, os

Types

BackgroundColor = enum
  bgBlack = 40,         	## black
  bgRed,                	## red
  bgGreen,              	## green
  bgYellow,             	## yellow
  bgBlue,               	## blue
  bgMagenta,            	## magenta
  bgCyan,               	## cyan
  bgWhite,              	## white
  bg8Bit,               	## 256-color (not supported, see `enableTrueColors` instead.)
  bgDefault              	## default terminal background color

	Terminal's background colors. Source   Edit   

ForegroundColor = enum
  fgBlack = 30,         	## black
  fgRed,                	## red
  fgGreen,              	## green
  fgYellow,             	## yellow
  fgBlue,               	## blue
  fgMagenta,            	## magenta
  fgCyan,               	## cyan
  fgWhite,              	## white
  fg8Bit,               	## 256-color (not supported, see `enableTrueColors` instead.)
  fgDefault              	## default terminal foreground color

	Terminal's foreground colors. Source   Edit   

Style = enum
  styleBright = 1,      	## bright text
  styleDim,             	## dim text
  styleItalic,          	## italic (or reverse on terminals not supporting)
  styleUnderscore,      	## underscored text
  styleBlink,           	## blinking/bold text
  styleBlinkRapid,      	## rapid blinking/bold text (not widely supported)
  styleReverse,         	## reverse
  styleHidden,          	## hidden text
  styleStrikethrough     	## strikethrough

	Different styles for text output. Source   Edit   

TerminalCmd = enum
  resetStyle,           	## reset attributes
  fgColor,              	## set foreground's true color
  bgColor                	## set background's true color

	commands that can be expressed as arguments Source   Edit   

Consts

ansiResetCode = "\e[0m"

	Source   Edit   

Procs

proc ansiBackgroundColorCode(color: Color): string {.....}

	Source   Edit   

proc ansiForegroundColorCode(color: Color): string {.....}

	Source   Edit   

proc ansiForegroundColorCode(fg: ForegroundColor; bright = false): string {.
	....}

	Source   Edit   

proc ansiStyleCode(style: int): string {.....}

	Source   Edit   

proc cursorBackward(f: File; count = 1) {.....}

Moves the cursor backward by count columns.

Example: cmd: -r:off

stdout.cursorBackward(2)
write(stdout, "Hello World!") # anything written at that location will be erased/replaced with this

	Source   Edit   

proc cursorDown(f: File; count = 1) {.....}

Moves the cursor down by count rows.

Example: cmd: -r:off

stdout.cursorDown(2)
write(stdout, "Hello World!") # anything written at that location will be erased/replaced with this

	Source   Edit   

proc cursorForward(f: File; count = 1) {.....}

Moves the cursor forward by count columns.

Example: cmd: -r:off

stdout.cursorForward(2)
write(stdout, "Hello World!") # anything written at that location will be erased/replaced with this

	Source   Edit   

proc cursorUp(f: File; count = 1) {.....}

Moves the cursor up by count rows.

Example: cmd: -r:off

stdout.cursorUp(2)
write(stdout, "Hello World!") # anything written at that location will be erased/replaced with this

	Source   Edit   

proc disableTrueColors() {.....}

	Disables true color. Source   Edit   

proc enableTrueColors() {.....}

	Enables true color. Source   Edit   

proc eraseLine(f: File) {.....}

Erases the entire current line.

Example: cmd: -r:off

write(stdout, "never mind")
stdout.eraseLine() # nothing will be printed on the screen

	Source   Edit   

proc eraseScreen(f: File) {.....}

	Erases the screen with the background colour and moves the cursor to home. Source   Edit   

proc getch(): char {.....}

	Reads a single character from the terminal, blocking until it is entered. The character is not printed to the terminal. Source   Edit   

proc hideCursor(f: File) {.....}

	Hides the cursor. Source   Edit   

proc isatty(f: File): bool {.....}

	Returns true if f is associated with a terminal device. Source   Edit   

proc isTrueColorSupported(): bool {.....}

	Returns true if a terminal supports true color. Source   Edit   

proc readPasswordFromStdin(prompt = "password: "): string {.....}

	Reads a password from stdin without printing it. Source   Edit   

proc readPasswordFromStdin(prompt: string; password: var string): bool {.
	....}

	Reads a password from stdin without printing it. password must not be nil! Returns false if the end of the file has been reached, true otherwise. Source   Edit   

proc resetAttributes() {.noconv, ....}

	Resets all attributes on stdout. It is advisable to register this as a quit proc with exitprocs.addExitProc(resetAttributes). Source   Edit   

proc resetAttributes(f: File) {.....}

	Resets all attributes. Source   Edit   

proc setBackgroundColor(f: File; bg: BackgroundColor; bright = false) {.
	....}

	Sets the terminal's background color. Source   Edit   

proc setBackgroundColor(f: File; color: Color) {.....}

	Sets the terminal's background true color. Source   Edit   

proc setCursorPos(f: File; x, y: int) {.....}

	Sets the terminal's cursor to the (x,y) position. (0,0) is the upper left of the screen. Source   Edit   

proc setCursorXPos(f: File; x: int) {.....}

	Sets the terminal's cursor to the x position. The y position is not changed. Source   Edit   

proc setCursorYPos(f: File; y: int) {.....}

	Sets the terminal's cursor to the y position. The x position is not changed. .. warning:: This is not supported on UNIX! Source   Edit   

proc setForegroundColor(f: File; color: Color) {.....}

	Sets the terminal's foreground true color. Source   Edit   

proc setForegroundColor(f: File; fg: ForegroundColor; bright = false) {.
	....}

	Sets the terminal's foreground color. Source   Edit   

proc setStyle(f: File; style: set[Style]) {.....}

	Sets the terminal style. Source   Edit   

proc showCursor(f: File) {.....}

	Shows the cursor. Source   Edit   

proc terminalHeight(): int {.....}

	Returns the terminal height in rows. Source   Edit   

proc terminalHeightIoctl(handles: openArray[Handle]): int {.....}

	Source   Edit   

proc terminalSize(): tuple[w, h: int] {.....}

	Returns the terminal width and height as a tuple. Internally calls terminalWidth and terminalHeight, so the same assumptions apply. Source   Edit   

proc terminalWidth(): int {.....}

	Returns the terminal width in columns. Source   Edit   

proc terminalWidthIoctl(handles: openArray[Handle]): int {.....}

	Source   Edit   

proc writeStyled(txt: string; style: set[Style] = {styleBright}) {.
	....}

	Writes the text txt in a given style to stdout. Source   Edit   

Macros

macro styledWrite(f: File; m: varargs[typed]): untyped

Similar to write, but treating terminal style arguments specially. When some argument is Style, set[Style], ForegroundColor, BackgroundColor or TerminalCmd then it is not sent directly to f, but instead corresponding terminal style proc is called.

Example: cmd: -r:off

stdout.styledWrite(fgRed, "red text ")
stdout.styledWrite(fgGreen, "green text")

	Source   Edit   

Templates

template ansiBackgroundColorCode(color: static[Color]): string

	Source   Edit   

template ansiForegroundColorCode(color: static[Color]): string

	Source   Edit   

template ansiForegroundColorCode(fg: static[ForegroundColor];
                             	bright: static[bool] = false): string

	Source   Edit   

template ansiStyleCode(style: static[Style]): string

	Source   Edit   

template ansiStyleCode(style: Style): string

	Source   Edit   

template cursorBackward(count = 1)

	Source   Edit   

template cursorDown(count = 1)

	Source   Edit   

template cursorForward(count = 1)

	Source   Edit   

template cursorUp(count = 1)

	Source   Edit   

template eraseLine()

	Source   Edit   

template eraseScreen()

	Source   Edit   

template hideCursor()

	Source   Edit   

template setBackgroundColor(bg: BackgroundColor; bright = false)

	Source   Edit   

template setBackgroundColor(color: Color)

	Source   Edit   

template setCursorPos(x, y: int)

	Source   Edit   

template setCursorXPos(x: int)

	Source   Edit   

template setCursorYPos(x: int)

	Source   Edit   

template setForegroundColor(color: Color)

	Source   Edit   

template setForegroundColor(fg: ForegroundColor; bright = false)

	Source   Edit   

template setStyle(style: set[Style])

	Source   Edit   

template showCursor()

	Source   Edit   

template styledEcho(args: varargs[untyped])

	Echoes styles arguments to stdout using styledWriteLine. Source   Edit   

template styledWriteLine(f: File; args: varargs[untyped])

Calls styledWrite and appends a newline at the end.

Example:

proc error(msg: string) =
  styledWriteLine(stderr, fgRed, "Error: ", resetStyle, msg)

	Source   Edit   


std/tempfiles


std/tempfiles
Source   Edit  

This module creates temporary files and directories.

Experimental API, subject to change.

Imports

os, random, winlean

Procs

proc createTempDir(prefix, suffix: string; dir = ""): string {.
	....}

Creates a new temporary directory in the directory dir.

This generates a dir name using genTempPath(prefix, suffix, dir), creates the directory and returns it, possibly after retrying to ensure it doesn't already exist.

If failing to create a temporary directory, OSError will be raised.
Note: It is the caller's responsibility to remove the directory when no longer needed.
Note: dir must exist (empty dir will resolve to getTempDir).

Example:

import std/os
doAssertRaises(OSError): discard createTempDir("", "", "nonexistent")
let dir = createTempDir("tmpprefix_", "_end")
# dir looks like: getTempDir() / "tmpprefix_YEl9VuVj_end"
assert dirExists(dir)
removeDir(dir)

	Source   Edit   

proc createTempFile(prefix, suffix: string; dir = ""): tuple[cfile: File,
	path: string] {.....}

Creates a new temporary file in the directory dir.

This generates a path name using genTempPath(prefix, suffix, dir) and returns a file handle to an open file and the path of that file, possibly after retrying to ensure it doesn't already exist.

If failing to create a temporary file, OSError will be raised.
Note: It is the caller's responsibility to close result.cfile and remove result.file when no longer needed.
Note: dir must exist (empty dir will resolve to getTempDir).

Example:

import std/os
doAssertRaises(OSError): discard createTempFile("", "", "nonexistent")
let (cfile, path) = createTempFile("tmpprefix_", "_end.tmp")
# path looks like: getTempDir() / "tmpprefix_FDCIRZA0_end.tmp"
cfile.write "foo"
cfile.setFilePos 0
assert readAll(cfile) == "foo"
close cfile
assert readFile(path) == "foo"
removeFile(path)

	Source   Edit   

proc genTempPath(prefix, suffix: string; dir = ""): string {.....}

	Generates a path name in dir.

	The path begins with prefix and ends with suffix.
	Note: dir must exist (empty dir will resolve to getTempDir).
	Source   Edit   


Math libraries

std/complex


std/complex
Source   Edit  

This module implements complex numbers and basic mathematical operations on them.

Complex numbers are currently generic over 64-bit or 32-bit floats.

Example:

import std/complex
from std/math import almostEqual, sqrt

let
  z1 = complex(1.0, 2.0)
  z2 = complex(3.0, -4.0)

assert almostEqual(z1 + z2, complex(4.0, -2.0))
assert almostEqual(z1 - z2, complex(-2.0, 6.0))
assert almostEqual(z1 * z2, complex(11.0, 2.0))
assert almostEqual(z1 / z2, complex(-0.2, 0.4))

assert almostEqual(abs(z1), sqrt(5.0))
assert almostEqual(conjugate(z1), complex(1.0, -2.0))

let (r, phi) = z1.polar
assert almostEqual(rect(r, phi), z1)

Imports

math

Types

Complex[T] = object
  re*, im*: T

	A complex number, consisting of a real and an imaginary part. Source   Edit   

Complex32 = Complex[float32]

	Alias for a complex number using 32-bit floats. Source   Edit   

Complex64 = Complex[float64]

	Alias for a complex number using 64-bit floats. Source   Edit   

Procs

func `$`(z: Complex): string

Returns z's string representation as "(re, im)".

Example:

doAssert $complex(1.0, 2.0) == "(1.0, 2.0)"

	Source   Edit   

func `*`[T](x, y: Complex[T]): Complex[T]

	Multiplies two complex numbers. Source   Edit   

func `*`[T](x: Complex[T]; y: T): Complex[T]

	Multiplies a complex number with a real number. Source   Edit   

func `*`[T](x: T; y: Complex[T]): Complex[T]

	Multiplies a real number with a complex number. Source   Edit   

func `*=`[T](x: var Complex[T]; y: Complex[T])

	Multiplies x by y. Source   Edit   

func `+`[T](x, y: Complex[T]): Complex[T]

	Adds two complex numbers. Source   Edit   

func `+`[T](x: Complex[T]; y: T): Complex[T]

	Adds a complex number to a real number. Source   Edit   

func `+`[T](x: T; y: Complex[T]): Complex[T]

	Adds a real number to a complex number. Source   Edit   

func `+=`[T](x: var Complex[T]; y: Complex[T])

	Adds y to x. Source   Edit   

func `-`[T](x, y: Complex[T]): Complex[T]

	Subtracts two complex numbers. Source   Edit   

func `-`[T](x: Complex[T]; y: T): Complex[T]

	Subtracts a real number from a complex number. Source   Edit   

func `-`[T](x: T; y: Complex[T]): Complex[T]

	Subtracts a complex number from a real number. Source   Edit   

func `-`[T](z: Complex[T]): Complex[T]

	Unary minus for complex numbers. Source   Edit   

func `-=`[T](x: var Complex[T]; y: Complex[T])

	Subtracts y from x. Source   Edit   

func `/`[T](x, y: Complex[T]): Complex[T]

	Divides two complex numbers. Source   Edit   

func `/`[T](x: Complex[T]; y: T): Complex[T]

	Divides a complex number by a real number. Source   Edit   

func `/`[T](x: T; y: Complex[T]): Complex[T]

	Divides a real number by a complex number. Source   Edit   

func `/=`[T](x: var Complex[T]; y: Complex[T])

	Divides x by y in place. Source   Edit   

func `==`[T](x, y: Complex[T]): bool

	Compares two complex numbers for equality. Source   Edit   

func abs[T](z: Complex[T]): T

	Returns the absolute value of z, that is the distance from (0, 0) to z. Source   Edit   

func abs2[T](z: Complex[T]): T

	Returns the squared absolute value of z, that is the squared distance from (0, 0) to z. This is more efficient than abs(z) ^ 2. Source   Edit   

func almostEqual[T: SomeFloat](x, y: Complex[T]; unitsInLastPlace: Natural = 4): bool

	Checks if two complex values are almost equal, using the machine epsilon.

	Two complex values are considered almost equal if their real and imaginary components are almost equal.

	unitsInLastPlace is the max number of units in the last place difference tolerated when comparing two numbers. The larger the value, the more error is allowed. A 0 value means that two numbers must be exactly the same to be considered equal.

	The machine epsilon has to be scaled to the magnitude of the values used and multiplied by the desired precision in ULPs unless the difference is subnormal.
	Source   Edit   

func arccos[T](z: Complex[T]): Complex[T]

	Returns the inverse cosine of z. Source   Edit   

func arccosh[T](z: Complex[T]): Complex[T]

	Returns the inverse hyperbolic cosine of z. Source   Edit   

func arccot[T](z: Complex[T]): Complex[T]

	Returns the inverse cotangent of z. Source   Edit   

func arccoth[T](z: Complex[T]): Complex[T]

	Returns the inverse hyperbolic cotangent of z. Source   Edit   

func arccsc[T](z: Complex[T]): Complex[T]

	Returns the inverse cosecant of z. Source   Edit   

func arccsch[T](z: Complex[T]): Complex[T]

	Returns the inverse hyperbolic cosecant of z. Source   Edit   

func arcsec[T](z: Complex[T]): Complex[T]

	Returns the inverse secant of z. Source   Edit   

func arcsech[T](z: Complex[T]): Complex[T]

	Returns the inverse hyperbolic secant of z. Source   Edit   

func arcsin[T](z: Complex[T]): Complex[T]

	Returns the inverse sine of z. Source   Edit   

func arcsinh[T](z: Complex[T]): Complex[T]

	Returns the inverse hyperbolic sine of z. Source   Edit   

func arctan[T](z: Complex[T]): Complex[T]

	Returns the inverse tangent of z. Source   Edit   

func arctanh[T](z: Complex[T]): Complex[T]

	Returns the inverse hyperbolic tangent of z. Source   Edit   

func complex[T: SomeFloat](re: T; im: T = 0.0): Complex[T]

	Returns a Complex[T] with real part re and imaginary part im. Source   Edit   

func complex32(re: float32; im: float32 = 0.0): Complex32 {.....}

	Returns a Complex32 with real part re and imaginary part im. Source   Edit   

func complex64(re: float64; im: float64 = 0.0): Complex64 {.....}

	Returns a Complex64 with real part re and imaginary part im. Source   Edit   

func conjugate[T](z: Complex[T]): Complex[T]

	Returns the complex conjugate of z (complex(z.re, -z.im)). Source   Edit   

func cos[T](z: Complex[T]): Complex[T]

	Returns the cosine of z. Source   Edit   

func cosh[T](z: Complex[T]): Complex[T]

	Returns the hyperbolic cosine of z. Source   Edit   

func cot[T](z: Complex[T]): Complex[T]

	Returns the cotangent of z. Source   Edit   

func coth[T](z: Complex[T]): Complex[T]

	Returns the hyperbolic cotangent of z. Source   Edit   

func csc[T](z: Complex[T]): Complex[T]

	Returns the cosecant of z. Source   Edit   

func csch[T](z: Complex[T]): Complex[T]

	Returns the hyperbolic cosecant of z. Source   Edit   

func exp[T](z: Complex[T]): Complex[T]

	Computes the exponential function (e^z). Source   Edit   

func inv[T](z: Complex[T]): Complex[T]

	Returns the multiplicative inverse of z (1/z). Source   Edit   

func ln[T](z: Complex[T]): Complex[T]

	Returns the (principal value of the) natural logarithm of z. Source   Edit   

func log2[T](z: Complex[T]): Complex[T]

	Returns the logarithm base 2 of z.

	See also:

    	ln func

	Source   Edit   

func log10[T](z: Complex[T]): Complex[T]

	Returns the logarithm base 10 of z.

	See also:

    	ln func

	Source   Edit   

func phase[T](z: Complex[T]): T

	Returns the phase (or argument) of z, that is the angle in polar representation.

	result = arctan2(z.im, z.re)
	Source   Edit   

func polar[T](z: Complex[T]): tuple[r, phi: T]

	Returns z in polar coordinates.

	result.r = abs(z)
	result.phi = phase(z)

	See also:

    	rect func for the inverse operation

	Source   Edit   

func pow[T](x, y: Complex[T]): Complex[T]

	x raised to the power of y. Source   Edit   

func pow[T](x: Complex[T]; y: T): Complex[T]

	The complex number x raised to the power of the real number y. Source   Edit   

func rect[T](r, phi: T): Complex[T]

	Returns the complex number with polar coordinates r and phi.

	result.re = r * cos(phi)
	result.im = r * sin(phi)

	See also:

    	polar func for the inverse operation

	Source   Edit   

func sec[T](z: Complex[T]): Complex[T]

	Returns the secant of z. Source   Edit   

func sech[T](z: Complex[T]): Complex[T]

	Returns the hyperbolic secant of z. Source   Edit   

func sgn[T](z: Complex[T]): Complex[T]

	Returns the phase of z as a unit complex number, or 0 if z is 0. Source   Edit   

func sin[T](z: Complex[T]): Complex[T]

	Returns the sine of z. Source   Edit   

func sinh[T](z: Complex[T]): Complex[T]

	Returns the hyperbolic sine of z. Source   Edit   

func sqrt[T](z: Complex[T]): Complex[T]

	Computes the (principal) square root of a complex number z. Source   Edit   

func tan[T](z: Complex[T]): Complex[T]

	Returns the tangent of z. Source   Edit   

func tanh[T](z: Complex[T]): Complex[T]

	Returns the hyperbolic tangent of z. Source   Edit   

Templates

template im(arg: float32): Complex32

	Returns arg as an imaginary number (complex32(0, arg)). Source   Edit   

template im(arg: float64): Complex64

	Returns arg as an imaginary number (complex64(0, arg)). Source   Edit   

template im(arg: typedesc[float32]): Complex32

	Returns the imaginary unit (complex32(0, 1)). Source   Edit   

template im(arg: typedesc[float64]): Complex64

	Returns the imaginary unit (complex64(0, 1)). Source   Edit   


std/fenv


std/fenv
Source   Edit  

Floating-point environment. Handling of floating-point rounding and exceptions (overflow, division by zero, etc.). The types, vars and procs are bindings for the C standard library <fenv.h> header.
Types

Tfenv {.importc: "fenv_t", header: "<fenv.h>", final, pure.} = object

	Represents the entire floating-point environment. The floating-point environment refers collectively to any floating-point status flags and control modes supported by the implementation. Source   Edit   

Tfexcept {.importc: "fexcept_t", header: "<fenv.h>", final, pure.} = object

	Represents the floating-point status flags collectively, including any status the implementation associates with the flags. A floating-point status flag is a system variable whose value is set (but never cleared) when a floating-point exception is raised, which occurs as a side effect of exceptional floating-point arithmetic to provide auxiliary information. A floating-point control mode is a system variable whose value may be set by the user to affect the subsequent behavior of floating-point arithmetic. Source   Edit   

Vars

FE_ALL_EXCEPT {.importc, header: "<fenv.h>".}: cint

	bitwise OR of all supported exceptions Source   Edit   

FE_DFL_ENV {.importc, header: "<fenv.h>".}: cint

	macro of type pointer to fenv_t to be used as the argument to functions taking an argument of type fenv_t; in this case the default environment will be used Source   Edit   

FE_DIVBYZERO {.importc, header: "<fenv.h>".}: cint

	division by zero Source   Edit   

FE_DOWNWARD {.importc, header: "<fenv.h>".}: cint

	round toward -Inf Source   Edit   

FE_INEXACT {.importc, header: "<fenv.h>".}: cint

	inexact result Source   Edit   

FE_INVALID {.importc, header: "<fenv.h>".}: cint

	invalid operation Source   Edit   

FE_OVERFLOW {.importc, header: "<fenv.h>".}: cint

	result not representable due to overflow Source   Edit   

FE_TONEAREST {.importc, header: "<fenv.h>".}: cint

	round to nearest Source   Edit   

FE_TOWARDZERO {.importc, header: "<fenv.h>".}: cint

	round toward 0 Source   Edit   

FE_UNDERFLOW {.importc, header: "<fenv.h>".}: cint

	result not representable due to underflow Source   Edit   

FE_UPWARD {.importc, header: "<fenv.h>".}: cint

	round toward +Inf Source   Edit   

Procs

proc feclearexcept(excepts: cint): cint {.importc, header: "<fenv.h>",
	....}

	Clear the supported exceptions represented by excepts. Source   Edit   

proc fegetenv(envp: ptr Tfenv): cint {.importc, header: "<fenv.h>", ....}

	Store the current floating-point environment in the object pointed to by envp. Source   Edit   

proc fegetexceptflag(flagp: ptr Tfexcept; excepts: cint): cint {.importc,
	header: "<fenv.h>", ....}

	Store implementation-defined representation of the exception flags indicated by excepts in the object pointed to by flagp. Source   Edit   

proc fegetround(): cint {.importc, header: "<fenv.h>", ....}

	Get current rounding direction. Source   Edit   

proc feholdexcept(envp: ptr Tfenv): cint {.importc, header: "<fenv.h>",
	....}

	Save the current environment in the object pointed to by envp, clear exception flags and install a non-stop mode (if available) for all exceptions. Source   Edit   

proc feraiseexcept(excepts: cint): cint {.importc, header: "<fenv.h>",
	....}

	Raise the supported exceptions represented by excepts. Source   Edit   

proc fesetenv(a1: ptr Tfenv): cint {.importc, header: "<fenv.h>", ....}

	Establish the floating-point environment represented by the object pointed to by envp. Source   Edit   

proc fesetexceptflag(flagp: ptr Tfexcept; excepts: cint): cint {.importc,
	header: "<fenv.h>", ....}

	Set complete status for exceptions indicated by excepts according to the representation in the object pointed to by flagp. Source   Edit   

proc fesetround(roundingDirection: cint): cint {.importc, header: "<fenv.h>",
	....}

	Establish the rounding direction represented by roundingDirection. Source   Edit   

proc fetestexcept(excepts: cint): cint {.importc, header: "<fenv.h>",
	....}

	Determine which of subset of the exceptions specified by excepts are currently set. Source   Edit   

proc feupdateenv(envp: ptr Tfenv): cint {.importc, header: "<fenv.h>",
	....}

	Save current exceptions in temporary storage, install environment represented by object pointed to by envp and raise exceptions according to saved exceptions. Source   Edit   

Templates

template digits(T: typedesc[float32]): int

	Number of decimal digits that can be represented in a 32-bit floating-point type without losing precision. Source   Edit   

template digits(T: typedesc[float64]): int

	Number of decimal digits that can be represented in a 64-bit floating-point type without losing precision. Source   Edit   

template epsilon(T: typedesc[float32]): float32

	The difference between 1.0 and the smallest number greater than 1.0 that can be represented in a 32-bit floating-point type. Source   Edit   

template epsilon(T: typedesc[float64]): float64

	The difference between 1.0 and the smallest number greater than 1.0 that can be represented in a 64-bit floating-point type. Source   Edit   

template fpRadix(): int

	The (integer) value of the radix used to represent any floating point type on the architecture used to build the program. Source   Edit   

template mantissaDigits(T: typedesc[float32]): int

	Number of digits (in base floatingPointRadix) in the mantissa of 32-bit floating-point numbers. Source   Edit   

template mantissaDigits(T: typedesc[float64]): int

	Number of digits (in base floatingPointRadix) in the mantissa of 64-bit floating-point numbers. Source   Edit   

template max10Exponent(T: typedesc[float32]): int

	Maximum (positive) exponent in base 10 for 32-bit floating-point numbers. Source   Edit   

template max10Exponent(T: typedesc[float64]): int

	Maximum (positive) exponent in base 10 for 64-bit floating-point numbers. Source   Edit   

template maxExponent(T: typedesc[float32]): int

	Maximum (positive) exponent for 32-bit floating-point numbers. Source   Edit   

template maxExponent(T: typedesc[float64]): int

	Maximum (positive) exponent for 64-bit floating-point numbers. Source   Edit   

template maximumPositiveValue(T: typedesc[float32]): float32

	The largest positive number that can be represented in a 32-bit floating-point type. Source   Edit   

template maximumPositiveValue(T: typedesc[float64]): float64

	The largest positive number that can be represented in a 64-bit floating-point type. Source   Edit   

template min10Exponent(T: typedesc[float32]): int

	Minimum (negative) exponent in base 10 for 32-bit floating-point numbers. Source   Edit   

template min10Exponent(T: typedesc[float64]): int

	Minimum (negative) exponent in base 10 for 64-bit floating-point numbers. Source   Edit   

template minExponent(T: typedesc[float32]): int

	Minimum (negative) exponent for 32-bit floating-point numbers. Source   Edit   

template minExponent(T: typedesc[float64]): int

	Minimum (negative) exponent for 64-bit floating-point numbers. Source   Edit   

template minimumPositiveValue(T: typedesc[float32]): float32

	The smallest positive (nonzero) number that can be represented in a 32-bit floating-point type. Source   Edit   

template minimumPositiveValue(T: typedesc[float64]): float64

	The smallest positive (nonzero) number that can be represented in a 64-bit floating-point type. Source   Edit   


std/lenientops


std/lenientops
Source   Edit  

This module offers implementations of common binary operations like +, -, *, / and comparison operations, which work for mixed float/int operands. All operations convert the integer operand into the type of the float operand. For numerical expressions, the return type is always the type of the float involved in the expression, i.e., there is no auto conversion from float32 to float64.

Note: In general, auto-converting from int to float loses information, which is why these operators live in a separate module. Use with care.

Regarding binary comparison, this module only provides unequal operators. The equality operator == is omitted, because depending on the use case either casting to float or rounding to int might be preferred, and users should make an explicit choice.

Procs

func `*`[I: SomeInteger; F: SomeFloat](f: F; i: I): F {.inline.}

	Source   Edit   

func `*`[I: SomeInteger; F: SomeFloat](i: I; f: F): F {.inline.}

	Source   Edit   

func `+`[I: SomeInteger; F: SomeFloat](f: F; i: I): F {.inline.}

	Source   Edit   

func `+`[I: SomeInteger; F: SomeFloat](i: I; f: F): F {.inline.}

	Source   Edit   

func `-`[I: SomeInteger; F: SomeFloat](f: F; i: I): F {.inline.}

	Source   Edit   

func `-`[I: SomeInteger; F: SomeFloat](i: I; f: F): F {.inline.}

	Source   Edit   

func `/`[I: SomeInteger; F: SomeFloat](f: F; i: I): F {.inline.}

	Source   Edit   

func `/`[I: SomeInteger; F: SomeFloat](i: I; f: F): F {.inline.}

	Source   Edit   

func `<`[I: SomeInteger; F: SomeFloat](f: F; i: I): bool {.inline.}

	Source   Edit   

func `<`[I: SomeInteger; F: SomeFloat](i: I; f: F): bool {.inline.}

	Source   Edit   

func `<=`[I: SomeInteger; F: SomeFloat](f: F; i: I): bool {.inline.}

	Source   Edit   

func `<=`[I: SomeInteger; F: SomeFloat](i: I; f: F): bool {.inline.}

	Source   Edit   


std/math


std/math
Source   Edit  

Constructive mathematics is naturally typed. -- Simon Thompson

Basic math routines for Nim.

Note that the trigonometric functions naturally operate on radians. The helper functions degToRad and radToDeg provide conversion between radians and degrees.

Example:

import std/math
from std/fenv import epsilon
from std/random import rand

proc generateGaussianNoise(mu: float = 0.0, sigma: float = 1.0): (float, float) =
  # Generates values from a normal distribution.
  # Translated from https://en.wikipedia.org/wiki/Box%E2%80%93Muller_transform#Implementation.
  var u1: float
  var u2: float
  while true:
	u1 = rand(1.0)
	u2 = rand(1.0)
	if u1 > epsilon(float): break
  let mag = sigma * sqrt(-2 * ln(u1))
  let z0 = mag * cos(2 * PI * u2) + mu
  let z1 = mag * sin(2 * PI * u2) + mu
  (z0, z1)

echo generateGaussianNoise()

This module is available for the JavaScript target.
See also

	complex module for complex numbers and their mathematical operations
	rationals module for rational numbers and their mathematical operations
	fenv module for handling of floating-point rounding and exceptions (overflow, zero-divide, etc.)
	random module for a fast and tiny random number generator
	stats module for statistical analysis
	strformat module for formatting floats for printing
	system module for some very basic and trivial math operators (shr, shl, xor, clamp, etc.)

Imports

since, bitops, fenv

Types

FloatClass = enum
  fcNormal,             	## value is an ordinary nonzero floating point value
  fcSubnormal,          	## value is a subnormal (a very small) floating point value
  fcZero,               	## value is zero
  fcNegZero,            	## value is the negative zero
  fcNan,                	## value is Not a Number (NaN)
  fcInf,                	## value is positive infinity
  fcNegInf               	## value is negative infinity

	Describes the class a floating point value belongs to. This is the type that is returned by the classify func. Source   Edit   

Consts

E = 2.718281828459045

	Euler's number. Source   Edit   

MaxFloat32Precision = 8

	Maximum number of meaningful digits after the decimal point for Nim's float32 type. Source   Edit   

MaxFloat64Precision = 16

	Maximum number of meaningful digits after the decimal point for Nim's float64 type. Source   Edit   

MaxFloatPrecision = 16

	Maximum number of meaningful digits after the decimal point for Nim's float type. Source   Edit   

MinFloatNormal = 2.225073858507201e-308

	Smallest normal number for Nim's float type (= 2^-1022). Source   Edit   

PI = 3.141592653589793

	The circle constant PI (Ludolph's number). Source   Edit   

TAU = 6.283185307179586

	The circle constant TAU (= 2 * PI). Source   Edit   

Procs

func `^`[T: SomeNumber](x: T; y: Natural): T

Computes x to the power of y.

The exponent y must be non-negative, use pow for negative exponents.

See also:

	pow func for negative exponent or floats
	sqrt func
	cbrt func

Example:

doAssert -3 ^ 0 == 1
doAssert -3 ^ 1 == -3
doAssert -3 ^ 2 == 9

	Source   Edit   

func almostEqual[T: SomeFloat](x, y: T; unitsInLastPlace: Natural = 4): bool {.
	inline.}

Checks if two float values are almost equal, using the machine epsilon.

unitsInLastPlace is the max number of units in the last place difference tolerated when comparing two numbers. The larger the value, the more error is allowed. A 0 value means that two numbers must be exactly the same to be considered equal.

The machine epsilon has to be scaled to the magnitude of the values used and multiplied by the desired precision in ULPs unless the difference is subnormal.

Example:

doAssert almostEqual(PI, 3.14159265358979)
doAssert almostEqual(Inf, Inf)
doAssert not almostEqual(NaN, NaN)

	Source   Edit   

func arccos(x: float32): float32 {.importc: "acosf", header: "<math.h>",
                               	....}

	Source   Edit   

func arccos(x: float64): float64 {.importc: "acos", header: "<math.h>",
                               	....}

Computes the arc cosine of x.

See also:

	cos func

Example:

doAssert almostEqual(radToDeg(arccos(0.0)), 90.0)
doAssert almostEqual(radToDeg(arccos(1.0)), 0.0)

	Source   Edit   

func arccosh(x: float32): float32 {.importc: "acoshf", header: "<math.h>",
                                	....}

	Source   Edit   

func arccosh(x: float64): float64 {.importc: "acosh", header: "<math.h>",
                                	....}

	Computes the inverse hyperbolic cosine of x.

	See also:

    	cosh func

	Source   Edit   

func arccot[T: float32 | float64](x: T): T

	Computes the inverse cotangent of x (arctan(1/x)). Source   Edit   

func arccoth[T: float32 | float64](x: T): T

	Computes the inverse hyperbolic cotangent of x (arctanh(1/x)). Source   Edit   

func arccsc[T: float32 | float64](x: T): T

	Computes the inverse cosecant of x (arcsin(1/x)). Source   Edit   

func arccsch[T: float32 | float64](x: T): T

	Computes the inverse hyperbolic cosecant of x (arcsinh(1/x)). Source   Edit   

func arcsec[T: float32 | float64](x: T): T

	Computes the inverse secant of x (arccos(1/x)). Source   Edit   

func arcsech[T: float32 | float64](x: T): T

	Computes the inverse hyperbolic secant of x (arccosh(1/x)). Source   Edit   

func arcsin(x: float32): float32 {.importc: "asinf", header: "<math.h>",
                               	....}

	Source   Edit   

func arcsin(x: float64): float64 {.importc: "asin", header: "<math.h>",
                               	....}

Computes the arc sine of x.

See also:

	sin func

Example:

doAssert almostEqual(radToDeg(arcsin(0.0)), 0.0)
doAssert almostEqual(radToDeg(arcsin(1.0)), 90.0)

	Source   Edit   

func arcsinh(x: float32): float32 {.importc: "asinhf", header: "<math.h>",
                                	....}

	Source   Edit   

func arcsinh(x: float64): float64 {.importc: "asinh", header: "<math.h>",
                                	....}

	Computes the inverse hyperbolic sine of x.

	See also:

    	sinh func

	Source   Edit   

func arctan(x: float32): float32 {.importc: "atanf", header: "<math.h>",
                               	....}

	Source   Edit   

func arctan(x: float64): float64 {.importc: "atan", header: "<math.h>",
                               	....}

Calculate the arc tangent of x.

See also:

	arctan2 func
	tan func

Example:

doAssert almostEqual(arctan(1.0), 0.7853981633974483)
doAssert almostEqual(radToDeg(arctan(1.0)), 45.0)

	Source   Edit   

func arctan2(y, x: float32): float32 {.importc: "atan2f", header: "<math.h>",
                                   	....}

	Source   Edit   

func arctan2(y, x: float64): float64 {.importc: "atan2", header: "<math.h>",
                                   	....}

Calculate the arc tangent of y/x.

It produces correct results even when the resulting angle is near PI/2 or -PI/2 (x near 0).

See also:

	arctan func

Example:

doAssert almostEqual(arctan2(1.0, 0.0), PI / 2.0)
doAssert almostEqual(radToDeg(arctan2(1.0, 0.0)), 90.0)

	Source   Edit   

func arctanh(x: float32): float32 {.importc: "atanhf", header: "<math.h>",
                                	....}

	Source   Edit   

func arctanh(x: float64): float64 {.importc: "atanh", header: "<math.h>",
                                	....}

	Computes the inverse hyperbolic tangent of x.

	See also:

    	tanh func

	Source   Edit   

func binom(n, k: int): int {.....}

Computes the binomial coefficient.

Example:

doAssert binom(6, 2) == 15
doAssert binom(-6, 2) == 1
doAssert binom(6, 0) == 1

	Source   Edit   

func cbrt(x: float32): float32 {.importc: "cbrtf", header: "<math.h>",
                             	....}

	Source   Edit   

func cbrt(x: float64): float64 {.importc: "cbrt", header: "<math.h>",
                             	....}

Computes the cube root of x.

See also:

	sqrt func for the square root

Example:

doAssert almostEqual(cbrt(8.0), 2.0)
doAssert almostEqual(cbrt(2.197), 1.3)
doAssert almostEqual(cbrt(-27.0), -3.0)

	Source   Edit   

func ceil(x: float32): float32 {.importc: "ceilf", header: "<math.h>",
                             	....}

	Source   Edit   

func ceil(x: float64): float64 {.importc: "ceil", header: "<math.h>",
                             	....}

Computes the ceiling function (i.e. the smallest integer not smaller than x).

See also:

	floor func
	round func
	trunc func

Example:

doAssert ceil(2.1)  == 3.0
doAssert ceil(2.9)  == 3.0
doAssert ceil(-2.1) == -2.0

	Source   Edit   

func ceilDiv[T: SomeInteger](x, y: T): T {.inline.}

Ceil division is conceptually defined as ceil(x / y).

Assumes x >= 0 and y > 0 (and x + y - 1 <= high(T) if T is SomeUnsignedInt).

This is different from the system.div operator, which works like trunc(x / y). That is, div rounds towards 0 and ceilDiv rounds up.

This function has the above input limitation, because that allows the compiler to generate faster code and it is rarely used with negative values or unsigned integers close to high(T)/2. If you need a ceilDiv that works with any input, see: https://github.com/demotomohiro/divmath.

See also:

	system.div proc for integer division
	floorDiv func for integer division which rounds down.

Example:

assert ceilDiv(12, 3) ==  4
assert ceilDiv(13, 3) ==  5

	Source   Edit   

func clamp[T](val: T; bounds: Slice[T]): T {.inline.}

Like system.clamp, but takes a slice, so you can easily clamp within a range.

Example:

assert clamp(10, 1 .. 5) == 5
assert clamp(1, 1 .. 3) == 1
type A = enum a0, a1, a2, a3, a4, a5
assert a1.clamp(a2..a4) == a2
assert clamp((3, 0), (1, 0) .. (2, 9)) == (2, 9)
doAssertRaises(AssertionDefect): discard clamp(1, 3..2) # invalid bounds

	Source   Edit   

func classify(x: float): FloatClass {.....}

Classifies a floating point value.

Returns x's class as specified by the FloatClass enum.

Example:

doAssert classify(0.3) == fcNormal
doAssert classify(0.0) == fcZero
doAssert classify(0.3 / 0.0) == fcInf
doAssert classify(-0.3 / 0.0) == fcNegInf
doAssert classify(5.0e-324) == fcSubnormal

	Source   Edit   

func copySign[T: SomeFloat](x, y: T): T {.inline.}

Returns a value with the magnitude of x and the sign of y; this works even if x or y are NaN, infinity or zero, all of which can carry a sign.

Example:

doAssert copySign(10.0, 1.0) == 10.0
doAssert copySign(10.0, -1.0) == -10.0
doAssert copySign(-Inf, -0.0) == -Inf
doAssert copySign(NaN, 1.0).isNaN
doAssert copySign(1.0, copySign(NaN, -1.0)) == -1.0

	Source   Edit   

func cos(x: float32): float32 {.importc: "cosf", header: "<math.h>", ....}

	Source   Edit   

func cos(x: float64): float64 {.importc: "cos", header: "<math.h>", ....}

Computes the cosine of x.

See also:

	arccos func

Example:

doAssert almostEqual(cos(2 * PI), 1.0)
doAssert almostEqual(cos(degToRad(60.0)), 0.5)

	Source   Edit   

func cosh(x: float32): float32 {.importc: "coshf", header: "<math.h>",
                             	....}

	Source   Edit   

func cosh(x: float64): float64 {.importc: "cosh", header: "<math.h>",
                             	....}

Computes the hyperbolic cosine of x.

See also:

	arccosh func

Example:

doAssert almostEqual(cosh(0.0), 1.0)
doAssert almostEqual(cosh(1.0), 1.543080634815244)

	Source   Edit   

func cot[T: float32 | float64](x: T): T

	Computes the cotangent of x (1/tan(x)). Source   Edit   

func coth[T: float32 | float64](x: T): T

	Computes the hyperbolic cotangent of x (1/tanh(x)). Source   Edit   

func csc[T: float32 | float64](x: T): T

	Computes the cosecant of x (1/sin(x)). Source   Edit   

func csch[T: float32 | float64](x: T): T

	Computes the hyperbolic cosecant of x (1/sinh(x)). Source   Edit   

func cumsum[T](x: var openArray[T])

Transforms x in-place (must be declared as var) into its cumulative (aka prefix) summation.

See also:

	sum func
	cumsummed func for a version which returns a cumsummed sequence

Example:

var a = [1, 2, 3, 4]
cumsum(a)
doAssert a == @[1, 3, 6, 10]

	Source   Edit   

func cumsummed[T](x: openArray[T]): seq[T]

Returns the cumulative (aka prefix) summation of x.

If x is empty, @[] is returned.

See also:

	sum func
	cumsum func for the in-place version

Example:

doAssert cumsummed([1, 2, 3, 4]) == @[1, 3, 6, 10]

	Source   Edit   

func degToRad[T: float32 | float64](d: T): T {.inline.}

Converts from degrees to radians.

See also:

	radToDeg func

Example:

doAssert almostEqual(degToRad(180.0), PI)

	Source   Edit   

func divmod[T: SomeInteger](x, y: T): (T, T) {.inline.}

Specialized instructions for computing both division and modulus. Return structure is: (quotient, remainder)

Example:

doAssert divmod(5, 2) == (2, 1)
doAssert divmod(5, -3) == (-1, 2)

	Source   Edit   

func erf(x: float32): float32 {.importc: "erff", header: "<math.h>", ....}

	Source   Edit   

func erf(x: float64): float64 {.importc: "erf", header: "<math.h>", ....}

	Computes the error function for x.

	Note: Not available for the JS backend.
	Source   Edit   

func erfc(x: float32): float32 {.importc: "erfcf", header: "<math.h>",
                             	....}

	Source   Edit   

func erfc(x: float64): float64 {.importc: "erfc", header: "<math.h>",
                             	....}

	Computes the complementary error function for x.

	Note: Not available for the JS backend.
	Source   Edit   

func euclDiv[T: SomeInteger](x, y: T): T

Returns euclidean division of x by y.

Example:

doAssert euclDiv(13, 3) == 4
doAssert euclDiv(-13, 3) == -5
doAssert euclDiv(13, -3) == -4
doAssert euclDiv(-13, -3) == 5

	Source   Edit   

func euclMod[T: SomeNumber](x, y: T): T

Returns euclidean modulo of x by y. euclMod(x, y) is non-negative.

Example:

doAssert euclMod(13, 3) == 1
doAssert euclMod(-13, 3) == 2
doAssert euclMod(13, -3) == 1
doAssert euclMod(-13, -3) == 2

	Source   Edit   

func exp(x: float32): float32 {.importc: "expf", header: "<math.h>", ....}

	Source   Edit   

func exp(x: float64): float64 {.importc: "exp", header: "<math.h>", ....}

Computes the exponential function of x (e^x).

See also:

	ln func

Example:

doAssert almostEqual(exp(1.0), E)
doAssert almostEqual(ln(exp(4.0)), 4.0)
doAssert almostEqual(exp(0.0), 1.0)

	Source   Edit   

func fac(n: int): int {.....}

Computes the factorial of a non-negative integer n.

See also:

	prod func

Example:

doAssert fac(0) == 1
doAssert fac(4) == 24
doAssert fac(10) == 3628800

	Source   Edit   

func floor(x: float32): float32 {.importc: "floorf", header: "<math.h>",
                              	....}

	Source   Edit   

func floor(x: float64): float64 {.importc: "floor", header: "<math.h>",
                              	....}

Computes the floor function (i.e. the largest integer not greater than x).

See also:

	ceil func
	round func
	trunc func

Example:

doAssert floor(2.1)  == 2.0
doAssert floor(2.9)  == 2.0
doAssert floor(-3.5) == -4.0

	Source   Edit   

func floorDiv[T: SomeInteger](x, y: T): T

Floor division is conceptually defined as floor(x / y).

This is different from the system.div operator, which is defined as trunc(x / y). That is, div rounds towards 0 and floorDiv rounds down.

See also:

	system.div proc for integer division
	floorMod func for Python-like (% operator) behavior

Example:

doAssert floorDiv( 13,  3) ==  4
doAssert floorDiv(-13,  3) == -5
doAssert floorDiv( 13, -3) == -5
doAssert floorDiv(-13, -3) ==  4

	Source   Edit   

func floorMod[T: SomeNumber](x, y: T): T

Floor modulo is conceptually defined as x - (floorDiv(x, y) * y).

This func behaves the same as the % operator in Python.

See also:

	mod func
	floorDiv func

Example:

doAssert floorMod( 13,  3) ==  1
doAssert floorMod(-13,  3) ==  2
doAssert floorMod( 13, -3) == -2
doAssert floorMod(-13, -3) == -1

	Source   Edit   

func frexp[T: float32 | float64](x: T): tuple[frac: T, exp: int] {.inline.}

Splits x into a normalized fraction frac and an integral power of 2 exp, such that abs(frac) in 0.5..<1 and x == frac * 2 ^ exp, except for special cases shown below.

Example:

doAssert frexp(8.0) == (0.5, 4)
doAssert frexp(-8.0) == (-0.5, 4)
doAssert frexp(0.0) == (0.0, 0)

# special cases:
when sizeof(int) == 8:
  doAssert frexp(-0.0).frac.signbit # signbit preserved for +-0
  doAssert frexp(Inf).frac == Inf # +- Inf preserved
  doAssert frexp(NaN).frac.isNaN

	Source   Edit   

func frexp[T: float32 | float64](x: T; exponent: var int): T {.inline.}

Overload of frexp that calls (result, exponent) = frexp(x).

Example:

var x: int
doAssert frexp(5.0, x) == 0.625
doAssert x == 3

	Source   Edit   

func gamma(x: float32): float32 {.importc: "tgammaf", header: "<math.h>",
                              	....}

	Source   Edit   

func gamma(x: float64): float64 {.importc: "tgamma", header: "<math.h>",
                              	....}

Computes the gamma function for x.

Note: Not available for the JS backend.

See also:

	lgamma func for the natural logarithm of the gamma function

Example:

doAssert almostEqual(gamma(1.0), 1.0)
doAssert almostEqual(gamma(4.0), 6.0)
doAssert almostEqual(gamma(11.0), 3628800.0)

	Source   Edit   

func gcd(x, y: SomeInteger): SomeInteger

Computes the greatest common (positive) divisor of x and y, using the binary GCD (aka Stein's) algorithm.

See also:

	gcd func for a float version
	lcm func

Example:

doAssert gcd(12, 8) == 4
doAssert gcd(17, 63) == 1

	Source   Edit   

func gcd[T](x, y: T): T

Computes the greatest common (positive) divisor of x and y.

Note that for floats, the result cannot always be interpreted as "greatest decimal z such that z*N == x and z*M == y where N and M are positive integers".

See also:

	gcd func for an integer version
	lcm func

Example:

doAssert gcd(13.5, 9.0) == 4.5

	Source   Edit   

func gcd[T](x: openArray[T]): T

Computes the greatest common (positive) divisor of the elements of x.

See also:

	gcd func for a version with two arguments

Example:

doAssert gcd(@[13.5, 9.0]) == 4.5

	Source   Edit   

func hypot(x, y: float32): float32 {.importc: "hypotf", header: "<math.h>",
                                 	....}

	Source   Edit   

func hypot(x, y: float64): float64 {.importc: "hypot", header: "<math.h>",
                                 	....}

Computes the length of the hypotenuse of a right-angle triangle with x as its base and y as its height. Equivalent to sqrt(x*x + y*y).

Example:

doAssert almostEqual(hypot(3.0, 4.0), 5.0)

	Source   Edit   

func isNaN(x: SomeFloat): bool {.inline.}

Returns whether x is a NaN, more efficiently than via classify(x) == fcNan. Works even with --passc:-ffast-math.

Example:

doAssert NaN.isNaN
doAssert not Inf.isNaN
doAssert not isNaN(3.1415926)

	Source   Edit   

func isPowerOfTwo(x: int): bool {.....}

Returns true, if x is a power of two, false otherwise.

Zero and negative numbers are not a power of two.

See also:

	nextPowerOfTwo func

Example:

doAssert isPowerOfTwo(16)
doAssert not isPowerOfTwo(5)
doAssert not isPowerOfTwo(0)
doAssert not isPowerOfTwo(-16)

	Source   Edit   

func lcm[T](x, y: T): T

Computes the least common multiple of x and y.

See also:

	gcd func

Example:

doAssert lcm(24, 30) == 120
doAssert lcm(13, 39) == 39

	Source   Edit   

func lcm[T](x: openArray[T]): T

Computes the least common multiple of the elements of x.

See also:

	lcm func for a version with two arguments

Example:

doAssert lcm(@[24, 30]) == 120

	Source   Edit   

func lgamma(x: float32): float32 {.importc: "lgammaf", header: "<math.h>",
                               	....}

	Source   Edit   

func lgamma(x: float64): float64 {.importc: "lgamma", header: "<math.h>",
                               	....}

	Computes the natural logarithm of the gamma function for x.

	Note: Not available for the JS backend.

	See also:

    	gamma func for gamma function

	Source   Edit   

func ln(x: float32): float32 {.importc: "logf", header: "<math.h>", ....}

	Source   Edit   

func ln(x: float64): float64 {.importc: "log", header: "<math.h>", ....}

Computes the natural logarithm of x.

See also:

	log func
	log10 func
	log2 func
	exp func

Example:

doAssert almostEqual(ln(exp(4.0)), 4.0)
doAssert almostEqual(ln(1.0), 0.0)
doAssert almostEqual(ln(0.0), -Inf)
doAssert ln(-7.0).isNaN

	Source   Edit   

func log[T: SomeFloat](x, base: T): T

Computes the logarithm of x to base base.

See also:

	ln func
	log10 func
	log2 func

Example:

doAssert almostEqual(log(9.0, 3.0), 2.0)
doAssert almostEqual(log(0.0, 2.0), -Inf)
doAssert log(-7.0, 4.0).isNaN
doAssert log(8.0, -2.0).isNaN

	Source   Edit   

func log2(x: float32): float32 {.importc: "log2f", header: "<math.h>",
                             	....}

	Source   Edit   

func log2(x: float64): float64 {.importc: "log2", header: "<math.h>",
                             	....}

Computes the binary logarithm (base 2) of x.

See also:

	log func
	log10 func
	ln func

Example:

doAssert almostEqual(log2(8.0), 3.0)
doAssert almostEqual(log2(1.0), 0.0)
doAssert almostEqual(log2(0.0), -Inf)
doAssert log2(-2.0).isNaN

	Source   Edit   

func log10(x: float32): float32 {.importc: "log10f", header: "<math.h>",
                              	....}

	Source   Edit   

func log10(x: float64): float64 {.importc: "log10", header: "<math.h>",
                              	....}

Computes the common logarithm (base 10) of x.

See also:

	ln func
	log func
	log2 func

Example:

doAssert almostEqual(log10(100.0) , 2.0)
doAssert almostEqual(log10(0.0), -Inf)
doAssert log10(-100.0).isNaN

	Source   Edit   

func `mod`(x, y: float32): float32 {.importc: "fmodf", header: "<math.h>",
                                 	....}

	Source   Edit   

func `mod`(x, y: float64): float64 {.importc: "fmod", header: "<math.h>",
                                 	....}

Computes the modulo operation for float values (the remainder of x divided by y).

See also:

	floorMod func for Python-like (% operator) behavior

Example:

doAssert  6.5 mod  2.5 ==  1.5
doAssert -6.5 mod  2.5 == -1.5
doAssert  6.5 mod -2.5 ==  1.5
doAssert -6.5 mod -2.5 == -1.5

	Source   Edit   

func nextPowerOfTwo(x: int): int {.....}

Returns x rounded up to the nearest power of two.

Zero and negative numbers get rounded up to 1.

See also:

	isPowerOfTwo func

Example:

doAssert nextPowerOfTwo(16) == 16
doAssert nextPowerOfTwo(5) == 8
doAssert nextPowerOfTwo(0) == 1
doAssert nextPowerOfTwo(-16) == 1

	Source   Edit   

func pow(x, y: float32): float32 {.importc: "powf", header: "<math.h>",
                               	....}

	Source   Edit   

func pow(x, y: float64): float64 {.importc: "pow", header: "<math.h>",
                               	....}

Computes x raised to the power of y.

To compute the power between integers (e.g. 2^6), use the ^ func.

See also:

	^ func
	sqrt func
	cbrt func

Example:

doAssert almostEqual(pow(100, 1.5), 1000.0)
doAssert almostEqual(pow(16.0, 0.5), 4.0)

	Source   Edit   

func prod[T](x: openArray[T]): T

Computes the product of the elements in x.

If x is empty, 1 is returned.

See also:

	sum func
	fac func

Example:

doAssert prod([1, 2, 3, 4]) == 24
doAssert prod([-4, 3, 5]) == -60

	Source   Edit   

func radToDeg[T: float32 | float64](d: T): T {.inline.}

Converts from radians to degrees.

See also:

	degToRad func

Example:

doAssert almostEqual(radToDeg(2 * PI), 360.0)

	Source   Edit   

func round(x: float32): float32 {.importc: "roundf", header: "<math.h>",
                              	....}

	Source   Edit   

func round(x: float64): float64 {.importc: "round", header: "<math.h>",
                              	....}

Rounds a float to zero decimal places.

Used internally by the round func when the specified number of places is 0.

See also:

	round func for rounding to the specific number of decimal places
	floor func
	ceil func
	trunc func

Example:

doAssert round(3.4) == 3.0
doAssert round(3.5) == 4.0
doAssert round(4.5) == 5.0

	Source   Edit   

func round[T: float32 | float64](x: T; places: int): T

Decimal rounding on a binary floating point number.

This function is NOT reliable. Floating point numbers cannot hold non integer decimals precisely. If places is 0 (or omitted), round to the nearest integral value following normal mathematical rounding rules (e.g. round(54.5) -> 55.0). If places is greater than 0, round to the given number of decimal places, e.g. round(54.346, 2) -> 54.350000000000001421…. If places is negative, round to the left of the decimal place, e.g. round(537.345, -1) -> 540.0.

Example:

doAssert round(PI, 2) == 3.14
doAssert round(PI, 4) == 3.1416

	Source   Edit   

func sec[T: float32 | float64](x: T): T

	Computes the secant of x (1/cos(x)). Source   Edit   

func sech[T: float32 | float64](x: T): T

	Computes the hyperbolic secant of x (1/cosh(x)). Source   Edit   

func sgn[T: SomeNumber](x: T): int {.inline.}

Sign function.

Returns:

	-1 for negative numbers and NegInf,
	1 for positive numbers and Inf,
	0 for positive zero, negative zero and NaN

Example:

doAssert sgn(5) == 1
doAssert sgn(0) == 0
doAssert sgn(-4.1) == -1

	Source   Edit   

proc signbit(x: SomeFloat): bool {.inline.}

Returns true if x is negative, false otherwise.

Example:

doAssert not signbit(0.0)
doAssert signbit(-0.0)
doAssert signbit(-0.1)
doAssert not signbit(0.1)

	Source   Edit   

func sin(x: float32): float32 {.importc: "sinf", header: "<math.h>", ....}

	Source   Edit   

func sin(x: float64): float64 {.importc: "sin", header: "<math.h>", ....}

Computes the sine of x.

See also:

	arcsin func

Example:

doAssert almostEqual(sin(PI / 6), 0.5)
doAssert almostEqual(sin(degToRad(90.0)), 1.0)

	Source   Edit   

func sinh(x: float32): float32 {.importc: "sinhf", header: "<math.h>",
                             	....}

	Source   Edit   

func sinh(x: float64): float64 {.importc: "sinh", header: "<math.h>",
                             	....}

Computes the hyperbolic sine of x.

See also:

	arcsinh func

Example:

doAssert almostEqual(sinh(0.0), 0.0)
doAssert almostEqual(sinh(1.0), 1.175201193643801)

	Source   Edit   

func splitDecimal[T: float32 | float64](x: T): tuple[intpart: T, floatpart: T]

Breaks x into an integer and a fractional part.

Returns a tuple containing intpart and floatpart, representing the integer part and the fractional part, respectively.

Both parts have the same sign as x. Analogous to the modf function in C.

Example:

doAssert splitDecimal(5.25) == (intpart: 5.0, floatpart: 0.25)
doAssert splitDecimal(-2.73) == (intpart: -2.0, floatpart: -0.73)

	Source   Edit   

func sqrt(x: float32): float32 {.importc: "sqrtf", header: "<math.h>",
                             	....}

	Source   Edit   

func sqrt(x: float64): float64 {.importc: "sqrt", header: "<math.h>",
                             	....}

Computes the square root of x.

See also:

	cbrt func for the cube root

Example:

doAssert almostEqual(sqrt(4.0), 2.0)
doAssert almostEqual(sqrt(1.44), 1.2)

	Source   Edit   

func sum[T](x: openArray[T]): T

Computes the sum of the elements in x.

If x is empty, 0 is returned.

See also:

	prod func
	cumsum func
	cumsummed func

Example:

doAssert sum([1, 2, 3, 4]) == 10
doAssert sum([-4, 3, 5]) == 4

	Source   Edit   

func tan(x: float32): float32 {.importc: "tanf", header: "<math.h>", ....}

	Source   Edit   

func tan(x: float64): float64 {.importc: "tan", header: "<math.h>", ....}

Computes the tangent of x.

See also:

	arctan func

Example:

doAssert almostEqual(tan(degToRad(45.0)), 1.0)
doAssert almostEqual(tan(PI / 4), 1.0)

	Source   Edit   

func tanh(x: float32): float32 {.importc: "tanhf", header: "<math.h>",
                             	....}

	Source   Edit   

func tanh(x: float64): float64 {.importc: "tanh", header: "<math.h>",
                             	....}

Computes the hyperbolic tangent of x.

See also:

	arctanh func

Example:

doAssert almostEqual(tanh(0.0), 0.0)
doAssert almostEqual(tanh(1.0), 0.7615941559557649)

	Source   Edit   

func trunc(x: float32): float32 {.importc: "truncf", header: "<math.h>",
                              	....}

	Source   Edit   

func trunc(x: float64): float64 {.importc: "trunc", header: "<math.h>",
                              	....}

Truncates x to the decimal point.

See also:

	floor func
	ceil func
	round func

Example:

doAssert trunc(PI) == 3.0
doAssert trunc(-1.85) == -1.0

	Source   Edit   


std/random


std/random
Source   Edit  

Nim's standard random number generator (RNG).

Its implementation is based on the xoroshiro128+ (xor/rotate/shift/rotate) library.

	More information: http://xoroshiro.di.unimi.it
	C implementation: http://xoroshiro.di.unimi.it/xoroshiro128plus.c

Do not use this module for cryptographic purposes!
Basic usage

Example:

import std/random
# Call randomize() once to initialize the default random number generator.
# If this is not called, the same results will occur every time these
# examples are run.
randomize()

# Pick a number in 0..100.
let num = rand(100)
doAssert num in 0..100

# Roll a six-sided die.
let roll = rand(1..6)
doAssert roll in 1..6

# Pick a marble from a bag.
let marbles = ["red", "blue", "green", "yellow", "purple"]
let pick = sample(marbles)
doAssert pick in marbles

# Shuffle some cards.
var cards = ["Ace", "King", "Queen", "Jack", "Ten"]
shuffle(cards)
doAssert cards.len == 5

These examples all use the default RNG. The Rand type represents the state of an RNG. For convenience, this module contains a default Rand state that corresponds to the default RNG. Most procs in this module which do not take in a Rand parameter, including those called in the above examples, use the default generator. Those procs are not thread-safe.

Note that the default generator always starts in the same state. The randomize proc can be called to initialize the default generator with a seed based on the current time, and it only needs to be called once before the first usage of procs from this module. If randomize is not called, the default generator will always produce the same results.

RNGs that are independent of the default one can be created with the initRand proc.

Again, it is important to remember that this module must not be used for cryptographic applications.
See also

	std/sysrand module for a cryptographically secure pseudorandom number generator
	math module for basic math routines
	stats module for statistical analysis
	list of cryptographic and hashing modules in the standard library

Imports

algorithm, math, since, jsutils, hashes, os, sysrand, monotimes, locks

Types

Rand = object

	State of a random number generator.

	Create a new Rand state using the initRand proc.

	The module contains a default Rand state for convenience. It corresponds to the default RNG's state. The default Rand state always starts with the same values, but the randomize proc can be used to seed the default generator with a value based on the current time.

	Many procs have two variations: one that takes in a Rand parameter and another that uses the default generator. The procs that use the default generator are not thread-safe!
	Source   Edit   

Procs

proc gauss(mu = 0.0; sigma = 1.0): float {.....}

	Returns a Gaussian random variate, with mean mu and standard deviation sigma.

	If randomize has not been called, the order of outcomes from this proc will always be the same.

	This proc uses the default RNG. Thus, it is not thread-safe.
	Source   Edit   

proc gauss(r: var Rand; mu = 0.0; sigma = 1.0): float {.....}

	Returns a Gaussian random variate, with mean mu and standard deviation sigma using the given state. Source   Edit   

proc initRand(): Rand {.....}

	Initializes a new Rand state.

	The resulting state is independent of the default RNG's state.

	Note: Does not work for the compile-time VM.

	See also:

    	initRand proc that accepts a seed for a new Rand state
    	randomize proc that initializes the default RNG using the current time
    	randomize proc that accepts a seed for the default RNG

	Source   Edit   

proc initRand(seed: int64): Rand {.....}

Initializes a new Rand state using the given seed.

Providing a specific seed will produce the same results for that seed each time.

The resulting state is independent of the default RNG's state. When seed == 0, we internally set the seed to an implementation defined non-zero value.

See also:

	initRand proc that uses the current time
	randomize proc that accepts a seed for the default RNG
	randomize proc that initializes the default RNG using the current time

Example:

from std/times import getTime, toUnix, nanosecond

var r1 = initRand(123)
let now = getTime()
var r2 = initRand(now.toUnix * 1_000_000_000 + now.nanosecond)

	Source   Edit   

proc initRand(seed: int64): Rand {.....}

Initializes a new Rand state using the given seed.

Providing a specific seed will produce the same results for that seed each time.

The resulting state is independent of the default RNG's state. When seed == 0, we internally set the seed to an implementation defined non-zero value.

See also:

	initRand proc that uses the current time
	randomize proc that accepts a seed for the default RNG
	randomize proc that initializes the default RNG using the current time

Example:

from std/times import getTime, toUnix, nanosecond

var r1 = initRand(123)
let now = getTime()
var r2 = initRand(now.toUnix * 1_000_000_000 + now.nanosecond)

	Source   Edit   

proc next(r: var Rand): uint64 {.....}

Computes a random uint64 number using the given state.

See also:

	rand proc that returns an integer between zero and a given upper bound
	rand proc that returns a float
	rand proc that accepts a slice
	rand proc that accepts an integer or range type
	skipRandomNumbers proc

Example: cmd: -r:off

var r = initRand(2019)
assert r.next() == 13223559681708962501'u64 # implementation defined
assert r.next() == 7229677234260823147'u64 # ditto

	Source   Edit   

proc rand(max: float): float {.....}

Returns a random floating point number in the range 0.0..max.

If randomize has not been called, the sequence of random numbers returned from this proc will always be the same.

This proc uses the default RNG. Thus, it is not thread-safe.

See also:

	rand proc that returns a float using a provided state
	rand proc that returns an integer
	rand proc that accepts a slice
	rand proc that accepts an integer or range type

Example:

randomize(234)
let f = rand(1.0) # 8.717181376738381e-07

	Source   Edit   

proc rand(max: int): int {.....}

Returns a random integer in the range 0..max.

If randomize has not been called, the sequence of random numbers returned from this proc will always be the same.

This proc uses the default RNG. Thus, it is not thread-safe.

See also:

	rand proc that returns an integer using a provided state
	rand proc that returns a float
	rand proc that accepts a slice
	rand proc that accepts an integer or range type

Example: cmd: -r:off

randomize(123)
assert [rand(100), rand(100)] == [96, 63] # implementation defined

	Source   Edit   

proc rand(r: var Rand; max: Natural): int {.....}

Returns a random integer in the range 0..max using the given state.

See also:

	rand proc that returns an integer using the default RNG
	rand proc that returns a float
	rand proc that accepts a slice
	rand proc that accepts an integer or range type

Example:

var r = initRand(123)
if false:
  assert r.rand(100) == 96 # implementation defined

	Source   Edit   

proc rand(r: var Rand; max: range[0.0 .. high(float)]): float {.....}

Returns a random floating point number in the range 0.0..max using the given state.

See also:

	rand proc that returns a float using the default RNG
	rand proc that returns an integer
	rand proc that accepts a slice
	rand proc that accepts an integer or range type

Example:

var r = initRand(234)
let f = r.rand(1.0) # 8.717181376738381e-07

	Source   Edit   

proc rand[T: Ordinal or SomeFloat](r: var Rand; x: HSlice[T, T]): T

For a slice a..b, returns a value in the range a..b using the given state.

Allowed types for T are integers, floats, and enums without holes.

See also:

	rand proc that accepts a slice and uses the default RNG
	rand proc that returns an integer
	rand proc that returns a float
	rand proc that accepts an integer or range type

Example:

var r = initRand(345)
assert r.rand(1..5) <= 5
assert r.rand(-1.1 .. 1.2) >= -1.1

	Source   Edit   

proc rand[T: Ordinal or SomeFloat](x: HSlice[T, T]): T

For a slice a..b, returns a value in the range a..b.

Allowed types for T are integers, floats, and enums without holes.

If randomize has not been called, the sequence of random numbers returned from this proc will always be the same.

This proc uses the default RNG. Thus, it is not thread-safe.

See also:

	rand proc that accepts a slice and uses a provided state
	rand proc that returns an integer
	rand proc that returns a floating point number
	rand proc that accepts an integer or range type

Example:

randomize(345)
assert rand(1..6) <= 6

	Source   Edit   

proc rand[T: Ordinal](r: var Rand; t: typedesc[T]): T

	Returns a random Ordinal in the range low(T)..high(T).

	If randomize has not been called, the sequence of random numbers returned from this proc will always be the same.

	See also:

    	rand proc that returns an integer
    	rand proc that returns a floating point number
    	rand proc that accepts a slice

	Source   Edit   

proc rand[T: Ordinal](t: typedesc[T]): T

Returns a random Ordinal in the range low(T)..high(T).

If randomize has not been called, the sequence of random numbers returned from this proc will always be the same.

This proc uses the default RNG. Thus, it is not thread-safe.

See also:

	rand proc that returns an integer
	rand proc that returns a floating point number
	rand proc that accepts a slice

Example:

randomize(567)
type E = enum a, b, c, d

assert rand(E) in a..d
assert rand(char) in low(char)..high(char)
assert rand(int8) in low(int8)..high(int8)
assert rand(uint32) in low(uint32)..high(uint32)
assert rand(range[1..16]) in 1..16

	Source   Edit   

proc randomize() {.....}

	Initializes the default random number generator with a seed based on random number source.

	This proc only needs to be called once, and it should be called before the first usage of procs from this module that use the default RNG.

	Note: Does not work for the compile-time VM.

	See also:

    	randomize proc that accepts a seed
    	initRand proc that initializes a Rand state using the current time
    	initRand proc that initializes a Rand state with a given seed

	Source   Edit   

proc randomize(seed: int64) {.....}

Initializes the default random number generator with the given seed.

Providing a specific seed will produce the same results for that seed each time.

See also:

	initRand proc that initializes a Rand state with a given seed
	randomize proc that uses the current time instead
	initRand proc that initializes a Rand state using the current time

Example:

from std/times import getTime, toUnix, nanosecond

randomize(123)

let now = getTime()
randomize(now.toUnix * 1_000_000_000 + now.nanosecond)

	Source   Edit   

proc sample[T, U](a: openArray[T]; cdf: openArray[U]): T

Returns an element from a using a cumulative distribution function (CDF).

This proc works similarly to sample. See that proc's documentation for more details.

If randomize has not been called, the order of outcomes from this proc will always be the same.

This proc uses the default RNG. Thus, it is not thread-safe.

See also:

	sample proc that also utilizes a CDF but uses a provided state
	sample proc that does not use a CDF
	sample proc for sets

Example:

from std/math import cumsummed

let marbles = ["red", "blue", "green", "yellow", "purple"]
let count = [1, 6, 8, 3, 4]
let cdf = count.cumsummed
randomize(789)
assert sample(marbles, cdf) in marbles

	Source   Edit   

proc sample[T, U](r: var Rand; a: openArray[T]; cdf: openArray[U]): T

Returns an element from a using a cumulative distribution function (CDF) and the given state.

The cdf argument does not have to be normalized, and it could contain any type of elements that can be converted to a float. It must be the same length as a. Each element in cdf should be greater than or equal to the previous element.

The outcome of the cumsum proc and the return value of the cumsummed proc, which are both in the math module, can be used as the cdf argument.

See also:

	sample proc that also utilizes a CDF but uses the default RNG
	sample proc that does not use a CDF
	sample proc for sets

Example:

from std/math import cumsummed

let marbles = ["red", "blue", "green", "yellow", "purple"]
let count = [1, 6, 8, 3, 4]
let cdf = count.cumsummed
var r = initRand(789)
assert r.sample(marbles, cdf) in marbles

	Source   Edit   

proc sample[T](a: openArray[T]): lent T

Returns a random element from a.

If randomize has not been called, the order of outcomes from this proc will always be the same.

This proc uses the default RNG. Thus, it is not thread-safe.

See also:

	sample proc that uses a provided state
	sample proc that uses a cumulative distribution function
	sample proc for sets

Example:

let marbles = ["red", "blue", "green", "yellow", "purple"]
randomize(456)
assert sample(marbles) in marbles

	Source   Edit   

proc sample[T](r: var Rand; a: openArray[T]): T

Returns a random element from a using the given state.

See also:

	sample proc that uses the default RNG
	sample proc that uses a cumulative distribution function
	sample proc for sets

Example:

let marbles = ["red", "blue", "green", "yellow", "purple"]
var r = initRand(456)
assert r.sample(marbles) in marbles

	Source   Edit   

proc sample[T](r: var Rand; s: set[T]): T

Returns a random element from the set s using the given state.

See also:

	sample proc that uses the default RNG
	sample proc for openArrays
	sample proc that uses a cumulative distribution function

Example:

var r = initRand(987)
let s = {1, 3, 5, 7, 9}
assert r.sample(s) in s

	Source   Edit   

proc sample[T](s: set[T]): T

Returns a random element from the set s.

If randomize has not been called, the order of outcomes from this proc will always be the same.

This proc uses the default RNG. Thus, it is not thread-safe.

See also:

	sample proc that uses a provided state
	sample proc for openArrays
	sample proc that uses a cumulative distribution function

Example:

randomize(987)
let s = {1, 3, 5, 7, 9}
assert sample(s) in s

	Source   Edit   

proc shuffle[T](r: var Rand; x: var openArray[T])

Shuffles a sequence of elements in-place using the given state.

See also:

	shuffle proc that uses the default RNG

Example:

var cards = ["Ace", "King", "Queen", "Jack", "Ten"]
var r = initRand(678)
r.shuffle(cards)
import std/algorithm
assert cards.sorted == @["Ace", "Jack", "King", "Queen", "Ten"]

	Source   Edit   

proc shuffle[T](x: var openArray[T])

Shuffles a sequence of elements in-place.

If randomize has not been called, the order of outcomes from this proc will always be the same.

This proc uses the default RNG. Thus, it is not thread-safe.

See also:

	shuffle proc that uses a provided state

Example:

var cards = ["Ace", "King", "Queen", "Jack", "Ten"]
randomize(678)
shuffle(cards)
import std/algorithm
assert cards.sorted == @["Ace", "Jack", "King", "Queen", "Ten"]

	Source   Edit   

proc skipRandomNumbers(s: var Rand) {.....}

The jump function for the generator.

This proc is equivalent to 2^64 calls to next, and it can be used to generate 2^64 non-overlapping subsequences for parallel computations.

When multiple threads are generating random numbers, each thread must own the Rand state it is using so that the thread can safely obtain random numbers. However, if each thread creates its own Rand state, the subsequences of random numbers that each thread generates may overlap, even if the provided seeds are unique. This is more likely to happen as the number of threads and amount of random numbers generated increases.

If many threads will generate random numbers concurrently, it is better to create a single Rand state and pass it to each thread. After passing the Rand state to a thread, call this proc before passing it to the next one. By using the Rand state this way, the subsequences of random numbers generated in each thread will never overlap as long as no thread generates more than 2^64 random numbers.

See also:

	next proc

Example: cmd: --threads:on

import std/random

const numbers = 100000

var
  thr: array[0..3, Thread[(Rand, int)]]
  vals: array[0..3, int]

proc randomSum(params: tuple[r: Rand, index: int]) {.thread.} =
  var r = params.r
  var s = 0 # avoid cache thrashing
  for i in 1..numbers:
	s += r.rand(0..10)
  vals[params.index] = s

var r = initRand(2019)
for i in 0..<thr.len:
  createThread(thr[i], randomSum, (r, i))
  r.skipRandomNumbers()

joinThreads(thr)

for val in vals:
  doAssert abs(val - numbers * 5) / numbers < 0.1

doAssert vals == [501737, 497901, 500683, 500157]

	Source   Edit   

Templates

template randState(): untyped

	Makes the default Rand state accessible from other modules. Useful for module authors. Source   Edit   

std/rationals


std/rationals
Source   Edit  

This module implements rational numbers, consisting of a numerator and a denominator. The denominator can not be 0.

Example:

import std/rationals
let
  r1 = 1 // 2
  r2 = -3 // 4

doAssert r1 + r2 == -1 // 4
doAssert r1 - r2 ==  5 // 4
doAssert r1 * r2 == -3 // 8
doAssert r1 / r2 == -2 // 3

Imports

math, hashes

Types

Rational[T] = object
  num*, den*: T

	A rational number, consisting of a numerator num and a denominator den. Source   Edit   

Procs

func `$`[T](x: Rational[T]): string

Turns a rational number into a string.

Example:

doAssert $(1 // 2) == "1/2"

	Source   Edit   

func `*`[T](x, y: Rational[T]): Rational[T]

	Multiplies two rational numbers. Source   Edit   

func `*`[T](x: Rational[T]; y: T): Rational[T]

	Multiplies the rational x with the int y. Source   Edit   

func `*`[T](x: T; y: Rational[T]): Rational[T]

	Multiplies the int x with the rational y. Source   Edit   

func `*=`[T](x: var Rational[T]; y: Rational[T])

	Multiplies the rational x by y in-place. Source   Edit   

func `*=`[T](x: var Rational[T]; y: T)

	Multiplies the rational x by the int y in-place. Source   Edit   

func `+`[T](x, y: Rational[T]): Rational[T]

	Adds two rational numbers. Source   Edit   

func `+`[T](x: Rational[T]; y: T): Rational[T]

	Adds the rational x to the int y. Source   Edit   

func `+`[T](x: T; y: Rational[T]): Rational[T]

	Adds the int x to the rational y. Source   Edit   

func `+=`[T](x: var Rational[T]; y: Rational[T])

	Adds the rational y to the rational x in-place. Source   Edit   

func `+=`[T](x: var Rational[T]; y: T)

	Adds the int y to the rational x in-place. Source   Edit   

func `-`[T](x, y: Rational[T]): Rational[T]

	Subtracts two rational numbers. Source   Edit   

func `-`[T](x: Rational[T]): Rational[T]

	Unary minus for rational numbers. Source   Edit   

func `-`[T](x: Rational[T]; y: T): Rational[T]

	Subtracts the int y from the rational x. Source   Edit   

func `-`[T](x: T; y: Rational[T]): Rational[T]

	Subtracts the rational y from the int x. Source   Edit   

func `-=`[T](x: var Rational[T]; y: Rational[T])

	Subtracts the rational y from the rational x in-place. Source   Edit   

func `-=`[T](x: var Rational[T]; y: T)

	Subtracts the int y from the rational x in-place. Source   Edit   

func `/`[T](x, y: Rational[T]): Rational[T]

	Divides the rational x by the rational y. Source   Edit   

func `/`[T](x: Rational[T]; y: T): Rational[T]

	Divides the rational x by the int y. Source   Edit   

func `/`[T](x: T; y: Rational[T]): Rational[T]

	Divides the int x by the rational y. Source   Edit   

func `//`[T](num, den: T): Rational[T]

A friendlier version of initRational.

Example:

let x = 1 // 3 + 1 // 5
doAssert x == 8 // 15

	Source   Edit   

func `/=`[T](x: var Rational[T]; y: Rational[T])

	Divides the rational x by the rational y in-place. Source   Edit   

func `/=`[T](x: var Rational[T]; y: T)

	Divides the rational x by the int y in-place. Source   Edit   

func `<`(x, y: Rational): bool

	Returns true if x is less than y. Source   Edit   

func `<=`(x, y: Rational): bool

	Returns tue if x is less than or equal to y. Source   Edit   

func `==`(x, y: Rational): bool

	Compares two rationals for equality. Source   Edit   

func abs[T](x: Rational[T]): Rational[T]

Returns the absolute value of x.

Example:

doAssert abs(1 // 2) == 1 // 2
doAssert abs(-1 // 2) == 1 // 2

	Source   Edit   

func cmp(x, y: Rational): int

	Compares two rationals. Returns

    	a value less than zero, if x < y
    	a value greater than zero, if x > y
    	zero, if x == y

	Source   Edit   

func `div`[T: SomeInteger](x, y: Rational[T]): T

	Computes the rational truncated division. Source   Edit   

func floorDiv[T: SomeInteger](x, y: Rational[T]): T

	Computes the rational floor division.

	Floor division is conceptually defined as floor(x / y). This is different from the div operator, which is defined as trunc(x / y). That is, div rounds towards 0 and floorDiv rounds down.
	Source   Edit   

func floorMod[T: SomeInteger](x, y: Rational[T]): Rational[T]

	Computes the rational modulo by floor division (modulo).

	This is same as x - floorDiv(x, y) * y. This func behaves the same as the % operator in Python.
	Source   Edit   

func hash[T](x: Rational[T]): Hash

	Computes the hash for the rational x. Source   Edit   

func initRational[T: SomeInteger](num, den: T): Rational[T]

	Creates a new rational number with numerator num and denominator den. den must not be 0.

	Note: den != 0 is not checked when assertions are turned off.
	Source   Edit   

func `mod`[T: SomeInteger](x, y: Rational[T]): Rational[T]

	Computes the rational modulo by truncated division (remainder). This is same as x - (x div y) * y. Source   Edit   

func reciprocal[T](x: Rational[T]): Rational[T]

	Calculates the reciprocal of x (1/x). If x is 0, raises DivByZeroDefect. Source   Edit   

func reduce[T: SomeInteger](x: var Rational[T])

Reduces the rational number x, so that the numerator and denominator have no common divisors other than 1 (and -1). If x is 0, raises DivByZeroDefect.

Note: This is called automatically by the various operations on rationals.

Example:

var r = Rational[int](num: 2, den: 4) # 1/2
reduce(r)
doAssert r.num == 1
doAssert r.den == 2

	Source   Edit   

func toFloat[T](x: Rational[T]): float

	Converts a rational number x to a float. Source   Edit   

func toInt[T](x: Rational[T]): int

	Converts a rational number x to an int. Conversion rounds towards 0 if x does not contain an integer value. Source   Edit   

func toRational(x: float; n: int = high(int) shr 32): Rational[int] {.
	....}

Calculates the best rational approximation of x, where the denominator is smaller than n (default is the largest possible int for maximal resolution).

The algorithm is based on the theory of continued fractions.

Example:

let x = 1.2
doAssert x.toRational.toFloat == x

	Source   Edit   

func toRational[T: SomeInteger](x: T): Rational[T]

Converts some integer x to a rational number.

Example:

doAssert toRational(42) == 42 // 1

	Source   Edit   

std/stats


std/stats
Source   Edit  

Statistical analysis framework for performing basic statistical analysis of data. The data is analysed in a single pass, when it is pushed to a RunningStat or RunningRegress object.

RunningStat calculates for a single data set

	n (data count)
	min (smallest value)
	max (largest value)
	sum
	mean
	variance
	varianceS (sample variance)
	standardDeviation
	standardDeviationS (sample standard deviation)
	skewness (the third statistical moment)
	kurtosis (the fourth statistical moment)

RunningRegress calculates for two sets of data

	n (data count)
	slope
	intercept
	correlation

Procs are provided to calculate statistics on openArrays.

However, if more than a single statistical calculation is required, it is more efficient to push the data once to a RunningStat object and then call the numerous statistical procs for the RunningStat object:

Example:

import std/stats
from std/math import almostEqual

template `~=`(a, b: float): bool = almostEqual(a, b)

var statistics: RunningStat  # must be var
statistics.push(@[1.0, 2.0, 1.0, 4.0, 1.0, 4.0, 1.0, 2.0])
doAssert statistics.n == 8
doAssert statistics.mean() ~= 2.0
doAssert statistics.variance() ~= 1.5
doAssert statistics.varianceS() ~= 1.714285714285715
doAssert statistics.skewness() ~= 0.8164965809277261
doAssert statistics.skewnessS() ~= 1.018350154434631
doAssert statistics.kurtosis() ~= -1.0
doAssert statistics.kurtosisS() ~= -0.7000000000000008

Imports

math

Types

RunningRegress = object
  n*: int                	## amount of pushed data
  x_stats*: RunningStat  	## stats for the first set of data
  y_stats*: RunningStat  	## stats for the second set of data
  ## accumulated data for combined xy

	An accumulator for regression calculations. Source   Edit   

RunningStat = object
  n*: int                	## amount of pushed data
  min*, max*, sum*: float	## self-explaining
  ## statistical moments, mom1 is mean

	An accumulator for statistical data. Source   Edit   

Procs

proc `$`(a: RunningStat): string {.....}

	Produces a string representation of the RunningStat. The exact format is currently unspecified and subject to change. Currently it contains:

    	the number of probes
    	min, max values
    	sum, mean and standard deviation.

	Source   Edit   

proc `+`(a, b: RunningRegress): RunningRegress {.....}

	Combines two RunningRegress objects.

	Useful when performing parallel analysis of data series and needing to re-combine parallel result sets
	Source   Edit   

proc `+`(a, b: RunningStat): RunningStat {.....}

	Combines two RunningStats.

	Useful when performing parallel analysis of data series and needing to re-combine parallel result sets.
	Source   Edit   

proc `+=`(a: var RunningRegress; b: RunningRegress) {.....}

	Adds the RunningRegress b to a. Source   Edit   

proc `+=`(a: var RunningStat; b: RunningStat) {.inline, ....}

	Adds the RunningStat b to a. Source   Edit   

proc clear(r: var RunningRegress) {.....}

	Resets r. Source   Edit   

proc clear(s: var RunningStat) {.....}

	Resets s. Source   Edit   

proc correlation(r: RunningRegress): float {.....}

	Computes the current correlation of the two data sets pushed into r. Source   Edit   

proc intercept(r: RunningRegress): float {.....}

	Computes the current intercept of r. Source   Edit   

proc kurtosis(s: RunningStat): float {.....}

	Computes the current population kurtosis of s. Source   Edit   

proc kurtosis[T](x: openArray[T]): float

	Computes the population kurtosis of x. Source   Edit   

proc kurtosisS(s: RunningStat): float {.....}

	Computes the current sample kurtosis of s. Source   Edit   

proc kurtosisS[T](x: openArray[T]): float

	Computes the sample kurtosis of x. Source   Edit   

proc mean(s: RunningStat): float {.....}

	Computes the current mean of s. Source   Edit   

proc mean[T](x: openArray[T]): float

	Computes the mean of x. Source   Edit   

proc push(r: var RunningRegress; x, y: float) {.....}

	Pushes two values x and y for processing. Source   Edit   

proc push(r: var RunningRegress; x, y: int) {.inline, ....}

	Pushes two values x and y for processing.

	x and y are converted to float and the other push operation is called.
	Source   Edit   

proc push(r: var RunningRegress; x, y: openArray[float | int])

	Pushes two sets of values x and y for processing. Source   Edit   

proc push(s: var RunningStat; x: float) {.....}

	Pushes a value x for processing. Source   Edit   

proc push(s: var RunningStat; x: int) {.....}

	Pushes a value x for processing.

	x is simply converted to float and the other push operation is called.
	Source   Edit   

proc push(s: var RunningStat; x: openArray[float | int])

	Pushes all values of x for processing.

	Int values of x are simply converted to float and the other push operation is called.
	Source   Edit   

proc skewness(s: RunningStat): float {.....}

	Computes the current population skewness of s. Source   Edit   

proc skewness[T](x: openArray[T]): float

	Computes the population skewness of x. Source   Edit   

proc skewnessS(s: RunningStat): float {.....}

	Computes the current sample skewness of s. Source   Edit   

proc skewnessS[T](x: openArray[T]): float

	Computes the sample skewness of x. Source   Edit   

proc slope(r: RunningRegress): float {.....}

	Computes the current slope of r. Source   Edit   

proc standardDeviation(s: RunningStat): float {.....}

	Computes the current population standard deviation of s. Source   Edit   

proc standardDeviation[T](x: openArray[T]): float

	Computes the population standard deviation of x. Source   Edit   

proc standardDeviationS(s: RunningStat): float {.....}

	Computes the current sample standard deviation of s. Source   Edit   

proc standardDeviationS[T](x: openArray[T]): float

	Computes the sample standard deviation of x. Source   Edit   

proc variance(s: RunningStat): float {.....}

	Computes the current population variance of s. Source   Edit   

proc variance[T](x: openArray[T]): float

	Computes the population variance of x. Source   Edit   

proc varianceS(s: RunningStat): float {.....}

	Computes the current sample variance of s. Source   Edit   

proc varianceS[T](x: openArray[T]): float

	Computes the sample variance of x. Source   Edit   

std/sysrand


std/sysrand
Source   Edit  

Warning: This module was added in Nim 1.6. If you are using it for cryptographic purposes, keep in mind that so far this has not been audited by any security professionals, therefore may not be secure.

std/sysrand generates random numbers from a secure source provided by the operating system. It is a cryptographically secure pseudorandom number generator and should be unpredictable enough for cryptographic applications, though its exact quality depends on the OS implementation.
Targets	Implementation
Windows	BCryptGenRandom
Linux	getrandom
MacOSX	SecRandomCopyBytes
iOS	SecRandomCopyBytes
OpenBSD	getentropy openbsd
FreeBSD	getrandom freebsd
JS (Web Browser)	getRandomValues
Node.js	randomFillSync
Other Unix platforms	/dev/urandom

On a Linux target, a call to the getrandom syscall can be avoided (e.g. for targets running kernel version < 3.17) by passing a compile flag of -d:nimNoGetRandom. If this flag is passed, sysrand will use /dev/urandom as with any other POSIX compliant OS.

Example:

import std/sysrand
doAssert urandom(0).len == 0
doAssert urandom(113).len == 113
doAssert urandom(1234) != urandom(1234) # unlikely to fail in practice

See also

	random module

Imports

oserrors

Procs

proc urandom(dest: var openArray[byte]): bool {.....}

	Fills dest with random bytes suitable for cryptographic use. If the call succeeds, returns true.

	If dest is empty, urandom immediately returns success, without calling the underlying operating system API.
	Warning: The code hasn't been audited by cryptography experts and is provided as-is without guarantees. Use at your own risks. For production systems we advise you to request an external audit.
	Source   Edit   

proc urandom(size: Natural): seq[byte] {.inline, ....}

	Returns random bytes suitable for cryptographic use.
	Warning: The code hasn't been audited by cryptography experts and is provided as-is without guarantees. Use at your own risks. For production systems we advise you to request an external audit.
	Source   Edit   


Internet Protocols and Support

std/async


std/async
Source   Edit  

Exports asyncmacro and asyncfutures for native backends, and asyncjs on the JS backend.
Imports

asyncmacro, asyncfutures

Exports

multisync, await, async, await, and, addCallback, asyncCheck, or, read, fail, setCallSoonProc, callSoon, addCallback, clean, clearCallbacks, newFutureVar, mget, Future, failed, $, callback=, complete, callback=, NimAsyncContinueSuffix, FutureBase, all, complete, FutureError, getCallSoonProc, FutureVar, isFutureLoggingEnabled, complete, readError, complete, newFuture, finished


std/asyncdispatch


std/asyncdispatch
Source   Edit  

This module implements asynchronous IO. This includes a dispatcher, a Future type implementation, and an async macro which allows asynchronous code to be written in a synchronous style with the await keyword.

The dispatcher acts as a kind of event loop. You must call poll on it (or a function which does so for you such as waitFor or runForever) in order to poll for any outstanding events. The underlying implementation is based on epoll on Linux, IO Completion Ports on Windows and select on other operating systems.

The poll function will not, on its own, return any events. Instead an appropriate Future object will be completed. A Future is a type which holds a value which is not yet available, but which may be available in the future. You can check whether a future is finished by using the finished function. When a future is finished it means that either the value that it holds is now available or it holds an error instead. The latter situation occurs when the operation to complete a future fails with an exception. You can distinguish between the two situations with the failed function.

Future objects can also store a callback procedure which will be called automatically once the future completes.

Futures therefore can be thought of as an implementation of the proactor pattern. In this pattern you make a request for an action, and once that action is fulfilled a future is completed with the result of that action. Requests can be made by calling the appropriate functions. For example: calling the recv function will create a request for some data to be read from a socket. The future which the recv function returns will then complete once the requested amount of data is read or an exception occurs.

Code to read some data from a socket may look something like this:

var future = socket.recv(100)
future.addCallback(
  proc () =
	echo(future.read)
)

All asynchronous functions returning a Future will not block. They will not however return immediately. An asynchronous function will have code which will be executed before an asynchronous request is made, in most cases this code sets up the request.

In the above example, the recv function will return a brand new Future instance once the request for data to be read from the socket is made. This Future instance will complete once the requested amount of data is read, in this case it is 100 bytes. The second line sets a callback on this future which will be called once the future completes. All the callback does is write the data stored in the future to stdout. The read function is used for this and it checks whether the future completes with an error for you (if it did, it will simply raise the error), if there is no error, however, it returns the value of the future.
Asynchronous procedures

Asynchronous procedures remove the pain of working with callbacks. They do this by allowing you to write asynchronous code the same way as you would write synchronous code.

An asynchronous procedure is marked using the {.async.} pragma. When marking a procedure with the {.async.} pragma it must have a Future[T] return type or no return type at all. If you do not specify a return type then Future[void] is assumed.

Inside asynchronous procedures await can be used to call any procedures which return a Future; this includes asynchronous procedures. When a procedure is "awaited", the asynchronous procedure it is awaited in will suspend its execution until the awaited procedure's Future completes. At which point the asynchronous procedure will resume its execution. During the period when an asynchronous procedure is suspended other asynchronous procedures will be run by the dispatcher.

The await call may be used in many contexts. It can be used on the right hand side of a variable declaration: var data = await socket.recv(100), in which case the variable will be set to the value of the future automatically. It can be used to await a Future object, and it can be used to await a procedure returning a Future[void]: await socket.send("foobar").

If an awaited future completes with an error, then await will re-raise this error. To avoid this, you can use the yield keyword instead of await. The following section shows different ways that you can handle exceptions in async procs.
Caution: Procedures marked {.async.} do not support mutable parameters such as var int. References such as ref int should be used instead.
Handling Exceptions

You can handle exceptions in the same way as in ordinary Nim code; by using the try statement:

try:
  let data = await sock.recv(100)
  echo("Received ", data)
except:
  # Handle exception

An alternative approach to handling exceptions is to use yield on a future then check the future's failed property. For example:

var future = sock.recv(100)
yield future
if future.failed:
  # Handle exception

Discarding futures

Futures should never be discarded directly because they may contain errors. If you do not care for the result of a Future then you should use the asyncCheck procedure instead of the discard keyword. Note that this does not wait for completion, and you should use waitFor or await for that purpose.
Note: await also checks if the future fails, so you can safely discard its result.
Handling futures

There are many different operations that apply to a future. The three primary high-level operations are asyncCheck, waitFor, and await.

	asyncCheck: Raises an exception if the future fails. It neither waits for the future to finish nor returns the result of the future.
	waitFor: Polls the event loop and blocks the current thread until the future finishes. This is often used to call an async procedure from a synchronous context and should never be used in an async proc.
	await: Pauses execution in the current async procedure until the future finishes. While the current procedure is paused, other async procedures will continue running. Should be used instead of waitFor in an async procedure.

Here is a handy quick reference chart showing their high-level differences:
Procedure	Context	Blocking
asyncCheck	non-async and async	non-blocking
waitFor	non-async	blocks current thread
await	async	suspends current proc
Examples

For examples take a look at the documentation for the modules implementing asynchronous IO. A good place to start is the asyncnet module.
Investigating pending futures

It's possible to get into a situation where an async proc, or more accurately a Future[T] gets stuck and never completes. This can happen for various reasons and can cause serious memory leaks. When this occurs it's hard to identify the procedure that is stuck.

Thankfully there is a mechanism which tracks the count of each pending future. All you need to do to enable it is compile with -d:futureLogging and use the getFuturesInProgress procedure to get the list of pending futures together with the stack traces to the moment of their creation.

You may also find it useful to use this prometheus package which will log the pending futures into prometheus, allowing you to analyse them via a nice graph.
Limitations/Bugs

	The effect system (raises: []) does not work with async procedures.
	Mutable parameters are not supported by async procedures.

Multiple async backend support

Thanks to its powerful macro support, Nim allows async/await to be implemented in libraries with only minimal support from the language - as such, multiple async libraries exist, including asyncdispatch and chronos, and more may come to be developed in the future.

Libraries built on top of async/await may wish to support multiple async backends - the best way to do so is to create separate modules for each backend that may be imported side-by-side.

An alternative way is to select backend using a global compile flag - this method makes it difficult to compose applications that use both backends as may happen with transitive dependencies, but may be appropriate in some cases - libraries choosing this path should call the flag asyncBackend, allowing applications to choose the backend with -d:asyncBackend=<backend_name>.

Known async backends include:

	-d:asyncBackend=none: disable async support completely
	-d:asyncBackend=asyncdispatch: https://nim-lang.org/docs/asyncdispatch.html
	-d:asyncBackend=chronos: https://github.com/status-im/nim-chronos/

none can be used when a library supports both a synchronous and asynchronous API, to disable the latter.

Imports

os, tables, strutils, times, heapqueue, options, asyncstreams, options, math, monotimes, asyncfutures, nativesockets, net, deques, winlean, sets, hashes, asyncmacro

Types

AsyncEvent = ptr AsyncEventImpl

	Source   Edit   

AsyncFD = distinct int

	Source   Edit   

Callback = proc (fd: AsyncFD): bool {.closure, ....}

	Source   Edit   

CompletionData = object
  fd*: AsyncFD
  cb*: owned(proc (fd: AsyncFD; bytesTransferred: DWORD; errcode: OSErrorCode) {.
  	closure, ....})
  cell*: ForeignCell

	Source   Edit   

CustomRef = ref CustomObj

	Source   Edit   

PDispatcher = ref object of PDispatcherBase
  handles*: HashSet[AsyncFD]

	Source   Edit   

Procs

proc `==`(x: AsyncFD; y: AsyncFD): bool {.borrow, ....}

	Source   Edit   

proc accept(socket: AsyncFD; flags = {SafeDisconn};
        	inheritable = defined(nimInheritHandles)): owned(Future[AsyncFD]) {.
	....}

	Accepts a new connection. Returns a future containing the client socket corresponding to that connection.

	If inheritable is false (the default), the resulting client socket will not be inheritable by child processes.

	The future will complete when the connection is successfully accepted.
	Source   Edit   

proc acceptAddr(socket: AsyncFD; flags = {SafeDisconn};
            	inheritable = defined(nimInheritHandles)): owned(
	Future[tuple[address: string, client: AsyncFD]]) {.....}

	Accepts a new connection. Returns a future containing the client socket corresponding to that connection and the remote address of the client. The future will complete when the connection is successfully accepted.

	The resulting client socket is automatically registered to the dispatcher.

	If inheritable is false (the default), the resulting client socket will not be inheritable by child processes.

	The accept call may result in an error if the connecting socket disconnects during the duration of the accept. If the SafeDisconn flag is specified then this error will not be raised and instead accept will be called again.
	Source   Edit   

proc activeDescriptors(): int {.inline, ....}

	Returns the current number of active file descriptors for the current event loop. This is a cheap operation that does not involve a system call. Source   Edit   

proc addEvent(ev: AsyncEvent; cb: Callback) {.....}

	Registers callback cb to be called when ev will be signaled Source   Edit   

proc addProcess(pid: int; cb: Callback) {.....}

	Registers callback cb to be called when process with process ID pid exited. Source   Edit   

proc addRead(fd: AsyncFD; cb: Callback) {.....}

	Start watching the file descriptor for read availability and then call the callback cb.

	This is not pure mechanism for Windows Completion Ports (IOCP), so if you can avoid it, please do it. Use addRead only if really need it (main usecase is adaptation of unix-like libraries to be asynchronous on Windows).

	If you use this function, you don't need to use asyncdispatch.recv() or asyncdispatch.accept(), because they are using IOCP, please use nativesockets.recv() and nativesockets.accept() instead.

	Be sure your callback cb returns true, if you want to remove watch of read notifications, and false, if you want to continue receiving notifications.
	Source   Edit   

proc addTimer(timeout: int; oneshot: bool; cb: Callback) {.....}

	Registers callback cb to be called when timer expired.

	Parameters:

    	timeout - timeout value in milliseconds.
    	oneshot
        	true - generate only one timeout event
        	false - generate timeout events periodically

	Source   Edit   

proc addWrite(fd: AsyncFD; cb: Callback) {.....}

	Start watching the file descriptor for write availability and then call the callback cb.

	This is not pure mechanism for Windows Completion Ports (IOCP), so if you can avoid it, please do it. Use addWrite only if really need it (main usecase is adaptation of unix-like libraries to be asynchronous on Windows).

	If you use this function, you don't need to use asyncdispatch.send() or asyncdispatch.connect(), because they are using IOCP, please use nativesockets.send() and nativesockets.connect() instead.

	Be sure your callback cb returns true, if you want to remove watch of write notifications, and false, if you want to continue receiving notifications.
	Source   Edit   

proc callSoon(cbproc: proc () {.....}) {.....}

	Schedule cbproc to be called as soon as possible. The callback is called when control returns to the event loop. Source   Edit   

proc close(ev: AsyncEvent) {.....}

	Closes event ev. Source   Edit   

proc closeSocket(socket: AsyncFD) {.....}

	Closes a socket and ensures that it is unregistered. Source   Edit   

proc connect(socket: AsyncFD; address: string; port: Port;
         	domain = Domain.AF_INET): owned(Future[void]) {.
	....}

	Source   Edit   

proc contains(disp: PDispatcher; fd: AsyncFD): bool {.....}

	Source   Edit   

proc createAsyncNativeSocket(domain: cint; sockType: cint; protocol: cint;
                         	inheritable = defined(nimInheritHandles)): AsyncFD {.
	....}

	Source   Edit   

proc createAsyncNativeSocket(domain: Domain = Domain.AF_INET;
                         	sockType: SockType = SOCK_STREAM;
                         	protocol: Protocol = IPPROTO_TCP;
                         	inheritable = defined(nimInheritHandles)): AsyncFD {.
	....}

	Source   Edit   

proc dial(address: string; port: Port; protocol: Protocol = IPPROTO_TCP): owned(
	Future[AsyncFD]) {.....}

	Establishes connection to the specified address:port pair via the specified protocol. The procedure iterates through possible resolutions of the address until it succeeds, meaning that it seamlessly works with both IPv4 and IPv6. Returns the async file descriptor, registered in the dispatcher of the current thread, ready to send or receive data. Source   Edit   

proc drain(timeout = 500) {.....}

	Waits for completion of all events and processes them. Raises ValueError if there are no pending operations. In contrast to poll this processes as many events as are available until the timeout has elapsed. Source   Edit   

proc getGlobalDispatcher(): PDispatcher {.....}

	Source   Edit   

proc getIoHandler(disp: PDispatcher): Handle {.....}

	Returns the underlying IO Completion Port handle (Windows) or selector (Unix) for the specified dispatcher. Source   Edit   

proc hasPendingOperations(): bool {.....}

	Returns true if the global dispatcher has pending operations. Source   Edit   

proc maxDescriptors(): int {.....}

	Returns the maximum number of active file descriptors for the current process. This involves a system call. For now maxDescriptors is supported on the following OSes: Windows, Linux, OSX, BSD, Solaris. Source   Edit   

proc newAsyncEvent(): AsyncEvent {.....}

	Creates a new thread-safe AsyncEvent object.

	New AsyncEvent object is not automatically registered with dispatcher like AsyncSocket.
	Source   Edit   

proc newCustom(): CustomRef {.....}

	Source   Edit   

proc newDispatcher(): owned PDispatcher {.....}

	Creates a new Dispatcher instance. Source   Edit   

proc poll(timeout = 500) {.....}

	Waits for completion events and processes them. Raises ValueError if there are no pending operations. This runs the underlying OS epoll or kqueue primitive only once. Source   Edit   

proc readAll(future: FutureStream[string]): owned(Future[string]) {.
	....}

	Returns a future that will complete when all the string data from the specified future stream is retrieved. Source   Edit   

proc recv(socket: AsyncFD; size: int; flags = {SafeDisconn}): owned(
	Future[string]) {.....}

	Reads up to size bytes from socket. Returned future will complete once all the data requested is read, a part of the data has been read, or the socket has disconnected in which case the future will complete with a value of "".
	Warning: The Peek socket flag is not supported on Windows.
	Source   Edit   

proc recvFromInto(socket: AsyncFD; data: pointer; size: int;
              	saddr: ptr SockAddr; saddrLen: ptr SockLen;
              	flags = {SafeDisconn}): owned(Future[int]) {.
	....}

	Receives a datagram data from socket into buf, which must be at least of size size, address of datagram's sender will be stored into saddr and saddrLen. Returned future will complete once one datagram has been received, and will return size of packet received. Source   Edit   

proc recvInto(socket: AsyncFD; buf: pointer; size: int; flags = {SafeDisconn}): owned(
	Future[int]) {.....}

	Reads up to size bytes from socket into buf, which must at least be of that size. Returned future will complete once all the data requested is read, a part of the data has been read, or the socket has disconnected in which case the future will complete with a value of 0.
	Warning: The Peek socket flag is not supported on Windows.
	Source   Edit   

proc register(fd: AsyncFD) {.....}

	Registers fd with the dispatcher. Source   Edit   

proc runForever() {.....}

	Begins a never ending global dispatcher poll loop. Source   Edit   

proc send(socket: AsyncFD; buf: pointer; size: int; flags = {SafeDisconn}): owned(
	Future[void]) {.....}

	Sends size bytes from buf to socket. The returned future will complete once all data has been sent.
	Warning: Use it with caution. If buf refers to GC'ed object, you must use GC_ref/GC_unref calls to avoid early freeing of the buffer.
	Source   Edit   

proc send(socket: AsyncFD; data: string; flags = {SafeDisconn}): owned(
	Future[void]) {.....}

	Sends data to socket. The returned future will complete once all data has been sent. Source   Edit   

proc sendTo(socket: AsyncFD; data: pointer; size: int; saddr: ptr SockAddr;
        	saddrLen: SockLen; flags = {SafeDisconn}): owned(Future[void]) {.
	....}

	Sends data to specified destination saddr, using socket socket. The returned future will complete once all data has been sent. Source   Edit   

proc setGlobalDispatcher(disp: sink PDispatcher) {.....}

	Source   Edit   

proc setInheritable(fd: AsyncFD; inheritable: bool): bool {.....}

	Control whether a file handle can be inherited by child processes. Returns true on success.

	This procedure is not guaranteed to be available for all platforms. Test for availability with declared().
	Source   Edit   

proc sleepAsync(ms: int | float): owned(Future[void])

	Suspends the execution of the current async procedure for the next ms milliseconds. Source   Edit   

proc trigger(ev: AsyncEvent) {.....}

	Set event ev to signaled state. Source   Edit   

proc unregister(ev: AsyncEvent) {.....}

	Unregisters event ev. Source   Edit   

proc unregister(fd: AsyncFD) {.....}

	Unregisters fd. Source   Edit   

proc waitFor[T](fut: Future[T]): T

	Blocks the current thread until the specified future completes. Source   Edit   

proc withTimeout[T](fut: Future[T]; timeout: int): owned(Future[bool])

	Returns a future which will complete once fut completes or after timeout milliseconds has elapsed.

	If fut completes first the returned future will hold true, otherwise, if timeout milliseconds has elapsed first, the returned future will hold false.
	Source   Edit   

Exports

Port, SocketFlag, and, addCallback, asyncCheck, or, read, fail, setCallSoonProc, addCallback, clean, clearCallbacks, newFutureVar, mget, Future, failed, $, callback=, complete, callback=, NimAsyncContinueSuffix, FutureBase, all, complete, FutureError, getCallSoonProc, FutureVar, isFutureLoggingEnabled, complete, readError, complete, newFuture, finished, len, callback=, fail, newFutureStream, finished, write, complete, FutureStream, read, failed, multisync, await, async, await


std/asyncfile


std/asyncfile
Source   Edit  

This module implements asynchronous file reading and writing.

import std/[asyncfile, asyncdispatch, os]

proc main() {.async.} =
  var file = openAsync(getTempDir() / "foobar.txt", fmReadWrite)
  await file.write("test")
  file.setFilePos(0)
  let data = await file.readAll()
  doAssert data == "test"
  file.close()

waitFor main()

Imports

asyncdispatch, os, winlean

Types

AsyncFile = ref object

	Source   Edit   

Procs

proc close(f: AsyncFile) {.....}

	Closes the file specified. Source   Edit   

proc getFilePos(f: AsyncFile): int64 {.....}

	Retrieves the current position of the file pointer that is used to read from the specified file. The file's first byte has the index zero. Source   Edit   

proc getFileSize(f: AsyncFile): int64 {.....}

	Retrieves the specified file's size. Source   Edit   

proc newAsyncFile(fd: AsyncFD): AsyncFile {.....}

	Creates AsyncFile with a previously opened file descriptor fd. Source   Edit   

proc openAsync(filename: string; mode = fmRead): AsyncFile {.....}

	Opens a file specified by the path in filename using the specified FileMode mode asynchronously. Source   Edit   

proc read(f: AsyncFile; size: int): Future[string] {.
	....}

	Read size bytes from the specified file asynchronously starting at the current position of the file pointer. size should be greater than zero.

	If the file pointer is past the end of the file then an empty string is returned.
	Source   Edit   

proc readAll(f: AsyncFile): Future[string] {.....}

	Reads all data from the specified file. Source   Edit   

proc readBuffer(f: AsyncFile; buf: pointer; size: int): Future[int] {.
	....}

	Read size bytes from the specified file asynchronously starting at the current position of the file pointer.

	If the file pointer is past the end of the file then zero is returned and no bytes are read into buf
	Source   Edit   

proc readLine(f: AsyncFile): Future[string] {.....}

	Reads a single line from the specified file asynchronously. Source   Edit   

proc readToStream(f: AsyncFile; fs: FutureStream[string]): owned(
	Future[void]) {.....}

	Writes data to the specified future stream as the file is read. Source   Edit   

proc setFilePos(f: AsyncFile; pos: int64) {.....}

	Sets the position of the file pointer that is used for read/write operations. The file's first byte has the index zero. Source   Edit   

proc setFileSize(f: AsyncFile; length: int64) {.....}

	Set a file length. Source   Edit   

proc write(f: AsyncFile; data: string): Future[void] {.....}

	Writes data to the file specified asynchronously.

	The returned Future will complete once all data has been written to the specified file.
	Source   Edit   

proc writeBuffer(f: AsyncFile; buf: pointer; size: int): Future[void] {.
	....}

	Writes size bytes from buf to the file specified asynchronously.

	The returned Future will complete once all data has been written to the specified file.
	Source   Edit   

proc writeFromStream(f: AsyncFile; fs: FutureStream[string]): owned(
	Future[void]) {.....}

	Reads data from the specified future stream until it is completed. The data which is read is written to the file immediately and freed from memory.

	This procedure is perfect for saving streamed data to a file without wasting memory.
	Source   Edit   



src/asyncftpclient


src/asyncftpclient

Note: In order to use this module, run nimble install asyncftpclient.

This module implements an asynchronous FTP client. It allows you to connect to an FTP server and perform operations on it such as for example:

	The upload of new files.
	The removal of existing files.
	Download of files.
	Changing of files' permissions.
	Navigation through the FTP server's directories.

Connecting to an FTP server

In order to begin any sort of transfer of files you must first connect to an FTP server. You can do so with the connect procedure.

import std/asyncdispatch
import pkg/asyncftpclient
proc main() {.async.} =
  var ftp = newAsyncFtpClient("example.com", user = "test", pass = "test")
  await ftp.connect()
  echo("Connected")
waitFor(main())

A new main async procedure must be declared to allow the use of the await keyword. The connection will complete asynchronously and the client will be connected after the await ftp.connect() call.
Uploading a new file

After a connection is made you can use the store procedure to upload a new file to the FTP server. Make sure to check you are in the correct working directory before you do so with the pwd procedure, you can also instead specify an absolute path.

import std/asyncdispatch
import pkg/asyncftpclient
proc main() {.async.} =
  var ftp = newAsyncFtpClient("example.com", user = "test", pass = "test")
  await ftp.connect()
  let currentDir = await ftp.pwd()
  assert currentDir == "/home/user/"
  await ftp.store("file.txt", "file.txt")
  echo("File finished uploading")
waitFor(main())

Checking the progress of a file transfer

The progress of either a file upload or a file download can be checked by specifying a onProgressChanged procedure to the store or retrFile procedures.

Procs that take an onProgressChanged callback will call this every progressInterval milliseconds.

import std/asyncdispatch
import pkg/asyncftpclient

proc onProgressChanged(total, progress: BiggestInt,
                    	speed: float) {.async.} =
  echo("Uploaded ", progress, " of ", total, " bytes")
  echo("Current speed: ", speed, " kb/s")

proc main() {.async.} =
  var ftp = newAsyncFtpClient("example.com", user = "test", pass = "test", progressInterval = 500)
  await ftp.connect()
  await ftp.store("file.txt", "/home/user/file.txt", onProgressChanged)
  echo("File finished uploading")
waitFor(main())

Types

AsyncFtpClient = ref object
  csock*: AsyncSocket
  dsock*: AsyncSocket
  user*, pass*: string
  address*: string
  port*: Port
  jobInProgress*: bool
  job*: FtpJob
  dsockConnected*: bool
  when defined(ssl):

FtpEvent = object
  filename*: string
  case typ*: FtpEventType
  of EvLines:
	lines*: string       	## Lines that have been transferred.
  of EvRetr, EvStore:   	## Retr/Store operation finished.
	nil
  of EvTransferProgress:
	bytesTotal*: BiggestInt  ## Bytes total.
	bytesFinished*: BiggestInt ## Bytes transferred.
	speed*: BiggestInt   	## Speed in bytes/s
	currentJob*: FtpJobType  ## The current job being performed.

	Event

FtpEventType = enum
  EvTransferProgress, EvLines, EvRetr, EvStore

FtpJobType = enum
  JRetrText, JRetr, JStore

ProgressChangedProc = proc (total, progress: BiggestInt; speed: float): Future[
	void] {.closure, ....}

ReplyError = object of IOError

Procs

proc cd(ftp: AsyncFtpClient; dir: string): owned(Future[void]) {.
	....}

	Changes the current directory on the remote FTP server to dir.

proc cdup(ftp: AsyncFtpClient): owned(Future[void]) {.....}

	Changes the current directory to the parent of the current directory.

proc chmod(ftp: AsyncFtpClient; path: string; permissions: set[FilePermission]): owned(
	Future[void]) {.....}

	Changes permission of path to permissions.

proc connect(ftp: AsyncFtpClient): owned(Future[void]) {.....}

	Connect to the FTP server specified by ftp.

proc createDir(ftp: AsyncFtpClient; dir: string; recursive = false): owned(
	Future[void]) {.....}

	Creates a directory dir. If recursive is true, the topmost subdirectory of dir will be created first, following the secondmost... etc. this allows you to give a full path as the dir without worrying about subdirectories not existing.

proc defaultOnProgressChanged(total, progress: BiggestInt; speed: float): Future[
	void] {.nimcall, ....}

	Default FTP onProgressChanged handler. Does nothing.

proc fileExists(ftp: AsyncFtpClient; file: string): Future[bool] {.
	....}

	Determines whether file exists.

proc list(ftp: AsyncFtpClient; dir = ""): Future[string] {.....}

	Lists all files in dir. If dir is "", uses the current working directory.

proc listDirs(ftp: AsyncFtpClient; dir = ""): Future[seq[string]] {.
	....}

	Returns a list of filenames in the given directory. If dir is "", the current directory is used. If async is true, this function will return immediately and it will be your job to use asyncdispatch's poll to progress this operation.

proc newAsyncFtpClient(address: string; port = Port(21); user, pass = "";
                   	progressInterval: int = 1000; useTls = false;
                   	sslContext: SslContext = nil): AsyncFtpClient {.
	....}

	Creates a new AsyncFtpClient object.

proc pwd(ftp: AsyncFtpClient): Future[string] {.....}

	Returns the current working directory.

proc removeDir(ftp: AsyncFtpClient; dir: string): owned(Future[void]) {.
	....}

	Delete a directory dir on the remote FTP server

proc removeFile(ftp: AsyncFtpClient; filename: string): owned(Future[void]) {.
	....}

	Delete a file filename on the remote FTP server

proc rename(ftp: AsyncFtpClient; nameFrom: string; nameTo: string): owned(
	Future[void]) {.....}

	Rename a file or directory on the remote FTP Server from current name name_from to new name name_to

proc retrFile(ftp: AsyncFtpClient; file, dest: string;
          	onProgressChanged: ProgressChangedProc = defaultOnProgressChanged): owned(
	Future[void]) {.....}

	Downloads file and saves it to dest. The EvRetr event is passed to the specified handleEvent function when the download is finished. The event's filename field will be equal to file.

proc retrText(ftp: AsyncFtpClient; file: string): Future[string] {.
	....}

	Retrieves file. File must be ASCII text.

proc send(ftp: AsyncFtpClient; m: string): Future[string] {.....}

	Send a message to the server, and wait for a primary reply. \c\L is added for you.

	You need to make sure that the message m doesn't contain any newline characters. Failing to do so will raise AssertionDefect.

	Note: The server may return multiple lines of coded replies.

proc store(ftp: AsyncFtpClient; file, dest: string;
       	onProgressChanged: ProgressChangedProc = defaultOnProgressChanged): owned(
	Future[void]) {.....}

	Uploads file to dest on the remote FTP server. Usage of this function asynchronously is recommended to view the progress of the download. The EvStore event is passed to the specified handleEvent function when the upload is finished, and the filename field will be equal to file.


std/asynchttpserver



std/asynchttpserver
Source   Edit  

This module implements a high performance asynchronous HTTP server.

This HTTP server has not been designed to be used in production, but for testing applications locally. Because of this, when deploying your application in production you should use a reverse proxy (for example nginx) instead of allowing users to connect directly to this server.

Example: cmd: -r:off

import std/asynchttpserver
# This example will create an HTTP server on an automatically chosen port.
# It will respond to all requests with a `200 OK` response code and "Hello World"
# as the response body.
import std/asyncdispatch
proc main {.async.} =
  var server = newAsyncHttpServer()
  proc cb(req: Request) {.async.} =
	echo (req.reqMethod, req.url, req.headers)
	let headers = {"Content-type": "text/plain; charset=utf-8"}
	await req.respond(Http200, "Hello World", headers.newHttpHeaders())

  server.listen(Port(0)) # or Port(8080) to hardcode the standard HTTP port.
  let port = server.getPort
  echo "test this with: curl localhost:" & $port.uint16 & "/"
  while true:
	if server.shouldAcceptRequest():
  	await server.acceptRequest(cb)
	else:
  	# too many concurrent connections, `maxFDs` exceeded
  	# wait 500ms for FDs to be closed
  	await sleepAsync(500)

waitFor main()

Imports

asyncnet, asyncdispatch, parseutils, uri, strutils, httpcore, nativesockets, since

Types

AsyncHttpServer = ref object
  ## The maximum content-length that will be read for the body.

	Source   Edit   

Request = object
  client*: AsyncSocket
  reqMethod*: HttpMethod
  headers*: HttpHeaders
  protocol*: tuple[orig: string, major, minor: int]
  url*: Uri
  hostname*: string      	## The hostname of the client that made the request.
  body*: string

	Source   Edit   

Consts

nimMaxDescriptorsFallback {.intdefine.} = 16000

	fallback value for when maxDescriptors is not available. This can be set on the command line during compilation via -d:nimMaxDescriptorsFallback=N Source   Edit   

Procs

proc acceptRequest(server: AsyncHttpServer; callback: proc (request: Request): Future[
	void] {.closure, ....}): owned(Future[void]) {.....}

	Accepts a single request. Write an explicit loop around this proc so that errors can be handled properly. Source   Edit   

proc close(server: AsyncHttpServer) {.....}

	Terminates the async http server instance. Source   Edit   

proc getPort(self: AsyncHttpServer): Port {.....}

Returns the port self was bound to.

Useful for identifying what port self is bound to, if it was chosen automatically, for example via listen(Port(0)).

Example:

from std/nativesockets import Port
let server = newAsyncHttpServer()
server.listen(Port(0))
assert server.getPort.uint16 > 0
server.close()

	Source   Edit   

proc listen(server: AsyncHttpServer; port: Port; address = ""; domain = AF_INET) {.
	....}

	Listen to the given port and address. Source   Edit   

proc newAsyncHttpServer(reuseAddr = true; reusePort = false; maxBody = 8388608): AsyncHttpServer {.
	....}

	Creates a new AsyncHttpServer instance. Source   Edit   

proc respond(req: Request; code: HttpCode; content: string;
         	headers: HttpHeaders = nil): Future[void] {.....}

Responds to the request with the specified HttpCode, headers and content.

This procedure will not close the client socket.

Example:

import std/json
proc handler(req: Request) {.async.} =
  if req.url.path == "/hello-world":
	let msg = %* {"message": "Hello World"}
	let headers = newHttpHeaders([("Content-Type","application/json")])
	await req.respond(Http200, $msg, headers)
  else:
	await req.respond(Http404, "Not Found")

	Source   Edit   

proc sendHeaders(req: Request; headers: HttpHeaders): Future[void] {.
	....}

	Sends the specified headers to the requesting client. Source   Edit   

proc serve(server: AsyncHttpServer; port: Port;
       	callback: proc (request: Request): Future[void] {.closure, ....};
       	address = ""; assumedDescriptorsPerRequest = -1; domain = AF_INET): owned(
	Future[void]) {.....}

	Starts the process of listening for incoming HTTP connections on the specified address and port.

	When a request is made by a client the specified callback will be called.

	If assumedDescriptorsPerRequest is 0 or greater the server cares about the process's maximum file descriptor limit. It then ensures that the process still has the resources for assumedDescriptorsPerRequest file descriptors before accepting a connection.

	You should prefer to call acceptRequest instead with a custom server loop so that you're in control over the error handling and logging.
	Source   Edit   

proc shouldAcceptRequest(server: AsyncHttpServer;
                     	assumedDescriptorsPerRequest = 5): bool {.inline,
	....}

	Returns true if the process's current number of opened file descriptors is still within the maximum limit and so it's reasonable to accept yet another request. Source   Edit   

Exports

Http417, Http503, Http431, HttpTrace, contains, Http304, Http406, $, HttpMethod, Http408, is4xx, is1xx, Http411, is3xx, Http207, Http418, Http206, HttpHead, HttpPost, clear, Http101, httpNewLine, Http505, Http413, Http423, Http409, hasKey, Http200, []=, Http414, add, Http401, Http511, Http205, ==, Http407, Http500, Http404, Http416, Http507, Http302, HttpHeaders, Http300, Http428, Http410, is2xx, Http202, Http502, headerLimit, HttpHeaderValues, Http425, contains, newHttpHeaders, $, [], Http510, newHttpHeaders, Http305, Http451, Http504, Http426, HttpConnect, ==, Http308, del, HttpPut, Http402, pairs, Http429, HttpVersion, HttpDelete, is5xx, Http421, HttpOptions, Http307, Http102, Http301, HttpPatch, Http201, Http203, getOrDefault, Http100, Http208, Http501, []=, len, Http506, Http400, Http403, HttpGet, Http508, Http415, toString, Http412, Http103, Http405, Http303, Http204, Http424, HttpCode, Http422, Http226, []


std/asyncmacro


std/asyncmacro
Source   Edit  

Implements the async and multisync macros for asyncdispatch.
Imports

macros, strutils, asyncfutures

Macros

macro async(prc: untyped): untyped

	Macro which processes async procedures into the appropriate iterators and yield statements. Source   Edit   

macro multisync(prc: untyped): untyped

	Macro which processes async procedures into both asynchronous and synchronous procedures.

	The generated async procedures use the async macro, whereas the generated synchronous procedures simply strip off the await calls.
	Source   Edit   

Templates

template await(f: typed): untyped {.used.}

	Source   Edit   

template await[T](f: Future[T]): auto {.used.}

	Source   Edit   


std/asyncnet


std/asyncnet
Source   Edit  

This module implements a high-level asynchronous sockets API based on the asynchronous dispatcher defined in the asyncdispatch module.
Asynchronous IO in Nim

Async IO in Nim consists of multiple layers (from highest to lowest):

	asyncnet module
	Async await
	asyncdispatch module (event loop)
	selectors module

Each builds on top of the layers below it. The selectors module is an abstraction for the various system select() mechanisms such as epoll or kqueue. If you wish you can use it directly, and some people have done so successfully. But you must be aware that on Windows it only supports select().

The async dispatcher implements the proactor pattern and also has an implementation of IOCP. It implements the proactor pattern for other OS' via the selectors module. Futures are also implemented here, and indeed all the procedures return a future.

The final layer is the async await transformation. This allows you to write asynchronous code in a synchronous style and works similar to C#'s await. The transformation works by converting any async procedures into an iterator.

This is all single threaded, fully non-blocking and does give you a lot of control. In theory you should be able to work with any of these layers interchangeably (as long as you only care about non-Windows platforms).

For most applications using asyncnet is the way to go as it builds over all the layers, providing some extra features such as buffering.
SSL

SSL can be enabled by compiling with the -d:ssl flag.

You must create a new SSL context with the newContext function defined in the net module. You may then call wrapSocket on your socket using the newly created SSL context to get an SSL socket.
Examples
Chat server

The following example demonstrates a simple chat server.

import std/[asyncnet, asyncdispatch]

var clients {.threadvar.}: seq[AsyncSocket]

proc processClient(client: AsyncSocket) {.async.} =
  while true:
	let line = await client.recvLine()
	if line.len == 0: break
	for c in clients:
  	await c.send(line & "\c\L")

proc serve() {.async.} =
  clients = @[]
  var server = newAsyncSocket()
  server.setSockOpt(OptReuseAddr, true)
  server.bindAddr(Port(12345))
  server.listen()
 
  while true:
	let client = await server.accept()
	clients.add client
    
	asyncCheck processClient(client)

asyncCheck serve()
runForever()

Imports

since, asyncdispatch, nativesockets, net, os, openssl

Types

AsyncSocket = ref AsyncSocketDesc

	Source   Edit   

Procs

proc accept(socket: AsyncSocket; flags = {SafeDisconn}): owned(
	Future[AsyncSocket]) {.....}

	Accepts a new connection. Returns a future containing the client socket corresponding to that connection. If inheritable is false (the default), the resulting client socket will not be inheritable by child processes. The future will complete when the connection is successfully accepted. Source   Edit   

proc acceptAddr(socket: AsyncSocket; flags = {SafeDisconn};
            	inheritable = defined(nimInheritHandles)): owned(
	Future[tuple[address: string, client: AsyncSocket]]) {.
	....}

	Accepts a new connection. Returns a future containing the client socket corresponding to that connection and the remote address of the client.

	If inheritable is false (the default), the resulting client socket will not be inheritable by child processes.

	The future will complete when the connection is successfully accepted.
	Source   Edit   

proc bindAddr(socket: AsyncSocket; port = Port(0); address = "") {.
	....}

	Binds address:port to the socket.

	If address is "" then ADDR_ANY will be bound.
	Source   Edit   

proc bindUnix(socket: AsyncSocket; path: string) {.....}

	Binds Unix socket to path. This only works on Unix-style systems: Mac OS X, BSD and Linux Source   Edit   

proc close(socket: AsyncSocket) {.....}

	Closes the socket. Source   Edit   

proc connect(socket: AsyncSocket; address: string; port: Port): owned(
	Future[void]) {.....}

	Connects socket to server at address:port.

	Returns a Future which will complete when the connection succeeds or an error occurs.
	Source   Edit   

proc connectUnix(socket: AsyncSocket; path: string): owned(Future[void]) {.
	....}

	Binds Unix socket to path. This only works on Unix-style systems: Mac OS X, BSD and Linux Source   Edit   

proc dial(address: string; port: Port; protocol = IPPROTO_TCP; buffered = true): owned(
	Future[AsyncSocket]) {.....}

	Establishes connection to the specified address:port pair via the specified protocol. The procedure iterates through possible resolutions of the address until it succeeds, meaning that it seamlessly works with both IPv4 and IPv6. Returns AsyncSocket ready to send or receive data. Source   Edit   

proc getFd(socket: AsyncSocket): SocketHandle {.....}

	Returns the socket's file descriptor. Source   Edit   

proc getLocalAddr(socket: AsyncSocket): (string, Port) {.
	....}

	Get the socket's local address and port number.

	This is high-level interface for getsockname.
	Source   Edit   

proc getPeerAddr(socket: AsyncSocket): (string, Port) {.
	....}

	Get the socket's peer address and port number.

	This is high-level interface for getpeername.
	Source   Edit   

proc getPeerCertificates(socket: AsyncSocket): seq[Certificate] {.
	....}

	Returns the certificate chain received by the peer we are connected to through the given socket. The handshake must have been completed and the certificate chain must have been verified successfully or else an empty sequence is returned. The chain is ordered from leaf certificate to root certificate. Source   Edit   

proc getSockOpt(socket: AsyncSocket; opt: SOBool; level = SOL_SOCKET): bool {.
	....}

	Retrieves option opt as a boolean value. Source   Edit   

proc hasDataBuffered(s: AsyncSocket): bool {.....}

	Determines whether an AsyncSocket has data buffered. Source   Edit   

proc isClosed(socket: AsyncSocket): bool {.....}

	Determines whether the socket has been closed. Source   Edit   

proc isSsl(socket: AsyncSocket): bool {.....}

	Determines whether socket is a SSL socket. Source   Edit   

proc listen(socket: AsyncSocket; backlog = SOMAXCONN) {.....}

	Marks socket as accepting connections. Backlog specifies the maximum length of the queue of pending connections.

	Raises an OSError error upon failure.
	Source   Edit   

proc newAsyncSocket(domain, sockType, protocol: cint; buffered = true;
                	inheritable = defined(nimInheritHandles)): owned(AsyncSocket) {.
	....}

	Creates a new asynchronous socket.

	This procedure will also create a brand new file descriptor for this socket.

	If inheritable is false (the default), the new file descriptor will not be inheritable by child processes.
	Source   Edit   

proc newAsyncSocket(domain: Domain = AF_INET; sockType: SockType = SOCK_STREAM;
                	protocol: Protocol = IPPROTO_TCP; buffered = true;
                	inheritable = defined(nimInheritHandles)): owned(AsyncSocket) {.
	....}

	Creates a new asynchronous socket.

	This procedure will also create a brand new file descriptor for this socket.

	If inheritable is false (the default), the new file descriptor will not be inheritable by child processes.
	Source   Edit   

proc newAsyncSocket(fd: AsyncFD; domain: Domain = AF_INET;
                	sockType: SockType = SOCK_STREAM;
                	protocol: Protocol = IPPROTO_TCP; buffered = true;
                	inheritable = defined(nimInheritHandles)): owned(AsyncSocket) {.
	....}

	Creates a new AsyncSocket based on the supplied params.

	The supplied fd's non-blocking state will be enabled implicitly.

	If inheritable is false (the default), the supplied fd will not be inheritable by child processes.

	Note: This procedure will NOT register fd with the global async dispatcher. You need to do this manually. If you have used newAsyncNativeSocket to create fd then it's already registered.
	Source   Edit   

proc recv(socket: AsyncSocket; size: int; flags = {SafeDisconn}): owned(
	Future[string]) {.....}

	Reads up to size bytes from socket.

	For buffered sockets this function will attempt to read all the requested data. It will read this data in BufferSize chunks.

	For unbuffered sockets this function makes no effort to read all the data requested. It will return as much data as the operating system gives it.

	If socket is disconnected during the recv operation then the future may complete with only a part of the requested data.

	If socket is disconnected and no data is available to be read then the future will complete with a value of "".
	Source   Edit   

proc recvFrom(socket: AsyncSocket; data: FutureVar[string]; size: int;
          	address: FutureVar[string]; port: FutureVar[Port];
          	flags = {SafeDisconn}): owned(Future[int]) {.....}

	Receives a datagram data from socket into data, which must be at least of size size. The address and port of datagram's sender will be stored into address and port, respectively. Returned future will complete once one datagram has been received, and will return size of packet received.

	If an error occurs an OSError exception will be raised.

	This proc is normally used with connectionless sockets (UDP sockets).

	Notes

    	data must be initialized to the length of size.
    	address must be initialized to 46 in length.

	Source   Edit   

proc recvFrom(socket: AsyncSocket; size: int; flags = {SafeDisconn}): owned(
	Future[tuple[data: string, address: string, port: Port]]) {.
	....}

	Receives a datagram data from socket, which must be at least of size size. Returned future will complete once one datagram has been received and will return tuple with: data of packet received; and address and port of datagram's sender.

	If an error occurs an OSError exception will be raised.

	This proc is normally used with connectionless sockets (UDP sockets).
	Source   Edit   

proc recvInto(socket: AsyncSocket; buf: pointer; size: int;
          	flags = {SafeDisconn}): owned(Future[int]) {.....}

	Reads up to size bytes from socket into buf.

	For buffered sockets this function will attempt to read all the requested data. It will read this data in BufferSize chunks.

	For unbuffered sockets this function makes no effort to read all the data requested. It will return as much data as the operating system gives it.

	If socket is disconnected during the recv operation then the future may complete with only a part of the requested data.

	If socket is disconnected and no data is available to be read then the future will complete with a value of 0.
	Source   Edit   

proc recvLine(socket: AsyncSocket; flags = {SafeDisconn};
          	maxLength = MaxLineLength): owned(Future[string]) {.
	....}

	Reads a line of data from socket. Returned future will complete once a full line is read or an error occurs.

	If a full line is read \r\L is not added to line, however if solely \r\L is read then line will be set to it.

	If the socket is disconnected, line will be set to "".

	If the socket is disconnected in the middle of a line (before \r\L is read) then line will be set to "". The partial line will be lost.

	The maxLength parameter determines the maximum amount of characters that can be read. The result is truncated after that.
	Warning: The Peek flag is not yet implemented.
	Warning: recvLine on unbuffered sockets assumes that the protocol uses \r\L to delimit a new line.
	Source   Edit   

proc recvLineInto(socket: AsyncSocket; resString: FutureVar[string];
              	flags = {SafeDisconn}; maxLength = MaxLineLength): owned(
	Future[void]) {.....}

	Reads a line of data from socket into resString.

	If a full line is read \r\L is not added to line, however if solely \r\L is read then line will be set to it.

	If the socket is disconnected, line will be set to "".

	If the socket is disconnected in the middle of a line (before \r\L is read) then line will be set to "". The partial line will be lost.

	The maxLength parameter determines the maximum amount of characters that can be read. resString will be truncated after that.
	Warning: The Peek flag is not yet implemented.
	Warning: recvLineInto on unbuffered sockets assumes that the protocol uses \r\L to delimit a new line.
	Source   Edit   

proc send(socket: AsyncSocket; buf: pointer; size: int; flags = {SafeDisconn}): owned(
	Future[void]) {.....}

	Sends size bytes from buf to socket. The returned future will complete once all data has been sent. Source   Edit   

proc send(socket: AsyncSocket; data: string; flags = {SafeDisconn}): owned(
	Future[void]) {.....}

	Sends data to socket. The returned future will complete once all data has been sent. Source   Edit   

proc sendTo(socket: AsyncSocket; address: string; port: Port; data: string;
        	flags = {SafeDisconn}): owned(Future[void]) {.....}

	This proc sends data to the specified address, which may be an IP address or a hostname. If a hostname is specified this function will try each IP of that hostname. The returned future will complete once all data has been sent.

	If an error occurs an OSError exception will be raised.

	This proc is normally used with connectionless sockets (UDP sockets).
	Source   Edit   

proc setSockOpt(socket: AsyncSocket; opt: SOBool; value: bool;
            	level = SOL_SOCKET) {.....}

	Sets option opt to a boolean value specified by value. Source   Edit   

proc sslHandle(self: AsyncSocket): SslPtr {.....}

	Retrieve the ssl pointer of socket. Useful for interfacing with openssl. Source   Edit   

proc wrapConnectedSocket(ctx: SslContext; socket: AsyncSocket;
                     	handshake: SslHandshakeType; hostname: string = "") {.
	....}

	Wraps a connected socket in an SSL context. This function effectively turns socket into an SSL socket. hostname should be specified so that the client knows which hostname the server certificate should be validated against.

	This should be called on a connected socket, and will perform an SSL handshake immediately.

	Disclaimer: This code is not well tested, may be very unsafe and prone to security vulnerabilities.
	Source   Edit   

proc wrapSocket(ctx: SslContext; socket: AsyncSocket) {.....}

	Wraps a socket in an SSL context. This function effectively turns socket into an SSL socket.

	Disclaimer: This code is not well tested, may be very unsafe and prone to security vulnerabilities.
	Source   Edit   

Exports

SOBool


std/asyncstreams


std/asyncstreams
Source   Edit  

Unstable API.
Imports

asyncfutures, deques

Types

FutureStream[T] = ref object
  error*: ref Exception

	Special future that acts as a queue. Its API is still experimental and so is subject to change. Source   Edit   

Procs

proc callback=[T](future: FutureStream[T];
              	cb: proc (future: FutureStream[T]) {.closure, ....})

	Sets the callback proc to be called when data was placed inside the future stream.

	The callback is also called when the future is completed. So you should use finished to check whether data is available.

	If the future stream already has data or is finished then cb will be called immediately.
	Source   Edit   

proc complete[T](future: FutureStream[T])

	Completes a FutureStream signalling the end of data. Source   Edit   

proc fail[T](future: FutureStream[T]; error: ref Exception)

	Completes future with error. Source   Edit   

proc failed[T](future: FutureStream[T]): bool

	Determines whether future completed with an error. Source   Edit   

proc finished[T](future: FutureStream[T]): bool

	Check if a FutureStream is finished. true value means that no more data will be placed inside the stream and that there is no data waiting to be retrieved. Source   Edit   

proc len[T](future: FutureStream[T]): int

	Returns the amount of data pieces inside the stream. Source   Edit   

proc newFutureStream[T](fromProc = "unspecified"): FutureStream[T]

	Create a new FutureStream. This future's callback is activated when two events occur:

    	New data is written into the future stream.
    	The future stream is completed (this means that no more data will be written).

	Specifying fromProc, which is a string specifying the name of the proc that this future belongs to, is a good habit as it helps with debugging.

	Note: The API of FutureStream is still new and so has a higher likelihood of changing in the future.
	Source   Edit   

proc read[T](future: FutureStream[T]): owned(Future[(bool, T)])

	Returns a future that will complete when the FutureStream has data placed into it. The future will be completed with the oldest value stored inside the stream. The return value will also determine whether data was retrieved, false means that the future stream was completed and no data was retrieved.

	This function will remove the data that was returned from the underlying FutureStream.
	Source   Edit   

proc write[T](future: FutureStream[T]; value: T): Future[void]

	Writes the specified value inside the specified future stream.

	This will raise ValueError if future is finished.
	Source   Edit   


std/cgi


std/cgi
Source   Edit  

This module implements helper procs for CGI applications. Example:

import std/[strtabs, cgi]

# Fill the values when debugging:
when debug:
  setTestData("name", "Klaus", "password", "123456")
# read the data into `myData`
var myData = readData()
# check that the data's variable names are "name" or "password"
validateData(myData, "name", "password")
# start generating content:
writeContentType()
# generate content:
write(stdout, "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\">\n")
write(stdout, "<html><head><title>Test</title></head><body>\n")
writeLine(stdout, "your name: " & myData["name"])
writeLine(stdout, "your password: " & myData["password"])
writeLine(stdout, "</body></html>")

Imports

strutils, os, strtabs, cookies, uri

Types

CgiError = object of IOError

	Exception that is raised if a CGI error occurs. Source   Edit   

RequestMethod = enum
  methodNone,           	## no REQUEST_METHOD environment variable
  methodPost,           	## query uses the POST method
  methodGet              	## query uses the GET method

	The used request method. Source   Edit   

Procs

proc cgiError(msg: string) {.noreturn, ....}

	Raises a CgiError exception with message msg. Source   Edit   

proc existsCookie(name: string): bool {.....}

	Checks if a cookie of name exists. Source   Edit   

proc getContentLength(): string {.....}

	Returns contents of the CONTENT_LENGTH environment variable. Source   Edit   

proc getContentType(): string {.....}

	Returns contents of the CONTENT_TYPE environment variable. Source   Edit   

proc getCookie(name: string): string {.....}

	Gets a cookie. If no cookie of name exists, "" is returned. Source   Edit   

proc getDocumentRoot(): string {.....}

	Returns contents of the DOCUMENT_ROOT environment variable. Source   Edit   

proc getGatewayInterface(): string {.....}

	Returns contents of the GATEWAY_INTERFACE environment variable. Source   Edit   

proc getHttpAccept(): string {.....}

	Returns contents of the HTTP_ACCEPT environment variable. Source   Edit   

proc getHttpAcceptCharset(): string {.....}

	Returns contents of the HTTP_ACCEPT_CHARSET environment variable. Source   Edit   

proc getHttpAcceptEncoding(): string {.....}

	Returns contents of the HTTP_ACCEPT_ENCODING environment variable. Source   Edit   

proc getHttpAcceptLanguage(): string {.....}

	Returns contents of the HTTP_ACCEPT_LANGUAGE environment variable. Source   Edit   

proc getHttpConnection(): string {.....}

	Returns contents of the HTTP_CONNECTION environment variable. Source   Edit   

proc getHttpCookie(): string {.....}

	Returns contents of the HTTP_COOKIE environment variable. Source   Edit   

proc getHttpHost(): string {.....}

	Returns contents of the HTTP_HOST environment variable. Source   Edit   

proc getHttpReferer(): string {.....}

	Returns contents of the HTTP_REFERER environment variable. Source   Edit   

proc getHttpUserAgent(): string {.....}

	Returns contents of the HTTP_USER_AGENT environment variable. Source   Edit   

proc getPathInfo(): string {.....}

	Returns contents of the PATH_INFO environment variable. Source   Edit   

proc getPathTranslated(): string {.....}

	Returns contents of the PATH_TRANSLATED environment variable. Source   Edit   

proc getQueryString(): string {.....}

	Returns contents of the QUERY_STRING environment variable. Source   Edit   

proc getRemoteAddr(): string {.....}

	Returns contents of the REMOTE_ADDR environment variable. Source   Edit   

proc getRemoteHost(): string {.....}

	Returns contents of the REMOTE_HOST environment variable. Source   Edit   

proc getRemoteIdent(): string {.....}

	Returns contents of the REMOTE_IDENT environment variable. Source   Edit   

proc getRemotePort(): string {.....}

	Returns contents of the REMOTE_PORT environment variable. Source   Edit   

proc getRemoteUser(): string {.....}

	Returns contents of the REMOTE_USER environment variable. Source   Edit   

proc getRequestMethod(): string {.....}

	Returns contents of the REQUEST_METHOD environment variable. Source   Edit   

proc getRequestURI(): string {.....}

	Returns contents of the REQUEST_URI environment variable. Source   Edit   

proc getScriptFilename(): string {.....}

	Returns contents of the SCRIPT_FILENAME environment variable. Source   Edit   

proc getScriptName(): string {.....}

	Returns contents of the SCRIPT_NAME environment variable. Source   Edit   

proc getServerAddr(): string {.....}

	Returns contents of the SERVER_ADDR environment variable. Source   Edit   

proc getServerAdmin(): string {.....}

	Returns contents of the SERVER_ADMIN environment variable. Source   Edit   

proc getServerName(): string {.....}

	Returns contents of the SERVER_NAME environment variable. Source   Edit   

proc getServerPort(): string {.....}

	Returns contents of the SERVER_PORT environment variable. Source   Edit   

proc getServerProtocol(): string {.....}

	Returns contents of the SERVER_PROTOCOL environment variable. Source   Edit   

proc getServerSignature(): string {.....}

	Returns contents of the SERVER_SIGNATURE environment variable. Source   Edit   

proc getServerSoftware(): string {.....}

	Returns contents of the SERVER_SOFTWARE environment variable. Source   Edit   

proc readData(allowedMethods: set[RequestMethod] = {methodNone, methodPost,
	methodGet}): StringTableRef {.....}

	Reads CGI data. If the client does not use a method listed in the allowedMethods set, a CgiError exception is raised. Source   Edit   

proc readData(data: string): StringTableRef {.....}

	Reads CGI data from a string. Source   Edit   

proc setCookie(name, value: string) {.....}

	Sets a cookie. Source   Edit   

proc setStackTraceStdout() {.....}

	Makes Nim output stacktraces to stdout, instead of server log. Source   Edit   

proc setTestData(keysvalues: varargs[string]) {.....}

Fills the appropriate environment variables to test your CGI application. This can only simulate the 'GET' request method. keysvalues should provide embedded (name, value)-pairs. Example:

setTestData("name", "Hanz", "password", "12345")

	Source   Edit   

proc validateData(data: StringTableRef; validKeys: varargs[string]) {.
	....}

	Validates data; raises CgiError if this fails. This checks that each variable name of the CGI data occurs in the validKeys array. Source   Edit   

proc writeContentType() {.....}

Calls this before starting to send your HTML data to stdout. This implements this part of the CGI protocol:

write(stdout, "Content-type: text/html\n\n")

	Source   Edit   

proc writeErrorMessage(data: string) {.....}

	Tries to reset browser state and writes data to stdout in <plaintext> tag. Source   Edit   

proc xmlEncode(s: string): string {.....}

	Encodes a value to be XML safe:

    	" is replaced by &quot;
    	< is replaced by &lt;
    	> is replaced by &gt;
    	& is replaced by &amp;
    	every other character is carried over.

	Source   Edit   

Iterators

iterator decodeData(allowedMethods: set[RequestMethod] = {methodNone,
	methodPost, methodGet}): tuple[key, value: string] {.
	....}

	Reads and decodes CGI data and yields the (name, value) pairs the data consists of. If the client does not use a method listed in the allowedMethods set, a CgiError exception is raised. Source   Edit   

iterator decodeData(data: string): tuple[key, value: string] {.....}

	Reads and decodes CGI data and yields the (name, value) pairs the data consists of. Source   Edit   

Exports

encodeUrl, decodeUrl

std/cookies


std/cookies
Source   Edit  

This module implements helper procs for parsing Cookies.
Imports

strtabs, times, options

Types

SameSite {.pure.} = enum
  Default, None, Lax, Strict

	The SameSite cookie attribute. Default means that setCookie proc will not set SameSite attribute. Source   Edit   

Procs

proc parseCookies(s: string): StringTableRef {.....}

Parses cookies into a string table.

The proc is meant to parse the Cookie header set by a client, not the "Set-Cookie" header set by servers.

Example:

import std/strtabs
let cookieJar = parseCookies("a=1; foo=bar")
assert cookieJar["a"] == "1"
assert cookieJar["foo"] == "bar"

	Source   Edit   

proc setCookie(key, value: string; domain = ""; path = ""; expires = "";
           	noName = false; secure = false; httpOnly = false;
           	maxAge = none(int); sameSite = SameSite.Default): string {.
	....}

	Creates a command in the format of Set-Cookie: key=value; Domain=...; ...
	Tip: Cookies can be vulnerable. Consider setting secure=true, httpOnly=true and sameSite=Strict.
	Source   Edit   

proc setCookie(key, value: string; expires: DateTime | Time; domain = "";
           	path = ""; noName = false; secure = false; httpOnly = false;
           	maxAge = none(int); sameSite = SameSite.Default): string

	Creates a command in the format of Set-Cookie: key=value; Domain=...; ... Source   Edit   


std/httpclient


std/httpclient
Source   Edit  

This module implements a simple HTTP client that can be used to retrieve webpages and other data.
Warning: Validate untrusted inputs: URI parsers and getters are not detecting malicious URIs.
Retrieving a website

This example uses HTTP GET to retrieve http://google.com:

import std/httpclient
var client = newHttpClient()
try:
  echo client.getContent("http://google.com")
finally:
  client.close()

The same action can also be performed asynchronously, simply use the AsyncHttpClient:

import std/[asyncdispatch, httpclient]

proc asyncProc(): Future[string] {.async.} =
  var client = newAsyncHttpClient()
  try:
	return await client.getContent("http://google.com")
  finally:
	client.close()

echo waitFor asyncProc()

The functionality implemented by HttpClient and AsyncHttpClient is the same, so you can use whichever one suits you best in the examples shown here.

Note: You need to run asynchronous examples in an async proc otherwise you will get an Undeclared identifier: 'await' error.

Note: An asynchronous client instance can only deal with one request at a time. To send multiple requests in parallel, use multiple client instances.
Using HTTP POST

This example demonstrates the usage of the W3 HTML Validator, it uses multipart/form-data as the Content-Type to send the HTML to be validated to the server.

var client = newHttpClient()
var data = newMultipartData()
data["output"] = "soap12"
data["uploaded_file"] = ("test.html", "text/html",
  "<html><head></head><body><p>test</p></body></html>")
try:
  echo client.postContent("http://validator.w3.org/check", multipart=data)
finally:
  client.close()

To stream files from disk when performing the request, use addFiles.

Note: This will allocate a new Mimetypes database every time you call it, you can pass your own via the mimeDb parameter to avoid this.

let mimes = newMimetypes()
var client = newHttpClient()
var data = newMultipartData()
data.addFiles({"uploaded_file": "test.html"}, mimeDb = mimes)
try:
  echo client.postContent("http://validator.w3.org/check", multipart=data)
finally:
  client.close()

You can also make post requests with custom headers. This example sets Content-Type to application/json and uses a json object for the body

import std/[httpclient, json]

let client = newHttpClient()
client.headers = newHttpHeaders({ "Content-Type": "application/json" })
let body = %*{
	"data": "some text"
}
try:
  let response = client.request("http://some.api", httpMethod = HttpPost, body = $body)
  echo response.status
finally:
  client.close()

Progress reporting

You may specify a callback procedure to be called during an HTTP request. This callback will be executed every second with information about the progress of the HTTP request.

import std/[asyncdispatch, httpclient]

proc onProgressChanged(total, progress, speed: BiggestInt) {.async.} =
  echo("Downloaded ", progress, " of ", total)
  echo("Current rate: ", speed div 1000, "kb/s")

proc asyncProc() {.async.} =
  var client = newAsyncHttpClient()
  client.onProgressChanged = onProgressChanged
  try:
	discard await client.getContent("http://speedtest-ams2.digitalocean.com/100mb.test")
  finally:
	client.close()

waitFor asyncProc()

If you would like to remove the callback simply set it to nil.

client.onProgressChanged = nil

Warning: The total reported by httpclient may be 0 in some cases.
SSL/TLS support

This requires the OpenSSL library. Fortunately it's widely used and installed on many operating systems. httpclient will use SSL automatically if you give any of the functions a url with the https schema, for example: https://github.com/.

You will also have to compile with ssl defined like so: nim c -d:ssl ....

Certificate validation is performed by default.

A set of directories and files from the ssl_certs module are scanned to locate CA certificates.

Example of setting SSL verification parameters in a new client:

import httpclient
var client = newHttpClient(sslContext=newContext(verifyMode=CVerifyPeer))

There are three options for verify mode:

	CVerifyNone: certificates are not verified;
	CVerifyPeer: certificates are verified;
	CVerifyPeerUseEnvVars: certificates are verified and the optional environment variables SSL_CERT_FILE and SSL_CERT_DIR are also used to locate certificates

See newContext to tweak or disable certificate validation.
Timeouts

Currently only the synchronous functions support a timeout. The timeout is measured in milliseconds, once it is set any call on a socket which may block will be susceptible to this timeout.

It may be surprising but the function as a whole can take longer than the specified timeout, only individual internal calls on the socket are affected. In practice this means that as long as the server is sending data an exception will not be raised, if however data does not reach the client within the specified timeout a TimeoutError exception will be raised.

Here is how to set a timeout when creating an HttpClient instance:

import std/httpclient

let client = newHttpClient(timeout = 42)

Proxy

A proxy can be specified as a param to any of the procedures defined in this module. To do this, use the newProxy constructor. Unfortunately, only basic authentication is supported at the moment.

Some examples on how to configure a Proxy for HttpClient:

import std/httpclient

let myProxy = newProxy("http://myproxy.network")
let client = newHttpClient(proxy = myProxy)

Use proxies with basic authentication:

import std/httpclient

let myProxy = newProxy("http://myproxy.network", auth="user:password")
let client = newHttpClient(proxy = myProxy)

Get Proxy URL from environment variables:

import std/httpclient

var url = ""
try:
  if existsEnv("http_proxy"):
	url = getEnv("http_proxy")
  elif existsEnv("https_proxy"):
	url = getEnv("https_proxy")
except ValueError:
  echo "Unable to parse proxy from environment variables."

let myProxy = newProxy(url = url)
let client = newHttpClient(proxy = myProxy)

Redirects

The maximum redirects can be set with the maxRedirects of int type, it specifies the maximum amount of redirects to follow, it defaults to 5, you can set it to 0 to disable redirects.

Here you can see an example about how to set the maxRedirects of HttpClient:

import std/httpclient

let client = newHttpClient(maxRedirects = 0)

Imports

since, net, strutils, uri, parseutils, base64, os, mimetypes, math, random, httpcore, times, tables, streams, monotimes, asyncnet, asyncdispatch, asyncfile, nativesockets

Types

AsyncHttpClient = HttpClientBase[AsyncSocket]

	Source   Edit   

AsyncResponse = ref object
  version*: string
  status*: string
  headers*: HttpHeaders
  bodyStream*: FutureStream[string]

	Source   Edit   

HttpClient = HttpClientBase[Socket]

	Source   Edit   

HttpClientBase[SocketType] = ref object
  ## Where we are currently connected.
  headers*: HttpHeaders  	## Headers to send in requests.
  ## Maximum redirects, set to `0` to disable.
  timeout*: int          	## Only used for blocking HttpClient for now.
  ## `nil` or the callback to call when request progress changes.
  when SocketType is Socket:
	onProgressChanged*: ProgressChangedProc[void]
  else:
	onProgressChanged*: ProgressChangedProc[Future[void]]
  when defined(ssl):
  when SocketType is AsyncSocket:
  else:
  ## When `false`, the body is never read in requestAux.

	Source   Edit   

HttpRequestError = object of IOError

	Thrown in the getContent proc and postContent proc, when the server returns an error Source   Edit   

MultipartData = ref object

	Source   Edit   

MultipartEntries = openArray[tuple[name, content: string]]

	Source   Edit   

ProgressChangedProc[ReturnType] = proc (total, progress, speed: BiggestInt): ReturnType {.
	closure, ....}

	Source   Edit   

ProtocolError = object of IOError

	exception that is raised when server does not conform to the implemented protocol Source   Edit   

Proxy = ref object
  url*: Uri
  auth*: string

	Source   Edit   

Response = ref object
  version*: string
  status*: string
  headers*: HttpHeaders
  bodyStream*: Stream

	Source   Edit   

Consts

defUserAgent = "Nim httpclient/2.0.8"

	Source   Edit   

Procs

proc `$`(data: MultipartData): string {.....}

	convert MultipartData to string so it's human readable when echo see https://github.com/nim-lang/Nim/issues/11863 Source   Edit   

proc `[]=`(p: MultipartData; name, content: string) {.inline,
	....}

Add a multipart entry to the multipart data p. The value is added without a filename and without a content type.

data["username"] = "NimUser"

	Source   Edit   

proc `[]=`(p: MultipartData; name: string;
       	file: tuple[name, contentType, content: string]) {.inline,
	....}

Add a file to the multipart data p, specifying filename, contentType and content manually.

data["uploaded_file"] = ("test.html", "text/html",
  "<html><head></head><body><p>test</p></body></html>")

	Source   Edit   

proc add(p: MultipartData; name, content: string; filename: string = "";
     	contentType: string = ""; useStream = true) {.....}

	Add a value to the multipart data.

	When useStream is false, the file will be read into memory.

	Raises a ValueError exception if name, filename or contentType contain newline characters.
	Source   Edit   

proc add(p: MultipartData; xs: MultipartEntries): MultipartData {.discardable,
	....}

Add a list of multipart entries to the multipart data p. All values are added without a filename and without a content type.

data.add({"action": "login", "format": "json"})

	Source   Edit   

proc addFiles(p: MultipartData; xs: openArray[tuple[name, file: string]];
          	mimeDb = newMimetypes(); useStream = true): MultipartData {.
	discardable, ....}

Add files to a multipart data object. The files will be streamed from disk when the request is being made. When stream is false, the files are instead read into memory, but beware this is very memory ineffecient even for small files. The MIME types will automatically be determined. Raises an IOError if the file cannot be opened or reading fails. To manually specify file content, filename and MIME type, use []= instead.

data.addFiles({"uploaded_file": "public/test.html"})

	Source   Edit   

proc body(response: AsyncResponse): Future[string] {.....}

	Reads the response's body and caches it. The read is performed only once. Source   Edit   

proc body(response: Response): string {.....}

	Retrieves the specified response's body.

	The response's body stream is read synchronously.
	Source   Edit   

proc close(client: HttpClient | AsyncHttpClient)

	Closes any connections held by the HTTP client. Source   Edit   

proc code(response: Response | AsyncResponse): HttpCode {.
	....}

	Retrieves the specified response's HttpCode.

	Raises a ValueError if the response's status does not have a corresponding HttpCode.
	Source   Edit   

proc contentLength(response: Response | AsyncResponse): int

	Retrieves the specified response's content length.

	This is effectively the value of the "Content-Length" header.

	A ValueError exception will be raised if the value is not an integer. If the Content-Length header is not set in the response, ContentLength is set to the value -1.
	Source   Edit   

proc contentType(response: Response | AsyncResponse): string {.inline.}

	Retrieves the specified response's content type.

	This is effectively the value of the "Content-Type" header.
	Source   Edit   

proc delete(client: AsyncHttpClient; url: Uri | string): Future[AsyncResponse] {.
	....}

	Connects to the hostname specified by the URL and performs a DELETE request. This procedure uses httpClient values such as client.maxRedirects. Source   Edit   

proc delete(client: HttpClient; url: Uri | string): Response

	Source   Edit   

proc deleteContent(client: AsyncHttpClient; url: Uri | string): Future[string] {.
	....}

	Connects to the hostname specified by the URL and returns the content of a DELETE request. Source   Edit   

proc deleteContent(client: HttpClient; url: Uri | string): string

	Source   Edit   

proc downloadFile(client: AsyncHttpClient; url: Uri | string; filename: string): Future[
	void]

	Source   Edit   

proc downloadFile(client: HttpClient; url: Uri | string; filename: string)

	Downloads url and saves it to filename. Source   Edit   

proc get(client: AsyncHttpClient; url: Uri | string): Future[AsyncResponse] {.
	....}

	Connects to the hostname specified by the URL and performs a GET request.

	This procedure uses httpClient values such as client.maxRedirects.
	Source   Edit   

proc get(client: HttpClient; url: Uri | string): Response

	Source   Edit   

proc getContent(client: AsyncHttpClient; url: Uri | string): Future[string] {.
	....}

	Connects to the hostname specified by the URL and returns the content of a GET request. Source   Edit   

proc getContent(client: HttpClient; url: Uri | string): string

	Source   Edit   

proc getSocket(client: AsyncHttpClient): AsyncSocket {.inline, ....}

	Source   Edit   

proc getSocket(client: HttpClient): Socket {.inline, ....}

Get network socket, useful if you want to find out more details about the connection

this example shows info about local and remote endpoints

if client.connected:
  echo client.getSocket.getLocalAddr
  echo client.getSocket.getPeerAddr

	Source   Edit   

proc head(client: AsyncHttpClient; url: Uri | string): Future[AsyncResponse] {.
	....}

	Connects to the hostname specified by the URL and performs a HEAD request.

	This procedure uses httpClient values such as client.maxRedirects.
	Source   Edit   

proc head(client: HttpClient; url: Uri | string): Response

	Source   Edit   

proc lastModified(response: Response | AsyncResponse): DateTime

	Retrieves the specified response's last modified time.

	This is effectively the value of the "Last-Modified" header.

	Raises a ValueError if the parsing fails or the value is not a correctly formatted time.
	Source   Edit   

proc newAsyncHttpClient(userAgent = defUserAgent; maxRedirects = 5;
                    	sslContext = getDefaultSSL(); proxy: Proxy = nil;
                    	headers = newHttpHeaders()): AsyncHttpClient {.
	....}

Creates a new AsyncHttpClient instance.

userAgent specifies the user agent that will be used when making requests.

maxRedirects specifies the maximum amount of redirects to follow, default is 5.

sslContext specifies the SSL context to use for HTTPS requests.

proxy specifies an HTTP proxy to use for this HTTP client's connections.

headers specifies the HTTP Headers.

Example:

import std/[asyncdispatch, strutils]

proc asyncProc(): Future[string] {.async.} =
  let client = newAsyncHttpClient()
  result = await client.getContent("http://example.com")

let exampleHtml = waitFor asyncProc()
assert "Example Domain" in exampleHtml
assert "Pizza" notin exampleHtml

	Source   Edit   

proc newHttpClient(userAgent = defUserAgent; maxRedirects = 5;
               	sslContext = getDefaultSSL(); proxy: Proxy = nil;
               	timeout = -1; headers = newHttpHeaders()): HttpClient {.
	....}

Creates a new HttpClient instance.

userAgent specifies the user agent that will be used when making requests.

maxRedirects specifies the maximum amount of redirects to follow, default is 5.

sslContext specifies the SSL context to use for HTTPS requests. See SSL/TLS support

proxy specifies an HTTP proxy to use for this HTTP client's connections.

timeout specifies the number of milliseconds to allow before a TimeoutError is raised.

headers specifies the HTTP Headers.

Example:

import std/strutils

let exampleHtml = newHttpClient().getContent("http://example.com")
assert "Example Domain" in exampleHtml
assert "Pizza" notin exampleHtml

	Source   Edit   

proc newMultipartData(): MultipartData {.inline, ....}

	Constructs a new MultipartData object. Source   Edit   

proc newMultipartData(xs: MultipartEntries): MultipartData {.
	....}

Create a new multipart data object and fill it with the entries xs directly.

var data = newMultipartData({"action": "login", "format": "json"})

	Source   Edit   

proc newProxy(url: string; auth = ""): Proxy {.....}

	Constructs a new TProxy object. Source   Edit   

proc newProxy(url: Uri; auth = ""): Proxy {.....}

	Constructs a new TProxy object. Source   Edit   

proc patch(client: AsyncHttpClient; url: Uri | string; body = "";
       	multipart: MultipartData = nil): Future[AsyncResponse] {.
	....}

	Connects to the hostname specified by the URL and performs a PATCH request. This procedure uses httpClient values such as client.maxRedirects. Source   Edit   

proc patch(client: HttpClient; url: Uri | string; body = "";
       	multipart: MultipartData = nil): Response

	Source   Edit   

proc patchContent(client: AsyncHttpClient; url: Uri | string; body = "";
              	multipart: MultipartData = nil): Future[string] {.
	....}

	Connects to the hostname specified by the URL and returns the content of a PATCH request. Source   Edit   

proc patchContent(client: HttpClient; url: Uri | string; body = "";
              	multipart: MultipartData = nil): string

	Source   Edit   

proc post(client: AsyncHttpClient; url: Uri | string; body = "";
      	multipart: MultipartData = nil): Future[AsyncResponse] {.
	....}

	Connects to the hostname specified by the URL and performs a POST request. This procedure uses httpClient values such as client.maxRedirects. Source   Edit   

proc post(client: HttpClient; url: Uri | string; body = "";
      	multipart: MultipartData = nil): Response

	Source   Edit   

proc postContent(client: AsyncHttpClient; url: Uri | string; body = "";
             	multipart: MultipartData = nil): Future[string] {.
	....}

	Connects to the hostname specified by the URL and returns the content of a POST request. Source   Edit   

proc postContent(client: HttpClient; url: Uri | string; body = "";
             	multipart: MultipartData = nil): string

	Source   Edit   

proc put(client: AsyncHttpClient; url: Uri | string; body = "";
     	multipart: MultipartData = nil): Future[AsyncResponse] {.
	....}

	Connects to the hostname specified by the URL and performs a PUT request. This procedure uses httpClient values such as client.maxRedirects. Source   Edit   

proc put(client: HttpClient; url: Uri | string; body = "";
     	multipart: MultipartData = nil): Response

	Source   Edit   

proc putContent(client: AsyncHttpClient; url: Uri | string; body = "";
            	multipart: MultipartData = nil): Future[string] {.
	....}

	Connects to the hostname specified by the URL andreturns the content of a PUT request. Source   Edit   

proc putContent(client: HttpClient; url: Uri | string; body = "";
            	multipart: MultipartData = nil): string

	Source   Edit   

proc request(client: AsyncHttpClient; url: Uri | string;
         	httpMethod: HttpMethod | string = HttpGet; body = "";
         	headers: HttpHeaders = nil; multipart: MultipartData = nil): Future[
	AsyncResponse] {.....}

	Connects to the hostname specified by the URL and performs a request using the custom method string specified by httpMethod.

	Connection will be kept alive. Further requests on the same client to the same hostname will not require a new connection to be made. The connection can be closed by using the close procedure.

	This procedure will follow redirects up to a maximum number of redirects specified in client.maxRedirects.

	You need to make sure that the url doesn't contain any newline characters. Failing to do so will raise AssertionDefect.

	headers are HTTP headers that override the client.headers for this specific request only and will not be persisted.

	Deprecated since v1.5: use HttpMethod enum instead; string parameter httpMethod is deprecated
	Source   Edit   

proc request(client: HttpClient; url: Uri | string;
         	httpMethod: HttpMethod | string = HttpGet; body = "";
         	headers: HttpHeaders = nil; multipart: MultipartData = nil): Response

	Source   Edit   

Exports

Http417, Http503, Http431, HttpTrace, contains, Http304, Http406, $, HttpMethod, Http408, is4xx, is1xx, Http411, is3xx, Http207, Http418, Http206, HttpHead, HttpPost, clear, Http101, httpNewLine, Http505, Http413, Http423, Http409, hasKey, Http200, []=, Http414, add, Http401, Http511, Http205, ==, Http407, Http500, Http404, Http416, Http507, Http302, HttpHeaders, Http300, Http428, Http410, is2xx, Http202, Http502, headerLimit, HttpHeaderValues, Http425, contains, newHttpHeaders, $, [], Http510, newHttpHeaders, Http305, Http451, Http504, Http426, HttpConnect, ==, Http308, del, HttpPut, Http402, pairs, Http429, HttpVersion, HttpDelete, is5xx, Http421, HttpOptions, Http307, Http102, Http301, HttpPatch, Http201, Http203, getOrDefault, Http100, Http208, Http501, []=, len, Http506, Http400, Http403, HttpGet, Http508, Http415, toString, Http412, Http103, Http405, Http303, Http204, Http424, HttpCode, Http422, Http226, []

std/mimetypes


std/mimetypes
Source   Edit  

This module implements a mimetypes database

Example:

import std/mimetypes
var m = newMimetypes()
doAssert m.getMimetype("mp4") == "video/mp4"
doAssert m.getExt("text/html") == "html"
## Values can be uppercase too.
doAssert m.getMimetype("MP4") == "video/mp4"
doAssert m.getExt("TEXT/HTML") == "html"
## If values are invalid then `default` is returned.
doAssert m.getMimetype("INVALID") == "text/plain"
doAssert m.getExt("INVALID/NONEXISTENT") == "txt"
doAssert m.getMimetype("") == "text/plain"
doAssert m.getExt("") == "txt"
## Register new Mimetypes.
m.register(ext = "fakext", mimetype = "text/fakelang")
doAssert m.getMimetype("fakext") == "text/fakelang"
doAssert m.getMimetype("FaKeXT") == "text/fakelang"

Imports

tables, strutils

Types

MimeDB = object

	Source   Edit   

Consts

mimes = [("ez", "application/andrew-inset"), ("aw", "application/applixware"),
     	("atom", "application/atom+xml"),
     	("atomcat", "application/atomcat+xml"),
     	("atomsvc", "application/atomsvc+xml"),
     	("ccxml", "application/ccxml+xml"),
     	("cdmia", "application/cdmi-capability"),
     	("cdmic", "application/cdmi-container"),
     	("cdmid", "application/cdmi-domain"),
     	("cdmio", "application/cdmi-object"),
     	("cdmiq", "application/cdmi-queue"), ("cu", "application/cu-seeme"),
     	("davmount", "application/davmount+xml"),
     	("dbk", "application/docbook+xml"), ("dssc", "application/dssc+der"),
     	("xdssc", "application/dssc+xml"), ("ecma", "application/ecmascript"),
     	("emma", "application/emma+xml"), ("epub", "application/epub+zip"),
     	("exi", "application/exi"), ("pfr", "application/font-tdpfr"),
     	("gml", "application/gml+xml"), ("gpx", "application/gpx+xml"),
     	("gxf", "application/gxf"), ("stk", "application/hyperstudio"),
     	("ink", "application/inkml+xml"), ("inkml", "application/inkml+xml"),
     	("ipfix", "application/ipfix"), ("jar", "application/java-archive"),
     	("ser", "application/java-serialized-object"),
     	("class", "application/java-vm"), ("json", "application/json"),
     	("jsonml", "application/jsonml+json"),
     	("lostxml", "application/lost+xml"),
     	("hqx", "application/mac-binhex40"),
     	("cpt", "application/mac-compactpro"),
     	("mads", "application/mads+xml"), ("mrc", "application/marc"),
     	("mrcx", "application/marcxml+xml"),
     	("ma", "application/mathematica"), ("nb", "application/mathematica"),
     	("mb", "application/mathematica"),
     	("mathml", "application/mathml+xml"), ("mbox", "application/mbox"),
     	("mscml", "application/mediaservercontrol+xml"),
     	("metalink", "application/metalink+xml"),
     	("meta4", "application/metalink4+xml"),
     	("mets", "application/mets+xml"), ("mods", "application/mods+xml"),
     	("m21", "application/mp21"), ("mp21", "application/mp21"),
     	("mp4s", "application/mp4"), ("doc", "application/msword"),
     	("dot", "application/msword"), ("mxf", "application/mxf"),
     	("bin", "application/octet-stream"),
     	("dms", "application/octet-stream"),
     	("lrf", "application/octet-stream"),
     	("mar", "application/octet-stream"),
     	("so", "application/octet-stream"),
     	("dist", "application/octet-stream"),
     	("distz", "application/octet-stream"),
     	("pkg", "application/octet-stream"),
     	("bpk", "application/octet-stream"),
     	("dump", "application/octet-stream"),
     	("elc", "application/octet-stream"),
     	("deploy", "application/octet-stream"), ("oda", "application/oda"),
     	("opf", "application/oebps-package+xml"), ("ogx", "application/ogg"),
     	("omdoc", "application/omdoc+xml"), ("onetoc", "application/onenote"),
     	("onetoc2", "application/onenote"), ("onetmp", "application/onenote"),
     	("onepkg", "application/onenote"), ("oxps", "application/oxps"),
     	("xer", "application/patch-ops-error+xml"),
     	("pdf", "application/pdf"), ("pgp", "application/pgp-encrypted"),
     	("asc", "application/pgp-signature"),
     	("sig", "application/pgp-signature"),
     	("prf", "application/pics-rules"), ("p10", "application/pkcs10"),
     	("p7m", "application/pkcs7-mime"), ("p7c", "application/pkcs7-mime"),
     	("p7s", "application/pkcs7-signature"), ("p8", "application/pkcs8"),
     	("ac", "application/pkix-attr-cert"),
     	("cer", "application/pkix-cert"), ("crl", "application/pkix-crl"),
     	("pkipath", "application/pkix-pkipath"),
     	("pki", "application/pkixcmp"), ("pls", "application/pls+xml"),
     	("ai", "application/postscript"), ("eps", "application/postscript"),
     	("ps", "application/postscript"), ("cww", "application/prs.cww"),
     	("pskcxml", "application/pskc+xml"), ("rdf", "application/rdf+xml"),
     	("rif", "application/reginfo+xml"),
     	("rnc", "application/relax-ng-compact-syntax"),
     	("rl", "application/resource-lists+xml"),
     	("rld", "application/resource-lists-diff+xml"),
     	("rs", "application/rls-services+xml"),
     	("gbr", "application/rpki-ghostbusters"),
     	("mft", "application/rpki-manifest"), ("roa", "application/rpki-roa"),
     	("rsd", "application/rsd+xml"), ("rss", "application/rss+xml"),
     	("rtf", "application/rtf"), ("sbml", "application/sbml+xml"),
     	("scq", "application/scvp-cv-request"),
     	("scs", "application/scvp-cv-response"),
     	("spq", "application/scvp-vp-request"),
     	("spp", "application/scvp-vp-response"), ("sdp", "application/sdp"),
     	("setpay", "application/set-payment-initiation"),
     	("setreg", "application/set-registration-initiation"),
     	("shf", "application/shf+xml"), ("smi", "application/smil+xml"),
     	("smil", "application/smil+xml"), ("rq", "application/sparql-query"),
     	("srx", "application/sparql-results+xml"),
     	("gram", "application/srgs"), ("grxml", "application/srgs+xml"),
     	("sru", "application/sru+xml"), ("ssdl", "application/ssdl+xml"),
     	("ssml", "application/ssml+xml"), ("tei", "application/tei+xml"),
     	("teicorpus", "application/tei+xml"),
     	("tfi", "application/thraud+xml"),
     	("tsd", "application/timestamped-data"),
     	("plb", "application/vnd.3gpp.pic-bw-large"),
     	("psb", "application/vnd.3gpp.pic-bw-small"),
     	("pvb", "application/vnd.3gpp.pic-bw-var"),
     	("tcap", "application/vnd.3gpp2.tcap"),
     	("pwn", "application/vnd.3m.post-it-notes"),
     	("aso", "application/vnd.accpac.simply.aso"),
     	("imp", "application/vnd.accpac.simply.imp"),
     	("acu", "application/vnd.acucobol"),
     	("atc", "application/vnd.acucorp"),
     	("acutc", "application/vnd.acucorp"), ("air",
	"application/vnd.adobe.air-application-installer-package+zip"),
     	("fcdt", "application/vnd.adobe.formscentral.fcdt"),
     	("fxp", "application/vnd.adobe.fxp"),
     	("fxpl", "application/vnd.adobe.fxp"),
     	("xdp", "application/vnd.adobe.xdp+xml"),
     	("xfdf", "application/vnd.adobe.xfdf"),
     	("ahead", "application/vnd.ahead.space"),
     	("azf", "application/vnd.airzip.filesecure.azf"),
     	("azs", "application/vnd.airzip.filesecure.azs"),
     	("azw", "application/vnd.amazon.ebook"),
     	("acc", "application/vnd.americandynamics.acc"),
     	("ami", "application/vnd.amiga.ami"),
     	("apk", "application/vnd.android.package-archive"),
     	("cii", "application/vnd.anser-web-certificate-issue-initiation"),
     	("fti", "application/vnd.anser-web-funds-transfer-initiation"),
     	("atx", "application/vnd.antix.game-component"),
     	("mpkg", "application/vnd.apple.installer+xml"),
     	("m3u8", "application/vnd.apple.mpegurl"),
     	("swi", "application/vnd.aristanetworks.swi"),
     	("iota", "application/vnd.astraea-software.iota"),
     	("aep", "application/vnd.audiograph"),
     	("mpm", "application/vnd.blueice.multipass"),
     	("bmi", "application/vnd.bmi"),
     	("rep", "application/vnd.businessobjects"),
     	("cdxml", "application/vnd.chemdraw+xml"),
     	("mmd", "application/vnd.chipnuts.karaoke-mmd"),
     	("cdy", "application/vnd.cinderella"),
     	("cla", "application/vnd.claymore"),
     	("rp9", "application/vnd.cloanto.rp9"),
     	("c4g", "application/vnd.clonk.c4group"),
     	("c4d", "application/vnd.clonk.c4group"),
     	("c4f", "application/vnd.clonk.c4group"),
     	("c4p", "application/vnd.clonk.c4group"),
     	("c4u", "application/vnd.clonk.c4group"),
     	("c11amc", "application/vnd.cluetrust.cartomobile-config"),
     	("c11amz", "application/vnd.cluetrust.cartomobile-config-pkg"),
     	("csp", "application/vnd.commonspace"),
     	("cdbcmsg", "application/vnd.contact.cmsg"),
     	("cmc", "application/vnd.cosmocaller"),
     	("clkx", "application/vnd.crick.clicker"),
     	("clkk", "application/vnd.crick.clicker.keyboard"),
     	("clkp", "application/vnd.crick.clicker.palette"),
     	("clkt", "application/vnd.crick.clicker.template"),
     	("clkw", "application/vnd.crick.clicker.wordbank"),
     	("wbs", "application/vnd.criticaltools.wbs+xml"),
     	("pml", "application/vnd.ctc-posml"),
     	("ppd", "application/vnd.cups-ppd"),
     	("car", "application/vnd.curl.car"),
     	("pcurl", "application/vnd.curl.pcurl"),
     	("dart", "application/vnd.dart"),
     	("rdz", "application/vnd.data-vision.rdz"),
     	("uvf", "application/vnd.dece.data"),
     	("uvvf", "application/vnd.dece.data"),
     	("uvd", "application/vnd.dece.data"),
     	("uvvd", "application/vnd.dece.data"),
     	("uvt", "application/vnd.dece.ttml+xml"),
     	("uvvt", "application/vnd.dece.ttml+xml"),
     	("uvx", "application/vnd.dece.unspecified"),
     	("uvvx", "application/vnd.dece.unspecified"),
     	("uvz", "application/vnd.dece.zip"),
     	("uvvz", "application/vnd.dece.zip"),
     	("fe_launch", "application/vnd.denovo.fcselayout-link"),
     	("dna", "application/vnd.dna"), ("mlp", "application/vnd.dolby.mlp"),
     	("dpg", "application/vnd.dpgraph"),
     	("dfac", "application/vnd.dreamfactory"),
     	("kpxx", "application/vnd.ds-keypoint"),
     	("ait", "application/vnd.dvb.ait"),
     	("svc", "application/vnd.dvb.service"),
     	("geo", "application/vnd.dynageo"),
     	("mag", "application/vnd.ecowin.chart"),
     	("nml", "application/vnd.enliven"),
     	("esf", "application/vnd.epson.esf"),
     	("msf", "application/vnd.epson.msf"),
     	("qam", "application/vnd.epson.quickanime"),
     	("slt", "application/vnd.epson.salt"),
     	("ssf", "application/vnd.epson.ssf"),
     	("es3", "application/vnd.eszigno3+xml"),
     	("et3", "application/vnd.eszigno3+xml"),
     	("ez2", "application/vnd.ezpix-album"),
     	("ez3", "application/vnd.ezpix-package"),
     	("fdf", "application/vnd.fdf"),
     	("mseed", "application/vnd.fdsn.mseed"),
     	("seed", "application/vnd.fdsn.seed"),
     	("dataless", "application/vnd.fdsn.seed"),
     	("gph", "application/vnd.flographit"),
     	("ftc", "application/vnd.fluxtime.clip"),
     	("fm", "application/vnd.framemaker"),
     	("frame", "application/vnd.framemaker"),
     	("maker", "application/vnd.framemaker"),
     	("book", "application/vnd.framemaker"),
     	("fnc", "application/vnd.frogans.fnc"),
     	("ltf", "application/vnd.frogans.ltf"),
     	("fsc", "application/vnd.fsc.weblaunch"),
     	("oas", "application/vnd.fujitsu.oasys"),
     	("oa2", "application/vnd.fujitsu.oasys2"),
     	("oa3", "application/vnd.fujitsu.oasys3"),
     	("fg5", "application/vnd.fujitsu.oasysgp"),
     	("bh2", "application/vnd.fujitsu.oasysprs"),
     	("ddd", "application/vnd.fujixerox.ddd"),
     	("xdw", "application/vnd.fujixerox.docuworks"),
     	("xbd", "application/vnd.fujixerox.docuworks.binder"),
     	("fzs", "application/vnd.fuzzysheet"),
     	("txd", "application/vnd.genomatix.tuxedo"),
     	("ggb", "application/vnd.geogebra.file"),
     	("ggs", "application/vnd.geogebra.slides"),
     	("ggt", "application/vnd.geogebra.tool"),
     	("gex", "application/vnd.geometry-explorer"),
     	("gre", "application/vnd.geometry-explorer"),
     	("gxt", "application/vnd.geonext"),
     	("g2w", "application/vnd.geoplan"),
     	("g3w", "application/vnd.geospace"), ("gmx", "application/vnd.gmx"),
     	("kml", "application/vnd.google-earth.kml+xml"),
     	("kmz", "application/vnd.google-earth.kmz"),
     	("gqf", "application/vnd.grafeq"), ("gqs", "application/vnd.grafeq"),
     	("gac", "application/vnd.groove-account"),
     	("ghf", "application/vnd.groove-help"),
     	("gim", "application/vnd.groove-identity-message"),
     	("grv", "application/vnd.groove-injector"),
     	("gtm", "application/vnd.groove-tool-message"),
     	("tpl", "application/vnd.groove-tool-template"),
     	("vcg", "application/vnd.groove-vcard"),
     	("hal", "application/vnd.hal+xml"),
     	("zmm", "application/vnd.handheld-entertainment+xml"),
     	("hbci", "application/vnd.hbci"),
     	("les", "application/vnd.hhe.lesson-player"),
     	("hpgl", "application/vnd.hp-hpgl"),
     	("hpid", "application/vnd.hp-hpid"),
     	("hps", "application/vnd.hp-hps"), ("jlt", "application/vnd.hp-jlyt"),
     	("pcl", "application/vnd.hp-pcl"),
     	("pclxl", "application/vnd.hp-pclxl"),
     	("sfd-hdstx", "application/vnd.hydrostatix.sof-data"),
     	("mpy", "application/vnd.ibm.minipay"),
     	("afp", "application/vnd.ibm.modcap"),
     	("listafp", "application/vnd.ibm.modcap"),
     	("list3820", "application/vnd.ibm.modcap"),
     	("irm", "application/vnd.ibm.rights-management"),
     	("sc", "application/vnd.ibm.secure-container"),
     	("icc", "application/vnd.iccprofile"),
     	("icm", "application/vnd.iccprofile"),
     	("igl", "application/vnd.igloader"),
     	("ivp", "application/vnd.immervision-ivp"),
     	("ivu", "application/vnd.immervision-ivu"),
     	("igm", "application/vnd.insors.igm"),
     	("xpw", "application/vnd.intercon.formnet"),
     	("xpx", "application/vnd.intercon.formnet"),
     	("i2g", "application/vnd.intergeo"),
     	("qbo", "application/vnd.intu.qbo"),
     	("qfx", "application/vnd.intu.qfx"),
     	("rcprofile", "application/vnd.ipunplugged.rcprofile"),
     	("irp", "application/vnd.irepository.package+xml"),
     	("xpr", "application/vnd.is-xpr"),
     	("fcs", "application/vnd.isac.fcs"), ("jam", "application/vnd.jam"),
     	("rms", "application/vnd.jcp.javame.midlet-rms"),
     	("jisp", "application/vnd.jisp"),
     	("joda", "application/vnd.joost.joda-archive"),
     	("ktz", "application/vnd.kahootz"),
     	("ktr", "application/vnd.kahootz"),
     	("karbon", "application/vnd.kde.karbon"),
     	("chrt", "application/vnd.kde.kchart"),
     	("kfo", "application/vnd.kde.kformula"),
     	("flw", "application/vnd.kde.kivio"),
     	("kon", "application/vnd.kde.kontour"),
     	("kpr", "application/vnd.kde.kpresenter"),
     	("kpt", "application/vnd.kde.kpresenter"),
     	("ksp", "application/vnd.kde.kspread"),
     	("kwd", "application/vnd.kde.kword"),
     	("kwt", "application/vnd.kde.kword"),
     	("htke", "application/vnd.kenameaapp"),
     	("kia", "application/vnd.kidspiration"),
     	("kne", "application/vnd.kinar"), ("knp", "application/vnd.kinar"),
     	("skp", "application/vnd.koan"), ("skd", "application/vnd.koan"),
     	("skt", "application/vnd.koan"), ("skm", "application/vnd.koan"),
     	("sse", "application/vnd.kodak-descriptor"),
     	("lasxml", "application/vnd.las.las+xml"),
     	("lbd", "application/vnd.llamagraphics.life-balance.desktop"),
     	("lbe", "application/vnd.llamagraphics.life-balance.exchange+xml"),
     	("123", "application/vnd.lotus-1-2-3"),
     	("apr", "application/vnd.lotus-approach"),
     	("pre", "application/vnd.lotus-freelance"),
     	("nsf", "application/vnd.lotus-notes"),
     	("org", "application/vnd.lotus-organizer"),
     	("scm", "application/vnd.lotus-screencam"),
     	("lwp", "application/vnd.lotus-wordpro"),
     	("portpkg", "application/vnd.macports.portpkg"),
     	("mcd", "application/vnd.mcd"),
     	("mc1", "application/vnd.medcalcdata"),
     	("cdkey", "application/vnd.mediastation.cdkey"),
     	("mwf", "application/vnd.mfer"), ("mfm", "application/vnd.mfmp"),
     	("flo", "application/vnd.micrografx.flo"),
     	("igx", "application/vnd.micrografx.igx"),
     	("mif", "application/vnd.mif"), ("daf", "application/vnd.mobius.daf"),
     	("dis", "application/vnd.mobius.dis"),
     	("mbk", "application/vnd.mobius.mbk"),
     	("mqy", "application/vnd.mobius.mqy"),
     	("msl", "application/vnd.mobius.msl"),
     	("plc", "application/vnd.mobius.plc"),
     	("txf", "application/vnd.mobius.txf"),
     	("mpn", "application/vnd.mophun.application"),
     	("mpc", "application/vnd.mophun.certificate"),
     	("xul", "application/vnd.mozilla.xul+xml"),
     	("cil", "application/vnd.ms-artgalry"),
     	("cab", "application/vnd.ms-cab-compressed"),
     	("xls", "application/vnd.ms-excel"),
     	("xlm", "application/vnd.ms-excel"),
     	("xla", "application/vnd.ms-excel"),
     	("xlc", "application/vnd.ms-excel"),
     	("xlt", "application/vnd.ms-excel"),
     	("xlw", "application/vnd.ms-excel"),
     	("xlam", "application/vnd.ms-excel.addin.macroenabled.12"),
     	("xlsb", "application/vnd.ms-excel.sheet.binary.macroenabled.12"),
     	("xlsm", "application/vnd.ms-excel.sheet.macroenabled.12"),
     	("xltm", "application/vnd.ms-excel.template.macroenabled.12"),
     	("eot", "application/vnd.ms-fontobject"),
     	("chm", "application/vnd.ms-htmlhelp"),
     	("ims", "application/vnd.ms-ims"), ("lrm", "application/vnd.ms-lrm"),
     	("thmx", "application/vnd.ms-officetheme"),
     	("cat", "application/vnd.ms-pki.seccat"),
     	("stl", "application/vnd.ms-pki.stl"),
     	("ppt", "application/vnd.ms-powerpoint"),
     	("pps", "application/vnd.ms-powerpoint"),
     	("pot", "application/vnd.ms-powerpoint"),
     	("ppam", "application/vnd.ms-powerpoint.addin.macroenabled.12"), (
	"pptm", "application/vnd.ms-powerpoint.presentation.macroenabled.12"),
     	("sldm", "application/vnd.ms-powerpoint.slide.macroenabled.12"),
     	("ppsm", "application/vnd.ms-powerpoint.slideshow.macroenabled.12"),
     	("potm", "application/vnd.ms-powerpoint.template.macroenabled.12"),
     	("mpp", "application/vnd.ms-project"),
     	("mpt", "application/vnd.ms-project"),
     	("docm", "application/vnd.ms-word.document.macroenabled.12"),
     	("dotm", "application/vnd.ms-word.template.macroenabled.12"),
     	("wps", "application/vnd.ms-works"),
     	("wks", "application/vnd.ms-works"),
     	("wcm", "application/vnd.ms-works"),
     	("wdb", "application/vnd.ms-works"),
     	("wpl", "application/vnd.ms-wpl"),
     	("xps", "application/vnd.ms-xpsdocument"),
     	("mseq", "application/vnd.mseq"), ("mus", "application/vnd.musician"),
     	("msty", "application/vnd.muvee.style"),
     	("taglet", "application/vnd.mynfc"),
     	("nlu", "application/vnd.neurolanguage.nlu"), ("nim", "text/nim"),
     	("nimble", "text/nimble"), ("nimf", "text/nim"), ("nims", "text/nim"),
     	("ntf", "application/vnd.nitf"), ("nitf", "application/vnd.nitf"),
     	("nnd", "application/vnd.noblenet-directory"),
     	("nns", "application/vnd.noblenet-sealer"),
     	("nnw", "application/vnd.noblenet-web"),
     	("ngdat", "application/vnd.nokia.n-gage.data"),
     	("n-gage", "application/vnd.nokia.n-gage.symbian.install"),
     	("rpst", "application/vnd.nokia.radio-preset"),
     	("rpss", "application/vnd.nokia.radio-presets"),
     	("edm", "application/vnd.novadigm.edm"),
     	("edx", "application/vnd.novadigm.edx"),
     	("ext", "application/vnd.novadigm.ext"),
     	("odc", "application/vnd.oasis.opendocument.chart"),
     	("otc", "application/vnd.oasis.opendocument.chart-template"),
     	("odb", "application/vnd.oasis.opendocument.database"),
     	("odf", "application/vnd.oasis.opendocument.formula"),
     	("odft", "application/vnd.oasis.opendocument.formula-template"),
     	("odg", "application/vnd.oasis.opendocument.graphics"),
     	("otg", "application/vnd.oasis.opendocument.graphics-template"),
     	("odi", "application/vnd.oasis.opendocument.image"),
     	("oti", "application/vnd.oasis.opendocument.image-template"),
     	("odp", "application/vnd.oasis.opendocument.presentation"),
     	("otp", "application/vnd.oasis.opendocument.presentation-template"),
     	("ods", "application/vnd.oasis.opendocument.spreadsheet"),
     	("ots", "application/vnd.oasis.opendocument.spreadsheet-template"),
     	("odt", "application/vnd.oasis.opendocument.text"),
     	("odm", "application/vnd.oasis.opendocument.text-master"),
     	("ott", "application/vnd.oasis.opendocument.text-template"),
     	("oth", "application/vnd.oasis.opendocument.text-web"),
     	("xo", "application/vnd.olpc-sugar"),
     	("dd2", "application/vnd.oma.dd2+xml"),
     	("oxt", "application/vnd.openofficeorg.extension"), ("pptx",
	"application/vnd.openxmlformats-officedocument.presentationml.presentation"), (
	"sldx", "application/vnd.openxmlformats-officedocument.presentationml.slide"), (
	"ppsx",
	"application/vnd.openxmlformats-officedocument.presentationml.slideshow"), (
	"potx",
	"application/vnd.openxmlformats-officedocument.presentationml.template"), (
	"xlsx", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"), (
	"xltx",
	"application/vnd.openxmlformats-officedocument.spreadsheetml.template"), (
	"docx",
	"application/vnd.openxmlformats-officedocument.wordprocessingml.document"), (
	"dotx",
	"application/vnd.openxmlformats-officedocument.wordprocessingml.template"),
     	("mgp", "application/vnd.osgeo.mapguide.package"),
     	("dp", "application/vnd.osgi.dp"),
     	("esa", "application/vnd.osgi.subsystem"),
     	("pdb", "application/vnd.palm"), ("pqa", "application/vnd.palm"),
     	("oprc", "application/vnd.palm"),
     	("paw", "application/vnd.pawaafile"),
     	("str", "application/vnd.pg.format"),
     	("ei6", "application/vnd.pg.osasli"),
     	("efif", "application/vnd.picsel"),
     	("wg", "application/vnd.pmi.widget"),
     	("plf", "application/vnd.pocketlearn"),
     	("pbd", "application/vnd.powerbuilder6"),
     	("box", "application/vnd.previewsystems.box"),
     	("mgz", "application/vnd.proteus.magazine"),
     	("qps", "application/vnd.publishare-delta-tree"),
     	("ptid", "application/vnd.pvi.ptid1"),
     	("qxd", "application/vnd.quark.quarkxpress"),
     	("qxt", "application/vnd.quark.quarkxpress"),
     	("qwd", "application/vnd.quark.quarkxpress"),
     	("qwt", "application/vnd.quark.quarkxpress"),
     	("qxl", "application/vnd.quark.quarkxpress"),
     	("qxb", "application/vnd.quark.quarkxpress"),
     	("bed", "application/vnd.realvnc.bed"),
     	("mxl", "application/vnd.recordare.musicxml"),
     	("musicxml", "application/vnd.recordare.musicxml+xml"),
     	("cryptonote", "application/vnd.rig.cryptonote"),
     	("cod", "application/vnd.rim.cod"),
     	("rm", "application/vnd.rn-realmedia"),
     	("rmvb", "application/vnd.rn-realmedia-vbr"),
     	("link66", "application/vnd.route66.link66+xml"),
     	("st", "application/vnd.sailingtracker.track"),
     	("see", "application/vnd.seemail"), ("sema", "application/vnd.sema"),
     	("semd", "application/vnd.semd"), ("semf", "application/vnd.semf"),
     	("ifm", "application/vnd.shana.informed.formdata"),
     	("itp", "application/vnd.shana.informed.formtemplate"),
     	("iif", "application/vnd.shana.informed.interchange"),
     	("ipk", "application/vnd.shana.informed.package"),
     	("twd", "application/vnd.simtech-mindmapper"),
     	("twds", "application/vnd.simtech-mindmapper"),
     	("mmf", "application/vnd.smaf"),
     	("teacher", "application/vnd.smart.teacher"),
     	("sdkm", "application/vnd.solent.sdkm+xml"),
     	("sdkd", "application/vnd.solent.sdkm+xml"),
     	("dxp", "application/vnd.spotfire.dxp"),
     	("sfs", "application/vnd.spotfire.sfs"),
     	("sdc", "application/vnd.stardivision.calc"),
     	("sda", "application/vnd.stardivision.draw"),
     	("sdd", "application/vnd.stardivision.impress"),
     	("smf", "application/vnd.stardivision.math"),
     	("sdw", "application/vnd.stardivision.writer"),
     	("vor", "application/vnd.stardivision.writer"),
     	("sgl", "application/vnd.stardivision.writer-global"),
     	("smzip", "application/vnd.stepmania.package"),
     	("sm", "application/vnd.stepmania.stepchart"),
     	("sxc", "application/vnd.sun.xml.calc"),
     	("stc", "application/vnd.sun.xml.calc.template"),
     	("sxd", "application/vnd.sun.xml.draw"),
     	("std", "application/vnd.sun.xml.draw.template"),
     	("sxi", "application/vnd.sun.xml.impress"),
     	("sti", "application/vnd.sun.xml.impress.template"),
     	("sxm", "application/vnd.sun.xml.math"),
     	("sxw", "application/vnd.sun.xml.writer"),
     	("sxg", "application/vnd.sun.xml.writer.global"),
     	("stw", "application/vnd.sun.xml.writer.template"),
     	("sus", "application/vnd.sus-calendar"),
     	("susp", "application/vnd.sus-calendar"),
     	("svd", "application/vnd.svd"),
     	("sis", "application/vnd.symbian.install"),
     	("sisx", "application/vnd.symbian.install"),
     	("xsm", "application/vnd.syncml+xml"),
     	("bdm", "application/vnd.syncml.dm+wbxml"),
     	("xdm", "application/vnd.syncml.dm+xml"),
     	("tao", "application/vnd.tao.intent-module-archive"),
     	("pcap", "application/vnd.tcpdump.pcap"),
     	("cap", "application/vnd.tcpdump.pcap"),
     	("dmp", "application/vnd.tcpdump.pcap"),
     	("tmo", "application/vnd.tmobile-livetv"),
     	("tpt", "application/vnd.trid.tpt"),
     	("mxs", "application/vnd.triscape.mxs"),
     	("tra", "application/vnd.trueapp"), ("ufd", "application/vnd.ufdl"),
     	("ufdl", "application/vnd.ufdl"),
     	("utz", "application/vnd.uiq.theme"),
     	("umj", "application/vnd.umajin"),
     	("unityweb", "application/vnd.unity"),
     	("uoml", "application/vnd.uoml+xml"), ("vcx", "application/vnd.vcx"),
     	("vsd", "application/vnd.visio"), ("vst", "application/vnd.visio"),
     	("vss", "application/vnd.visio"), ("vsw", "application/vnd.visio"),
     	("vis", "application/vnd.visionary"), ("vsf", "application/vnd.vsf"),
     	("wbxml", "application/vnd.wap.wbxml"),
     	("wmlc", "application/vnd.wap.wmlc"),
     	("wmlsc", "application/vnd.wap.wmlscriptc"),
     	("wtb", "application/vnd.webturbo"),
     	("nbp", "application/vnd.wolfram.player"),
     	("wpd", "application/vnd.wordperfect"),
     	("wqd", "application/vnd.wqd"), ("stf", "application/vnd.wt.stf"),
     	("xar", "application/vnd.xara"), ("xfdl", "application/vnd.xfdl"),
     	("hvd", "application/vnd.yamaha.hv-dic"),
     	("hvs", "application/vnd.yamaha.hv-script"),
     	("hvp", "application/vnd.yamaha.hv-voice"),
     	("osf", "application/vnd.yamaha.openscoreformat"),
     	("osfpvg", "application/vnd.yamaha.openscoreformat.osfpvg+xml"),
     	("saf", "application/vnd.yamaha.smaf-audio"),
     	("spf", "application/vnd.yamaha.smaf-phrase"),
     	("cmp", "application/vnd.yellowriver-custom-menu"),
     	("zir", "application/vnd.zul"), ("zirz", "application/vnd.zul"),
     	("zaz", "application/vnd.zzazz.deck+xml"),
     	("vxml", "application/voicexml+xml"), ("wasm", "application/wasm"),
     	("wgt", "application/widget"), ("hlp", "application/winhlp"),
     	("wsdl", "application/wsdl+xml"),
     	("wspolicy", "application/wspolicy+xml"),
     	("7z", "application/x-7z-compressed"),
     	("abw", "application/x-abiword"),
     	("ace", "application/x-ace-compressed"),
     	("dmg", "application/x-apple-diskimage"),
     	("aab", "application/x-authorware-bin"),
     	("x32", "application/x-authorware-bin"),
     	("u32", "application/x-authorware-bin"),
     	("vox", "application/x-authorware-bin"),
     	("aam", "application/x-authorware-map"),
     	("aas", "application/x-authorware-seg"),
     	("bcpio", "application/x-bcpio"),
     	("torrent", "application/x-bittorrent"),
     	("blb", "application/x-blorb"), ("blorb", "application/x-blorb"),
     	("bz", "application/x-bzip"), ("bz2", "application/x-bzip2"),
     	("boz", "application/x-bzip2"), ("cbr", "application/x-cbr"),
     	("cba", "application/x-cbr"), ("cbt", "application/x-cbr"),
     	("cbz", "application/x-cbr"), ("cb7", "application/x-cbr"),
     	("vcd", "application/x-cdlink"),
     	("cfs", "application/x-cfs-compressed"),
     	("chat", "application/x-chat"), ("pgn", "application/x-chess-pgn"),
     	("nsc", "application/x-conference"), ("cpio", "application/x-cpio"),
     	("csh", "application/x-csh"), ("deb", "application/x-debian-package"),
     	("udeb", "application/x-debian-package"),
     	("dgc", "application/x-dgc-compressed"),
     	("dir", "application/x-director"), ("dcr", "application/x-director"),
     	("dxr", "application/x-director"), ("cst", "application/x-director"),
     	("cct", "application/x-director"), ("cxt", "application/x-director"),
     	("w3d", "application/x-director"), ("fgd", "application/x-director"),
     	("swa", "application/x-director"), ("wad", "application/x-doom"),
     	("ncx", "application/x-dtbncx+xml"),
     	("dtb", "application/x-dtbook+xml"),
     	("res", "application/x-dtbresource+xml"),
     	("dvi", "application/x-dvi"), ("evy", "application/x-envoy"),
     	("eva", "application/x-eva"), ("bdf", "application/x-font-bdf"),
     	("gsf", "application/x-font-ghostscript"),
     	("psf", "application/x-font-linux-psf"),
     	("pcf", "application/x-font-pcf"), ("snf", "application/x-font-snf"),
     	("pfa", "application/x-font-type1"),
     	("pfb", "application/x-font-type1"),
     	("pfm", "application/x-font-type1"),
     	("afm", "application/x-font-type1"), ("arc", "application/x-freearc"),
     	("spl", "application/x-futuresplash"),
     	("gca", "application/x-gca-compressed"),
     	("ulx", "application/x-glulx"),
     	("gnumeric", "application/x-gnumeric"),
     	("gramps", "application/x-gramps-xml"),
     	("gtar", "application/x-gtar"), ("hdf", "application/x-hdf"),
     	("install", "application/x-install-instructions"),
     	("iso", "application/x-iso9660-image"),
     	("jnlp", "application/x-java-jnlp-file"),
     	("latex", "application/x-latex"),
     	("lzh", "application/x-lzh-compressed"),
     	("lha", "application/x-lzh-compressed"), ("mie", "application/x-mie"),
     	("prc", "application/x-mobipocket-ebook"),
     	("mobi", "application/x-mobipocket-ebook"),
     	("application", "application/x-ms-application"),
     	("lnk", "application/x-ms-shortcut"), ("wmd", "application/x-ms-wmd"),
     	("wmz", "application/x-ms-wmz"), ("xbap", "application/x-ms-xbap"),
     	("mdb", "application/x-msaccess"), ("obd", "application/x-msbinder"),
     	("crd", "application/x-mscardfile"), ("clp", "application/x-msclip"),
     	("exe", "application/x-msdownload"),
     	("dll", "application/x-msdownload"),
     	("com", "application/x-msdownload"),
     	("bat", "application/x-msdownload"),
     	("msi", "application/x-msdownload"),
     	("mvb", "application/x-msmediaview"),
     	("m13", "application/x-msmediaview"),
     	("m14", "application/x-msmediaview"),
     	("wmf", "application/x-msmetafile"),
     	("wmz", "application/x-msmetafile"),
     	("emf", "application/x-msmetafile"),
     	("emz", "application/x-msmetafile"), ("mny", "application/x-msmoney"),
     	("pub", "application/x-mspublisher"),
     	("scd", "application/x-msschedule"),
     	("trm", "application/x-msterminal"), ("wri", "application/x-mswrite"),
     	("nc", "application/x-netcdf"), ("cdf", "application/x-netcdf"),
     	("nzb", "application/x-nzb"), ("p12", "application/x-pkcs12"),
     	("pfx", "application/x-pkcs12"),
     	("p7b", "application/x-pkcs7-certificates"),
     	("spc", "application/x-pkcs7-certificates"),
     	("p7r", "application/x-pkcs7-certreqresp"),
     	("rar", "application/x-rar-compressed"),
     	("ris", "application/x-research-info-systems"),
     	("sh", "application/x-sh"), ("shar", "application/x-shar"),
     	("swf", "application/x-shockwave-flash"),
     	("xap", "application/x-silverlight-app"),
     	("sql", "application/x-sql"), ("sit", "application/x-stuffit"),
     	("sitx", "application/x-stuffitx"), ("srt", "application/x-subrip"),
     	("sv4cpio", "application/x-sv4cpio"),
     	("sv4crc", "application/x-sv4crc"),
     	("t3", "application/x-t3vm-image"), ("gam", "application/x-tads"),
     	("tar", "application/x-tar"), ("tcl", "application/x-tcl"),
     	("tex", "application/x-tex"), ("tfm", "application/x-tex-tfm"),
     	("texinfo", "application/x-texinfo"),
     	("texi", "application/x-texinfo"), ("obj", "application/x-tgif"),
     	("ustar", "application/x-ustar"),
     	("src", "application/x-wais-source"),
     	("der", "application/x-x509-ca-cert"),
     	("crt", "application/x-x509-ca-cert"), ("fig", "application/x-xfig"),
     	("xlf", "application/x-xliff+xml"),
     	("xpi", "application/x-xpinstall"), ("xz", "application/x-xz"),
     	("z1", "application/x-zmachine"), ("z2", "application/x-zmachine"),
     	("z3", "application/x-zmachine"), ("z4", "application/x-zmachine"),
     	("z5", "application/x-zmachine"), ("z6", "application/x-zmachine"),
     	("z7", "application/x-zmachine"), ("z8", "application/x-zmachine"),
     	("xaml", "application/xaml+xml"),
     	("xdf", "application/xcap-diff+xml"),
     	("xenc", "application/xenc+xml"), ("xhtml", "application/xhtml+xml"),
     	("xht", "application/xhtml+xml"), ("xml", "application/xml"),
     	("xsl", "application/xml"), ("dtd", "application/xml-dtd"),
     	("xop", "application/xop+xml"), ("xpl", "application/xproc+xml"),
     	("xslt", "application/xslt+xml"), ("xspf", "application/xspf+xml"),
     	("mxml", "application/xv+xml"), ("xhvml", "application/xv+xml"),
     	("xvml", "application/xv+xml"), ("xvm", "application/xv+xml"),
     	("yang", "application/yang"), ("yin", "application/yin+xml"),
     	("zip", "application/zip"), ("adp", "audio/adpcm"),
     	("au", "audio/basic"), ("snd", "audio/basic"), ("mid", "audio/midi"),
     	("midi", "audio/midi"), ("kar", "audio/midi"), ("rmi", "audio/midi"),
     	("m4a", "audio/mp4"), ("mp4a", "audio/mp4"), ("mpga", "audio/mpeg"),
     	("mp2", "audio/mpeg"), ("mp2a", "audio/mpeg"), ("mp3", "audio/mpeg"),
     	("m2a", "audio/mpeg"), ("m3a", "audio/mpeg"), ("oga", "audio/ogg"),
     	("ogg", "audio/ogg"), ("spx", "audio/ogg"), ("opus", "audio/ogg"),
     	("s3m", "audio/s3m"), ("sil", "audio/silk"),
     	("uva", "audio/vnd.dece.audio"), ("uvva", "audio/vnd.dece.audio"),
     	("eol", "audio/vnd.digital-winds"), ("dra", "audio/vnd.dra"),
     	("dts", "audio/vnd.dts"), ("dtshd", "audio/vnd.dts.hd"),
     	("lvp", "audio/vnd.lucent.voice"),
     	("pya", "audio/vnd.ms-playready.media.pya"),
     	("ecelp4800", "audio/vnd.nuera.ecelp4800"),
     	("ecelp7470", "audio/vnd.nuera.ecelp7470"),
     	("ecelp9600", "audio/vnd.nuera.ecelp9600"), ("rip", "audio/vnd.rip"),
     	("weba", "audio/webm"), ("aac", "audio/x-aac"),
     	("aif", "audio/x-aiff"), ("aiff", "audio/x-aiff"),
     	("aifc", "audio/x-aiff"), ("caf", "audio/x-caf"),
     	("flac", "audio/x-flac"), ("mka", "audio/x-matroska"),
     	("m3u", "audio/x-mpegurl"), ("wax", "audio/x-ms-wax"),
     	("wma", "audio/x-ms-wma"), ("ram", "audio/x-pn-realaudio"),
     	("ra", "audio/x-pn-realaudio"),
     	("rmp", "audio/x-pn-realaudio-plugin"), ("wav", "audio/x-wav"),
     	("xm", "audio/xm"), ("cdx", "chemical/x-cdx"),
     	("cif", "chemical/x-cif"), ("cmdf", "chemical/x-cmdf"),
     	("cml", "chemical/x-cml"), ("csml", "chemical/x-csml"),
     	("xyz", "chemical/x-xyz"), ("ttc", "font/collection"),
     	("otf", "font/otf"), ("ttf", "font/ttf"), ("woff", "font/woff"),
     	("woff2", "font/woff2"), ("bmp", "image/bmp"), ("cgm", "image/cgm"),
     	("g3", "image/g3fax"), ("gif", "image/gif"), ("ief", "image/ief"),
     	("jpeg", "image/jpeg"), ("jpg", "image/jpeg"), ("jpe", "image/jpeg"),
     	("ktx", "image/ktx"), ("png", "image/png"),
     	("btif", "image/prs.btif"), ("sgi", "image/sgi"),
     	("svg", "image/svg+xml"), ("svgz", "image/svg+xml"),
     	("tiff", "image/tiff"), ("tif", "image/tiff"),
     	("psd", "image/vnd.adobe.photoshop"),
     	("uvi", "image/vnd.dece.graphic"), ("uvvi", "image/vnd.dece.graphic"),
     	("uvg", "image/vnd.dece.graphic"), ("uvvg", "image/vnd.dece.graphic"),
     	("djvu", "image/vnd.djvu"), ("djv", "image/vnd.djvu"),
     	("sub", "image/vnd.dvb.subtitle"), ("dwg", "image/vnd.dwg"),
     	("dxf", "image/vnd.dxf"), ("fbs", "image/vnd.fastbidsheet"),
     	("fpx", "image/vnd.fpx"), ("fst", "image/vnd.fst"),
     	("mmr", "image/vnd.fujixerox.edmics-mmr"),
     	("rlc", "image/vnd.fujixerox.edmics-rlc"),
     	("mdi", "image/vnd.ms-modi"), ("wdp", "image/vnd.ms-photo"),
     	("npx", "image/vnd.net-fpx"), ("wbmp", "image/vnd.wap.wbmp"),
     	("xif", "image/vnd.xiff"), ("webp", "image/webp"),
     	("3ds", "image/x-3ds"), ("ras", "image/x-cmu-raster"),
     	("cmx", "image/x-cmx"), ("fh", "image/x-freehand"),
     	("fhc", "image/x-freehand"), ("fh4", "image/x-freehand"),
     	("fh5", "image/x-freehand"), ("fh7", "image/x-freehand"),
     	("ico", "image/x-icon"), ("sid", "image/x-mrsid-image"),
     	("pcx", "image/x-pcx"), ("pic", "image/x-pict"),
     	("pct", "image/x-pict"), ("pnm", "image/x-portable-anymap"),
     	("pbm", "image/x-portable-bitmap"),
     	("pgm", "image/x-portable-graymap"),
     	("ppm", "image/x-portable-pixmap"), ("rgb", "image/x-rgb"),
     	("tga", "image/x-tga"), ("xbm", "image/x-xbitmap"),
     	("xpm", "image/x-xpixmap"), ("xwd", "image/x-xwindowdump"),
     	("eml", "message/rfc822"), ("mime", "message/rfc822"),
     	("igs", "model/iges"), ("iges", "model/iges"), ("msh", "model/mesh"),
     	("mesh", "model/mesh"), ("silo", "model/mesh"),
     	("dae", "model/vnd.collada+xml"), ("dwf", "model/vnd.dwf"),
     	("gdl", "model/vnd.gdl"), ("gtw", "model/vnd.gtw"),
     	("mts", "model/vnd.mts"), ("vtu", "model/vnd.vtu"),
     	("wrl", "model/vrml"), ("vrml", "model/vrml"),
     	("x3db", "model/x3d+binary"), ("x3dbz", "model/x3d+binary"),
     	("x3dv", "model/x3d+vrml"), ("x3dvz", "model/x3d+vrml"),
     	("x3d", "model/x3d+xml"), ("x3dz", "model/x3d+xml"),
     	("appcache", "text/cache-manifest"), ("ics", "text/calendar"),
     	("ifb", "text/calendar"), ("css", "text/css"), ("csv", "text/csv"),
     	("html", "text/html"), ("htm", "text/html"),
     	("js", "text/javascript"), ("mjs", "text/javascript"),
     	("n3", "text/n3"), ("txt", "text/plain"), ("text", "text/plain"),
     	("conf", "text/plain"), ("def", "text/plain"), ("list", "text/plain"),
     	("log", "text/plain"), ("in", "text/plain"),
     	("dsc", "text/prs.lines.tag"), ("rtx", "text/richtext"),
     	("sgml", "text/sgml"), ("sgm", "text/sgml"),
     	("tsv", "text/tab-separated-values"), ("t", "text/troff"),
     	("tr", "text/troff"), ("roff", "text/troff"), ("man", "text/troff"),
     	("me", "text/troff"), ("ms", "text/troff"), ("ttl", "text/turtle"),
     	("uri", "text/uri-list"), ("uris", "text/uri-list"),
     	("urls", "text/uri-list"), ("vcard", "text/vcard"),
     	("curl", "text/vnd.curl"), ("dcurl", "text/vnd.curl.dcurl"),
     	("mcurl", "text/vnd.curl.mcurl"), ("scurl", "text/vnd.curl.scurl"),
     	("sub", "text/vnd.dvb.subtitle"), ("fly", "text/vnd.fly"),
     	("flx", "text/vnd.fmi.flexstor"), ("gv", "text/vnd.graphviz"),
     	("3dml", "text/vnd.in3d.3dml"), ("spot", "text/vnd.in3d.spot"),
     	("jad", "text/vnd.sun.j2me.app-descriptor"),
     	("wml", "text/vnd.wap.wml"), ("wmls", "text/vnd.wap.wmlscript"),
     	("s", "text/x-asm"), ("asm", "text/x-asm"), ("c", "text/x-c"),
     	("cc", "text/x-c"), ("cxx", "text/x-c"), ("cpp", "text/x-c"),
     	("h", "text/x-c"), ("hh", "text/x-c"), ("dic", "text/x-c"),
     	("f", "text/x-fortran"), ("for", "text/x-fortran"),
     	("f77", "text/x-fortran"), ("f90", "text/x-fortran"),
     	("java", "text/x-java-source"), ("nfo", "text/x-nfo"),
     	("opml", "text/x-opml"), ("p", "text/x-pascal"),
     	("pas", "text/x-pascal"), ("etx", "text/x-setext"),
     	("sfv", "text/x-sfv"), ("uu", "text/x-uuencode"),
     	("vcs", "text/x-vcalendar"), ("vcf", "text/x-vcard"),
     	("3gp", "video/3gpp"), ("3g2", "video/3gpp2"), ("h261", "video/h261"),
     	("h263", "video/h263"), ("h264", "video/h264"),
     	("jpgv", "video/jpeg"), ("jpm", "video/jpm"), ("jpgm", "video/jpm"),
     	("mj2", "video/mj2"), ("mjp2", "video/mj2"), ("mp4", "video/mp4"),
     	("mp4v", "video/mp4"), ("mpg4", "video/mp4"), ("mpeg", "video/mpeg"),
     	("mpg", "video/mpeg"), ("mpe", "video/mpeg"), ("m1v", "video/mpeg"),
     	("m2v", "video/mpeg"), ("ogv", "video/ogg"),
     	("qt", "video/quicktime"), ("mov", "video/quicktime"),
     	("uvh", "video/vnd.dece.hd"), ("uvvh", "video/vnd.dece.hd"),
     	("uvm", "video/vnd.dece.mobile"), ("uvvm", "video/vnd.dece.mobile"),
     	("uvp", "video/vnd.dece.pd"), ("uvvp", "video/vnd.dece.pd"),
     	("uvs", "video/vnd.dece.sd"), ("uvvs", "video/vnd.dece.sd"),
     	("uvv", "video/vnd.dece.video"), ("uvvv", "video/vnd.dece.video"),
     	("dvb", "video/vnd.dvb.file"), ("fvt", "video/vnd.fvt"),
     	("mxu", "video/vnd.mpegurl"), ("m4u", "video/vnd.mpegurl"),
     	("pyv", "video/vnd.ms-playready.media.pyv"),
     	("uvu", "video/vnd.uvvu.mp4"), ("uvvu", "video/vnd.uvvu.mp4"),
     	("viv", "video/vnd.vivo"), ("webm", "video/webm"),
     	("f4v", "video/x-f4v"), ("fli", "video/x-fli"),
     	("flv", "video/x-flv"), ("m4v", "video/x-m4v"),
     	("mkv", "video/x-matroska"), ("mk3d", "video/x-matroska"),
     	("mks", "video/x-matroska"), ("mng", "video/x-mng"),
     	("asf", "video/x-ms-asf"), ("asx", "video/x-ms-asf"),
     	("vob", "video/x-ms-vob"), ("wm", "video/x-ms-wm"),
     	("wmv", "video/x-ms-wmv"), ("wmx", "video/x-ms-wmx"),
     	("wvx", "video/x-ms-wvx"), ("avi", "video/x-msvideo"),
     	("movie", "video/x-sgi-movie"), ("smv", "video/x-smv"),
     	("ice", "x-conference/x-cooltalk")]

	Source   Edit   

Procs

func getExt(mimedb: MimeDB; mimetype: string; default = "txt"): string {.
	....}

	Gets extension which corresponds to mimetype. Returns default if mimetype could not be found. Extensions are returned without the leading dot. mimetype is lowercased before querying mimedb. Source   Edit   

func getMimetype(mimedb: MimeDB; ext: string; default = "text/plain"): string {.
	....}

	Gets mimetype which corresponds to ext. Returns default if ext could not be found. ext can start with an optional dot which is ignored. ext is lowercased before querying mimedb. Source   Edit   

func newMimetypes(): MimeDB {.....}

	Creates a new Mimetypes database. The database will contain the most common mimetypes. Source   Edit   

func register(mimedb: var MimeDB; ext: string; mimetype: string) {.....}

	Adds mimetype to the mimedb. mimetype and ext are lowercased before registering on mimedb. Source   Edit   


std/nativesockets


std/nativesockets
Source   Edit  

This module implements a low-level cross-platform sockets interface. Look at the net module for the higher-level version.
Imports

os, options, since, strbasics, winlean

Types

Domain = enum
  AF_UNSPEC = 0, ## unspecified domain (can be detected automatically by
              	## some procedures, such as getaddrinfo)
  AF_UNIX = 1,          	## for local socket (using a file). Unsupported on Windows.
  AF_INET = 2,          	## for network protocol IPv4 or
  AF_INET6 = 23

	domain, which specifies the protocol family of the created socket. Other domains than those that are listed here are unsupported. Source   Edit   

Hostent = object
  name*: string
  aliases*: seq[string]
  addrtype*: Domain
  length*: int
  addrList*: seq[string]

	information about a given host Source   Edit   

Port = distinct uint16

	port type Source   Edit   

Protocol = enum
  IPPROTO_TCP = 6,      	## Transmission control protocol.
  IPPROTO_UDP = 17,     	## User datagram protocol.
  IPPROTO_IP,           	## Internet protocol.
  IPPROTO_IPV6,         	## Internet Protocol Version 6.
  IPPROTO_RAW,          	## Raw IP Packets Protocol. Unsupported on Windows.
  IPPROTO_ICMP,         	## Internet Control message protocol.
  IPPROTO_ICMPV6         	## Internet Control message protocol for IPv6.

	third argument to socket proc Source   Edit   

Servent = object
  name*: string
  aliases*: seq[string]
  port*: Port
  proto*: string

	information about a service Source   Edit   

SockType = enum
  SOCK_STREAM = 1,      	## reliable stream-oriented service or Stream Sockets
  SOCK_DGRAM = 2,       	## datagram service or Datagram Sockets
  SOCK_RAW = 3,         	## raw protocols atop the network layer.
  SOCK_SEQPACKET = 5     	## reliable sequenced packet service

	second argument to socket proc Source   Edit   

Lets

osInvalidSocket = INVALID_SOCKET

	Source   Edit   

Consts

FIONBIO = -2147195266'i32

	Source   Edit   

IOC_IN = -2147483648

	Source   Edit   

IOCPARM_MASK = 127

	Source   Edit   

Procs

proc `$`(p: Port): string {.borrow, ....}

	Returns the port number as a string Source   Edit   

proc `==`(a, b: Port): bool {.borrow, ....}

	== for ports. Source   Edit   

proc accept(fd: SocketHandle; inheritable = defined(nimInheritHandles)): (
	SocketHandle, string) {.....}

	Accepts a new client connection.

	inheritable decides if the resulting SocketHandle can be inherited by child processes.

	Returns (osInvalidSocket, "") if an error occurred.
	Source   Edit   

proc bindAddr(socket: SocketHandle; name: ptr SockAddr; namelen: SockLen): cint {.
	....}

	Source   Edit   

proc close(socket: SocketHandle) {.....}

	Closes a socket. Source   Edit   

proc createNativeSocket(domain: cint; sockType: cint; protocol: cint;
                    	inheritable: bool = defined(nimInheritHandles)): SocketHandle {.
	....}

	Creates a new socket; returns osInvalidSocket if an error occurs.

	inheritable decides if the resulting SocketHandle can be inherited by child processes.

	Use this overload if one of the enums specified above does not contain what you need.
	Source   Edit   

proc createNativeSocket(domain: Domain = AF_INET;
                    	sockType: SockType = SOCK_STREAM;
                    	protocol: Protocol = IPPROTO_TCP;
                    	inheritable: bool = defined(nimInheritHandles)): SocketHandle {.
	....}

	Creates a new socket; returns osInvalidSocket if an error occurs.

	inheritable decides if the resulting SocketHandle can be inherited by child processes.
	Source   Edit   

proc getAddrInfo(address: string; port: Port; domain: Domain = AF_INET;
             	sockType: SockType = SOCK_STREAM;
             	protocol: Protocol = IPPROTO_TCP): ptr AddrInfo {.
	....}

	Warning: The resulting ptr AddrInfo must be freed using freeAddrInfo!
	Source   Edit   

proc getAddrString(sockAddr: ptr SockAddr): string {.
	....}

	Returns the string representation of address within sockAddr Source   Edit   

proc getAddrString(sockAddr: ptr SockAddr; strAddress: var string) {.
	....}

	Stores in strAddress the string representation of the address inside sockAddr

	Note

    	strAddress must be initialized to 46 in length.

	Source   Edit   

proc getHostByAddr(ip: string): Hostent {.....}

	This function will lookup the hostname of an IP Address. Source   Edit   

proc getHostByName(name: string): Hostent {.....}

	This function will lookup the IP address of a hostname. Source   Edit   

proc getHostname(): string {.....}

	Returns the local hostname (not the FQDN) Source   Edit   

proc getLocalAddr(socket: SocketHandle; domain: Domain): (string, Port) {.
	....}

	Returns the socket's local address and port number.

	Similar to POSIX's getsockname.
	Source   Edit   

proc getPeerAddr(socket: SocketHandle; domain: Domain): (string, Port) {.
	....}

	Returns the socket's peer address and port number.

	Similar to POSIX's getpeername
	Source   Edit   

proc getProtoByName(name: string): int {.....}

	Returns a protocol code from the database that matches the protocol name. Source   Edit   

proc getServByName(name, proto: string): Servent {.....}

	Searches the database from the beginning and finds the first entry for which the service name specified by name matches the s_name member and the protocol name specified by proto matches the s_proto member.

	On posix this will search through the /etc/services file.
	Source   Edit   

proc getServByPort(port: Port; proto: string): Servent {.....}

	Searches the database from the beginning and finds the first entry for which the port specified by port matches the s_port member and the protocol name specified by proto matches the s_proto member.

	On posix this will search through the /etc/services file.
	Source   Edit   

proc getSockDomain(socket: SocketHandle): Domain {.....}

	Returns the socket's domain (AF_INET or AF_INET6). Source   Edit   

proc getSockName(socket: SocketHandle): Port {.....}

	Returns the socket's associated port number. Source   Edit   

proc getSockOptInt(socket: SocketHandle; level, optname: int): int {.
	....}

	getsockopt for integer options. Source   Edit   

proc ioctlsocket(s: SocketHandle; cmd: clong; argptr: ptr clong): cint {.
	stdcall, importc: "ioctlsocket", dynlib: "ws2_32.dll", ....}

	Source   Edit   

proc listen(socket: SocketHandle; backlog = SOMAXCONN): cint {.
	....}

	Marks socket as accepting connections. Backlog specifies the maximum length of the queue of pending connections. Source   Edit   

proc ntohl(x: uint32): uint32 {.....}

	Converts 32-bit unsigned integers from network to host byte order. On machines where the host byte order is the same as network byte order, this is a no-op; otherwise, it performs a 4-byte swap operation. Source   Edit   

proc ntohs(x: uint16): uint16 {.....}

	Converts 16-bit unsigned integers from network to host byte order. On machines where the host byte order is the same as network byte order, this is a no-op; otherwise, it performs a 2-byte swap operation. Source   Edit   

proc selectRead(readfds: var seq[SocketHandle]; timeout = 500): int {.
	....}

	When a socket in readfds is ready to be read from then a non-zero value will be returned specifying the count of the sockets which can be read from. The sockets which cannot be read from will also be removed from readfds.

	timeout is specified in milliseconds and -1 can be specified for an unlimited time.
	Source   Edit   

proc selectWrite(writefds: var seq[SocketHandle]; timeout = 500): int {.
	....}

	When a socket in writefds is ready to be written to then a non-zero value will be returned specifying the count of the sockets which can be written to. The sockets which cannot be written to will also be removed from writefds.

	timeout is specified in milliseconds and -1 can be specified for an unlimited time.
	Source   Edit   

proc setBlocking(s: SocketHandle; blocking: bool) {.....}

	Sets blocking mode on socket.

	Raises OSError on error.
	Source   Edit   

proc setInheritable(s: SocketHandle; inheritable: bool): bool {.inline,
	....}

	Set whether a socket is inheritable by child processes. Returns true on success.

	This function is not implemented on all platform, test for availability with declared() <system.html#declared,untyped>.
	Source   Edit   

proc setSockOptInt(socket: SocketHandle; level, optname, optval: int) {.
	....}

	setsockopt for integer options. Source   Edit   

proc toInt(domain: Domain): cint {.....}

	Converts the Domain enum to a platform-dependent cint. Source   Edit   

proc toInt(p: Protocol): cint {.....}

	Converts the Protocol enum to a platform-dependent cint. Source   Edit   

proc toInt(typ: SockType): cint {.....}

	Converts the SockType enum to a platform-dependent cint. Source   Edit   

proc toKnownDomain(family: cint): Option[Domain] {.....}

	Converts the platform-dependent cint to the Domain or none(), if the cint is not known. Source   Edit   

proc toSockType(protocol: Protocol): SockType {.....}

	Source   Edit   

Templates

template htonl(x: uint32): untyped

	Converts 32-bit unsigned integers from host to network byte order. On machines where the host byte order is the same as network byte order, this is a no-op; otherwise, it performs a 4-byte swap operation. Source   Edit   

template htons(x: uint16): untyped

	Converts 16-bit unsigned integers from host to network byte order. On machines where the host byte order is the same as network byte order, this is a no-op; otherwise, it performs a 2-byte swap operation. Source   Edit   

Exports

WSAEWOULDBLOCK, WSAECONNRESET, WSAECONNABORTED, WSAENETRESET, WSANOTINITIALISED, WSAENOTSOCK, WSAEINPROGRESS, WSAEINTR, WSAEDISCON, ERROR_NETNAME_DELETED, SocketHandle, Sockaddr_in, AddrInfo, INADDR_ANY, SockAddr, SockLen, Sockaddr_in6, Sockaddr_storage, recv, recv, ==, ==, ==, ==, ==, ==, ==, ==, ==, ==, ==, ==, ==, ==, ==, ==, ==, ==, ==, ==, ==, ==, ==, ==, ==, ==, ==, ==, ==, connect, send, send, accept, recvfrom, sendto, freeAddrInfo, inet_ntoa, SO_ERROR, SOL_SOCKET, SOMAXCONN, SO_ACCEPTCONN, SO_BROADCAST, SO_DEBUG, SO_DONTROUTE, SO_KEEPALIVE, SO_OOBINLINE, SO_REUSEADDR, SO_REUSEPORT, MSG_PEEK


std/net


std/net
Source   Edit  

This module implements a high-level cross-platform sockets interface. The procedures implemented in this module are primarily for blocking sockets. For asynchronous non-blocking sockets use the asyncnet module together with the asyncdispatch module.

The first thing you will always need to do in order to start using sockets, is to create a new instance of the Socket type using the newSocket procedure.
SSL

In order to use the SSL procedures defined in this module, you will need to compile your application with the -d:ssl flag. See the newContext procedure for additional details.
SSL on Windows

On Windows the SSL library checks for valid certificates. It uses the cacert.pem file for this purpose which was extracted from https://curl.se/ca/cacert.pem. Besides the OpenSSL DLLs (e.g. libssl-1_1-x64.dll, libcrypto-1_1-x64.dll) you also need to ship cacert.pem with your .exe file.
Examples
Connecting to a server

After you create a socket with the newSocket procedure, you can easily connect it to a server running at a known hostname (or IP address) and port. To do so over TCP, use the example below.

Example: cmd: -r:off

import std/net
let socket = newSocket()
socket.connect("google.com", Port(80))

For SSL, use the following example:

Example: cmd: -r:off -d:ssl

import std/net
let socket = newSocket()
let ctx = newContext()
wrapSocket(ctx, socket)
socket.connect("google.com", Port(443))

UDP is a connectionless protocol, so UDP sockets don't have to explicitly call the connect procedure. They can simply start sending data immediately.

Example: cmd: -r:off

import std/net
let socket = newSocket(AF_INET, SOCK_DGRAM, IPPROTO_UDP)
socket.sendTo("192.168.0.1", Port(27960), "status\n")

Example: cmd: -r:off

import std/net
let socket = newSocket(AF_INET, SOCK_DGRAM, IPPROTO_UDP)
let ip = parseIpAddress("192.168.0.1")
doAssert socket.sendTo(ip, Port(27960), "status\c\l") == 8

Creating a server

After you create a socket with the newSocket procedure, you can create a TCP server by calling the bindAddr and listen procedures.

Example: cmd: -r:off

import std/net
let socket = newSocket()
socket.bindAddr(Port(1234))
socket.listen()

# You can then begin accepting connections using the `accept` procedure.
var client: Socket
var address = ""
while true:
  socket.acceptAddr(client, address)
  echo "Client connected from: ", address

Imports

since, nativesockets, os, strutils, times, sets, options, monotimes, ssl_config, winlean, openssl, ssl_certs, winlean

Types

Certificate = string

	DER encoded certificate Source   Edit   

IpAddress = object
  case family*: IpAddressFamily ## the type of the IP address (IPv4 or IPv6)
  of IpAddressFamily.IPv6:
	address_v6*: array[0 .. 15, uint8] ## Contains the IP address in bytes in
                                   	## case of IPv6
  of IpAddressFamily.IPv4:
	address_v4*: array[0 .. 3, uint8] ## Contains the IP address in bytes in
                                  	## case of IPv4

	stores an arbitrary IP address Source   Edit   

IpAddressFamily {.pure.} = enum
  IPv6,                 	## IPv6 address
  IPv4                   	## IPv4 address

	Describes the type of an IP address Source   Edit   

ReadLineResult = enum
  ReadFullLine, ReadPartialLine, ReadDisconnected, ReadNone

	result for readLineAsync Source   Edit   

SOBool = enum
  OptAcceptConn, OptBroadcast, OptDebug, OptDontRoute, OptKeepAlive,
  OptOOBInline, OptReuseAddr, OptReusePort, OptNoDelay

	Boolean socket options. Source   Edit   

Socket = ref SocketImpl

	Source   Edit   

SocketFlag {.pure.} = enum
  Peek, SafeDisconn      	## Ensures disconnection exceptions (ECONNRESET, EPIPE etc) are not thrown.

	Source   Edit   

SocketImpl = object
  when defineSsl:
  ## stores the last error on this socket

	socket type Source   Edit   

SslAcceptResult = enum
  AcceptNoClient = 0, AcceptNoHandshake, AcceptSuccess

	Source   Edit   

SslClientGetPskFunc = proc (hint: string): tuple[identity: string, psk: string]

	Source   Edit   

SslContext = ref object
  context*: SslCtx

	Source   Edit   

SslCVerifyMode = enum
  CVerifyNone, CVerifyPeer, CVerifyPeerUseEnvVars

	Source   Edit   

SslError = object of CatchableError

	Source   Edit   

SslHandshakeType = enum
  handshakeAsClient, handshakeAsServer

	Source   Edit   

SslProtVersion = enum
  protSSLv2, protSSLv3, protTLSv1, protSSLv23

	Source   Edit   

SslServerGetPskFunc = proc (identity: string): string

	Source   Edit   

TimeoutError = object of CatchableError

	Source   Edit   

Consts

BufferSize: int = 4000

	size of a buffered socket's buffer Source   Edit   

MaxLineLength = 1000000

	Source   Edit   

Procs

proc `$`(address: IpAddress): string {.....}

	Converts an IpAddress into the textual representation Source   Edit   

proc `==`(lhs, rhs: IpAddress): bool {.....}

	Compares two IpAddresses for Equality. Returns true if the addresses are equal Source   Edit   

proc accept(server: Socket; client: var owned(Socket); flags = {SafeDisconn};
        	inheritable = defined(nimInheritHandles)) {.....}

	Equivalent to acceptAddr but doesn't return the address, only the socket.

	The SocketHandle associated with the resulting client will not be inheritable by child processes by default. This can be changed via the inheritable parameter.

	The accept call may result in an error if the connecting socket disconnects during the duration of the accept. If the SafeDisconn flag is specified then this error will not be raised and instead accept will be called again.
	Source   Edit   

proc acceptAddr(server: Socket; client: var owned(Socket); address: var string;
            	flags = {SafeDisconn}; inheritable = defined(nimInheritHandles)) {.
	....}

	Blocks until a connection is being made from a client. When a connection is made sets client to the client socket and address to the address of the connecting client. This function will raise OSError if an error occurs.

	The resulting client will inherit any properties of the server socket. For example: whether the socket is buffered or not.

	The SocketHandle associated with the resulting client will not be inheritable by child processes by default. This can be changed via the inheritable parameter.

	The accept call may result in an error if the connecting socket disconnects during the duration of the accept. If the SafeDisconn flag is specified then this error will not be raised and instead accept will be called again.
	Source   Edit   

proc bindAddr(socket: Socket; port = Port(0); address = "") {.
	....}

	Binds address:port to the socket.

	If address is "" then ADDR_ANY will be bound.
	Source   Edit   

proc bindUnix(socket: Socket; path: string) {.....}

	Binds Unix socket to path. This only works on Unix-style systems: Mac OS X, BSD and Linux Source   Edit   

proc clientGetPskFunc(ctx: SslContext): SslClientGetPskFunc {.....}

	Source   Edit   

proc clientGetPskFunc=(ctx: SslContext; fun: SslClientGetPskFunc) {.....}

	Sets function that returns the client identity and the PSK based on identity hint from the server.

	Only used in PSK ciphersuites.
	Source   Edit   

proc close(socket: Socket; flags = {SafeDisconn}) {.
	....}

	Closes a socket.

	If socket is an SSL/TLS socket, this proc will also send a closure notification to the peer. If SafeDisconn is in flags, failure to do so due to disconnections will be ignored. This is generally safe in practice. See here for more details.
	Source   Edit   

proc connect(socket: Socket; address: string; port = Port(0)) {.
	....}

	Connects socket to address:port. Address can be an IP address or a host name. If address is a host name, this function will try each IP of that host name. htons is already performed on port so you must not do it.

	If socket is an SSL socket a handshake will be automatically performed.
	Source   Edit   

proc connect(socket: Socket; address: string; port = Port(0); timeout: int) {.
	....}

	Connects to server as specified by address on port specified by port.

	The timeout parameter specifies the time in milliseconds to allow for the connection to the server to be made.
	Source   Edit   

proc connectUnix(socket: Socket; path: string) {.....}

	Connects to Unix socket on path. This only works on Unix-style systems: Mac OS X, BSD and Linux Source   Edit   

proc destroyContext(ctx: SslContext) {.....}

	Free memory referenced by SslContext. Source   Edit   

proc dial(address: string; port: Port; protocol = IPPROTO_TCP; buffered = true): owned(
	Socket) {.....}

	Establishes connection to the specified address:port pair via the specified protocol. The procedure iterates through possible resolutions of the address until it succeeds, meaning that it seamlessly works with both IPv4 and IPv6. Returns Socket ready to send or receive data. Source   Edit   

proc fromSockAddr(sa: Sockaddr_storage | SockAddr | Sockaddr_in | Sockaddr_in6;
              	sl: SockLen; address: var IpAddress; port: var Port) {.inline.}

	Converts SockAddr and SockLen to IpAddress and Port. Raises ObjectConversionDefect in case of invalid sa and sl arguments. Source   Edit   

proc getExtraData(ctx: SslContext; index: int): RootRef {.....}

	Retrieves arbitrary data stored inside SslContext. Source   Edit   

proc getFd(socket: Socket): SocketHandle {.....}

	Returns the socket's file descriptor Source   Edit   

proc getLocalAddr(socket: Socket): (string, Port) {.
	....}

	Get the socket's local address and port number.

	This is high-level interface for getsockname.
	Source   Edit   

proc getPeerAddr(socket: Socket): (string, Port) {.....}

	Get the socket's peer address and port number.

	This is high-level interface for getpeername.
	Source   Edit   

proc getPeerCertificates(socket: Socket): seq[Certificate] {.
	....}

	Returns the certificate chain received by the peer we are connected to through the given socket. The handshake must have been completed and the certificate chain must have been verified successfully or else an empty sequence is returned. The chain is ordered from leaf certificate to root certificate. Source   Edit   

proc getPeerCertificates(sslHandle: SslPtr): seq[Certificate] {.
	....}

	Returns the certificate chain received by the peer we are connected to through the OpenSSL connection represented by sslHandle. The handshake must have been completed and the certificate chain must have been verified successfully or else an empty sequence is returned. The chain is ordered from leaf certificate to root certificate. Source   Edit   

proc getPrimaryIPAddr(dest = parseIpAddress("8.8.8.8")): IpAddress {.
	....}

Finds the local IP address, usually assigned to eth0 on LAN or wlan0 on WiFi, used to reach an external address. Useful to run local services.

No traffic is sent.

Supports IPv4 and v6. Raises OSError if external networking is not set up.

Example: cmd: -r:off

echo getPrimaryIPAddr() # "192.168.1.2"

	Source   Edit   

proc getPskIdentity(socket: Socket): string {.....}

	Gets the PSK identity provided by the client. Source   Edit   

proc getSocketError(socket: Socket): OSErrorCode {.....}

	Checks osLastError for a valid error. If it has been reset it uses the last error stored in the socket object. Source   Edit   

proc getSockOpt(socket: Socket; opt: SOBool; level = SOL_SOCKET): bool {.
	....}

	Retrieves option opt as a boolean value. Source   Edit   

proc gotHandshake(socket: Socket): bool {.....}

	Determines whether a handshake has occurred between a client (socket) and the server that socket is connected to.

	Throws SslError if socket is not an SSL socket.
	Source   Edit   

proc hasDataBuffered(s: Socket): bool {.....}

	Determines whether a socket has data buffered. Source   Edit   

proc IPv4_any(): IpAddress {.....}

	Returns the IPv4 any address, which can be used to listen on all available network adapters Source   Edit   

proc IPv4_broadcast(): IpAddress {.....}

	Returns the IPv4 broadcast address (255.255.255.255) Source   Edit   

proc IPv4_loopback(): IpAddress {.....}

	Returns the IPv4 loopback address (127.0.0.1) Source   Edit   

proc IPv6_any(): IpAddress {.....}

	Returns the IPv6 any address (::0), which can be used to listen on all available network adapters Source   Edit   

proc IPv6_loopback(): IpAddress {.....}

	Returns the IPv6 loopback address (::1) Source   Edit   

proc isDisconnectionError(flags: set[SocketFlag]; lastError: OSErrorCode): bool {.
	....}

	Determines whether lastError is a disconnection error. Only does this if flags contains SafeDisconn. Source   Edit   

proc isIpAddress(addressStr: string): bool {.....}

	Checks if a string is an IP address Returns true if it is, false otherwise Source   Edit   

proc isSsl(socket: Socket): bool {.....}

	Determines whether socket is a SSL socket. Source   Edit   

proc listen(socket: Socket; backlog = SOMAXCONN) {.....}

	Marks socket as accepting connections. Backlog specifies the maximum length of the queue of pending connections.

	Raises an OSError error upon failure.
	Source   Edit   

proc newContext(protVersion = protSSLv23; verifyMode = CVerifyPeer;
            	certFile = ""; keyFile = ""; cipherList = CiphersIntermediate;
            	caDir = ""; caFile = ""; ciphersuites = CiphersModern): SslContext {.
	....}

	Creates an SSL context.

	Protocol version is currently ignored by default and TLS is used. With -d:openssl10, only SSLv23 and TLSv1 may be used.

	There are three options for verify mode: CVerifyNone: certificates are not verified; CVerifyPeer: certificates are verified; CVerifyPeerUseEnvVars: certificates are verified and the optional environment variables SSL_CERT_FILE and SSL_CERT_DIR are also used to locate certificates

	The nimDisableCertificateValidation define overrides verifyMode and disables certificate verification globally!

	CA certificates will be loaded, in the following order, from:

    	caFile, caDir, parameters, if set
    	if verifyMode is set to CVerifyPeerUseEnvVars, the SSL_CERT_FILE and SSL_CERT_DIR environment variables are used
    	a set of files and directories from the ssl_certs file.

	The last two parameters specify the certificate file path and the key file path, a server socket will most likely not work without these.

	Certificates can be generated using the following command:

    	openssl req -x509 -nodes -days 365 -newkey rsa:4096 -keyout mykey.pem -out mycert.pem

	or using ECDSA:

    	openssl ecparam -out mykey.pem -name secp256k1 -genkey
    	openssl req -new -key mykey.pem -x509 -nodes -days 365 -out mycert.pem

	Source   Edit   

proc newSocket(domain, sockType, protocol: cint; buffered = true;
           	inheritable = defined(nimInheritHandles)): owned(Socket) {.
	....}

	Creates a new socket.

	The SocketHandle associated with the resulting Socket will not be inheritable by child processes by default. This can be changed via the inheritable parameter.

	If an error occurs OSError will be raised.
	Source   Edit   

proc newSocket(domain: Domain = AF_INET; sockType: SockType = SOCK_STREAM;
           	protocol: Protocol = IPPROTO_TCP; buffered = true;
           	inheritable = defined(nimInheritHandles)): owned(Socket) {.
	....}

	Creates a new socket.

	The SocketHandle associated with the resulting Socket will not be inheritable by child processes by default. This can be changed via the inheritable parameter.

	If an error occurs OSError will be raised.
	Source   Edit   

proc newSocket(fd: SocketHandle; domain: Domain = AF_INET;
           	sockType: SockType = SOCK_STREAM;
           	protocol: Protocol = IPPROTO_TCP; buffered = true): owned(Socket) {.
	....}

	Creates a new socket as specified by the params. Source   Edit   

proc parseIpAddress(addressStr: string): IpAddress {.....}

	Parses an IP address

	Raises ValueError on error.

	For IPv4 addresses, only the strict form as defined in RFC 6943 is considered valid, see https://datatracker.ietf.org/doc/html/rfc6943#section-3.1.1.
	Source   Edit   

proc pskIdentityHint=(ctx: SslContext; hint: string) {.....}

	Sets the identity hint passed to server.

	Only used in PSK ciphersuites.
	Source   Edit   

proc raiseSSLError(s = "") {.....}

	Raises a new SSL error. Source   Edit   

proc readLine(socket: Socket; line: var string; timeout = -1;
          	flags = {SafeDisconn}; maxLength = MaxLineLength) {.
	....}

	Reads a line of data from socket.

	If a full line is read \r\L is not added to line, however if solely \r\L is read then line will be set to it.

	If the socket is disconnected, line will be set to "".

	An OSError exception will be raised in the case of a socket error.

	A timeout can be specified in milliseconds, if data is not received within the specified time a TimeoutError exception will be raised.

	The maxLength parameter determines the maximum amount of characters that can be read. The result is truncated after that.
	Warning: Only the SafeDisconn flag is currently supported.
	Source   Edit   

proc recv(socket: Socket; data: pointer; size: int): int {.....}

	Receives data from a socket.

	Note: This is a low-level function, you may be interested in the higher level versions of this function which are also named recv.
	Source   Edit   

proc recv(socket: Socket; data: pointer; size: int; timeout: int): int {.
	....}

	overload with a timeout parameter in milliseconds. Source   Edit   

proc recv(socket: Socket; data: var string; size: int; timeout = -1;
      	flags = {SafeDisconn}): int {.....}

	Higher-level version of recv.

	Reads up to size bytes from socket into data.

	For buffered sockets this function will attempt to read all the requested data. It will read this data in BufferSize chunks.

	For unbuffered sockets this function makes no effort to read all the data requested. It will return as much data as the operating system gives it.

	When 0 is returned the socket's connection has been closed.

	This function will throw an OSError exception when an error occurs. A value lower than 0 is never returned.

	A timeout may be specified in milliseconds, if enough data is not received within the time specified a TimeoutError exception will be raised.
	Warning: Only the SafeDisconn flag is currently supported.
	Source   Edit   

proc recv(socket: Socket; size: int; timeout = -1; flags = {SafeDisconn}): string {.
	inline, ....}

	Higher-level version of recv which returns a string.

	Reads up to size bytes from socket into the result.

	For buffered sockets this function will attempt to read all the requested data. It will read this data in BufferSize chunks.

	For unbuffered sockets this function makes no effort to read all the data requested. It will return as much data as the operating system gives it.

	When "" is returned the socket's connection has been closed.

	This function will throw an OSError exception when an error occurs.

	A timeout may be specified in milliseconds, if enough data is not received within the time specified a TimeoutError exception will be raised.
	Warning: Only the SafeDisconn flag is currently supported.
	Source   Edit   

proc recvFrom[T: string | IpAddress](socket: Socket; data: var string;
                                 	length: int; address: var T;
                                 	port: var Port; flags = 0'i32): int {.
	....}

	Receives data from socket. This function should normally be used with connection-less sockets (UDP sockets). The source address of the data packet is stored in the address argument as either a string or an IpAddress.

	If an error occurs an OSError exception will be raised. Otherwise the return value will be the length of data received.
	Warning: This function does not yet have a buffered implementation, so when socket is buffered the non-buffered implementation will be used. Therefore if socket contains something in its buffer this function will make no effort to return it.
	Source   Edit   

proc recvLine(socket: Socket; timeout = -1; flags = {SafeDisconn};
          	maxLength = MaxLineLength): string {.
	....}

	Reads a line of data from socket.

	If a full line is read \r\L is not added to the result, however if solely \r\L is read then the result will be set to it.

	If the socket is disconnected, the result will be set to "".

	An OSError exception will be raised in the case of a socket error.

	A timeout can be specified in milliseconds, if data is not received within the specified time a TimeoutError exception will be raised.

	The maxLength parameter determines the maximum amount of characters that can be read. The result is truncated after that.
	Warning: Only the SafeDisconn flag is currently supported.
	Source   Edit   

proc send(socket: Socket; data: pointer; size: int): int {.
	....}

	Sends data to a socket.

	Note: This is a low-level version of send. You likely should use the version below.
	Source   Edit   

proc send(socket: Socket; data: string; flags = {SafeDisconn}; maxRetries = 100) {.
	....}

	Sends data to a socket. Will try to send all the data by handling interrupts and incomplete writes up to maxRetries. Source   Edit   

proc sendTo(socket: Socket; address: IpAddress; port: Port; data: string;
        	flags = 0'i32): int {.discardable, ....}

	This proc sends data to the specified IpAddress and returns the number of bytes written.

	Generally for use with connection-less (UDP) sockets.

	If an error occurs an OSError exception will be raised.

	This is the high-level version of the above sendTo function.
	Source   Edit   

proc sendTo(socket: Socket; address: string; port: Port; data: pointer;
        	size: int; af: Domain = AF_INET; flags = 0'i32) {.
	....}

	This proc sends data to the specified address, which may be an IP address or a hostname, if a hostname is specified this function will try each IP of that hostname. This function should normally be used with connection-less sockets (UDP sockets).

	If an error occurs an OSError exception will be raised.

	Note: You may wish to use the high-level version of this function which is defined below.

	Note: This proc is not available for SSL sockets.
	Source   Edit   

proc sendTo(socket: Socket; address: string; port: Port; data: string) {.
	....}

	This proc sends data to the specified address, which may be an IP address or a hostname, if a hostname is specified this function will try each IP of that hostname.

	Generally for use with connection-less (UDP) sockets.

	If an error occurs an OSError exception will be raised.

	This is the high-level version of the above sendTo function.
	Source   Edit   

proc serverGetPskFunc(ctx: SslContext): SslServerGetPskFunc {.....}

	Source   Edit   

proc serverGetPskFunc=(ctx: SslContext; fun: SslServerGetPskFunc) {.....}

	Sets function that returns PSK based on the client identity.

	Only used in PSK ciphersuites.
	Source   Edit   

proc sessionIdContext=(ctx: SslContext; sidCtx: string) {.....}

	Sets the session id context in which a session can be reused. Used for permitting clients to reuse a session id instead of doing a new handshake.

	TLS clients might attempt to resume a session using the session id context, thus it must be set if verifyMode is set to CVerifyPeer or CVerifyPeerUseEnvVars, otherwise the connection will fail and SslError will be raised if resumption occurs.

    	Only useful if set server-side.
    	Should be unique per-application to prevent clients from malfunctioning.
    	sidCtx must be at most 32 characters in length.

	Source   Edit   

proc setExtraData(ctx: SslContext; index: int; data: RootRef) {.
	....}

	Stores arbitrary data inside SslContext. The unique index should be retrieved using getSslContextExtraDataIndex. Source   Edit   

proc setSockOpt(socket: Socket; opt: SOBool; value: bool; level = SOL_SOCKET) {.
	....}

Sets option opt to a boolean value specified by value.

Example: cmd: -r:off

let socket = newSocket()
socket.setSockOpt(OptReusePort, true)
socket.setSockOpt(OptNoDelay, true, level = IPPROTO_TCP.cint)

	Source   Edit   

proc skip(socket: Socket; size: int; timeout = -1) {.
	....}

	Skips size amount of bytes.

	An optional timeout can be specified in milliseconds, if skipping the bytes takes longer than specified a TimeoutError exception will be raised.

	Returns the number of skipped bytes.
	Source   Edit   

proc socketError(socket: Socket; err: int = -1; async = false;
             	lastError = -1.OSErrorCode; flags: set[SocketFlag] = {}) {.
	....}

	Source   Edit   

proc sslHandle(self: Socket): SslPtr {.....}

	Retrieve the ssl pointer of socket. Useful for interfacing with openssl. Source   Edit   

proc toCInt(opt: SOBool): cint {.....}

	Converts a SOBool into its Socket Option cint representation. Source   Edit   

proc toOSFlags(socketFlags: set[SocketFlag]): cint {.....}

	Converts the flags into the underlying OS representation. Source   Edit   

proc toSockAddr(address: IpAddress; port: Port; sa: var Sockaddr_storage;
            	sl: var SockLen) {.....}

	Converts IpAddress and Port to SockAddr and SockLen Source   Edit   

proc trySend(socket: Socket; data: string): bool {.....}

	Safe alternative to send. Does not raise an OSError when an error occurs, and instead returns false on failure. Source   Edit   

proc wrapConnectedSocket(ctx: SslContext; socket: Socket;
                     	handshake: SslHandshakeType; hostname: string = "") {.
	....}

	Wraps a connected socket in an SSL context. This function effectively turns socket into an SSL socket. hostname should be specified so that the client knows which hostname the server certificate should be validated against.

	This should be called on a connected socket, and will perform an SSL handshake immediately.

	FIXME: Disclaimer: This code is not well tested, may be very unsafe and prone to security vulnerabilities.
	Source   Edit   

proc wrapSocket(ctx: SslContext; socket: Socket) {.....}

	Wraps a socket in an SSL context. This function effectively turns socket into an SSL socket.

	This must be called on an unconnected socket; an SSL session will be started when the socket is connected.

	FIXME: Disclaimer: This code is not well tested, may be very unsafe and prone to security vulnerabilities.
	Source   Edit   

Templates

template `&=`(socket: Socket; data: typed)

	an alias for 'send'. Source   Edit   

Exports

Port, $, ==, ==, ==, ==, ==, ==, ==, ==, ==, ==, ==, ==, ==, ==, ==, ==, ==, ==, ==, ==, ==, ==, ==, ==, ==, ==, ==, ==, ==, ==, Domain, SockType, Protocol


std/selectors


std/selectors
Source   Edit  

This module allows high-level and efficient I/O multiplexing.

Supported OS primitives: epoll, kqueue, poll and Windows select.

To use threadsafe version of this module, it needs to be compiled with both -d:threadsafe and --threads:on options.

Supported features: files, sockets, pipes, timers, processes, signals and user events.

Fully supported OS: MacOSX, FreeBSD, OpenBSD, NetBSD, Linux (except for Android).

Partially supported OS: Windows (only sockets and user events), Solaris (files, sockets, handles and user events). Android (files, sockets, handles and user events).

TODO: /dev/poll, event ports and filesystem events.

Imports

nativesockets, oserrors

Types

Event {.pure.} = enum
  Read,                 	## Descriptor is available for read
  Write,                	## Descriptor is available for write
  Timer,                	## Timer descriptor is completed
  Signal,               	## Signal is raised
  Process,              	## Process is finished
  Vnode,                	## BSD specific file change
  User,                 	## User event is raised
  Error,                	## Error occurred while waiting for descriptor
  VnodeWrite,           	## NOTE_WRITE (BSD specific, write to file occurred)
  VnodeDelete,          	## NOTE_DELETE (BSD specific, unlink of file occurred)
  VnodeExtend,          	## NOTE_EXTEND (BSD specific, file extended)
  VnodeAttrib,          	## NOTE_ATTRIB (BSD specific, file attributes changed)
  VnodeLink,            	## NOTE_LINK (BSD specific, file link count changed)
  VnodeRename,          	## NOTE_RENAME (BSD specific, file renamed)
  VnodeRevoke            	## NOTE_REVOKE (BSD specific, file revoke occurred)

	An enum which hold event types Source   Edit   

IOSelectorsException = object of CatchableError

	Exception that is raised if an IOSelectors error occurs. Source   Edit   

ReadyKey = object
  fd*: int               	## file/socket descriptor
  events*: set[Event]    	## set of events
  errorCode*: OSErrorCode	## additional error code information for
                         	## Error events

	An object which holds result for descriptor Source   Edit   

SelectEvent = object

	An object which holds user defined event Source   Edit   

Selector[T] = ref object

	An object which holds descriptors to be checked for read/write status Source   Edit   

Consts

ioselSupportedPlatform = false

	This constant is used to determine whether the destination platform is fully supported by ioselectors module. Source   Edit   

Procs

proc close(ev: SelectEvent) {.....}

	Closes user-defined event ev. Source   Edit   

proc close[T](s: Selector[T])

	Closes the selector. Source   Edit   

proc contains[T](s: Selector[T]; fd: SocketHandle | int): bool {.inline.}

	Determines whether selector contains a file descriptor. Source   Edit   

proc getData[T](s: Selector[T]; fd: SocketHandle | int): var T

	Retrieves application-defined data associated with descriptor fd. If specified descriptor fd is not registered, empty/default value will be returned. Source   Edit   

proc getFd[T](s: Selector[T]): int

	Retrieves the underlying selector's file descriptor.

	For poll and select selectors -1 is returned.
	Source   Edit   

proc newSelectEvent(): SelectEvent {.....}

	Creates a new user-defined event. Source   Edit   

proc newSelector[T](): Selector[T]

	Creates a new selector Source   Edit   

proc registerEvent[T](s: Selector[T]; ev: SelectEvent; data: T)

	Registers selector event ev in selector s.

	The data is application-defined data, which will be passed when ev happens.
	Source   Edit   

proc registerHandle[T](s: Selector[T]; fd: int | SocketHandle;
                   	events: set[Event]; data: T)

	Registers file/socket descriptor fd to selector s with events set in events. The data is application-defined data, which will be passed when an event is triggered. Source   Edit   

proc registerProcess[T](s: Selector[T]; pid: int; data: T): int {.discardable.}

	Registers a process id (pid) notification (when process has exited) in selector s.

	The data is application-defined data, which will be passed when process with pid has exited.

	Returns the file descriptor for the registered signal.
	Source   Edit   

proc registerSignal[T](s: Selector[T]; signal: int; data: T): int {.discardable.}

	Registers Unix signal notification with signal to selector s.

	The data is application-defined data, which will be passed when signal raises.

	Returns the file descriptor for the registered signal.

	Note: This function is not supported on Windows.
	Source   Edit   

proc registerTimer[T](s: Selector[T]; timeout: int; oneshot: bool; data: T): int {.
	discardable.}

	Registers timer notification with timeout (in milliseconds) to selector s.

	If oneshot is true, timer will be notified only once.

	Set oneshot to false if you want periodic notifications.

	The data is application-defined data, which will be passed, when the timer is triggered.

	Returns the file descriptor for the registered timer.
	Source   Edit   

proc registerVnode[T](s: Selector[T]; fd: cint; events: set[Event]; data: T)

	Registers selector BSD/MacOSX specific vnode events for file descriptor fd and events events. data application-defined data, which to be passed, when vnode event happens.

	Note: This function is supported only by BSD and MacOSX.
	Source   Edit   

proc select[T](s: Selector[T]; timeout: int): seq[ReadyKey]

	Waits for events registered in selector s.

	The timeout argument specifies the maximum number of milliseconds the function will be blocked for if no events are ready. Specifying a timeout of -1 causes the function to block indefinitely.

	Returns a list of triggered events.
	Source   Edit   

proc selectInto[T](s: Selector[T]; timeout: int;
               	results: var openArray[ReadyKey]): int

	Waits for events registered in selector s.

	The timeout argument specifies the maximum number of milliseconds the function will be blocked for if no events are ready. Specifying a timeout of -1 causes the function to block indefinitely. All available events will be stored in results array.

	Returns number of triggered events.
	Source   Edit   

proc setData[T](s: Selector[T]; fd: SocketHandle | int; data: var T): bool

	Associate application-defined data with descriptor fd.

	Returns true, if data was successfully updated, false otherwise.
	Source   Edit   

proc trigger(ev: SelectEvent) {.....}

	Trigger event ev. Source   Edit   

proc unregister[T](s: Selector[T]; ev: SelectEvent)

	Unregisters user-defined event ev from selector s. Source   Edit   

proc unregister[T](s: Selector[T]; fd: int | SocketHandle | cint)

	Unregisters file/socket descriptor fd from selector s. Source   Edit   

proc updateHandle[T](s: Selector[T]; fd: int | SocketHandle; events: set[Event])

	Update file/socket descriptor fd, registered in selector s with new events set event. Source   Edit   

Templates

template isEmpty[T](s: Selector[T]): bool

	Returns true, if there are no registered events or descriptors in selector. Source   Edit   

template withData[T](s: Selector[T]; fd: SocketHandle | int;
                 	value, body1, body2: untyped)

Retrieves the application-data assigned with descriptor fd to value. This value can be modified in the scope of the withData call.

s.withData(fd, value) do:
  # block is executed only if `fd` registered in selector `s`.
  value.uid = 1000
do:
  # block is executed if `fd` not registered in selector `s`.
  raise

	Source   Edit   

template withData[T](s: Selector[T]; fd: SocketHandle | int;
                 	value, body: untyped)

Retrieves the application-data assigned with descriptor fd to value. This value can be modified in the scope of the withData call.

s.withData(fd, value) do:
  # block is executed only if `fd` registered in selector `s`
  value.uid = 1000

	Source   Edit   


src/smtp


src/smtp

Note: In order to use this module, run nimble install smtp.

This module implements the SMTP client protocol as specified by RFC 5321, this can be used to send mail to any SMTP Server.

This module also implements the protocol used to format messages, as specified by RFC 2822.

Example gmail use:

var msg = createMessage("Hello from Nim's SMTP",
                    	"Hello!.\n Is this awesome or what?",
                    	@["foo@gmail.com"])
let smtpConn = newSmtp(useSsl = true, debug=true)
smtpConn.connect("smtp.gmail.com", Port 465)
smtpConn.auth("username", "password")
smtpConn.sendmail("username@gmail.com", @["foo@gmail.com"], $msg)

Example for startTls use:

var msg = createMessage("Hello from Nim's SMTP",
                    	"Hello!.\n Is this awesome or what?",
                    	@["foo@gmail.com"])
let smtpConn = newSmtp(debug=true)
smtpConn.connect("smtp.mailtrap.io", Port 2525)
smtpConn.startTls()
smtpConn.auth("username", "password")
smtpConn.sendmail("username@gmail.com", @["foo@gmail.com"], $msg)

For SSL support this module relies on OpenSSL. If you want to enable SSL, compile with -d:ssl.

Types

AsyncSmtp = SmtpBase[AsyncSocket]

Message = object

ReplyError = object of IOError

Smtp = SmtpBase[Socket]

Procs

proc `$`(msg: Message): string {.....}

	stringify for Message.

proc auth(smtp: AsyncSmtp; username, password: string): owned(Future[void]) {.
	....}

	Sends an AUTH command to the server to login as the username using password. May fail with ReplyError.

proc auth(smtp: Smtp; username, password: string) {.
	....}

proc checkReply(smtp: AsyncSmtp; reply: string): owned(Future[void]) {.
	....}

	Calls debugRecv and checks that the received data starts with reply. If the received data does not start with reply, then a QUIT command will be sent to the SMTP server and a ReplyError exception will be raised.

	This is a lower level proc and not something that you typically would need to call when using this module. One exception to this is if you are implementing any SMTP extensions.

proc checkReply(smtp: Smtp; reply: string) {.
	....}

proc close(smtp: AsyncSmtp): owned(Future[void]) {.....}

	Disconnects from the SMTP server and closes the socket.

proc close(smtp: Smtp) {.....}

proc connect(smtp: AsyncSmtp; address: string; port: Port; helo: bool = true): owned(
	Future[void]) {.....}

	Establishes a connection with a SMTP server. May fail with ReplyError or with a socket error.

proc connect(smtp: Smtp; address: string; port: Port; helo: bool = true) {.
	....}

proc createMessage(mSubject, mBody: string; mTo, mCc: seq[string] = @[]): Message {.
	....}

	Alternate version of the above.

	You need to make sure that mSubject, mTo and mCc don't contain any newline characters. Failing to do so will raise AssertionDefect.

proc createMessage(mSubject, mBody: string; mTo, mCc: seq[string];
               	otherHeaders: openArray[tuple[name, value: string]]): Message {.
	....}

	Creates a new MIME compliant message.

	You need to make sure that mSubject, mTo and mCc don't contain any newline characters. Failing to do so will raise AssertionDefect.

proc debugRecv(smtp: AsyncSmtp): Future[string] {.....}

	Receives a line of data from the socket connected to the SMTP server.

	If the smtp object was created with debug enabled, debugRecv will invoke echo("S:" & result.string) after the data is received.

	This is a lower level proc and not something that you typically would need to call when using this module. One exception to this is if you are implementing any SMTP extensions.

	See checkReply(reply).

proc debugRecv(smtp: Smtp): string {.....}

proc debugSend(smtp: AsyncSmtp; cmd: string): owned(Future[void]) {.
	....}

	Sends cmd on the socket connected to the SMTP server.

	If the smtp object was created with debug enabled, debugSend will invoke echo("C:" & cmd) before sending.

	This is a lower level proc and not something that you typically would need to call when using this module. One exception to this is if you are implementing any SMTP extensions.

proc debugSend(smtp: Smtp; cmd: string) {.....}

proc dial(address: string; port: Port; useSsl = false; debug = false;
      	sslContext: SslContext = nil; helo: bool = true): Smtp {.....}

proc dialAsync(address: string; port: Port; useSsl = false; debug = false;
           	sslContext: SslContext = nil; helo: bool = true): Future[
	AsyncSmtp] {.....}

proc ehlo(smtp: AsyncSmtp): Future[bool] {.....}

	Sends EHLO request.

proc ehlo(smtp: Smtp): bool {.....}

proc helo(smtp: AsyncSmtp; helo: string = "HELO"): owned(Future[void]) {.
	....}

proc helo(smtp: Smtp; helo: string = "HELO") {.
	....}

proc lhlo(smtp: AsyncSmtp): owned(Future[void]) {.....}

proc lhlo(smtp: Smtp) {.....}

proc newAsyncSmtp(useSsl = false; debug = false; sslContext: SslContext = nil): AsyncSmtp {.
	....}

	Creates a new AsyncSmtp instance.

proc newSmtp(useSsl = false; debug = false; sslContext: SslContext = nil): Smtp {.
	....}

	Creates a new Smtp instance.

proc sendMail(smtp: AsyncSmtp; fromAddr: string; toAddrs: seq[string];
          	msg: string): owned(Future[void]) {.....}

	Sends msg from fromAddr to the addresses specified in toAddrs. Messages may be formed using createMessage by converting the Message into a string.

	You need to make sure that fromAddr and toAddrs don't contain any newline characters. Failing to do so will raise AssertionDefect.

proc sendMail(smtp: Smtp; fromAddr: string; toAddrs: seq[string]; msg: string) {.
	....}

proc startTls(smtp: AsyncSmtp; sslContext: SslContext = nil): owned(
	Future[void]) {.....}

	Put the SMTP connection in TLS (Transport Layer Security) mode. May fail with ReplyError

proc startTls(smtp: Smtp; sslContext: SslContext = nil) {.....}


std/socketstreams


std/socketstreams
Source   Edit  

This module provides an implementation of the streams interface for sockets. It contains two separate implementations, a ReadSocketStream and a WriteSocketStream.

The ReadSocketStream only supports reading, peeking, and seeking. It reads into a buffer, so even by seeking backwards it will only read the same position a single time from the underlying socket. To clear the buffer and free the data read into it you can call resetStream, this will also reset the position back to 0 but won't do anything to the underlying socket.

The WriteSocketStream allows both reading and writing, but it performs the reads on the internal buffer. So by writing to the buffer you can then read back what was written but without receiving anything from the socket. You can also set the position and overwrite parts of the buffer, and to send anything over the socket you need to call flush at which point you can't write anything to the buffer before the point of the flush (but it can still be read). Again to empty the underlying buffer you need to call resetStream.
Examples

import std/socketstreams

var
  socket = newSocket(AF_INET, SOCK_DGRAM, IPPROTO_UDP)
  stream = newReadSocketStream(socket)
socket.sendTo("127.0.0.1", Port(12345), "SOME REQUEST")
echo stream.readLine() # Will call `recv`
stream.setPosition(0)
echo stream.readLine() # Will return the read line from the buffer
stream.resetStream() # Buffer is now empty, position is 0
echo stream.readLine() # Will call `recv` again
stream.close() # Closes the socket

import std/socketstreams

var socket = newSocket(AF_INET, SOCK_DGRAM, IPPROTO_UDP)
socket.connect("127.0.0.1", Port(12345))
var sendStream = newWriteSocketStream(socket)
sendStream.write "NOM"
sendStream.setPosition(1)
echo sendStream.peekStr(2) # OM
sendStream.write "I"
sendStream.setPosition(0)
echo sendStream.readStr(3) # NIM
echo sendStream.getPosition() # 3
sendStream.flush() # This actually performs the writing to the socket
sendStream.setPosition(1)
sendStream.write "I" # Throws an error as we can't write into an already sent buffer

Imports

net, streams

Types

ReadSocketStream = ref ReadSocketStreamObj

	Source   Edit   

ReadSocketStreamObj = object of StreamObj

	Source   Edit   

WriteSocketStream = ref WriteSocketStreamObj

	Source   Edit   

WriteSocketStreamObj = object of ReadSocketStreamObj

	Source   Edit   

Procs

proc newReadSocketStream(s: Socket): owned ReadSocketStream {.....}

	Source   Edit   

proc newWriteSocketStream(s: Socket): owned WriteSocketStream {.....}

	Source   Edit   

proc resetStream(s: ReadSocketStream) {.....}

	Source   Edit   

proc resetStream(s: WriteSocketStream) {.....}

	Source   Edit   


std/uri


std/uri
Source   Edit  

This module implements URI parsing as specified by RFC 3986.

A Uniform Resource Identifier (URI) provides a simple and extensible means for identifying a resource. A URI can be further classified as a locator, a name, or both. The term "Uniform Resource Locator" (URL) refers to the subset of URIs.
Warning: URI parsers in this module do not perform security validation.
Basic usage
Combine URIs

Example:

import std/uri
let host = parseUri("https://nim-lang.org")
assert $host == "https://nim-lang.org"
assert $(host / "/blog.html") == "https://nim-lang.org/blog.html"
assert $(host / "blog2.html") == "https://nim-lang.org/blog2.html"

Access URI item

Example:

import std/uri
let res = parseUri("sftp://127.0.0.1:4343")
assert isAbsolute(res)
assert res.port == "4343"

Data URI Base64

Example:

import std/uri
assert getDataUri("Hello World", "text/plain") == "data:text/plain;charset=utf-8;base64,SGVsbG8gV29ybGQ="
assert getDataUri("Nim", "text/plain") == "data:text/plain;charset=utf-8;base64,Tmlt"

Imports

strutils, parseutils, base64, since, decode_helpers

Types

Uri = object
  scheme*, username*, password*: string
  hostname*, port*, path*, query*, anchor*: string
  opaque*: bool
  isIpv6*: bool

	Source   Edit   

UriParseError = object of ValueError

	Source   Edit   

Url = distinct string

	Source   Edit   

Procs

func `$`(u: Uri): string {.....}

Returns the string representation of the specified URI object.

Example:

assert $parseUri("https://nim-lang.org") == "https://nim-lang.org"

	Source   Edit   

func `/`(x: Uri; path: string): Uri {.....}

Concatenates the path specified to the specified URIs path.

Contrary to the combine func you do not have to worry about the slashes at the beginning and end of the path and URIs path respectively.

See also:

	combine func

Example:

let foo = parseUri("https://nim-lang.org/foo/bar") / "/baz"
assert foo.path == "/foo/bar/baz"
let bar = parseUri("https://nim-lang.org/foo/bar") / "baz"
assert bar.path == "/foo/bar/baz"
let qux = parseUri("https://nim-lang.org/foo/bar/") / "baz"
assert qux.path == "/foo/bar/baz"

	Source   Edit   

func `?`(u: Uri; query: openArray[(string, string)]): Uri {.....}

Concatenates the query parameters to the specified URI object.

Example:

let foo = parseUri("https://example.com") / "foo" ? {"bar": "qux"}
assert $foo == "https://example.com/foo?bar=qux"

	Source   Edit   

func combine(base: Uri; reference: Uri): Uri {.....}

Combines a base URI with a reference URI.

This uses the algorithm specified in section 5.2.2 of RFC 3986.

This means that the slashes inside the base URIs path as well as reference URIs path affect the resulting URI.

See also:

	/ func for building URIs

Example:

let foo = combine(parseUri("https://nim-lang.org/foo/bar"), parseUri("/baz"))
assert foo.path == "/baz"
let bar = combine(parseUri("https://nim-lang.org/foo/bar"), parseUri("baz"))
assert bar.path == "/foo/baz"
let qux = combine(parseUri("https://nim-lang.org/foo/bar/"), parseUri("baz"))
assert qux.path == "/foo/bar/baz"

	Source   Edit   

func combine(uris: varargs[Uri]): Uri {.....}

Combines multiple URIs together.

See also:

	/ func for building URIs

Example:

let foo = combine(parseUri("https://nim-lang.org/"), parseUri("docs/"),
	parseUri("manual.html"))
assert foo.hostname == "nim-lang.org"
assert foo.path == "/docs/manual.html"

	Source   Edit   

func decodeUrl(s: string; decodePlus = true): string {.....}

Decodes a URL according to RFC3986.

This means that any %xx (where xx denotes a hexadecimal value) are converted to the character with ordinal number xx, and every other character is carried over. If xx is not a valid hexadecimal value, it is left intact.

As a special rule, when the value of decodePlus is true, + characters are converted to a space.

See also:

	encodeUrl func

Example:

assert decodeUrl("https%3A%2F%2Fnim-lang.org") == "https://nim-lang.org"
assert decodeUrl("https%3A%2F%2Fnim-lang.org%2Fthis+is+a+test") == "https://nim-lang.org/this is a test"
assert decodeUrl("https%3A%2F%2Fnim-lang.org%2Fthis%20is%20a%20test",
	false) == "https://nim-lang.org/this is a test"
assert decodeUrl("abc%xyz") == "abc%xyz"

	Source   Edit   

func encodeQuery(query: openArray[(string, string)]; usePlus = true;
             	omitEq = true; sep = '&'): string {.....}

Encodes a set of (key, value) parameters into a URL query string.

Every (key, value) pair is URL-encoded and written as key=value. If the value is an empty string then the = is omitted, unless omitEq is false. The pairs are joined together by the sep character.

The usePlus parameter is passed down to the encodeUrl function that is used for the URL encoding of the string values.

See also:

	encodeUrl func

Example:

assert encodeQuery({: }) == ""
assert encodeQuery({"a": "1", "b": "2"}) == "a=1&b=2"
assert encodeQuery({"a": "1", "b": ""}) == "a=1&b"
assert encodeQuery({"a": "1", "b": ""}, omitEq = false, sep = ';') == "a=1;b="

	Source   Edit   

func encodeUrl(s: string; usePlus = true): string {.....}

Encodes a URL according to RFC3986.

This means that characters in the set {'a'..'z', 'A'..'Z', '0'..'9', '-', '.', '_', '~'} are carried over to the result. All other characters are encoded as %xx where xx denotes its hexadecimal value.

As a special rule, when the value of usePlus is true, spaces are encoded as + instead of %20.

See also:

	decodeUrl func

Example:

assert encodeUrl("https://nim-lang.org") == "https%3A%2F%2Fnim-lang.org"
assert encodeUrl("https://nim-lang.org/this is a test") == "https%3A%2F%2Fnim-lang.org%2Fthis+is+a+test"
assert encodeUrl("https://nim-lang.org/this is a test", false) == "https%3A%2F%2Fnim-lang.org%2Fthis%20is%20a%20test"

	Source   Edit   

proc getDataUri(data, mime: string; encoding = "utf-8"): string {.....}

Convenience proc for base64.encode returns a standard Base64 Data URI (RFC-2397)

See also:

	mimetypes for mime argument
	https://tools.ietf.org/html/rfc2397
	https://en.wikipedia.org/wiki/Data_URI_scheme

Example:

static: assert getDataUri("Nim", "text/plain") == "data:text/plain;charset=utf-8;base64,Tmlt"

	Source   Edit   

func initUri(isIpv6 = false): Uri {.....}

Initializes a URI with scheme, username, password, hostname, port, path, query, anchor and isIpv6.

See also:

	Uri type for available fields in the URI type

Example:

var uri2 = initUri(isIpv6 = true)
uri2.scheme = "tcp"
uri2.hostname = "2001:0db8:85a3:0000:0000:8a2e:0370:7334"
uri2.port = "8080"
assert $uri2 == "tcp://[2001:0db8:85a3:0000:0000:8a2e:0370:7334]:8080"

	Source   Edit   

func isAbsolute(uri: Uri): bool {.....}

Returns true if URI is absolute, false otherwise.

Example:

assert parseUri("https://nim-lang.org").isAbsolute
assert not parseUri("nim-lang").isAbsolute

	Source   Edit   

func parseUri(uri: string): Uri {.....}

Parses a URI and returns it.

See also:

	Uri type for available fields in the URI type

Example:

let res = parseUri("ftp://Username:Password@Hostname")
assert res.username == "Username"
assert res.password == "Password"
assert res.scheme == "ftp"

	Source   Edit   

func parseUri(uri: string; result: var Uri) {.....}

Parses a URI. The result variable will be cleared before.

See also:

	Uri type for available fields in the URI type
	initUri func for initializing a URI

Example:

var res = initUri()
parseUri("https://nim-lang.org/docs/manual.html", res)
assert res.scheme == "https"
assert res.hostname == "nim-lang.org"
assert res.path == "/docs/manual.html"

	Source   Edit   

proc uriParseError(msg: string) {.noreturn, ....}

	Raises a UriParseError exception with message msg. Source   Edit   

Iterators

iterator decodeQuery(data: string; sep = '&'): tuple[key, value: string] {.
	....}

Reads and decodes the query string data and yields the (key, value) pairs the data consists of. If compiled with -d:nimLegacyParseQueryStrict, a UriParseError is raised when there is an unencoded = character in a decoded value, which was the behavior in Nim < 1.5.1.

Example:

import std/sequtils
assert toSeq(decodeQuery("foo=1&bar=2=3")) == @[("foo", "1"), ("bar", "2=3")]
assert toSeq(decodeQuery("foo=1;bar=2=3", ';')) == @[("foo", "1"), ("bar", "2=3")]
assert toSeq(decodeQuery("&a&=b&=&&")) == @[("", ""), ("a", ""), ("", "b"), ("", ""), ("", "")]

	Source   Edit   

Threading
std/isolation


std/isolation
Source   Edit  

This module implements the Isolated[T] type for safe construction of isolated subgraphs that can be passed efficiently to different channels and threads.
Warning: This module is experimental and its interface may change.

Types

Isolated[T] {.sendable.} = object

	Isolated data can only be moved, not copied. Source   Edit   

Procs

proc `=copy`[T](dest: var Isolated[T]; src: Isolated[T]) {.error.}

	Source   Edit   

proc `=destroy`[T](dest: var Isolated[T]) {.inline, ....}

	Source   Edit   

proc `=sink`[T](dest: var Isolated[T]; src: Isolated[T]) {.inline.}

	Source   Edit   

func extract[T](src: var Isolated[T]): T

	Returns the internal value of src. The value is moved from src. Source   Edit   

func isolate[T](value: sink T): Isolated[T] {.magic: "Isolate", ....}

	Creates an isolated subgraph from the expression value. Isolation is checked at compile time.

	Please read https://github.com/nim-lang/RFCs/issues/244 for more details.
	Source   Edit   

func unsafeIsolate[T](value: sink T): Isolated[T]

	Creates an isolated subgraph from the expression value.
	Warning: The proc doesn't check whether value is isolated.
	Source   Edit   



std/tasks


std/tasks
Source   Edit  

This module provides basic primitives for creating parallel programs. A Task should be only owned by a single Thread, it cannot be shared by threads.

Example:

import std/tasks
block:
  var num = 0
  proc hello(a: int) = inc num, a

  let b = toTask hello(13)
  b.invoke()
  assert num == 13
  # A task can be invoked multiple times
  b.invoke()
  assert num == 26

block:
  type
	Runnable = ref object
  	data: int

  var data: int
  proc hello(a: Runnable) {.nimcall.} =
	a.data += 2
	data = a.data


  when false:
	# the parameters of call must be isolated.
	let x = Runnable(data: 12)
	let b = toTask hello(x) # error ----> expression cannot be isolated: x
	b.invoke()

  let b = toTask(hello(Runnable(data: 12)))
  b.invoke()
  assert data == 14
  b.invoke()
  assert data == 16

Imports

macros, isolation, typetraits, effecttraits

Types

Task = object

	Task contains the callback and its arguments. Source   Edit   

Procs

proc `=copy`(x: var Task; y: Task) {.error.}

	Source   Edit   

proc `=destroy`(t: var Task) {.inline, ....}

	Frees the resources allocated for a Task. Source   Edit   

proc invoke(task: Task; res: pointer = nil) {.inline, ....}

	Invokes the task. Source   Edit   

Macros

macro toTask(e: typed{nkCall | nkInfix | nkPrefix | nkPostfix | nkCommand |
	nkCallStrLit}): Task

Converts the call and its arguments to Task.

Example:

proc hello(a: int) = echo a

let b = toTask hello(13)
assert b is Task

	Source   Edit   

Exports

unsafeIsolate, =copy, =sink, extract, =destroy, Isolated, isolate


std/threadpool


std/threadpool
Source   Edit  
Deprecated: use the nimble packages `malebolgia`, `taskpools` or `weave` instead

Implements Nim's parallel & spawn statements.

Unstable API.
See also

	threads module for basic thread support
	locks module for locks and condition variables
	asyncdispatch module for asynchronous IO

Imports

cpuinfo, cpuload, locks, os

Types

FlowVar[T] {.compilerproc.} = ref FlowVarObj[T]

	A data flow variable. Source   Edit   

FlowVarBase = ref FlowVarBaseObj

	Untyped base class for FlowVar[T]. Source   Edit   

ThreadId = range[0 .. MaxDistinguishedThread - 1]

	A thread identifier. Source   Edit   

Consts

MaxDistinguishedThread {.intdefine.} = 32

	Maximum number of "distinguished" threads. Source   Edit   

MaxThreadPoolSize {.intdefine.} = 256

	Maximum size of the thread pool. 256 threads should be good enough for anybody ;-) Source   Edit   

Procs

proc `^`[T](fv: FlowVar[T]): T

	Blocks until the value is available and then returns this value. Source   Edit   

proc awaitAndThen[T](fv: FlowVar[T]; action: proc (x: T) {.closure.})

	Blocks until fv is available and then passes its value to action.

	Note that due to Nim's parameter passing semantics, this means that T doesn't need to be copied, so awaitAndThen can sometimes be more efficient than the ^ proc.
	Source   Edit   

proc blockUntil(fv: var FlowVarBaseObj) {.....}

	Waits until the value for fv arrives.

	Usually it is not necessary to call this explicitly.
	Source   Edit   

proc blockUntilAny(flowVars: openArray[FlowVarBase]): int {.....}

	Awaits any of the given flowVars. Returns the index of one flowVar for which a value arrived.

	A flowVar only supports one call to blockUntilAny at the same time. That means if you blockUntilAny([a,b]) and blockUntilAny([b,c]) the second call will only block until c. If there is no flowVar left to be able to wait on, -1 is returned.

	Note: This results in non-deterministic behaviour and should be avoided.
	Source   Edit   

proc isReady(fv: FlowVarBase): bool {.....}

	Determines whether the specified FlowVarBase's value is available.

	If true, awaiting fv will not block.
	Source   Edit   

proc parallel(body: untyped) {.magic: "Parallel", ....}

	A parallel section can be used to execute a block in parallel.

	body has to be in a DSL that is a particular subset of the language.

	Please refer to the manual for further information.
	Source   Edit   

proc pinnedSpawn(id: ThreadId; call: sink typed) {.magic: "Spawn", ....}

	Always spawns a new task on the worker thread with id, so that the call is always executed on the thread.

	call has to be a proc call p(...) where p is gcsafe and has a return type that is either void or compatible with FlowVar[T].
	Source   Edit   

proc preferSpawn(): bool {.....}

	Use this proc to determine quickly if a spawn or a direct call is preferable.

	If it returns true, a spawn may make sense. In general it is not necessary to call this directly; use the spawnX template instead.
	Source   Edit   

proc setMaxPoolSize(size: range[1 .. MaxThreadPoolSize]) {.....}

	Sets the maximum thread pool size. The default value of this is MaxThreadPoolSize. Source   Edit   

proc setMinPoolSize(size: range[1 .. MaxThreadPoolSize]) {.....}

	Sets the minimum thread pool size. The default value of this is 4. Source   Edit   

proc spawn(call: sink typed) {.magic: "Spawn", ....}

	Always spawns a new task, so that the call is never executed on the calling thread.

	call has to be a proc call p(...) where p is gcsafe and has a return type that is either void or compatible with FlowVar[T].
	Source   Edit   

proc sync() {.....}

	A simple barrier to wait for all spawned tasks.

	If you need more elaborate waiting, you have to use an explicit barrier.
	Source   Edit   

proc unsafeRead[T](fv: FlowVar[ref T]): ptr T

	Blocks until the value is available and then returns this value. Source   Edit   

Templates

template spawnX(call)

	Spawns a new task if a CPU core is ready, otherwise executes the call in the calling thread.

	Usually, it is advised to use the spawn proc in order to not block the producer for an unknown amount of time.

	call has to be a proc call p(...) where p is gcsafe and has a return type that is either 'void' or compatible with FlowVar[T].
	Source   Edit   


std/typedthreads


std/typedthreads
Source   Edit  

Thread support for Nim.
Examples

import std/locks

var
  thr: array[0..4, Thread[tuple[a,b: int]]]
  L: Lock

proc threadFunc(interval: tuple[a,b: int]) {.thread.} =
  for i in interval.a..interval.b:
	acquire(L) # lock stdout
	echo i
	release(L)

initLock(L)

for i in 0..high(thr):
  createThread(thr[i], threadFunc, (i*10, i*10+5))
joinThreads(thr)

deinitLock(L)

Imports

threadtypes, ansi_c

Procs

proc createThread(t: var Thread[void]; tp: proc () {.thread, nimcall.}) {.
	....}

	Source   Edit   

proc createThread[TArg](t: var Thread[TArg];
                    	tp: proc (arg: TArg) {.thread, nimcall.}; param: TArg)

	Creates a new thread t and starts its execution.

	Entry point is the proc tp. param is passed to tp. TArg can be void if you don't need to pass any data to the thread.
	Source   Edit   

proc getThreadId(): int {.....}

	Gets the ID of the currently running thread. Source   Edit   

proc handle[TArg](t: Thread[TArg]): SysThread {.inline.}

	Returns the thread handle of t. Source   Edit   

proc joinThread[TArg](t: Thread[TArg]) {.inline.}

	Waits for the thread t to finish. Source   Edit   

proc joinThreads[TArg](t: varargs[Thread[TArg]])

	Waits for every thread in t to finish. Source   Edit   

proc pinToCpu[Arg](t: var Thread[Arg]; cpu: Natural)

	Pins a thread to a CPU.

	In other words sets a thread's affinity. If you don't know what this means, you shouldn't use this proc.
	Source   Edit   

proc running[TArg](t: Thread[TArg]): bool {.inline.}

	Returns true if t is running. Source   Edit   

Exports

Thread

Parsers

std/htmlparser


std/htmlparser
Source   Edit  

NOTE: The behaviour might change in future versions as it is not clear what "wild HTML the real world uses" really implies.

It can be used to parse a wild HTML document and output it as valid XHTML document (well, if you are lucky):

echo loadHtml("mydirty.html")

Every tag in the resulting tree is in lower case.

Note: The resulting XmlNode already uses the clientData field, so it cannot be used by clients of this library.
Example: Transforming hyperlinks

This code demonstrates how you can iterate over all the tags in an HTML file and write back the modified version. In this case we look for hyperlinks ending with the extension .rst and convert them to .html.

import std/htmlparser
import std/xmltree  # To use '$' for XmlNode
import std/strtabs  # To access XmlAttributes
import std/os   	# To use splitFile
import std/strutils # To use cmpIgnoreCase

proc transformHyperlinks() =
  let html = loadHtml("input.html")
 
  for a in html.findAll("a"):
	if a.attrs.hasKey "href":
  	let (dir, filename, ext) = splitFile(a.attrs["href"])
  	if cmpIgnoreCase(ext, ".rst") == 0:
    	a.attrs["href"] = dir / filename & ".html"
 
  writeFile("output.html", $html)

Imports

strutils, streams, parsexml, xmltree, unicode, strtabs, os

Types

HtmlTag = enum
  tagUnknown,           	## unknown HTML element
  tagA,                 	## the HTML `a` element
  tagAbbr,              	## the deprecated HTML `abbr` element
  tagAcronym,           	## the HTML `acronym` element
  tagAddress,           	## the HTML `address` element
  tagApplet,            	## the deprecated HTML `applet` element
  tagArea,              	## the HTML `area` element
  tagArticle,           	## the HTML `article` element
  tagAside,             	## the HTML `aside` element
  tagAudio,             	## the HTML `audio` element
  tagB,                 	## the HTML `b` element
  tagBase,              	## the HTML `base` element
  tagBdi,               	## the HTML `bdi` element
  tagBdo,               	## the deprecated HTML `dbo` element
  tagBasefont,          	## the deprecated HTML `basefont` element
  tagBig,               	## the HTML `big` element
  tagBlockquote,        	## the HTML `blockquote` element
  tagBody,              	## the HTML `body` element
  tagBr,                	## the HTML `br` element
  tagButton,            	## the HTML `button` element
  tagCanvas,            	## the HTML `canvas` element
  tagCaption,           	## the HTML `caption` element
  tagCenter,            	## the deprecated HTML `center` element
  tagCite,              	## the HTML `cite` element
  tagCode,              	## the HTML `code` element
  tagCol,               	## the HTML `col` element
  tagColgroup,          	## the HTML `colgroup` element
  tagCommand,           	## the HTML `command` element
  tagDatalist,          	## the HTML `datalist` element
  tagDd,                	## the HTML `dd` element
  tagDel,               	## the HTML `del` element
  tagDetails,           	## the HTML `details` element
  tagDfn,               	## the HTML `dfn` element
  tagDialog,            	## the HTML `dialog` element
  tagDiv,               	## the HTML `div` element
  tagDir,               	## the deprecated HTLM `dir` element
  tagDl,                	## the HTML `dl` element
  tagDt,                	## the HTML `dt` element
  tagEm,                	## the HTML `em` element
  tagEmbed,             	## the HTML `embed` element
  tagFieldset,          	## the HTML `fieldset` element
  tagFigcaption,        	## the HTML `figcaption` element
  tagFigure,            	## the HTML `figure` element
  tagFont,              	## the deprecated HTML `font` element
  tagFooter,            	## the HTML `footer` element
  tagForm,              	## the HTML `form` element
  tagFrame,             	## the HTML `frame` element
  tagFrameset,          	## the deprecated HTML `frameset` element
  tagH1,                	## the HTML `h1` element
  tagH2,                	## the HTML `h2` element
  tagH3,                	## the HTML `h3` element
  tagH4,                	## the HTML `h4` element
  tagH5,                	## the HTML `h5` element
  tagH6,                	## the HTML `h6` element
  tagHead,              	## the HTML `head` element
  tagHeader,            	## the HTML `header` element
  tagHgroup,            	## the HTML `hgroup` element
  tagHtml,              	## the HTML `html` element
  tagHr,                	## the HTML `hr` element
  tagI,                 	## the HTML `i` element
  tagIframe,            	## the deprecated HTML `iframe` element
  tagImg,               	## the HTML `img` element
  tagInput,             	## the HTML `input` element
  tagIns,               	## the HTML `ins` element
  tagIsindex,           	## the deprecated HTML `isindex` element
  tagKbd,               	## the HTML `kbd` element
  tagKeygen,            	## the HTML `keygen` element
  tagLabel,             	## the HTML `label` element
  tagLegend,            	## the HTML `legend` element
  tagLi,                	## the HTML `li` element
  tagLink,              	## the HTML `link` element
  tagMap,               	## the HTML `map` element
  tagMark,              	## the HTML `mark` element
  tagMenu,              	## the deprecated HTML `menu` element
  tagMeta,              	## the HTML `meta` element
  tagMeter,             	## the HTML `meter` element
  tagNav,               	## the HTML `nav` element
  tagNobr,              	## the deprecated HTML `nobr` element
  tagNoframes,          	## the deprecated HTML `noframes` element
  tagNoscript,          	## the HTML `noscript` element
  tagObject,            	## the HTML `object` element
  tagOl,                	## the HTML `ol` element
  tagOptgroup,          	## the HTML `optgroup` element
  tagOption,            	## the HTML `option` element
  tagOutput,            	## the HTML `output` element
  tagP,                 	## the HTML `p` element
  tagParam,             	## the HTML `param` element
  tagPre,               	## the HTML `pre` element
  tagProgress,          	## the HTML `progress` element
  tagQ,                 	## the HTML `q` element
  tagRp,                	## the HTML `rp` element
  tagRt,                	## the HTML `rt` element
  tagRuby,              	## the HTML `ruby` element
  tagS,                 	## the deprecated HTML `s` element
  tagSamp,              	## the HTML `samp` element
  tagScript,            	## the HTML `script` element
  tagSection,           	## the HTML `section` element
  tagSelect,            	## the HTML `select` element
  tagSmall,             	## the HTML `small` element
  tagSource,            	## the HTML `source` element
  tagSpan,              	## the HTML `span` element
  tagStrike,            	## the deprecated HTML `strike` element
  tagStrong,            	## the HTML `strong` element
  tagStyle,             	## the HTML `style` element
  tagSub,               	## the HTML `sub` element
  tagSummary,           	## the HTML `summary` element
  tagSup,               	## the HTML `sup` element
  tagTable,             	## the HTML `table` element
  tagTbody,             	## the HTML `tbody` element
  tagTd,                	## the HTML `td` element
  tagTextarea,          	## the HTML `textarea` element
  tagTfoot,             	## the HTML `tfoot` element
  tagTh,                	## the HTML `th` element
  tagThead,             	## the HTML `thead` element
  tagTime,              	## the HTML `time` element
  tagTitle,             	## the HTML `title` element
  tagTr,                	## the HTML `tr` element
  tagTrack,             	## the HTML `track` element
  tagTt,                	## the HTML `tt` element
  tagU,                 	## the deprecated HTML `u` element
  tagUl,                	## the HTML `ul` element
  tagVar,               	## the HTML `var` element
  tagVideo,             	## the HTML `video` element
  tagWbr                 	## the HTML `wbr` element

	list of all supported HTML tags; order will always be alphabetically Source   Edit   

Consts

BlockTags = {tagAddress, tagBlockquote, tagCenter, tagDel, tagDir, tagDiv,
         	tagDl, tagFieldset, tagForm, tagH1, tagH2, tagH3, tagH4, tagH5,
         	tagH6, tagHr, tagIns, tagIsindex, tagMenu, tagNoframes,
         	tagNoscript, tagOl, tagP, tagPre, tagTable, tagUl, tagCenter,
         	tagDir, tagIsindex, tagMenu, tagNoframes}

	Source   Edit   

InlineTags = {tagA, tagAbbr, tagAcronym, tagApplet, tagB, tagBasefont, tagBdo,
          	tagBig, tagBr, tagButton, tagCite, tagCode, tagDel, tagDfn, tagEm,
          	tagFont, tagI, tagImg, tagIns, tagInput, tagIframe, tagKbd,
          	tagLabel, tagMap, tagObject, tagQ, tagSamp, tagScript, tagSelect,
          	tagSmall, tagSpan, tagStrong, tagSub, tagSup, tagTextarea, tagTt,
          	tagVar, tagApplet, tagBasefont, tagFont, tagIframe, tagU, tagS,
          	tagStrike, tagWbr}

	Source   Edit   

SingleTags = {tagArea, tagBase, tagBasefont, tagBr, tagCol, tagFrame, tagHr,
          	tagImg, tagIsindex, tagLink, tagMeta, tagParam, tagWbr, tagSource}

	Source   Edit   

tagToStr = ["a", "abbr", "acronym", "address", "applet", "area", "article",
        	"aside", "audio", "b", "base", "basefont", "bdi", "bdo", "big",
        	"blockquote", "body", "br", "button", "canvas", "caption", "center",
        	"cite", "code", "col", "colgroup", "command", "datalist", "dd",
        	"del", "details", "dfn", "dialog", "div", "dir", "dl", "dt", "em",
        	"embed", "fieldset", "figcaption", "figure", "font", "footer",
        	"form", "frame", "frameset", "h1", "h2", "h3", "h4", "h5", "h6",
        	"head", "header", "hgroup", "html", "hr", "i", "iframe", "img",
        	"input", "ins", "isindex", "kbd", "keygen", "label", "legend", "li",
        	"link", "map", "mark", "menu", "meta", "meter", "nav", "nobr",
        	"noframes", "noscript", "object", "ol", "optgroup", "option",
        	"output", "p", "param", "pre", "progress", "q", "rp", "rt", "ruby",
        	"s", "samp", "script", "section", "select", "small", "source",
        	"span", "strike", "strong", "style", "sub", "summary", "sup",
        	"table", "tbody", "td", "textarea", "tfoot", "th", "thead", "time",
        	"title", "tr", "track", "tt", "u", "ul", "var", "video", "wbr"]

	Source   Edit   

Procs

proc entityToRune(entity: string): Rune {.....}

Converts an HTML entity name like &Uuml; or values like &#220; or &#x000DC; to its UTF-8 equivalent. Rune(0) is returned if the entity name is unknown.

Example:

import std/unicode
doAssert entityToRune("") == Rune(0)
doAssert entityToRune("a") == Rune(0)
doAssert entityToRune("gt") == ">".runeAt(0)
doAssert entityToRune("Uuml") == "Ü".runeAt(0)
doAssert entityToRune("quest") == "?".runeAt(0)
doAssert entityToRune("#x0003F") == "?".runeAt(0)

	Source   Edit   

proc entityToUtf8(entity: string): string {.....}

Converts an HTML entity name like &Uuml; or values like &#220; or &#x000DC; to its UTF-8 equivalent. "" is returned if the entity name is unknown. The HTML parser already converts entities to UTF-8.

Example:

const sigma = "Σ"
doAssert entityToUtf8("") == ""
doAssert entityToUtf8("a") == ""
doAssert entityToUtf8("gt") == ">"
doAssert entityToUtf8("Uuml") == "Ü"
doAssert entityToUtf8("quest") == "?"
doAssert entityToUtf8("#63") == "?"
doAssert entityToUtf8("Sigma") == sigma
doAssert entityToUtf8("#931") == sigma
doAssert entityToUtf8("#0931") == sigma
doAssert entityToUtf8("#x3A3") == sigma
doAssert entityToUtf8("#x03A3") == sigma
doAssert entityToUtf8("#x3a3") == sigma
doAssert entityToUtf8("#X3a3") == sigma

	Source   Edit   

proc htmlTag(n: XmlNode): HtmlTag {.....}

	Gets n's tag as a HtmlTag. Source   Edit   

proc htmlTag(s: string): HtmlTag {.....}

	Converts s to a HtmlTag. If s is no HTML tag, tagUnknown is returned. Source   Edit   

proc loadHtml(path: string): XmlNode {.....}

	Loads and parses HTML from file specified by path, and returns a XmlNode. All parsing errors are ignored. Source   Edit   

proc loadHtml(path: string; errors: var seq[string]): XmlNode {.
	....}

	Loads and parses HTML from file specified by path, and returns a XmlNode. Every occurred parsing error is added to the errors sequence. Source   Edit   

proc parseHtml(html: string): XmlNode {.....}

	Parses the HTML from string html and returns a XmlNode. All parsing errors are ignored. Source   Edit   

proc parseHtml(s: Stream): XmlNode {.....}

	Parses the HTML from stream s and returns a XmlNode. All parsing errors are ignored. Source   Edit   

proc parseHtml(s: Stream; filename: string; errors: var seq[string]): XmlNode {.
	....}

	Parses the XML from stream s and returns a XmlNode. Every occurred parsing error is added to the errors sequence. Source   Edit   

proc runeToEntity(rune: Rune): string {.....}

converts a Rune to its numeric HTML entity equivalent.

Example:

import std/unicode
doAssert runeToEntity(Rune(0)) == ""
doAssert runeToEntity(Rune(-1)) == ""
doAssert runeToEntity("Ü".runeAt(0)) == "#220"
doAssert runeToEntity("∈".runeAt(0)) == "#8712"

	Source   Edit   


std/json


std/json
Source   Edit  

This module implements a simple high performance JSON parser. JSON (JavaScript Object Notation) is a lightweight data-interchange format that is easy for humans to read and write (unlike XML). It is easy for machines to parse and generate. JSON is based on a subset of the JavaScript Programming Language, Standard ECMA-262 3rd Edition - December 1999.
See also

	std/parsejson
	std/jsonutils
	std/marshal
	std/jscore

Overview
Parsing JSON

JSON often arrives into your program (via an API or a file) as a string. The first step is to change it from its serialized form into a nested object structure called a JsonNode.

The parseJson procedure takes a string containing JSON and returns a JsonNode object. This is an object variant and it is either a JObject, JArray, JString, JInt, JFloat, JBool or JNull. You check the kind of this object variant by using the kind accessor.

For a JsonNode who's kind is JObject, you can access its fields using the [] operator. The following example shows how to do this:

import std/json

let jsonNode = parseJson("""{"key": 3.14}""")

doAssert jsonNode.kind == JObject
doAssert jsonNode["key"].kind == JFloat

Reading values

Once you have a JsonNode, retrieving the values can then be achieved by using one of the helper procedures, which include:

	getInt
	getFloat
	getStr
	getBool

To retrieve the value of "key" you can do the following:

import std/json

let jsonNode = parseJson("""{"key": 3.14}""")

doAssert jsonNode["key"].getFloat() == 3.14

Important: The [] operator will raise an exception when the specified field does not exist.
Handling optional keys

By using the {} operator instead of [], it will return nil when the field is not found. The get-family of procedures will return a type's default value when called on nil.

import std/json

let jsonNode = parseJson("{}")

doAssert jsonNode{"nope"}.getInt() == 0
doAssert jsonNode{"nope"}.getFloat() == 0
doAssert jsonNode{"nope"}.getStr() == ""
doAssert jsonNode{"nope"}.getBool() == false

Using default values

The get-family helpers also accept an additional parameter which allow you to fallback to a default value should the key's values be null:

import std/json

let jsonNode = parseJson("""{"key": 3.14, "key2": null}""")

doAssert jsonNode["key"].getFloat(6.28) == 3.14
doAssert jsonNode["key2"].getFloat(3.14) == 3.14
doAssert jsonNode{"nope"}.getFloat(3.14) == 3.14 # note the {}

Unmarshalling

In addition to reading dynamic data, Nim can also unmarshal JSON directly into a type with the to macro.

Note: Use Option for keys sometimes missing in json responses, and backticks around keys with a reserved keyword as name.

import std/json
import std/options

type
  User = object
	name: string
	age: int
	`type`: Option[string]

let userJson = parseJson("""{ "name": "Nim", "age": 12 }""")
let user = to(userJson, User)
if user.`type`.isSome():
  assert user.`type`.get() != "robot"

Creating JSON

This module can also be used to comfortably create JSON using the %* operator:

import std/json

var hisName = "John"
let herAge = 31
var j = %*
  [
	{ "name": hisName, "age": 30 },
	{ "name": "Susan", "age": herAge }
  ]

var j2 = %* {"name": "Isaac", "books": ["Robot Dreams"]}
j2["details"] = %* {"age":35, "pi":3.1415}
echo j2

See also: std/jsonutils for hookable json serialization/deserialization of arbitrary types.

Example:

import std/json
## Note: for JObject, key ordering is preserved, unlike in some languages,
## this is convenient for some use cases. Example:
type Foo = object
  a1, a2, a0, a3, a4: int
doAssert $(%* Foo()) == """{"a1":0,"a2":0,"a0":0,"a3":0,"a4":0}"""

Imports

hashes, tables, strutils, lexbase, streams, macros, parsejson, options, since

Types

JsonNode = ref JsonNodeObj

	JSON node Source   Edit   

JsonNodeKind = enum
  JNull, JBool, JInt, JFloat, JString, JObject, JArray

	possible JSON node types Source   Edit   

JsonNodeObj {.acyclic.} = object
  case kind*: JsonNodeKind
  of JString:
	str*: string
  of JInt:
	num*: BiggestInt
  of JFloat:
	fnum*: float
  of JBool:
	bval*: bool
  of JNull:
	nil
  of JObject:
	fields*: OrderedTable[string, JsonNode]
  of JArray:
	elems*: seq[JsonNode]

	Source   Edit   

Procs

proc `$`(node: JsonNode): string {.....}

	Converts node to its JSON Representation on one line. Source   Edit   

proc `%`(b: bool): JsonNode {.....}

	Generic constructor for JSON data. Creates a new JBool JsonNode. Source   Edit   

proc `%`(keyVals: openArray[tuple[key: string, val: JsonNode]]): JsonNode {.
	....}

	Generic constructor for JSON data. Creates a new JObject JsonNode Source   Edit   

proc `%`(n: BiggestInt): JsonNode {.....}

	Generic constructor for JSON data. Creates a new JInt JsonNode. Source   Edit   

proc `%`(n: BiggestUInt): JsonNode {.....}

	Generic constructor for JSON data. Creates a new JInt JsonNode. Source   Edit   

proc `%`(n: float): JsonNode {.....}

Generic constructor for JSON data. Creates a new JFloat JsonNode.

Example:

assert $(%[NaN, Inf, -Inf, 0.0, -0.0, 1.0, 1e-2]) == """["nan","inf","-inf",0.0,-0.0,1.0,0.01]"""
assert (%NaN).kind == JString
assert (%0.0).kind == JFloat

	Source   Edit   

proc `%`(n: int): JsonNode {.....}

	Generic constructor for JSON data. Creates a new JInt JsonNode. Source   Edit   

proc `%`(n: uint): JsonNode {.....}

	Generic constructor for JSON data. Creates a new JInt JsonNode. Source   Edit   

proc `%`(o: enum): JsonNode

	Construct a JsonNode that represents the specified enum value as a string. Creates a new JString JsonNode. Source   Edit   

proc `%`(o: ref object): JsonNode

	Generic constructor for JSON data. Creates a new JObject JsonNode Source   Edit   

proc `%`(s: string): JsonNode {.....}

	Generic constructor for JSON data. Creates a new JString JsonNode. Source   Edit   

proc `%`[T: object](o: T): JsonNode

	Construct JsonNode from tuples and objects. Source   Edit   

proc `%`[T](elements: openArray[T]): JsonNode

	Generic constructor for JSON data. Creates a new JArray JsonNode Source   Edit   

proc `%`[T](opt: Option[T]): JsonNode

	Generic constructor for JSON data. Creates a new JNull JsonNode if opt is empty, otherwise it delegates to the underlying value. Source   Edit   

proc `%`[T](table: Table[string, T] | OrderedTable[string, T]): JsonNode

	Generic constructor for JSON data. Creates a new JObject JsonNode. Source   Edit   

proc `==`(a, b: JsonNode): bool {.noSideEffect, ....}

	Check two nodes for equality Source   Edit   

proc `[]`(node: JsonNode; index: BackwardsIndex): JsonNode {.inline, ....}

Gets the node at array.len-i in an array through the ^ operator.

i.e. j[^i] is a shortcut for j[j.len-i].

Example:

let
  j = parseJson("[1,2,3,4,5]")

doAssert j[^1].getInt == 5
doAssert j[^2].getInt == 4

	Source   Edit   

proc `[]`(node: JsonNode; index: int): JsonNode {.inline, ....}

	Gets the node at index in an Array. Result is undefined if index is out of bounds, but as long as array bound checks are enabled it will result in an exception. Source   Edit   

proc `[]`(node: JsonNode; name: string): JsonNode {.inline, ....}

	Gets a field from a JObject, which must not be nil. If the value at name does not exist, raises KeyError. Source   Edit   

proc `[]`[U, V](a: JsonNode; x: HSlice[U, V]): JsonNode

Slice operation for JArray.

Returns the inclusive range [a[x.a], a[x.b]]:

Example:

import json
let arr = %[0,1,2,3,4,5]
doAssert arr[2..4] == %[2,3,4]
doAssert arr[2..^2] == %[2,3,4]
doAssert arr[^4..^2] == %[2,3,4]

	Source   Edit   

proc `[]=`(obj: JsonNode; key: string; val: JsonNode) {.inline, ....}

	Sets a field from a JObject. Source   Edit   

proc add(father, child: JsonNode) {.....}

	Adds child to a JArray node father. Source   Edit   

proc add(obj: JsonNode; key: string; val: JsonNode) {.....}

	Sets a field from a JObject. Source   Edit   

proc contains(node: JsonNode; key: string): bool {.....}

	Checks if key exists in node. Source   Edit   

proc contains(node: JsonNode; val: JsonNode): bool {.....}

	Checks if val exists in array node. Source   Edit   

proc copy(p: JsonNode): JsonNode {.....}

	Performs a deep copy of p. Source   Edit   

proc delete(obj: JsonNode; key: string) {.....}

	Deletes obj[key]. Source   Edit   

proc escapeJson(s: string): string {.....}

	Converts a string s to its JSON representation with quotes. Source   Edit   

proc escapeJson(s: string; result: var string) {.....}

	Converts a string s to its JSON representation with quotes. Appends to result. Source   Edit   

proc escapeJsonUnquoted(s: string): string {.....}

	Converts a string s to its JSON representation without quotes. Source   Edit   

proc escapeJsonUnquoted(s: string; result: var string) {.....}

	Converts a string s to its JSON representation without quotes. Appends to result. Source   Edit   

proc getBiggestInt(n: JsonNode; default: BiggestInt = 0): BiggestInt {.
	....}

	Retrieves the BiggestInt value of a JInt JsonNode.

	Returns default if n is not a JInt, or if n is nil.
	Source   Edit   

proc getBool(n: JsonNode; default: bool = false): bool {.....}

	Retrieves the bool value of a JBool JsonNode.

	Returns default if n is not a JBool, or if n is nil.
	Source   Edit   

proc getElems(n: JsonNode; default: seq[JsonNode] = @[]): seq[JsonNode] {.
	....}

	Retrieves the array of a JArray JsonNode.

	Returns default if n is not a JArray, or if n is nil.
	Source   Edit   

proc getFields(n: JsonNode; default = initOrderedTable(2)): OrderedTable[string,
	JsonNode] {.....}

	Retrieves the key, value pairs of a JObject JsonNode.

	Returns default if n is not a JObject, or if n is nil.
	Source   Edit   

proc getFloat(n: JsonNode; default: float = 0.0): float {.....}

	Retrieves the float value of a JFloat JsonNode.

	Returns default if n is not a JFloat or JInt, or if n is nil.
	Source   Edit   

proc getInt(n: JsonNode; default: int = 0): int {.....}

	Retrieves the int value of a JInt JsonNode.

	Returns default if n is not a JInt, or if n is nil.
	Source   Edit   

proc getOrDefault(node: JsonNode; key: string): JsonNode {.....}

	Gets a field from a node. If node is nil or not an object or value at key does not exist, returns nil Source   Edit   

proc getStr(n: JsonNode; default: string = ""): string {.....}

	Retrieves the string value of a JString JsonNode.

	Returns default if n is not a JString, or if n is nil.
	Source   Edit   

proc hash(n: JsonNode): Hash {.noSideEffect, ....}

	Compute the hash for a JSON node Source   Edit   

proc hash(n: OrderedTable[string, JsonNode]): Hash {.noSideEffect,
	....}

	Source   Edit   

proc hasKey(node: JsonNode; key: string): bool {.....}

	Checks if key exists in node. Source   Edit   

proc len(n: JsonNode): int {.....}

	If n is a JArray, it returns the number of elements. If n is a JObject, it returns the number of pairs. Else it returns 0. Source   Edit   

proc newJArray(): JsonNode {.....}

	Creates a new JArray JsonNode Source   Edit   

proc newJBool(b: bool): JsonNode {.....}

	Creates a new JBool JsonNode. Source   Edit   

proc newJFloat(n: float): JsonNode {.....}

	Creates a new JFloat JsonNode. Source   Edit   

proc newJInt(n: BiggestInt): JsonNode {.....}

	Creates a new JInt JsonNode. Source   Edit   

proc newJNull(): JsonNode {.....}

	Creates a new JNull JsonNode. Source   Edit   

proc newJObject(): JsonNode {.....}

	Creates a new JObject JsonNode Source   Edit   

proc newJString(s: string): JsonNode {.....}

	Creates a new JString JsonNode. Source   Edit   

proc parseFile(filename: string): JsonNode {.
	....}

	Parses file into a JsonNode. If file contains extra data, it will raise JsonParsingError. Source   Edit   

proc parseJson(buffer: string; rawIntegers = false; rawFloats = false): JsonNode {.
	....}

	Parses JSON from buffer. If buffer contains extra data, it will raise JsonParsingError. If rawIntegers is true, integer literals will not be converted to a JInt field but kept as raw numbers via JString. If rawFloats is true, floating point literals will not be converted to a JFloat field but kept as raw numbers via JString. Source   Edit   

proc parseJson(s: Stream; filename: string = ""; rawIntegers = false;
           	rawFloats = false): JsonNode {.
	....}

	Parses from a stream s into a JsonNode. filename is only needed for nice error messages. If s contains extra data, it will raise JsonParsingError. This closes the stream s after it's done. If rawIntegers is true, integer literals will not be converted to a JInt field but kept as raw numbers via JString. If rawFloats is true, floating point literals will not be converted to a JFloat field but kept as raw numbers via JString. Source   Edit   

proc pretty(node: JsonNode; indent = 2): string {.....}

Returns a JSON Representation of node, with indentation and on multiple lines.

Similar to prettyprint in Python.

Example:

let j = %* {"name": "Isaac", "books": ["Robot Dreams"],
        	"details": {"age": 35, "pi": 3.1415}}
doAssert pretty(j) == """
{
  "name": "Isaac",
  "books": [
	"Robot Dreams"
  ],
  "details": {
	"age": 35,
	"pi": 3.1415
  }
}"""

	Source   Edit   

proc to[T](node: JsonNode; t: typedesc[T]): T

Unmarshals the specified node into the object type specified.

Known limitations:

	Heterogeneous arrays are not supported.
	Sets in object variants are not supported.
	Not nil annotations are not supported.

Example:

let jsonNode = parseJson("""
  	{
    	"person": {
      	"name": "Nimmer",
      	"age": 21
    	},
    	"list": [1, 2, 3, 4]
  	}
	""")

type
  Person = object
	name: string
	age: int

  Data = object
	person: Person
	list: seq[int]

var data = to(jsonNode, Data)
doAssert data.person.name == "Nimmer"
doAssert data.person.age == 21
doAssert data.list == @[1, 2, 3, 4]

	Source   Edit   

proc toUgly(result: var string; node: JsonNode) {.....}

	Converts node to its JSON Representation, without regard for human readability. Meant to improve $ string conversion performance.

	JSON representation is stored in the passed result

	This provides higher efficiency than the pretty procedure as it does not attempt to format the resulting JSON to make it human readable.
	Source   Edit   

proc `{}`(node: JsonNode; index: varargs[int]): JsonNode {.....}

	Traverses the node and gets the given value. If any of the indexes do not exist, returns nil. Also returns nil if one of the intermediate data structures is not an array. Source   Edit   

proc `{}`(node: JsonNode; key: string): JsonNode {.....}

	Gets a field from a node. If node is nil or not an object or value at key does not exist, returns nil Source   Edit   

proc `{}`(node: JsonNode; keys: varargs[string]): JsonNode {.....}

Traverses the node and gets the given value. If any of the keys do not exist, returns nil. Also returns nil if one of the intermediate data structures is not an object.

This proc can be used to create tree structures on the fly (sometimes called autovivification):

Example:

var myjson = %* {"parent": {"child": {"grandchild": 1}}}
doAssert myjson{"parent", "child", "grandchild"} == newJInt(1)

	Source   Edit   

proc `{}=`(node: JsonNode; keys: varargs[string]; value: JsonNode) {.
	....}

	Traverses the node and tries to set the value at the given location to value. If any of the keys are missing, they are added. Source   Edit   

Iterators

iterator items(node: JsonNode): JsonNode {.....}

	Iterator for the items of node. node has to be a JArray. Source   Edit   

iterator keys(node: JsonNode): string {.....}

	Iterator for the keys in node. node has to be a JObject. Source   Edit   

iterator mitems(node: var JsonNode): var JsonNode {.....}

	Iterator for the items of node. node has to be a JArray. Items can be modified. Source   Edit   

iterator mpairs(node: var JsonNode): tuple[key: string, val: var JsonNode] {.
	....}

	Iterator for the child elements of node. node has to be a JObject. Values can be modified Source   Edit   

iterator pairs(node: JsonNode): tuple[key: string, val: JsonNode] {.....}

	Iterator for the child elements of node. node has to be a JObject. Source   Edit   

iterator parseJsonFragments(s: Stream; filename: string = "";
                        	rawIntegers = false; rawFloats = false): JsonNode {.
	....}

	Parses from a stream s into JsonNodes. filename is only needed for nice error messages. The JSON fragments are separated by whitespace. This can be substantially faster than the comparable loop for x in splitWhitespace(s): yield parseJson(x). This closes the stream s after it's done. If rawIntegers is true, integer literals will not be converted to a JInt field but kept as raw numbers via JString. If rawFloats is true, floating point literals will not be converted to a JFloat field but kept as raw numbers via JString. Source   Edit   

Macros

macro `%*`(x: untyped): untyped

	Convert an expression to a JsonNode directly, without having to specify % for every element. Source   Edit   

macro isRefSkipDistinct(arg: typed): untyped

	internal only, do not use Source   Edit   

Templates

template `%`(j: JsonNode): JsonNode

	Source   Edit   

Exports

$, $, $, $, $, $, JsonEventKind, JsonError, JsonParser, JsonKindError, open, open, open, open, open, open, close, close, close, close, close, str, getInt, getFloat, kind, kind, getColumn, getLine, getFilename, errorMsg, errorMsgExpected, next, JsonParsingError, raiseParseErr, nimIdentNormalize


std/lexbase


std/lexbase
Source   Edit  

This module implements a base object of a lexer with efficient buffer handling. Only at line endings checks are necessary if the buffer needs refilling.
Imports

strutils, streams

Types

BaseLexer = object of RootObj
  bufpos*: int           	## the current position within the buffer
  buf*: string           	## the buffer itself
  ## the input stream
  lineNumber*: int       	## the current line number
  offsetBase*: int

	the base lexer. Inherit your lexer from this object. Source   Edit   

Consts

EndOfFile = '\x00'

	end of file marker Source   Edit   

NewLines = {'\r', '\n'}

	Source   Edit   

Procs

proc close(L: var BaseLexer) {.....}

	closes the base lexer. This closes L's associated stream too. Source   Edit   

proc getColNumber(L: BaseLexer; pos: int): int {.....}

	retrieves the current column. Source   Edit   

proc getCurrentLine(L: BaseLexer; marker: bool = true): string {.....}

	retrieves the current line. Source   Edit   

proc handleCR(L: var BaseLexer; pos: int): int {.....}

	Call this if you scanned over 'c' in the buffer; it returns the position to continue the scanning from. pos must be the position of the 'c'. Source   Edit   

proc handleLF(L: var BaseLexer; pos: int): int {.....}

	Call this if you scanned over 'L' in the buffer; it returns the position to continue the scanning from. pos must be the position of the 'L'. Source   Edit   

proc handleRefillChar(L: var BaseLexer; pos: int): int {.
	....}

	Call this if a terminator character other than a new line is scanned at pos; it returns the position to continue the scanning from. Source   Edit   

proc open(L: var BaseLexer; input: Stream; bufLen: int = 8192;
      	refillChars: set[char] = NewLines) {.....}

	inits the BaseLexer with a stream to read from. Source   Edit   


std/parsecfg


std/parsecfg
Source   Edit  

The parsecfg module implements a high performance configuration file parser. The configuration file's syntax is similar to the Windows .ini format, but much more powerful, as it is not a line based parser. String literals, raw string literals and triple quoted string literals are supported as in the Nim programming language.

Example of how a configuration file may look like:

# This is a comment.
; this too.

[Common]
cc=gcc 	# '=' and ':' are the same
--foo="bar"   # '--cc' and 'cc' are the same, 'bar' and '"bar"' are the same (except for '#')
macrosym: "#"  # Note that '#' is interpreted as a comment without the quotation
--verbose

[Windows]
isConsoleApplication=False ; another comment

[Posix]
isConsoleApplication=True

key1: "in this string backslash escapes are interpreted\n"
key2: r"in this string not"
key3: """triple quotes strings
are also supported. They may span
multiple lines."""

--"long option with spaces": r"c:\myfiles\test.txt"

Here is an example of how to use the configuration file parser:

Example: cmd: -r:off

import std/parsecfg
import std/[strutils, streams]

let configFile = "example.ini"
var f = newFileStream(configFile, fmRead)
assert f != nil, "cannot open " & configFile
var p: CfgParser
open(p, f, configFile)
while true:
  var e = next(p)
  case e.kind
  of cfgEof: break
  of cfgSectionStart:   ## a `[section]` has been parsed
	echo "new section: " & e.section
  of cfgKeyValuePair:
	echo "key-value-pair: " & e.key & ": " & e.value
  of cfgOption:
	echo "command: " & e.key & ": " & e.value
  of cfgError:
	echo e.msg
close(p)

Configuration file example

charset = "utf-8"
[Package]
name = "hello"
--threads:on
[Author]
name = "nim-lang"
website = "nim-lang.org"

Creating a configuration file

Example:

import std/parsecfg
var dict = newConfig()
dict.setSectionKey("","charset", "utf-8")
dict.setSectionKey("Package", "name", "hello")
dict.setSectionKey("Package", "--threads", "on")
dict.setSectionKey("Author", "name", "nim-lang")
dict.setSectionKey("Author", "website", "nim-lang.org")
assert $dict == """
charset=utf-8
[Package]
name=hello
--threads:on
[Author]
name=nim-lang
website=nim-lang.org
"""

Reading a configuration file

Example: cmd: -r:off

import std/parsecfg
let dict = loadConfig("config.ini")
let charset = dict.getSectionValue("","charset")
let threads = dict.getSectionValue("Package","--threads")
let pname = dict.getSectionValue("Package","name")
let name = dict.getSectionValue("Author","name")
let website = dict.getSectionValue("Author","website")
echo pname & "\n" & name & "\n" & website

Modifying a configuration file

Example: cmd: -r:off

import std/parsecfg
var dict = loadConfig("config.ini")
dict.setSectionKey("Author", "name", "nim-lang")
dict.writeConfig("config.ini")

Deleting a section key in a configuration file

Example: cmd: -r:off

import std/parsecfg
var dict = loadConfig("config.ini")
dict.delSectionKey("Author", "website")
dict.writeConfig("config.ini")

Supported INI File structure

Example:

import std/parsecfg
import std/streams

var dict = loadConfig(newStringStream("""[Simple Values]
	key=value
	spaces in keys=allowed
	spaces in values=allowed as well
	spaces around the delimiter = obviously
	you can also use : to delimit keys from values
	[All Values Are Strings]
	values like this: 19990429
	or this: 3.14159265359
	are they treated as numbers : no
	integers floats and booleans are held as: strings
	can use the API to get converted values directly: true
	[No Values]
	key_without_value
	# empty string value is not allowed =
	[ Seletion A   ]
	space around section name will be ignored
	[You can use comments]
	# like this
	; or this
	# By default only in an empty line.
	# Inline comments can be harmful because they prevent users
	# from using the delimiting characters as parts of values.
	# That being said, this can be customized.
    	[Sections Can Be Indented]
        	can_values_be_as_well = True
        	does_that_mean_anything_special = False
        	purpose = formatting for readability
        	# Did I mention we can indent comments, too?
	""")
)

let section1 = "Simple Values"
assert dict.getSectionValue(section1, "key") == "value"
assert dict.getSectionValue(section1, "spaces in keys") == "allowed"
assert dict.getSectionValue(section1, "spaces in values") == "allowed as well"
assert dict.getSectionValue(section1, "spaces around the delimiter") == "obviously"
assert dict.getSectionValue(section1, "you can also use") == "to delimit keys from values"

let section2 = "All Values Are Strings"
assert dict.getSectionValue(section2, "values like this") == "19990429"
assert dict.getSectionValue(section2, "or this") == "3.14159265359"
assert dict.getSectionValue(section2, "are they treated as numbers") == "no"
assert dict.getSectionValue(section2, "integers floats and booleans are held as") == "strings"
assert dict.getSectionValue(section2, "can use the API to get converted values directly") == "true"

let section3 = "Seletion A"
assert dict.getSectionValue(section3,
  "space around section name will be ignored", "not an empty value") == ""

let section4 = "Sections Can Be Indented"
assert dict.getSectionValue(section4, "can_values_be_as_well") == "True"
assert dict.getSectionValue(section4, "does_that_mean_anything_special") == "False"
assert dict.getSectionValue(section4, "purpose") == "formatting for readability"

Imports

strutils, lexbase, streams, tables, decode_helpers, since

Types

CfgEvent = object of RootObj
  case kind*: CfgEventKind   ## the kind of the event
  of cfgEof:
	nil
  of cfgSectionStart:
	section*: string     	## `section` contains the name of the
                         	## parsed section start (syntax: `[section]`)
  of cfgKeyValuePair, cfgOption:
	key*, value*: string 	## contains the (key, value) pair if an option
                         	## of the form `--key: value` or an ordinary
                         	## `key= value` pair has been parsed.
                         	## `value==""` if it was not specified in the
                         	## configuration file.
  of cfgError:          	## the parser encountered an error: `msg`
	msg*: string         	## contains the error message. No exceptions
                         	## are thrown if a parse error occurs.

	describes a parsing event Source   Edit   

CfgEventKind = enum
  cfgEof,               	## end of file reached
  cfgSectionStart,      	## a `[section]` has been parsed
  cfgKeyValuePair,      	## a `key=value` pair has been detected
  cfgOption,            	## a `--key=value` command line option
  cfgError               	## an error occurred during parsing

	enumeration of all events that may occur when parsing Source   Edit   

CfgParser = object of BaseLexer

	the parser object. Source   Edit   

Config = OrderedTableRef[string, OrderedTableRef[string, string]]

	Source   Edit   

Procs

proc `$`(dict: Config): string {.....}

	Writes the contents of the table to string.
	Note: Comment statement will be ignored.
	Source   Edit   

proc close(c: var CfgParser) {.....}

	Closes the parser c and its associated input stream. Source   Edit   

proc delSection(dict: var Config; section: string) {.....}

	Deletes the specified section and all of its sub keys. Source   Edit   

proc delSectionKey(dict: var Config; section, key: string) {.....}

	Deletes the key of the specified section. Source   Edit   

proc errorStr(c: CfgParser; msg: string): string {.....}

	Returns a properly formatted error message containing current line and column information. Source   Edit   

proc getColumn(c: CfgParser): int {.....}

	Gets the current column the parser has arrived at. Source   Edit   

proc getFilename(c: CfgParser): string {.....}

	Gets the filename of the file that the parser processes. Source   Edit   

proc getLine(c: CfgParser): int {.....}

	Gets the current line the parser has arrived at. Source   Edit   

proc getSectionValue(dict: Config; section, key: string; defaultVal = ""): string {.
	....}

	Gets the key value of the specified Section. Returns the specified default value if the specified key does not exist. Source   Edit   

proc ignoreMsg(c: CfgParser; e: CfgEvent): string {.....}

	Returns a properly formatted warning message containing that an entry is ignored. Source   Edit   

proc loadConfig(filename: string): Config {.
	....}

	Loads the specified configuration file into a new Config instance. Source   Edit   

proc loadConfig(stream: Stream; filename: string = "[stream]"): Config {.
	....}

	Loads the specified configuration from stream into a new Config instance. filename parameter is only used for nicer error messages. Source   Edit   

proc newConfig(): Config {.....}

	Creates a new configuration table. Useful when wanting to create a configuration file. Source   Edit   

proc next(c: var CfgParser): CfgEvent {.....}

	Retrieves the first/next event. This controls the parser. Source   Edit   

proc open(c: var CfgParser; input: Stream; filename: string; lineOffset = 0) {.
	....}

	Initializes the parser with an input stream. Filename is only used for nice error messages. lineOffset can be used to influence the line number information in the generated error messages. Source   Edit   

proc setSectionKey(dict: var Config; section, key, value: string) {.
	....}

	Sets the Key value of the specified Section. Source   Edit   

proc warningStr(c: CfgParser; msg: string): string {.....}

	Returns a properly formatted warning message containing current line and column information. Source   Edit   

proc writeConfig(dict: Config; filename: string) {.....}

	Writes the contents of the table to the specified configuration file.
	Note: Comment statement will be ignored.
	Source   Edit   

proc writeConfig(dict: Config; stream: Stream) {.....}

	Writes the contents of the table to the specified stream.
	Note: Comment statement will be ignored.
	Source   Edit   

Iterators

iterator sections(dict: Config): lent string {.....}

	Iterates through the sections in the dict. Source   Edit   


std/parsecsv


std/parsecsv
Source   Edit  

This module implements a simple high performance CSV (comma separated value) parser.
Basic usage

import std/parsecsv
from std/os import paramStr
from std/streams import newFileStream

var s = newFileStream(paramStr(1), fmRead)
if s == nil:
  quit("cannot open the file" & paramStr(1))

var x: CsvParser
open(x, s, paramStr(1))
while readRow(x):
  echo "new row: "
  for val in items(x.row):
	echo "##", val, "##"
close(x)

For CSV files with a header row, the header can be read and then used as a reference for item access with rowEntry:

import std/parsecsv

# Prepare a file
let content = """One,Two,Three,Four
1,2,3,4
10,20,30,40
100,200,300,400
"""
writeFile("temp.csv", content)

var p: CsvParser
p.open("temp.csv")
p.readHeaderRow()
while p.readRow():
  echo "new row: "
  for col in items(p.headers):
	echo "##", col, ":", p.rowEntry(col), "##"
p.close()

See also

	streams module for using open proc and other stream processing (like close proc)
	parseopt module for a command line parser
	parsecfg module for a configuration file parser
	parsexml module for a XML / HTML parser
	parsesql module for a SQL parser
	other parsers for other parsers

Imports

lexbase, streams, os

Types

CsvError = object of IOError

	An exception that is raised if a parsing error occurs. Source   Edit   

CsvParser = object of BaseLexer
  row*: CsvRow
  headers*: seq[string]

	The parser object.

	It consists of two public fields:

    	row is the current row
    	headers are the columns that are defined in the csv file (read using readHeaderRow). Used with rowEntry).

	Source   Edit   

CsvRow = seq[string]

	A row in a CSV file. Source   Edit   

Procs

proc close(self: var CsvParser) {.inline, ....}

	Closes the parser self and its associated input stream. Source   Edit   

proc open(self: var CsvParser; filename: string; separator = ','; quote = '\"';
      	escape = '\x00'; skipInitialSpace = false) {.
	....}

Similar to the other open proc, but creates the file stream for you.

Example:

from std/os import removeFile
writeFile("tmp.csv", "One,Two,Three\n1,2,3\n10,20,300")
var parser: CsvParser
parser.open("tmp.csv")
parser.close()
removeFile("tmp.csv")

	Source   Edit   

proc open(self: var CsvParser; input: Stream; filename: string; separator = ',';
      	quote = '\"'; escape = '\x00'; skipInitialSpace = false) {.
	....}

Initializes the parser with an input stream. Filename is only used for nice error messages. The parser's behaviour can be controlled by the diverse optional parameters:

	separator: character used to separate fields
	quote: Used to quote fields containing special characters like separator, quote or new-line characters. '\0' disables the parsing of quotes.
	escape: removes any special meaning from the following character; '\0' disables escaping; if escaping is disabled and quote is not '\0', two quote characters are parsed one literal quote character.
	skipInitialSpace: If true, whitespace immediately following the separator is ignored.

See also:

	open proc which creates the file stream for you

Example:

import std/streams
var strm = newStringStream("One,Two,Three\n1,2,3\n10,20,30")
var parser: CsvParser
parser.open(strm, "tmp.csv")
parser.close()
strm.close()

	Source   Edit   

proc processedRows(self: var CsvParser): int {.inline, ....}

Returns number of the processed rows.

But even if readRow arrived at EOF then processed rows counter is incremented.

Example:

import std/streams

var strm = newStringStream("One,Two,Three\n1,2,3")
var parser: CsvParser
parser.open(strm, "tmp.csv")
doAssert parser.readRow()
doAssert parser.processedRows() == 1
doAssert parser.readRow()
doAssert parser.processedRows() == 2
## Even if `readRow` arrived at EOF then `processedRows` is incremented.
doAssert parser.readRow() == false
doAssert parser.processedRows() == 3
doAssert parser.readRow() == false
doAssert parser.processedRows() == 4
parser.close()
strm.close()

	Source   Edit   

proc readHeaderRow(self: var CsvParser) {.....}

Reads the first row and creates a look-up table for column numbers See also:

	rowEntry proc

Example:

import std/streams

var strm = newStringStream("One,Two,Three\n1,2,3")
var parser: CsvParser
parser.open(strm, "tmp.csv")

parser.readHeaderRow()
doAssert parser.headers == @["One", "Two", "Three"]
doAssert parser.row == @["One", "Two", "Three"]

doAssert parser.readRow()
doAssert parser.headers == @["One", "Two", "Three"]
doAssert parser.row == @["1", "2", "3"]

parser.close()
strm.close()

	Source   Edit   

proc readRow(self: var CsvParser; columns = 0): bool {.
	....}

Reads the next row; if columns > 0, it expects the row to have exactly this many columns. Returns false if the end of the file has been encountered else true.

Blank lines are skipped.

Example:

import std/streams
var strm = newStringStream("One,Two,Three\n1,2,3\n\n10,20,30")
var parser: CsvParser
parser.open(strm, "tmp.csv")
doAssert parser.readRow()
doAssert parser.row == @["One", "Two", "Three"]
doAssert parser.readRow()
doAssert parser.row == @["1", "2", "3"]
## Blank lines are skipped.
doAssert parser.readRow()
doAssert parser.row == @["10", "20", "30"]

var emptySeq: seq[string]
doAssert parser.readRow() == false
doAssert parser.row == emptySeq
doAssert parser.readRow() == false
doAssert parser.row == emptySeq

parser.close()
strm.close()

	Source   Edit   

proc rowEntry(self: var CsvParser; entry: string): var string {.
	....}

Accesses a specified entry from the current row.

Assumes that readHeaderRow has already been called.

If specified entry does not exist, raises KeyError.

Example:

import std/streams
var strm = newStringStream("One,Two,Three\n1,2,3\n\n10,20,30")
var parser: CsvParser
parser.open(strm, "tmp.csv")
## Requires calling `readHeaderRow`.
parser.readHeaderRow()
doAssert parser.readRow()
doAssert parser.rowEntry("One") == "1"
doAssert parser.rowEntry("Two") == "2"
doAssert parser.rowEntry("Three") == "3"
doAssertRaises(KeyError):
  discard parser.rowEntry("NonexistentEntry")
parser.close()
strm.close()

	Source   Edit   

std/parsejson


std/parsejson
Source   Edit  

This module implements a json parser. It is used and exported by the json standard library module, but can also be used in its own right.
Imports

strutils, lexbase, streams, unicode, decode_helpers

Types

JsonError = enum
  errNone,              	## no error
  errInvalidToken,      	## invalid token
  errStringExpected,    	## string expected
  errColonExpected,     	## `:` expected
  errCommaExpected,     	## `,` expected
  errBracketRiExpected, 	## `]` expected
  errCurlyRiExpected,   	## `}` expected
  errQuoteExpected,     	## `"` or `'` expected
  errEOC_Expected,      	## `*/` expected
  errEofExpected,       	## EOF expected
  errExprExpected        	## expr expected

	enumeration that lists all errors that can occur Source   Edit   

JsonEventKind = enum
  jsonError,            	## an error occurred during parsing
  jsonEof,              	## end of file reached
  jsonString,           	## a string literal
  jsonInt,              	## an integer literal
  jsonFloat,            	## a float literal
  jsonTrue,             	## the value `true`
  jsonFalse,            	## the value `false`
  jsonNull,             	## the value `null`
  jsonObjectStart,      	## start of an object: the `{` token
  jsonObjectEnd,        	## end of an object: the `}` token
  jsonArrayStart,       	## start of an array: the `[` token
  jsonArrayEnd           	## end of an array: the `]` token

	enumeration of all events that may occur when parsing Source   Edit   

JsonKindError = object of ValueError

	raised by the to macro if the JSON kind is incorrect. Source   Edit   

JsonParser = object of BaseLexer
  a*: string
  tok*: TokKind

	the parser object. Source   Edit   

JsonParsingError = object of ValueError

	is raised for a JSON error Source   Edit   

TokKind = enum
  tkError, tkEof, tkString, tkInt, tkFloat, tkTrue, tkFalse, tkNull, tkCurlyLe,
  tkCurlyRi, tkBracketLe, tkBracketRi, tkColon, tkComma

	Source   Edit   

Consts

errorMessages: array[JsonError, string] = ["no error", "invalid token",
	"string expected", "\':\' expected", "\',\' expected", "\']\' expected",
	"\'}\' expected", "\'\"\' or \"\'\" expected", "\'*/\' expected",
	"EOF expected", "expression expected"]

	Source   Edit   

Procs

proc close(my: var JsonParser) {.inline, ....}

	closes the parser my and its associated input stream. Source   Edit   

proc eat(p: var JsonParser; tok: TokKind) {.
	....}

	Source   Edit   

proc errorMsg(my: JsonParser): string {.....}

	returns a helpful error message for the event jsonError Source   Edit   

proc errorMsgExpected(my: JsonParser; e: string): string {.....}

	returns an error message "e expected" in the same format as the other error messages Source   Edit   

proc getColumn(my: JsonParser): int {.inline, ....}

	get the current column the parser has arrived at. Source   Edit   

proc getFilename(my: JsonParser): string {.inline, ....}

	get the filename of the file that the parser processes. Source   Edit   

proc getFloat(my: JsonParser): float {.inline, ....}

	returns the number for the event: jsonFloat Source   Edit   

proc getInt(my: JsonParser): BiggestInt {.inline, ....}

	returns the number for the event: jsonInt Source   Edit   

proc getLine(my: JsonParser): int {.inline, ....}

	get the current line the parser has arrived at. Source   Edit   

proc getTok(my: var JsonParser): TokKind {.....}

	Source   Edit   

proc kind(my: JsonParser): JsonEventKind {.inline, ....}

	returns the current event type for the JSON parser Source   Edit   

proc next(my: var JsonParser) {.....}

	retrieves the first/next event. This controls the parser. Source   Edit   

proc open(my: var JsonParser; input: Stream; filename: string;
      	rawStringLiterals = false) {.....}

	initializes the parser with an input stream. Filename is only used for nice error messages. If rawStringLiterals is true, string literals are kept with their surrounding quotes and escape sequences in them are left untouched too. Source   Edit   

proc parseEscapedUTF16(buf: cstring; pos: var int): int {.....}

	Source   Edit   

proc raiseParseErr(p: JsonParser; msg: string) {.noinline, noreturn,
	....}

	raises an EJsonParsingError exception. Source   Edit   

proc str(my: JsonParser): string {.inline, ....}

	returns the character data for the events: jsonInt, jsonFloat, jsonString Source   Edit   

std/parseopt


std/parseopt
Source   Edit  

This module provides the standard Nim command line parser. It supports one convenience iterator over all command line options and some lower-level features.
Supported Syntax

The following syntax is supported when arguments for the shortNoVal and longNoVal parameters, which are described later, are not provided:

	Short options: -abcd, -e:5, -e=5
	Long options: --foo:bar, --foo=bar, --foo
	Arguments: everything that does not start with a -

These three kinds of tokens are enumerated in the CmdLineKind enum.

When option values begin with ':' or '=', they need to be doubled up (as in --delim::) or alternated (as in --delim=:).

The -- option, commonly used to denote that every token that follows is an argument, is interpreted as a long option, and its name is the empty string.
Parsing

Use an OptParser to parse command line options. It can be created with initOptParser, and next advances the parser by one token.

For each token, the parser's kind, key, and val fields give information about that token. If the token is a long or short option, key is the option's name, and val is either the option's value, if provided, or the empty string. For arguments, the key field contains the argument itself, and val is unused. To check if the end of the command line has been reached, check if kind is equal to cmdEnd.

Here is an example:

import std/parseopt

var p = initOptParser("-ab -e:5 --foo --bar=20 file.txt")
while true:
  p.next()
  case p.kind
  of cmdEnd: break
  of cmdShortOption, cmdLongOption:
	if p.val == "":
  	echo "Option: ", p.key
	else:
  	echo "Option and value: ", p.key, ", ", p.val
  of cmdArgument:
	echo "Argument: ", p.key

# Output:
# Option: a
# Option: b
# Option and value: e, 5
# Option: foo
# Option and value: bar, 20
# Argument: file.txt

The getopt iterator, which is provided for convenience, can be used to iterate through all command line options as well.

To set a default value for a variable assigned through getopt and accept arguments from the cmd line. Assign the default value to a variable before parsing. Then set the variable to the new value while parsing.

Here is an example: .. code-block:: import std/parseopt

var varName: string = "defaultValue"

for kind, key, val in getopt(): case kind of cmdArgument: discard of cmdLongOption, cmdShortOption: case key: of "varName": # --varName:<value> in the console when executing varName = val # do input sanitization in production systems of cmdEnd: discard
shortNoVal and longNoVal

The optional shortNoVal and longNoVal parameters present in initOptParser are for specifying which short and long options do not accept values.

When shortNoVal is non-empty, users are not required to separate short options and their values with a ':' or '=' since the parser knows which options accept values and which ones do not. This behavior also applies for long options if longNoVal is non-empty. For short options, -j4 becomes supported syntax, and for long options, --foo bar becomes supported. This is in addition to the previously mentioned syntax. Users can still separate options and their values with ':' or '=', but that becomes optional.

As more options which do not accept values are added to your program, remember to amend shortNoVal and longNoVal accordingly.

The following example illustrates the difference between having an empty shortNoVal and longNoVal, which is the default, and providing arguments for those two parameters:

import std/parseopt

proc printToken(kind: CmdLineKind, key: string, val: string) =
  case kind
  of cmdEnd: doAssert(false)  # Doesn't happen with getopt()
  of cmdShortOption, cmdLongOption:
	if val == "":
  	echo "Option: ", key
	else:
  	echo "Option and value: ", key, ", ", val
  of cmdArgument:
	echo "Argument: ", key

let cmdLine = "-j4 --first bar"

var emptyNoVal = initOptParser(cmdLine)
for kind, key, val in emptyNoVal.getopt():
  printToken(kind, key, val)

# Output:
# Option: j
# Option: 4
# Option: first
# Argument: bar

var withNoVal = initOptParser(cmdLine, shortNoVal = {'c'},
                          	longNoVal = @["second"])
for kind, key, val in withNoVal.getopt():
  printToken(kind, key, val)

# Output:
# Option and value: j, 4
# Option and value: first, bar

See also

	os module for lower-level command line parsing procs
	parseutils module for helpers that parse tokens, numbers, identifiers, etc.
	strutils module for common string handling operations
	json module for a JSON parser
	parsecfg module for a configuration file parser
	parsecsv module for a simple CSV (comma separated value) parser
	parsexml module for a XML / HTML parser
	other parsers for more parsers

Imports

os

Types

CmdLineKind = enum
  cmdEnd,               	## End of command line reached
  cmdArgument,          	## An argument such as a filename
  cmdLongOption,        	## A long option such as --option
  cmdShortOption         	## A short option such as -c

	The detected command line token. Source   Edit   

OptParser = object of RootObj
  kind*: CmdLineKind     	## The detected command line token
  key*, val*: string     	## Key and value pair; the key is the option
                         	## or the argument, and the value is not "" if
                         	## the option was given a value

	Implementation of the command line parser.

	To initialize it, use the initOptParser proc.
	Source   Edit   

Procs

proc cmdLineRest(p: OptParser): string {.....}

Retrieves the rest of the command line that has not been parsed yet.

See also:

	remainingArgs proc

Examples:

var p = initOptParser("--left -r:2 -- foo.txt bar.txt")
while true:
  p.next()
  if p.kind == cmdLongOption and p.key == "":  # Look for "--"
	break
doAssert p.cmdLineRest == "foo.txt bar.txt"

	Source   Edit   

proc initOptParser(cmdline = ""; shortNoVal: set[char] = {};
               	longNoVal: seq[string] = @[];
               	allowWhitespaceAfterColon = true): OptParser {.....}

Initializes the command line parser.

If cmdline == "", the real command line as provided by the os module is retrieved instead if it is available. If the command line is not available, a ValueError will be raised.

shortNoVal and longNoVal are used to specify which options do not take values. See the documentation about these parameters for more information on how this affects parsing.

This does not provide a way of passing default values to arguments.

See also:

	getopt iterator

Example:

var p = initOptParser()
p = initOptParser("--left --debug:3 -l -r:2")
p = initOptParser("--left --debug:3 -l -r:2",
              	shortNoVal = {'l'}, longNoVal = @["left"])

	Source   Edit   

proc initOptParser(cmdline: seq[string]; shortNoVal: set[char] = {};
               	longNoVal: seq[string] = @[];
               	allowWhitespaceAfterColon = true): OptParser {.....}

Initializes the command line parser.

If cmdline.len == 0, the real command line as provided by the os module is retrieved instead if it is available. If the command line is not available, a ValueError will be raised. Behavior of the other parameters remains the same as in initOptParser(string, ...).

See also:

	getopt iterator

Example:

var p = initOptParser()
p = initOptParser(@["--left", "--debug:3", "-l", "-r:2"])
p = initOptParser(@["--left", "--debug:3", "-l", "-r:2"],
              	shortNoVal = {'l'}, longNoVal = @["left"])

	Source   Edit   

proc next(p: var OptParser) {.....}

Parses the next token.

p.kind describes what kind of token has been parsed. p.key and p.val are set accordingly.

Example:

var p = initOptParser("--left -r:2 file.txt")
p.next()
doAssert p.kind == cmdLongOption and p.key == "left"
p.next()
doAssert p.kind == cmdShortOption and p.key == "r" and p.val == "2"
p.next()
doAssert p.kind == cmdArgument and p.key == "file.txt"
p.next()
doAssert p.kind == cmdEnd

	Source   Edit   

proc remainingArgs(p: OptParser): seq[string] {.....}

Retrieves a sequence of the arguments that have not been parsed yet.

See also:

	cmdLineRest proc

Examples:

var p = initOptParser("--left -r:2 -- foo.txt bar.txt")
while true:
  p.next()
  if p.kind == cmdLongOption and p.key == "":  # Look for "--"
	break
doAssert p.remainingArgs == @["foo.txt", "bar.txt"]

	Source   Edit   

Iterators

iterator getopt(cmdline: seq[string] = @[]; shortNoVal: set[char] = {};
            	longNoVal: seq[string] = @[]): tuple[kind: CmdLineKind,
	key, val: string] {.....}

Convenience iterator for iterating over command line arguments.

This creates a new OptParser. If no command line arguments are provided, the real command line as provided by the os module is retrieved instead.

shortNoVal and longNoVal are used to specify which options do not take values. See the documentation about these parameters for more information on how this affects parsing.

There is no need to check for cmdEnd while iterating. If using getopt with case switching, checking for cmdEnd is required.

See also:

	initOptParser proc

Examples:

# these are placeholders, of course
proc writeHelp() = discard
proc writeVersion() = discard

var filename: string
let params = @["--left", "--debug:3", "-l", "-r:2"]

for kind, key, val in getopt(params):
  case kind
  of cmdArgument:
	filename = key
  of cmdLongOption, cmdShortOption:
	case key
	of "help", "h": writeHelp()
	of "version", "v": writeVersion()
  of cmdEnd: assert(false) # cannot happen
if filename == "":
  # no filename has been written, so we show the help
  writeHelp()

	Source   Edit   

iterator getopt(p: var OptParser): tuple[kind: CmdLineKind, key, val: string] {.
	....}

Convenience iterator for iterating over the given OptParser.

There is no need to check for cmdEnd while iterating. If using getopt with case switching, checking for cmdEnd is required.

See also:

	initOptParser proc

Examples:

# these are placeholders, of course
proc writeHelp() = discard
proc writeVersion() = discard

var filename: string
var p = initOptParser("--left --debug:3 -l -r:2")

for kind, key, val in p.getopt():
  case kind
  of cmdArgument:
	filename = key
  of cmdLongOption, cmdShortOption:
	case key
	of "help", "h": writeHelp()
	of "version", "v": writeVersion()
  of cmdEnd: assert(false) # cannot happen
if filename == "":
  # no filename has been given, so we show the help
  writeHelp()

	Source   Edit   


std/parsesql


std/parsesql
Source   Edit  

The parsesql module implements a high performance SQL file parser. It parses PostgreSQL syntax and the SQL ANSI standard.

Unstable API.

Imports

strutils, lexbase, decode_helpers, streams

Types

SqlLexer = object of BaseLexer

	the parser object. Source   Edit   

SqlNode = ref SqlNodeObj

	an SQL abstract syntax tree node Source   Edit   

SqlNodeKind = enum
  nkNone, nkIdent, nkQuotedIdent, nkStringLit, nkBitStringLit, nkHexStringLit,
  nkIntegerLit, nkNumericLit, nkPrimaryKey, nkForeignKey, nkNotNull, nkNull,
  nkStmtList, nkDot, nkDotDot, nkPrefix, nkInfix, nkCall, nkPrGroup,
  nkColumnReference, nkReferences, nkDefault, nkCheck, nkConstraint, nkUnique,
  nkIdentity, nkColumnDef,  ## name, datatype, constraints
  nkInsert, nkUpdate, nkDelete, nkSelect, nkSelectDistinct, nkSelectColumns,
  nkSelectPair, nkAsgn, nkFrom, nkFromItemPair, nkGroup, nkLimit, nkOffset,
  nkHaving, nkOrder, nkJoin, nkDesc, nkUnion, nkIntersect, nkExcept,
  nkColumnList, nkValueList, nkWhere, nkCreateTable, nkCreateTableIfNotExists,
  nkCreateType, nkCreateTypeIfNotExists, nkCreateIndex,
  nkCreateIndexIfNotExists, nkEnumDef

	kind of SQL abstract syntax tree Source   Edit   

SqlNodeObj = object
  case kind*: SqlNodeKind	## kind of syntax tree
  of LiteralNodes:
	strVal*: string      	## AST leaf: the identifier, numeric literal
                         	## string literal, etc.
  else:
	sons*: seq[SqlNode]  	## the node's children

	an SQL abstract syntax tree node Source   Edit   

SqlParseError = object of ValueError

	Invalid SQL encountered Source   Edit   

SqlParser = object of SqlLexer

	SQL parser object Source   Edit   

Procs

proc `$`(n: SqlNode): string {.....}

	an alias for renderSql. Source   Edit   

proc `[]`(n: SqlNode; i: BackwardsIndex): SqlNode {.....}

	Source   Edit   

proc `[]`(n: SqlNode; i: int): SqlNode {.....}

	Source   Edit   

proc add(father, n: SqlNode) {.....}

	Source   Edit   

proc len(n: SqlNode): int {.....}

	Source   Edit   

proc newNode(k: SqlNodeKind): SqlNode {.....}

	Source   Edit   

proc newNode(k: SqlNodeKind; s: string): SqlNode {.....}

	Source   Edit   

proc newNode(k: SqlNodeKind; sons: seq[SqlNode]): SqlNode {.....}

	Source   Edit   

proc parseSql(input: Stream; filename: string): SqlNode {.....}

	parses the SQL from input into an AST and returns the AST. filename is only used for error messages. Syntax errors raise an SqlParseError exception. Source   Edit   

proc parseSql(input: string; filename = ""): SqlNode {.
	....}

	parses the SQL from input into an AST and returns the AST. filename is only used for error messages. Syntax errors raise an SqlParseError exception. Source   Edit   

proc renderSql(n: SqlNode; upperCase = false): string {.....}

	Converts an SQL abstract syntax tree to its string representation. Source   Edit   

proc treeRepr(s: SqlNode): string {.....}

	Source   Edit   


std/parseutils


std/parseutils
Source   Edit  

This module contains helpers for parsing tokens, numbers, integers, floats, identifiers, etc.

To unpack raw bytes look at the streams module.

let logs = @["2019-01-10: OK_", "2019-01-11: FAIL_", "2019-01: aaaa"]
var outp: seq[string]

for log in logs:
  var res: string
  if parseUntil(log, res, ':') == 10: # YYYY-MM-DD == 10
	outp.add(res & " - " & captureBetween(log, ' ', '_'))
doAssert outp == @["2019-01-10 - OK", "2019-01-11 - FAIL"]

from std/strutils import Digits, parseInt

let
  input1 = "2019 school start"
  input2 = "3 years back"
  startYear = input1[0 .. skipWhile(input1, Digits)-1] # 2019
  yearsBack = input2[0 .. skipWhile(input2, Digits)-1] # 3
  examYear = parseInt(startYear) + parseInt(yearsBack)
doAssert "Examination is in " & $examYear == "Examination is in 2022"

See also:

	strutils module for combined and identical parsing proc's
	json module for a JSON parser
	parsecfg module for a configuration file parser
	parsecsv module for a simple CSV (comma separated value) parser
	parseopt module for a command line parser
	parsexml module for a XML / HTML parser
	other parsers for other parsers

Types

InterpolatedKind = enum
  ikStr,                	## ``str`` part of the interpolated string
  ikDollar,             	## escaped ``$`` part of the interpolated string
  ikVar,                	## ``var`` part of the interpolated string
  ikExpr                 	## ``expr`` part of the interpolated string

	Describes for interpolatedFragments which part of the interpolated string is yielded; for example in "str$$$var${expr}" Source   Edit   

Procs

proc captureBetween(s: openArray[char]; first: char; second = '\x00'): string {.
	....}

Finds the first occurrence of first, then returns everything from there up to second (if second is '0', then first is used).

Example:

doAssert captureBetween("Hello World", 'e') == "llo World"
doAssert captureBetween("Hello World", 'e', 'r') == "llo Wo"
doAssert captureBetween("Hello World".toOpenArray(6, "Hello World".high), 'l') == "d"

	Source   Edit   

proc captureBetween(s: string; first: char; second = '\x00'; start = 0): string {.
	....}

Finds the first occurrence of first, then returns everything from there up to second (if second is '0', then first is used).

Example:

doAssert captureBetween("Hello World", 'e') == "llo World"
doAssert captureBetween("Hello World", 'e', 'r') == "llo Wo"
doAssert captureBetween("Hello World", 'l', start = 6) == "d"

	Source   Edit   

proc parseBiggestFloat(s: openArray[char]; number: var BiggestFloat): int {.
	magic: "ParseBiggestFloat", importc: "nimParseBiggestFloat", noSideEffect,
	....}

	Parses a float and stores the value into number. Result is the number of processed chars or 0 if a parsing error occurred. Source   Edit   

proc parseBiggestFloat(s: string; number: var BiggestFloat; start = 0): int {.
	noSideEffect, ....}

	Parses a float starting at start and stores the value into number. Result is the number of processed chars or 0 if a parsing error occurred. Source   Edit   

proc parseBiggestInt(s: openArray[char]; number: var BiggestInt): int {....noSideEffect, ....}

Parses an integer and stores the value into number. Result is the number of processed chars or 0 if there is no integer. ValueError is raised if the parsed integer is out of the valid range.

Example:

var res: BiggestInt
doAssert parseBiggestInt("9223372036854775807", res) == 19
doAssert res == 9223372036854775807

	Source   Edit   

proc parseBiggestInt(s: string; number: var BiggestInt; start = 0): int {.
	noSideEffect, ....}

Parses an integer starting at start and stores the value into number. Result is the number of processed chars or 0 if there is no integer. ValueError is raised if the parsed integer is out of the valid range.

Example:

var res: BiggestInt
doAssert parseBiggestInt("9223372036854775807", res, 0) == 19
doAssert res == 9223372036854775807

	Source   Edit   

proc parseBiggestUInt(s: openArray[char]; number: var BiggestUInt): int {.
	...noSideEffect, ....}

Parses an unsigned integer and stores the value into number. ValueError is raised if the parsed integer is out of the valid range.

Example:

var res: BiggestUInt
doAssert parseBiggestUInt("12", res, 0) == 2
doAssert res == 12
doAssert parseBiggestUInt("1111111111111111111", res, 0) == 19
doAssert res == 1111111111111111111'u64

	Source   Edit   

proc parseBiggestUInt(s: string; number: var BiggestUInt; start = 0): int {.
	noSideEffect, ....}

Parses an unsigned integer starting at start and stores the value into number. ValueError is raised if the parsed integer is out of the valid range.

Example:

var res: BiggestUInt
doAssert parseBiggestUInt("12", res, 0) == 2
doAssert res == 12
doAssert parseBiggestUInt("1111111111111111111", res, 0) == 19
doAssert res == 1111111111111111111'u64

	Source   Edit   

proc parseBin[T: SomeInteger](s: openArray[char]; number: var T; maxLen = 0): int {.
	noSideEffect.}

Parses a binary number and stores its value in number.

Returns the number of the parsed characters or 0 in case of an error. If error, the value of number is not changed.

If maxLen == 0, the parsing continues until the first non-bin character or to the end of the string. Otherwise, no more than maxLen characters are parsed starting from the start position.

It does not check for overflow. If the value represented by the string is too big to fit into number, only the value of last fitting characters will be stored in number without producing an error.

Example:

var num: int
doAssert parseBin("0100_1110_0110_1001_1110_1101", num) == 29
doAssert num == 5138925
doAssert parseBin("3", num) == 0
var num8: int8
doAssert parseBin("0b_0100_1110_0110_1001_1110_1101", num8) == 32
doAssert num8 == 0b1110_1101'i8
doAssert parseBin("0b_0100_1110_0110_1001_1110_1101", num8, 3, 9) == 9
doAssert num8 == 0b0100_1110'i8
var num8u: uint8
doAssert parseBin("0b_0100_1110_0110_1001_1110_1101", num8u) == 32
doAssert num8u == 237
var num64: int64
doAssert parseBin("0100111001101001111011010100111001101001", num64) == 40
doAssert num64 == 336784608873

	Source   Edit   

proc parseBin[T: SomeInteger](s: string; number: var T; start = 0; maxLen = 0): int {.
	noSideEffect.}

Parses a binary number and stores its value in number.

Returns the number of the parsed characters or 0 in case of an error. If error, the value of number is not changed.

If maxLen == 0, the parsing continues until the first non-bin character or to the end of the string. Otherwise, no more than maxLen characters are parsed starting from the start position.

It does not check for overflow. If the value represented by the string is too big to fit into number, only the value of last fitting characters will be stored in number without producing an error.

Example:

var num: int
doAssert parseBin("0100_1110_0110_1001_1110_1101", num) == 29
doAssert num == 5138925
doAssert parseBin("3", num) == 0
var num8: int8
doAssert parseBin("0b_0100_1110_0110_1001_1110_1101", num8) == 32
doAssert num8 == 0b1110_1101'i8
doAssert parseBin("0b_0100_1110_0110_1001_1110_1101", num8, 3, 9) == 9
doAssert num8 == 0b0100_1110'i8
var num8u: uint8
doAssert parseBin("0b_0100_1110_0110_1001_1110_1101", num8u) == 32
doAssert num8u == 237
var num64: int64
doAssert parseBin("0100111001101001111011010100111001101001", num64) == 40
doAssert num64 == 336784608873

	Source   Edit   

proc parseChar(s: openArray[char]; c: var char): int {.....}

Parses a single character, stores it in c and returns 1. In case of error (if start >= s.len) it returns 0 and the value of c is unchanged.

Example:

var c: char
doAssert "nim".parseChar(c, 3) == 0
doAssert c == '\0'
doAssert "nim".parseChar(c, 0) == 1
doAssert c == 'n'

	Source   Edit   

proc parseChar(s: string; c: var char; start = 0): int {.....}

Parses a single character, stores it in c and returns 1. In case of error (if start >= s.len) it returns 0 and the value of c is unchanged.

Example:

var c: char
doAssert "nim".parseChar(c, 3) == 0
doAssert c == '\0'
doAssert "nim".parseChar(c, 0) == 1
doAssert c == 'n'

	Source   Edit   

proc parseFloat(s: openArray[char]; number: var float): int {....noSideEffect, ....}

Parses a float and stores the value into number. Result is the number of processed chars or 0 if there occurred a parsing error.

Example:

var res: float
doAssert parseFloat("32", res, 0) == 2
doAssert res == 32.0
doAssert parseFloat("32.57", res, 0) == 5
doAssert res == 32.57
doAssert parseFloat("32.57", res, 3) == 2
doAssert res == 57.00

	Source   Edit   

proc parseFloat(s: string; number: var float; start = 0): int {.noSideEffect,
	....}

Parses a float starting at start and stores the value into number. Result is the number of processed chars or 0 if there occurred a parsing error.

Example:

var res: float
doAssert parseFloat("32", res, 0) == 2
doAssert res == 32.0
doAssert parseFloat("32.57", res, 0) == 5
doAssert res == 32.57
doAssert parseFloat("32.57", res, 3) == 2
doAssert res == 57.00

	Source   Edit   

proc parseHex[T: SomeInteger](s: openArray[char]; number: var T; maxLen = 0): int {.
	noSideEffect.}

Parses a hexadecimal number and stores its value in number.

Returns the number of the parsed characters or 0 in case of an error. If error, the value of number is not changed.

If maxLen == 0, the parsing continues until the first non-hex character or to the end of the string. Otherwise, no more than maxLen characters are parsed starting from the start position.

It does not check for overflow. If the value represented by the string is too big to fit into number, only the value of last fitting characters will be stored in number without producing an error.

Example:

var num: int
doAssert parseHex("4E_69_ED", num) == 8
doAssert num == 5138925
doAssert parseHex("X", num) == 0
doAssert parseHex("#ABC", num) == 4
var num8: int8
doAssert parseHex("0x_4E_69_ED", num8) == 11
doAssert num8 == 0xED'i8
doAssert parseHex("0x_4E_69_ED", num8, 3, 2) == 2
doAssert num8 == 0x4E'i8
var num8u: uint8
doAssert parseHex("0x_4E_69_ED", num8u) == 11
doAssert num8u == 237
var num64: int64
doAssert parseHex("4E69ED4E69ED", num64) == 12
doAssert num64 == 86216859871725

	Source   Edit   

proc parseHex[T: SomeInteger](s: string; number: var T; start = 0; maxLen = 0): int {.
	noSideEffect.}

Parses a hexadecimal number and stores its value in number.

Returns the number of the parsed characters or 0 in case of an error. If error, the value of number is not changed.

If maxLen == 0, the parsing continues until the first non-hex character or to the end of the string. Otherwise, no more than maxLen characters are parsed starting from the start position.

It does not check for overflow. If the value represented by the string is too big to fit into number, only the value of last fitting characters will be stored in number without producing an error.

Example:

var num: int
doAssert parseHex("4E_69_ED", num) == 8
doAssert num == 5138925
doAssert parseHex("X", num) == 0
doAssert parseHex("#ABC", num) == 4
var num8: int8
doAssert parseHex("0x_4E_69_ED", num8) == 11
doAssert num8 == 0xED'i8
doAssert parseHex("0x_4E_69_ED", num8, 3, 2) == 2
doAssert num8 == 0x4E'i8
var num8u: uint8
doAssert parseHex("0x_4E_69_ED", num8u) == 11
doAssert num8u == 237
var num64: int64
doAssert parseHex("4E69ED4E69ED", num64) == 12
doAssert num64 == 86216859871725

	Source   Edit   

proc parseIdent(s: openArray[char]): string {.....}

Parses an identifier and returns it or an empty string in case of an error.

Example:

doAssert parseIdent("Hello World", 0) == "Hello"
doAssert parseIdent("Hello World", 1) == "ello"
doAssert parseIdent("Hello World", 5) == ""
doAssert parseIdent("Hello World", 6) == "World"

	Source   Edit   

proc parseIdent(s: openArray[char]; ident: var string): int {.....}

Parses an identifier and stores it in ident. Returns the number of the parsed characters or 0 in case of an error. If error, the value of ident is not changed.

Example:

var res: string
doAssert parseIdent("Hello World", res, 0) == 5
doAssert res == "Hello"
doAssert parseIdent("Hello World", res, 1) == 4
doAssert res == "ello"
doAssert parseIdent("Hello World", res, 6) == 5
doAssert res == "World"

	Source   Edit   

proc parseIdent(s: string; ident: var string; start = 0): int {.....}

Parses an identifier and stores it in ident. Returns the number of the parsed characters or 0 in case of an error. If error, the value of ident is not changed.

Example:

var res: string
doAssert parseIdent("Hello World", res, 0) == 5
doAssert res == "Hello"
doAssert parseIdent("Hello World", res, 1) == 4
doAssert res == "ello"
doAssert parseIdent("Hello World", res, 6) == 5
doAssert res == "World"

	Source   Edit   

proc parseIdent(s: string; start = 0): string {.....}

Parses an identifier and returns it or an empty string in case of an error.

Example:

doAssert parseIdent("Hello World", 0) == "Hello"
doAssert parseIdent("Hello World", 1) == "ello"
doAssert parseIdent("Hello World", 5) == ""
doAssert parseIdent("Hello World", 6) == "World"

	Source   Edit   

proc parseInt(s: openArray[char]; number: var int): int {....noSideEffect, ....}

Parses an integer and stores the value into number. Result is the number of processed chars or 0 if there is no integer. ValueError is raised if the parsed integer is out of the valid range.

Example:

var res: int
doAssert parseInt("2019", res, 0) == 4
doAssert res == 2019
doAssert parseInt("2019", res, 2) == 2
doAssert res == 19

	Source   Edit   

proc parseInt(s: string; number: var int; start = 0): int {.noSideEffect,
	....}

Parses an integer starting at start and stores the value into number. Result is the number of processed chars or 0 if there is no integer. ValueError is raised if the parsed integer is out of the valid range.

Example:

var res: int
doAssert parseInt("2019", res, 0) == 4
doAssert res == 2019
doAssert parseInt("2019", res, 2) == 2
doAssert res == 19

	Source   Edit   

proc parseOct[T: SomeInteger](s: openArray[char]; number: var T; maxLen = 0): int {.
	noSideEffect.}

Parses an octal number and stores its value in number.

Returns the number of the parsed characters or 0 in case of an error. If error, the value of number is not changed.

If maxLen == 0, the parsing continues until the first non-oct character or to the end of the string. Otherwise, no more than maxLen characters are parsed starting from the start position.

It does not check for overflow. If the value represented by the string is too big to fit into number, only the value of last fitting characters will be stored in number without producing an error.

Example:

var num: int
doAssert parseOct("0o23464755", num) == 10
doAssert num == 5138925
doAssert parseOct("8", num) == 0
var num8: int8
doAssert parseOct("0o_1464_755", num8) == 11
doAssert num8 == -19
doAssert parseOct("0o_1464_755", num8, 3, 3) == 3
doAssert num8 == 102
var num8u: uint8
doAssert parseOct("1464755", num8u) == 7
doAssert num8u == 237
var num64: int64
doAssert parseOct("2346475523464755", num64) == 16
doAssert num64 == 86216859871725

	Source   Edit   

proc parseOct[T: SomeInteger](s: string; number: var T; start = 0; maxLen = 0): int {.
	noSideEffect.}

Parses an octal number and stores its value in number.

Returns the number of the parsed characters or 0 in case of an error. If error, the value of number is not changed.

If maxLen == 0, the parsing continues until the first non-oct character or to the end of the string. Otherwise, no more than maxLen characters are parsed starting from the start position.

It does not check for overflow. If the value represented by the string is too big to fit into number, only the value of last fitting characters will be stored in number without producing an error.

Example:

var num: int
doAssert parseOct("0o23464755", num) == 10
doAssert num == 5138925
doAssert parseOct("8", num) == 0
var num8: int8
doAssert parseOct("0o_1464_755", num8) == 11
doAssert num8 == -19
doAssert parseOct("0o_1464_755", num8, 3, 3) == 3
doAssert num8 == 102
var num8u: uint8
doAssert parseOct("1464755", num8u) == 7
doAssert num8u == 237
var num64: int64
doAssert parseOct("2346475523464755", num64) == 16
doAssert num64 == 86216859871725

	Source   Edit   

proc parseSaturatedNatural(s: openArray[char]; b: var int): int {.....}

Parses a natural number into b. This cannot raise an overflow error. high(int) is returned for an overflow. The number of processed character is returned. This is usually what you really want to use instead of parseInt.

Example:

var res = 0
discard parseSaturatedNatural("848", res)
doAssert res == 848

	Source   Edit   

proc parseSaturatedNatural(s: string; b: var int; start = 0): int {.....}

Parses a natural number into b. This cannot raise an overflow error. high(int) is returned for an overflow. The number of processed character is returned. This is usually what you really want to use instead of parseInt.

Example:

var res = 0
discard parseSaturatedNatural("848", res)
doAssert res == 848

	Source   Edit   

func parseSize(s: openArray[char]; size: var int64; alwaysBin = false): int {.
	....}

Parse a size qualified by binary or metric units into size. This format is often called "human readable". Result is the number of processed chars or 0 on parse errors and size is rounded to the nearest integer. Trailing garbage like "/s" in "1k/s" is allowed and detected by result < s.len.

To simplify use, following non-rare wild conventions, and since fractional data like milli-bytes is so rare, unit matching is case-insensitive but for the 'i' distinguishing binary-metric from metric (which cannot be 'I').

An optional trailing 'B|b' is ignored but processed. I.e., you must still know if units are bytes | bits or infer this fact via the case of s^1 (if users can even be relied upon to use 'B' for byte and 'b' for bit or have that be s^1).

If alwaysBin==true then scales are always binary-metric, but e.g. "KiB" is still accepted for clarity. If the value would exceed the range of int64, size saturates to int64.high. Supported metric prefix chars include k, m, g, t, p, e, z, y (but z & y saturate unless the number is a small fraction).

See also:

	https://en.wikipedia.org/wiki/Binary_prefix
	formatSize module for formatting

Example:

var res: int64  # caller must still know if 'b' refers to bytes|bits
doAssert parseSize("10.5 MB", res) == 7
doAssert res == 10_500_000  # decimal metric Mega prefix
doAssert parseSize("64 mib", res) == 6
doAssert res == 67108864	# 64 shl 20
doAssert parseSize("1G/h", res, true) == 2 # '/' stops parse
doAssert res == 1073741824  # 1 shl 30, forced binary metric

	Source   Edit   

proc parseUInt(s: openArray[char]; number: var uint): int {....noSideEffect, ....}

Parses an unsigned integer and stores the value into number. ValueError is raised if the parsed integer is out of the valid range.

Example:

var res: uint
doAssert parseUInt("3450", res) == 4
doAssert res == 3450
doAssert parseUInt("3450", res, 2) == 2
doAssert res == 50

	Source   Edit   

proc parseUInt(s: string; number: var uint; start = 0): int {.noSideEffect,
	....}

Parses an unsigned integer starting at start and stores the value into number. ValueError is raised if the parsed integer is out of the valid range.

Example:

var res: uint
doAssert parseUInt("3450", res) == 4
doAssert res == 3450
doAssert parseUInt("3450", res, 2) == 2
doAssert res == 50

	Source   Edit   

proc parseUntil(s: openArray[char]; token: var string; until: char): int {.
	inline, ....}

Parses a token and stores it in token. Returns the number of the parsed characters or 0 in case of an error. A token consists of any character that is not the until character.

Example:

var myToken: string
doAssert parseUntil("Hello World", myToken, 'W') == 6
doAssert myToken == "Hello "
doAssert parseUntil("Hello World", myToken, 'o') == 4
doAssert myToken == "Hell"
doAssert parseUntil("Hello World", myToken, 'o', 2) == 2
doAssert myToken == "ll"

	Source   Edit   

proc parseUntil(s: openArray[char]; token: var string; until: set[char]): int {.
	inline, ....}

Parses a token and stores it in token. Returns the number of the parsed characters or 0 in case of an error. A token consists of the characters notin until.

Example:

var myToken: string
doAssert parseUntil("Hello World", myToken, {'W', 'o', 'r'}) == 4
doAssert myToken == "Hell"
doAssert parseUntil("Hello World", myToken, {'W', 'r'}) == 6
doAssert myToken == "Hello "
doAssert parseUntil("Hello World", myToken, {'W', 'r'}, 3) == 3
doAssert myToken == "lo "

	Source   Edit   

proc parseUntil(s: openArray[char]; token: var string; until: string): int {.
	inline, ....}

Parses a token and stores it in token. Returns the number of the parsed characters or 0 in case of an error. A token consists of any character that comes before the until token.

Example:

var myToken: string
doAssert parseUntil("Hello World", myToken, "Wor") == 6
doAssert myToken == "Hello "
doAssert parseUntil("Hello World", myToken, "Wor", 2) == 4
doAssert myToken == "llo "

	Source   Edit   

proc parseUntil(s: string; token: var string; until: char; start = 0): int {.
	inline, ....}

Parses a token and stores it in token. Returns the number of the parsed characters or 0 in case of an error. A token consists of any character that is not the until character.

Example:

var myToken: string
doAssert parseUntil("Hello World", myToken, 'W') == 6
doAssert myToken == "Hello "
doAssert parseUntil("Hello World", myToken, 'o') == 4
doAssert myToken == "Hell"
doAssert parseUntil("Hello World", myToken, 'o', 2) == 2
doAssert myToken == "ll"

	Source   Edit   

proc parseUntil(s: string; token: var string; until: set[char]; start = 0): int {.
	inline, ....}

Parses a token and stores it in token. Returns the number of the parsed characters or 0 in case of an error. A token consists of the characters notin until.

Example:

var myToken: string
doAssert parseUntil("Hello World", myToken, {'W', 'o', 'r'}) == 4
doAssert myToken == "Hell"
doAssert parseUntil("Hello World", myToken, {'W', 'r'}) == 6
doAssert myToken == "Hello "
doAssert parseUntil("Hello World", myToken, {'W', 'r'}, 3) == 3
doAssert myToken == "lo "

	Source   Edit   

proc parseUntil(s: string; token: var string; until: string; start = 0): int {.
	inline, ....}

Parses a token and stores it in token. Returns the number of the parsed characters or 0 in case of an error. A token consists of any character that comes before the until token.

Example:

var myToken: string
doAssert parseUntil("Hello World", myToken, "Wor") == 6
doAssert myToken == "Hello "
doAssert parseUntil("Hello World", myToken, "Wor", 2) == 4
doAssert myToken == "llo "

	Source   Edit   

proc parseWhile(s: openArray[char]; token: var string; validChars: set[char]): int {.
	inline, ....}

Parses a token and stores it in token. Returns the number of the parsed characters or 0 in case of an error. A token consists of the characters in validChars.

Example:

var myToken: string
doAssert parseWhile("Hello World", myToken, {'W', 'o', 'r'}, 0) == 0
doAssert myToken.len() == 0
doAssert parseWhile("Hello World", myToken, {'W', 'o', 'r'}, 6) == 3
doAssert myToken == "Wor"

	Source   Edit   

proc parseWhile(s: string; token: var string; validChars: set[char]; start = 0): int {.
	inline, ....}

Parses a token and stores it in token. Returns the number of the parsed characters or 0 in case of an error. A token consists of the characters in validChars.

Example:

var myToken: string
doAssert parseWhile("Hello World", myToken, {'W', 'o', 'r'}, 0) == 0
doAssert myToken.len() == 0
doAssert parseWhile("Hello World", myToken, {'W', 'o', 'r'}, 6) == 3
doAssert myToken == "Wor"

	Source   Edit   

proc skip(s, token: openArray[char]): int {.inline, ....}

Skips the token starting at s[start]. Returns the length of token or 0 if there was no token at s[start].

Example:

doAssert skip("2019-01-22", "2019", 0) == 4
doAssert skip("2019-01-22", "19", 0) == 0
doAssert skip("2019-01-22", "19", 2) == 2
doAssert skip("CAPlow", "CAP", 0) == 3
doAssert skip("CAPlow", "cap", 0) == 0

	Source   Edit   

proc skip(s, token: string; start = 0): int {.inline, ....}

Skips the token starting at s[start]. Returns the length of token or 0 if there was no token at s[start].

Example:

doAssert skip("2019-01-22", "2019", 0) == 4
doAssert skip("2019-01-22", "19", 0) == 0
doAssert skip("2019-01-22", "19", 2) == 2
doAssert skip("CAPlow", "CAP", 0) == 3
doAssert skip("CAPlow", "cap", 0) == 0

	Source   Edit   

proc skipIgnoreCase(s, token: openArray[char]): int {.....}

Same as skip but case is ignored for token matching.

Example:

doAssert skipIgnoreCase("CAPlow", "CAP", 0) == 3
doAssert skipIgnoreCase("CAPlow", "cap", 0) == 3

	Source   Edit   

proc skipIgnoreCase(s, token: string; start = 0): int {.....}

Same as skip but case is ignored for token matching.

Example:

doAssert skipIgnoreCase("CAPlow", "CAP", 0) == 3
doAssert skipIgnoreCase("CAPlow", "cap", 0) == 3

	Source   Edit   

proc skipUntil(s: openArray[char]; until: char): int {.inline, ....}

Skips all characters until the char until is found or the end is reached. Returns number of characters skipped.

Example:

doAssert skipUntil("Hello World", 'o', 0) == 4
doAssert skipUntil("Hello World", 'o', 4) == 0
doAssert skipUntil("Hello World", 'W', 0) == 6
doAssert skipUntil("Hello World", 'w', 0) == 11

	Source   Edit   

proc skipUntil(s: openArray[char]; until: set[char]): int {.inline, ....}

Skips all characters until one char from the set until is found or the end is reached. Returns number of characters skipped.

Example:

doAssert skipUntil("Hello World", {'W', 'e'}, 0) == 1
doAssert skipUntil("Hello World", {'W'}, 0) == 6
doAssert skipUntil("Hello World", {'W', 'd'}, 0) == 6

	Source   Edit   

proc skipUntil(s: string; until: char; start = 0): int {.inline, ....}

Skips all characters until the char until is found or the end is reached. Returns number of characters skipped.

Example:

doAssert skipUntil("Hello World", 'o', 0) == 4
doAssert skipUntil("Hello World", 'o', 4) == 0
doAssert skipUntil("Hello World", 'W', 0) == 6
doAssert skipUntil("Hello World", 'w', 0) == 11

	Source   Edit   

proc skipUntil(s: string; until: set[char]; start = 0): int {.inline,
	....}

Skips all characters until one char from the set until is found or the end is reached. Returns number of characters skipped.

Example:

doAssert skipUntil("Hello World", {'W', 'e'}, 0) == 1
doAssert skipUntil("Hello World", {'W'}, 0) == 6
doAssert skipUntil("Hello World", {'W', 'd'}, 0) == 6

	Source   Edit   

proc skipWhile(s: openArray[char]; toSkip: set[char]): int {.inline, ....}

Skips all characters while one char from the set toSkip is found. Returns number of characters skipped.

Example:

doAssert skipWhile("Hello World", {'H', 'e'}) == 2
doAssert skipWhile("Hello World", {'e'}) == 0
doAssert skipWhile("Hello World", {'W', 'o', 'r'}, 6) == 3

	Source   Edit   

proc skipWhile(s: string; toSkip: set[char]; start = 0): int {.inline,
	....}

Skips all characters while one char from the set toSkip is found. Returns number of characters skipped.

Example:

doAssert skipWhile("Hello World", {'H', 'e'}) == 2
doAssert skipWhile("Hello World", {'e'}) == 0
doAssert skipWhile("Hello World", {'W', 'o', 'r'}, 6) == 3

	Source   Edit   

proc skipWhitespace(s: openArray[char]): int {.inline, ....}

Skips the whitespace starting at s[start]. Returns the number of skipped characters.

Example:

doAssert skipWhitespace("Hello World", 0) == 0
doAssert skipWhitespace(" Hello World", 0) == 1
doAssert skipWhitespace("Hello World", 5) == 1
doAssert skipWhitespace("Hello  World", 5) == 2

	Source   Edit   

proc skipWhitespace(s: string; start = 0): int {.inline, ....}

Skips the whitespace starting at s[start]. Returns the number of skipped characters.

Example:

doAssert skipWhitespace("Hello World", 0) == 0
doAssert skipWhitespace(" Hello World", 0) == 1
doAssert skipWhitespace("Hello World", 5) == 1
doAssert skipWhitespace("Hello  World", 5) == 2

	Source   Edit   

Iterators

iterator interpolatedFragments(s: openArray[char]): tuple[
	kind: InterpolatedKind, value: string] {.....}

Tokenizes the string s into substrings for interpolation purposes.

Example:

var outp: seq[tuple[kind: InterpolatedKind, value: string]]
for k, v in interpolatedFragments("  $this is ${an  example}  $$"):
  outp.add (k, v)
doAssert outp == @[(ikStr, "  "),
               	(ikVar, "this"),
               	(ikStr, " is "),
               	(ikExpr, "an  example"),
               	(ikStr, "  "),
               	(ikDollar, "$")]

	Source   Edit   

iterator interpolatedFragments(s: string): tuple[kind: InterpolatedKind,
	value: string] {.....}

Tokenizes the string s into substrings for interpolation purposes.

Example:

var outp: seq[tuple[kind: InterpolatedKind, value: string]]
for k, v in interpolatedFragments("  $this is ${an  example}  $$"):
  outp.add (k, v)
doAssert outp == @[(ikStr, "  "),
               	(ikVar, "this"),
               	(ikStr, " is "),
               	(ikExpr, "an  example"),
               	(ikStr, "  "),
               	(ikDollar, "$")]

	Source   Edit   


std/parsexml


std/parsexml
Source   Edit  

This module implements a simple high performance XML / HTML parser. The only encoding that is supported is UTF-8. The parser has been designed to be somewhat error correcting, so that even most "wild HTML" found on the web can be parsed with it. Note: This parser does not check that each <tag> has a corresponding </tag>! These checks have do be implemented by the client code for various reasons:

	Old HTML contains tags that have no end tag: <br> for example.
	HTML tags are case insensitive, XML tags are case sensitive. Since this library can parse both, only the client knows which comparison is to be used.
	Thus the checks would have been very difficult to implement properly with little benefit, especially since they are simple to implement in the client. The client should use the errorMsgExpected proc to generate a nice error message that fits the other error messages this library creates.

Example 1: Retrieve HTML title

The file examples/htmltitle.nim demonstrates how to use the XML parser to accomplish a simple task: To determine the title of an HTML document.

# Example program to show the parsexml module
# This program reads an HTML file and writes its title to stdout.
# Errors and whitespace are ignored.

import os, streams, parsexml, strutils

if paramCount() < 1:
  quit("Usage: htmltitle filename[.html]")

var filename = addFileExt(paramStr(1), "html")
var s = newFileStream(filename, fmRead)
if s == nil: quit("cannot open the file " & filename)
var x: XmlParser
open(x, s, filename)
while true:
  x.next()
  case x.kind
  of xmlElementStart:
	if cmpIgnoreCase(x.elementName, "title") == 0:
  	var title = ""
  	x.next()  # skip "<title>"
  	while x.kind == xmlCharData:
    	title.add(x.charData)
    	x.next()
  	if x.kind == xmlElementEnd and cmpIgnoreCase(x.elementName, "title") == 0:
    	echo("Title: " & title)
    	quit(0) # Success!
  	else:
    	echo(x.errorMsgExpected("/title"))
 
  of xmlEof: break # end of file reached
  else: discard # ignore other events

x.close()
quit("Could not determine title!")

Example 2: Retrieve all HTML links

The file examples/htmlrefs.nim demonstrates how to use the XML parser to accomplish another simple task: To determine all the links an HTML document contains.

# Example program to show the new parsexml module
# This program reads an HTML file and writes all its used links to stdout.
# Errors and whitespace are ignored.

import os, streams, parsexml, strutils

proc `=?=` (a, b: string): bool =
  # little trick: define our own comparator that ignores case
  return cmpIgnoreCase(a, b) == 0

if paramCount() < 1:
  quit("Usage: htmlrefs filename[.html]")

var links = 0 # count the number of links
var filename = addFileExt(paramStr(1), "html")
var s = newFileStream(filename, fmRead)
if s == nil: quit("cannot open the file " & filename)
var x: XmlParser
open(x, s, filename)
next(x) # get first event
block mainLoop:
  while true:
	case x.kind
	of xmlElementOpen:
  	# the <a href = "xyz"> tag we are interested in always has an attribute,
  	# thus we search for ``xmlElementOpen`` and not for ``xmlElementStart``
  	if x.elementName =?= "a":
    	x.next()
    	if x.kind == xmlAttribute:
      	if x.attrKey =?= "href":
        	var link = x.attrValue
        	inc(links)
        	# skip until we have an ``xmlElementClose`` event
        	while true:
          	x.next()
          	case x.kind
          	of xmlEof: break mainLoop
          	of xmlElementClose: break
          	else: discard
        	x.next() # skip ``xmlElementClose``
        	# now we have the description for the ``a`` element
        	var desc = ""
        	while x.kind == xmlCharData:
          	desc.add(x.charData)
          	x.next()
        	echo(desc & ": " & link)
  	else:
    	x.next()
	of xmlEof: break # end of file reached
	of xmlError:
  	echo(errorMsg(x))
  	x.next()
	else: x.next() # skip other events

echo($links & " link(s) found!")
x.close()

Imports

strutils, lexbase, streams, unicode, os

Types

XmlErrorKind = enum
  errNone,              	## no error
  errEndOfCDataExpected,	## ``]]>`` expected
  errNameExpected,      	## name expected
  errSemicolonExpected, 	## ``;`` expected
  errQmGtExpected,      	## ``?>`` expected
  errGtExpected,        	## ``>`` expected
  errEqExpected,        	## ``=`` expected
  errQuoteExpected,     	## ``"`` or ``'`` expected
  errEndOfCommentExpected,  ## ``-->`` expected
  errAttributeValueExpected  ## non-empty attribute value expected

	enumeration that lists all errors that can occur Source   Edit   

XmlEventKind = enum
  xmlError,             	## an error occurred during parsing
  xmlEof,               	## end of file reached
  xmlCharData,          	## character data
  xmlWhitespace,        	## whitespace has been parsed
  xmlComment,           	## a comment has been parsed
  xmlPI,                	## processing instruction (``<?name something ?>``)
  xmlElementStart,      	## ``<elem>``
  xmlElementEnd,        	## ``</elem>``
  xmlElementOpen,       	## ``<elem
  xmlAttribute,         	## ``key = "value"`` pair
  xmlElementClose,      	## ``>``
  xmlCData,             	## ``<![CDATA[`` ... data ... ``]]>``
  xmlEntity,            	## &entity;
  xmlSpecial             	## ``<! ... data ... >``

	enumeration of all events that may occur when parsing Source   Edit   

XmlParseOption = enum
  reportWhitespace,     	## report whitespace
  reportComments,       	## report comments
  allowUnquotedAttribs, 	## allow unquoted attribute values (for HTML)
  allowEmptyAttribs      	## allow empty attributes (without explicit value)

	options for the XML parser Source   Edit   

XmlParser = object of BaseLexer

	the parser object. Source   Edit   

Procs

proc close(my: var XmlParser) {.inline, ....}

	closes the parser my and its associated input stream. Source   Edit   

proc errorMsg(my: XmlParser): string {.....}

	returns a helpful error message for the event xmlError Source   Edit   

proc errorMsg(my: XmlParser; msg: string): string {.....}

	returns an error message with text msg in the same format as the other error messages Source   Edit   

proc errorMsgExpected(my: XmlParser; tag: string): string {.
	....}

	returns an error message "<tag> expected" in the same format as the other error messages Source   Edit   

proc getColumn(my: XmlParser): int {.inline, ....}

	get the current column the parser has arrived at. Source   Edit   

proc getFilename(my: XmlParser): string {.inline, ....}

	get the filename of the file that the parser processes. Source   Edit   

proc getLine(my: XmlParser): int {.inline, ....}

	get the current line the parser has arrived at. Source   Edit   

proc kind(my: XmlParser): XmlEventKind {.inline, ....}

	returns the current event type for the XML parser Source   Edit   

proc next(my: var XmlParser) {.....}

	retrieves the first/next event. This controls the parser. Source   Edit   

proc open(my: var XmlParser; input: Stream; filename: string;
      	options: set[XmlParseOption] = {}) {.....}

	initializes the parser with an input stream. Filename is only used for nice error messages. The parser's behaviour can be controlled by the options parameter: If options contains reportWhitespace a whitespace token is reported as an xmlWhitespace event. If options contains reportComments a comment token is reported as an xmlComment event. Source   Edit   

proc rawData(my: var XmlParser): lent string {.inline, ....}

	returns the underlying 'data' string by reference. This is only used for speed hacks. Source   Edit   

proc rawData2(my: var XmlParser): lent string {.inline, ....}

	returns the underlying second 'data' string by reference. This is only used for speed hacks. Source   Edit   

Templates

template attrKey(my: XmlParser): string

	returns the attribute key for the event xmlAttribute Raises an assertion in debug mode if my.kind is not xmlAttribute. In release mode, this will not trigger an error but the value returned will not be valid. Source   Edit   

template attrValue(my: XmlParser): string

	returns the attribute value for the event xmlAttribute Raises an assertion in debug mode if my.kind is not xmlAttribute. In release mode, this will not trigger an error but the value returned will not be valid. Source   Edit   

template charData(my: XmlParser): string

	returns the character data for the events: xmlCharData, xmlWhitespace, xmlComment, xmlCData, xmlSpecial Raises an assertion in debug mode if my.kind is not one of those events. In release mode, this will not trigger an error but the value returned will not be valid. Source   Edit   

template elementName(my: XmlParser): string

	returns the element name for the events: xmlElementStart, xmlElementEnd, xmlElementOpen Raises an assertion in debug mode if my.kind is not one of those events. In release mode, this will not trigger an error but the value returned will not be valid. Source   Edit   

template entityName(my: XmlParser): string

	returns the entity name for the event: xmlEntity Raises an assertion in debug mode if my.kind is not xmlEntity. In release mode, this will not trigger an error but the value returned will not be valid. Source   Edit   

template piName(my: XmlParser): string

	returns the processing instruction name for the event xmlPI Raises an assertion in debug mode if my.kind is not xmlPI. In release mode, this will not trigger an error but the value returned will not be valid. Source   Edit   

template piRest(my: XmlParser): string

	returns the rest of the processing instruction for the event xmlPI Raises an assertion in debug mode if my.kind is not xmlPI. In release mode, this will not trigger an error but the value returned will not be valid. Source   Edit   


std/pegs


std/pegs
Source   Edit  

Simple PEG (Parsing expression grammar) matching. Uses no memorization, but uses superoperators and symbol inlining to improve performance. Note: Matching performance is hopefully competitive with optimized regular expression engines.
PEG syntax and semantics

A PEG (Parsing expression grammar) is a simple deterministic grammar, that can be directly used for parsing. The current implementation has been designed as a more powerful replacement for regular expressions. UTF-8 is supported.

The notation used for a PEG is similar to that of EBNF:
notation	meaning
A / ... / Z	Ordered choice: Apply expressions A, ..., Z, in this order, to the text ahead, until one of them succeeds and possibly consumes some text. Indicate success if one of expressions succeeded. Otherwise, do not consume any text and indicate failure.
A ... Z	Sequence: Apply expressions A, ..., Z, in this order, to consume consecutive portions of the text ahead, as long as they succeed. Indicate success if all succeeded. Otherwise, do not consume any text and indicate failure. The sequence's precedence is higher than that of ordered choice: A B / C means (A B) / Z and not A (B / Z).
(E)	Grouping: Parenthesis can be used to change operator priority.
{E}	Capture: Apply expression E and store the substring that matched E into a capture that can be accessed after the matching process.
{}	Empty capture: Delete the last capture. No character is consumed.
$i	Back reference to the ith capture. i counts forwards from 1 or backwards (last capture to first) from ^1.
$	Anchor: Matches at the end of the input. No character is consumed. Same as !..
^	Anchor: Matches at the start of the input. No character is consumed.
&E	And predicate: Indicate success if expression E matches the text ahead; otherwise indicate failure. Do not consume any text.
!E	Not predicate: Indicate failure if expression E matches the text ahead; otherwise indicate success. Do not consume any text.
E+	One or more: Apply expression E repeatedly to match the text ahead, as long as it succeeds. Consume the matched text (if any) and indicate success if there was at least one match. Otherwise, indicate failure.
E*	Zero or more: Apply expression E repeatedly to match the text ahead, as long as it succeeds. Consume the matched text (if any). Always indicate success.
E?	Zero or one: If expression E matches the text ahead, consume it. Always indicate success.
[s]	Character class: If the character ahead appears in the string s, consume it and indicate success. Otherwise, indicate failure.
[a-b]	Character range: If the character ahead is one from the range a through b, consume it and indicate success. Otherwise, indicate failure.
's'	String: If the text ahead is the string s, consume it and indicate success. Otherwise, indicate failure.
i's'	String match ignoring case.
y's'	String match ignoring style.
v's'	Verbatim string match: Use this to override a global \i or \y modifier.
i$j	String match ignoring case for back reference.
y$j	String match ignoring style for back reference.
v$j	Verbatim string match for back reference.
.	Any character: If there is a character ahead, consume it and indicate success. Otherwise, (that is, at the end of input) indicate failure.
_	Any Unicode character: If there is a UTF-8 character ahead, consume it and indicate success. Otherwise, indicate failure.
@E	Search: Shorthand for (!E .)* E. (Search loop for the pattern E.)
{@} E	Captured Search: Shorthand for {(!E .)*} E. (Search loop for the pattern E.) Everything until and excluding E is captured.
@@ E	Same as {@} E.
A <- E	Rule: Bind the expression E to the nonterminal symbol A. Left recursive rules are not possible and crash the matching engine.
\identifier	Built-in macro for a longer expression.
\ddd	Character with decimal code ddd.
\", etc.	Literal ", etc.
Built-in macros
macro	meaning
\d	any decimal digit: [0-9]
\D	any character that is not a decimal digit: [^0-9]
\s	any whitespace character: [ \9-\13]
\S	any character that is not a whitespace character: [^ \9-\13]
\w	any "word" character: [a-zA-Z0-9_]
\W	any "non-word" character: [^a-zA-Z0-9_]
\a	same as [a-zA-Z]
\A	same as [^a-zA-Z]
\n	any newline combination: \10 / \13\10 / \13
\i	ignore case for matching; use this at the start of the PEG
\y	ignore style for matching; use this at the start of the PEG
\skip pat	skip pattern pat before trying to match other tokens; this is useful for whitespace skipping, for example: \skip(\s*) {\ident} ':' {\ident} matches key value pairs ignoring whitespace around the ':'.
\ident	a standard ASCII identifier: [a-zA-Z_][a-zA-Z_0-9]*
\letter	any Unicode letter
\upper	any Unicode uppercase letter
\lower	any Unicode lowercase letter
\title	any Unicode title letter
\white	any Unicode whitespace character

A backslash followed by a letter is a built-in macro, otherwise it is used for ordinary escaping:
notation	meaning
\\	a single backslash
\*	same as '*'
\t	not a tabulator, but an (unknown) built-in
Supported PEG grammar

The PEG parser implements this grammar (written in PEG syntax):

# Example grammar of PEG in PEG syntax.
# Comments start with '#'.
# First symbol is the start symbol.

grammar <- rule* / expr

identifier <- [A-Za-z][A-Za-z0-9_]*
charsetchar <- "\\" . / [^\]]
charset <- "[" "^"? (charsetchar ("-" charsetchar)?)+ "]"
stringlit <- identifier? ("\"" ("\\" . / [^"])* "\"" /
                      	"'" ("\\" . / [^'])* "'")
builtin <- "\\" identifier / [^\13\10]

comment <- '#' @ \n
ig <- (\s / comment)* # things to ignore

rule <- identifier \s* "<-" expr ig
identNoArrow <- identifier !(\s* "<-")
prefixOpr <- ig '&' / ig '!' / ig '@' / ig '{@}' / ig '@@'
literal <- ig identifier? '$' '^'? [0-9]+ / '$' / '^' /
       	ig identNoArrow /
       	ig charset /
       	ig stringlit /
       	ig builtin /
       	ig '.' /
       	ig '_' /
       	(ig "(" expr ig ")") /
       	(ig "{" expr? ig "}")
postfixOpr <- ig '?' / ig '*' / ig '+'
primary <- prefixOpr* (literal postfixOpr*)

# Concatenation has higher priority than choice:
# ``a b / c`` means ``(a b) / c``

seqExpr <- primary+
expr <- seqExpr (ig "/" expr)*

Note: As a special syntactic extension if the whole PEG is only a single expression, identifiers are not interpreted as non-terminals, but are interpreted as verbatim string:

abc =~ peg"abc" # is true

So it is not necessary to write peg" 'abc' " in the above example.
Examples

Check if s matches Nim's "while" keyword:

s =~ peg" y'while'"

Exchange (key, val)-pairs:

"key: val; key2: val2".replacef(peg"{\ident} \s* ':' \s* {\ident}", "$2: $1")

Determine the #include'ed files of a C file:

for line in lines("myfile.c"):
  if line =~ peg"""s <- ws '#include' ws '"' {[^"]+} '"' ws
               	comment <- '/*' @ '*/' / '//' .*
               	ws <- (comment / \s+)* """:
	echo matches[0]

PEG vs regular expression

As a regular expression \[.*\] matches the longest possible text between '[' and ']'. As a PEG it never matches anything, because a PEG is deterministic: .* consumes the rest of the input, so \] never matches. As a PEG this needs to be written as: \[ ( !\] . )* \] (or \[ @ \]).

Note that the regular expression does not behave as intended either: in the example * should not be greedy, so \[.*?\] should be used instead.
PEG construction

There are two ways to construct a PEG in Nim code:

	Parsing a string into an AST which consists of Peg nodes with the peg proc.
	Constructing the AST directly with proc calls. This method does not support constructing rules, only simple expressions and is not as convenient. Its only advantage is that it does not pull in the whole PEG parser into your executable.

Imports

strutils, macros, decode_helpers, unicode

Types

Captures = object

	contains the captured substrings. Source   Edit   

EInvalidPeg = object of ValueError

	raised if an invalid PEG has been detected Source   Edit   

NonTerminal = ref NonTerminalObj

	Source   Edit   

NonTerminalFlag = enum
  ntDeclared, ntUsed

	Source   Edit   

Peg {.shallow.} = object
  case
  of pkEmpty .. pkWhitespace:
	nil
  of pkTerminal, pkTerminalIgnoreCase, pkTerminalIgnoreStyle:
  of pkChar, pkGreedyRepChar:
  of pkCharChoice, pkGreedyRepSet:
  of pkNonTerminal:
  of pkBackRef .. pkBackRefIgnoreStyle:
  else:

	type that represents a PEG Source   Edit   

PegKind = enum
  pkEmpty, pkAny,       	## any character (.)
  pkAnyRune,            	## any Unicode character (_)
  pkNewLine,            	## CR-LF, LF, CR
  pkLetter,             	## Unicode letter
  pkLower,              	## Unicode lower case letter
  pkUpper,              	## Unicode upper case letter
  pkTitle,              	## Unicode title character
  pkWhitespace,         	## Unicode whitespace character
  pkTerminal, pkTerminalIgnoreCase, pkTerminalIgnoreStyle, pkChar, ## single character to match
  pkCharChoice, pkNonTerminal, pkSequence, ## a b c ... --> Internal DSL: peg(a, b, c)
  pkOrderedChoice,      	## a / b / ... --> Internal DSL: a / b or /[a, b, c]
  pkGreedyRep,          	## a* 	--> Internal DSL: *a
                         	## a+ 	--> (a a*)
  pkGreedyRepChar,      	## x* where x is a single character (superop)
  pkGreedyRepSet,       	## [set]* (superop)
  pkGreedyAny,          	## .* or _* (superop)
  pkOption,             	## a? 	--> Internal DSL: ?a
  pkAndPredicate,       	## &a 	--> Internal DSL: &a
  pkNotPredicate,       	## !a 	--> Internal DSL: !a
  pkCapture,            	## {a}	--> Internal DSL: capture(a)
  pkBackRef,            	## $i 	--> Internal DSL: backref(i)
  pkBackRefIgnoreCase, pkBackRefIgnoreStyle, pkSearch, ## @a 	--> Internal DSL: !*a
  pkCapturedSearch,     	## {@} a  --> Internal DSL: !*\a
  pkRule,               	## a <- b
  pkList,               	## a, b
  pkStartAnchor          	## ^  	--> Internal DSL: startAnchor()

	Source   Edit   

Consts

MaxSubpatterns = 20

	defines the maximum number of subpatterns that can be captured. More subpatterns cannot be captured! Source   Edit   

Procs

func `!`(a: Peg): Peg {.....}

	constructs a "not predicate" with the PEG a Source   Edit   

func `!*`(a: Peg): Peg {.....}

	constructs a "search" for the PEG a Source   Edit   

func `!*\`(a: Peg): Peg {.....}

	constructs a "captured search" for the PEG a Source   Edit   

func `$`(r: Peg): string {.....}

	converts a PEG to its string representation Source   Edit   

func `&`(a: Peg): Peg {.....}

	constructs an "and predicate" with the PEG a Source   Edit   

func `*`(a: Peg): Peg {.....}

	constructs a "greedy repetition" for the PEG a Source   Edit   

func `+`(a: Peg): Peg {.....}

	constructs a "greedy positive repetition" with the PEG a Source   Edit   

func `/`(a: varargs[Peg]): Peg {.....}

	constructs an ordered choice with the PEGs in a Source   Edit   

func `?`(a: Peg): Peg {.....}

	constructs an optional for the PEG a Source   Edit   

func any(): Peg {.inline, ....}

	constructs the PEG any character (.) Source   Edit   

func anyRune(): Peg {.inline, ....}

	constructs the PEG any rune (_) Source   Edit   

func backref(index: range[1 .. MaxSubpatterns]; reverse: bool = false): Peg {.
	....}

	constructs a back reference of the given index. index starts counting from 1. reverse specifies wether indexing starts from the end of the capture list. Source   Edit   

func backrefIgnoreCase(index: range[1 .. MaxSubpatterns]; reverse: bool = false): Peg {.
	....}

	constructs a back reference of the given index. index starts counting from 1. reverse specifies wether indexing starts from the end of the capture list. Ignores case for matching. Source   Edit   

func backrefIgnoreStyle(index: range[1 .. MaxSubpatterns]; reverse: bool = false): Peg {.
	....}

	constructs a back reference of the given index. index starts counting from 1. reverse specifies wether indexing starts from the end of the capture list. Ignores style for matching. Source   Edit   

func bounds(c: Captures; i: range[0 .. 20 - 1]): tuple[first, last: int] {.
	....}

	returns the bounds [first..last] of the i'th capture. Source   Edit   

func capture(a: Peg = Peg(kind: pkEmpty)): Peg {.....}

	constructs a capture with the PEG a Source   Edit   

func ch(p: Peg): char {.....}

	Returns the char representation of a given Peg variant object where present. Source   Edit   

func charChoice(p: Peg): ref set[char] {.....}

	Returns the charChoice field of a given Peg variant object where present. Source   Edit   

func charSet(s: set[char]): Peg {.....}

	constructs a PEG from a character set s Source   Edit   

func col(nt: NonTerminal): int {.....}

	Gets the column number of the definition of the parent Peg object variant of a given NonTerminal. Source   Edit   

func contains(s: string; pattern: Peg; matches: var openArray[string]; start = 0): bool {.
	....}

	same as find(s, pattern, matches, start) >= 0 Source   Edit   

func contains(s: string; pattern: Peg; start = 0): bool {.....}

	same as find(s, pattern, start) >= 0 Source   Edit   

func endAnchor(): Peg {.inline, ....}

	constructs the PEG $ which matches the end of the input. Source   Edit   

func endsWith(s: string; suffix: Peg; start = 0): bool {.....}

	returns true if s ends with the pattern suffix Source   Edit   

func escapePeg(s: string): string {.....}

	escapes s so that it is matched verbatim when used as a peg. Source   Edit   

func find(s: string; pattern: Peg; matches: var openArray[string]; start = 0): int {.
	....}

	returns the starting position of pattern in s and the captured substrings in the array matches. If it does not match, nothing is written into matches and -1 is returned. Source   Edit   

func find(s: string; pattern: Peg; start = 0): int {.....}

	returns the starting position of pattern in s. If it does not match, -1 is returned. Source   Edit   

func findAll(s: string; pattern: Peg; start = 0): seq[string] {.....}

	returns all matching substrings of s that match pattern. If it does not match, @[] is returned. Source   Edit   

func findBounds(s: string; pattern: Peg; matches: var openArray[string];
            	start = 0): tuple[first, last: int] {.....}

	returns the starting position and end position of pattern in s and the captured substrings in the array matches. If it does not match, nothing is written into matches and (-1,0) is returned. Source   Edit   

func flags(nt: NonTerminal): set[NonTerminalFlag] {.....}

	Gets the NonTerminalFlag-typed flags field of the parent Peg variant object of a given NonTerminal. Source   Edit   

func index(p: Peg): range[-20 .. 20 - 1] {.....}

	Returns the back-reference index of a captured sub-pattern in the Captures object for a given Peg variant object where present. Source   Edit   

func kind(p: Peg): PegKind {.....}

	Returns the PegKind of a given Peg object. Source   Edit   

func line(nt: NonTerminal): int {.....}

	Gets the line number of the definition of the parent Peg object variant of a given NonTerminal. Source   Edit   

func match(s: string; pattern: Peg; matches: var openArray[string]; start = 0): bool {.
	....}

	returns true if s[start..] matches the pattern and the captured substrings in the array matches. If it does not match, nothing is written into matches and false is returned. Source   Edit   

func match(s: string; pattern: Peg; start = 0): bool {.....}

	returns true if s matches the pattern beginning from start. Source   Edit   

func matchLen(s: string; pattern: Peg; matches: var openArray[string]; start = 0): int {.
	....}

	the same as match, but it returns the length of the match, if there is no match, -1 is returned. Note that a match length of zero can happen. It's possible that a suffix of s remains that does not belong to the match. Source   Edit   

func matchLen(s: string; pattern: Peg; start = 0): int {.....}

	the same as match, but it returns the length of the match, if there is no match, -1 is returned. Note that a match length of zero can happen. It's possible that a suffix of s remains that does not belong to the match. Source   Edit   

func name(nt: NonTerminal): string {.....}

	Gets the name of the symbol represented by the parent Peg object variant of a given NonTerminal. Source   Edit   

func newLine(): Peg {.inline, ....}

	constructs the PEG newline (\n) Source   Edit   

func newNonTerminal(name: string; line, column: int): NonTerminal {.....}

	constructs a nonterminal symbol Source   Edit   

func nonterminal(n: NonTerminal): Peg {.....}

	constructs a PEG that consists of the nonterminal symbol Source   Edit   

func nt(p: Peg): NonTerminal {.....}

	Returns the NonTerminal object of a given Peg variant object where present. Source   Edit   

func parallelReplace(s: string; subs: varargs[tuple[pattern: Peg, repl: string]]): string {.
	....}

	Returns a modified copy of s with the substitutions in subs applied in parallel. Source   Edit   

func parsePeg(pattern: string; filename = "pattern"; line = 1; col = 0): Peg {.
	....}

	constructs a Peg object from pattern. filename, line, col are used for error messages, but they only provide start offsets. parsePeg keeps track of line and column numbers within pattern. Source   Edit   

func peg(pattern: string): Peg {.....}

constructs a Peg object from the pattern. The short name has been chosen to encourage its use as a raw string modifier:

peg"{\ident} \s* '=' \s* {.*}"

	Source   Edit   

func rawMatch(s: string; p: Peg; start: int; c: var Captures): int {.....}

	low-level matching proc that implements the PEG interpreter. Use this for maximum efficiency (every other PEG operation ends up calling this proc). Returns -1 if it does not match, else the length of the match Source   Edit   

func replace(s: string; sub: Peg;
         	cb: proc (match: int; cnt: int; caps: openArray[string]): string): string {.
	...effectsOf: cb, ....}

Replaces sub in s by the resulting strings from the callback. The callback proc receives the index of the current match (starting with 0), the count of captures and an open array with the captures of each match. Examples:

func handleMatches*(m: int, n: int, c: openArray[string]): string =
  result = ""
  if m > 0:
	result.add ", "
  result.add case n:
	of 2: c[0].toLower & ": '" & c[1] & "'"
	of 1: c[0].toLower & ": ''"
	else: ""

let s = "Var1=key1;var2=Key2;   VAR3"
echo s.replace(peg"{\ident}('='{\ident})* ';'* \s*", handleMatches)

Results in:

"var1: 'key1', var2: 'Key2', var3: ''"

	Source   Edit   

func replace(s: string; sub: Peg; by = ""): string {.....}

	Replaces sub in s by the string by. Captures cannot be accessed in by. Source   Edit   

func replacef(s: string; sub: Peg; by: string): string {.....}

Replaces sub in s by the string by. Captures can be accessed in by with the notation $i and $# (see strutils.%). Examples:

"var1=key; var2=key2".replacef(peg"{\ident}'='{\ident}", "$1<-$2$2")

Results in:

"var1<-keykey; val2<-key2key2"

	Source   Edit   

func rule(nt: NonTerminal): Peg {.....}

	Gets the Peg object representing the rule definition of the parent Peg object variant of a given NonTerminal. Source   Edit   

func sequence(a: varargs[Peg]): Peg {.....}

	constructs a sequence with all the PEGs from a Source   Edit   

func split(s: string; sep: Peg): seq[string] {.....}

	Splits the string s into substrings. Source   Edit   

func startAnchor(): Peg {.inline, ....}

	constructs the PEG ^ which matches the start of the input. Source   Edit   

func startsWith(s: string; prefix: Peg; start = 0): bool {.....}

	returns true if s starts with the pattern prefix Source   Edit   

func term(p: Peg): string {.....}

	Returns the string representation of a given Peg variant object where present. Source   Edit   

func term(t: char): Peg {.....}

	constructs a PEG from a terminal char Source   Edit   

func term(t: string): Peg {.....}

	constructs a PEG from a terminal string Source   Edit   

func termIgnoreCase(t: string): Peg {.....}

	constructs a PEG from a terminal string; ignore case for matching Source   Edit   

func termIgnoreStyle(t: string): Peg {.....}

	constructs a PEG from a terminal string; ignore style for matching Source   Edit   

proc transformFile(infile, outfile: string;
               	subs: varargs[tuple[pattern: Peg, repl: string]]) {.....}

	reads in the file infile, performs a parallel replacement (calls parallelReplace) and writes back to outfile. Raises IOError if an error occurs. This is supposed to be used for quick scripting.

	Note: this proc does not exist while using the JS backend.
	Source   Edit   

func unicodeLetter(): Peg {.inline, ....}

	constructs the PEG \letter which matches any Unicode letter. Source   Edit   

func unicodeLower(): Peg {.inline, ....}

	constructs the PEG \lower which matches any Unicode lowercase letter. Source   Edit   

func unicodeTitle(): Peg {.inline, ....}

	constructs the PEG \title which matches any Unicode title letter. Source   Edit   

func unicodeUpper(): Peg {.inline, ....}

	constructs the PEG \upper which matches any Unicode uppercase letter. Source   Edit   

func unicodeWhitespace(): Peg {.inline, ....}

	constructs the PEG \white which matches any Unicode whitespace character. Source   Edit   

Iterators

iterator findAll(s: string; pattern: Peg; start = 0): string {.....}

	yields all matching substrings of s that match pattern. Source   Edit   

iterator items(p: Peg): Peg {.inline, ....}

	Yields the child nodes of a Peg variant object where present. Source   Edit   

iterator pairs(p: Peg): (int, Peg) {.inline, ....}

	Yields the indices and child nodes of a Peg variant object where present. Source   Edit   

iterator split(s: string; sep: Peg): string {.....}

Splits the string s into substrings.

Substrings are separated by the PEG sep. Examples:

for word in split("00232this02939is39an22example111", peg"\d+"):
  writeLine(stdout, word)

Results in:

"this"
"is"
"an"
"example"

	Source   Edit   

Templates

template `=~`(s: string; pattern: Peg): bool

This calls match with an implicit declared matches array that can be used in the scope of the =~ call:

if line =~ peg"\s* {\w+} \s* '=' \s* {\w+}":
  # matches a key=value pair:
  echo("Key: ", matches[0])
  echo("Value: ", matches[1])
elif line =~ peg"\s*{'#'.*}":
  # matches a comment
  # note that the implicit ``matches`` array is different from the
  # ``matches`` array of the first branch
  echo("comment: ", matches[0])
else:
  echo("syntax error")

	Source   Edit   

template digits(): Peg

	expands to charset({'0'..'9'}) Source   Edit   

template eventParser(pegAst, handlers: untyped): (proc (s: string): int)

Generates an interpreting event parser proc according to the specified PEG AST and handler code blocks. The proc can be called with a string to be parsed and will execute the handler code blocks whenever their associated grammar element is matched. It returns -1 if the string does not match, else the length of the total match. The following example code evaluates an arithmetic expression defined by a simple PEG:

import std/[strutils, pegs]

let
  pegAst = """
Expr	<- Sum
Sum 	<- Product (('+' / '-')Product)*
Product <- Value (('*' / '/')Value)*
Value   <- [0-9]+ / '(' Expr ')'
  """.peg
  txt = "(5+3)/2-7*22"

var
  pStack: seq[string] = @[]
  valStack: seq[float] = @[]
  opStack = ""
let
  parseArithExpr = pegAst.eventParser:
	pkNonTerminal:
  	enter:
    	pStack.add p.nt.name
  	leave:
    	pStack.setLen pStack.high
    	if length > 0:
      	let matchStr = s.substr(start, start+length-1)
      	case p.nt.name
      	of "Value":
        	try:
          	valStack.add matchStr.parseFloat
          	echo valStack
        	except ValueError:
          	discard
      	of "Sum", "Product":
        	try:
          	let val = matchStr.parseFloat
        	except ValueError:
          	if valStack.len > 1 and opStack.len > 0:
            	valStack[^2] = case opStack[^1]
            	of '+': valStack[^2] + valStack[^1]
            	of '-': valStack[^2] - valStack[^1]
            	of '*': valStack[^2] * valStack[^1]
            	else: valStack[^2] / valStack[^1]
            	valStack.setLen valStack.high
            	echo valStack
            	opStack.setLen opStack.high
            	echo opStack
	pkChar:
  	leave:
    	if length == 1 and "Value" != pStack[^1]:
      	let matchChar = s[start]
      	opStack.add matchChar
      	echo opStack

let pLen = parseArithExpr(txt)

	The handlers parameter consists of code blocks for PegKinds, which define the grammar elements of interest. Each block can contain handler code to be executed when the parser enters and leaves text matching the grammar element. An enter handler can access the specific PEG AST node being matched as p, the entire parsed string as s and the position of the matched text segment in s as start. A leave handler can access p, s, start and also the length of the matched text segment as length. For an unsuccessful match, the enter and leave handlers will be executed, with length set to -1.

	Symbols declared in an enter handler can be made visible in the corresponding leave handler by annotating them with an inject pragma.
	Source   Edit   

template ident(): Peg

	same as [a-zA-Z_][a-zA-z_0-9]*; standard identifier Source   Edit   

template identChars(): Peg

	expands to charset({'a'..'z', 'A'..'Z', '0'..'9', '_'}) Source   Edit   

template identStartChars(): Peg

	expands to charset({'A'..'Z', 'a'..'z', '_'}) Source   Edit   

template letters(): Peg

	expands to charset({'A'..'Z', 'a'..'z'}) Source   Edit   

template natural(): Peg

	same as \d+ Source   Edit   

template whitespace(): Peg

	expands to charset({' ', '\9'..'\13'}) Source   Edit   

Exports

==

Docutils

packages/docutils/highlite


packages/docutils/highlite
Source   Edit  

Source highlighter for programming or markup languages. Currently only few languages are supported, other languages may be added. The interface supports one language nested in another.

You can use this to build your own syntax highlighting, check this example:

let code = """for x in $int.high: echo x.ord mod 2 == 0"""
var toknizr: GeneralTokenizer
initGeneralTokenizer(toknizr, code)
while true:
  getNextToken(toknizr, langNim)
  case toknizr.kind
  of gtEof: break  # End Of File (or string)
  of gtWhitespace:
	echo gtWhitespace # Maybe you want "visible" whitespaces?.
	echo substr(code, toknizr.start, toknizr.length + toknizr.start - 1)
  of gtOperator:
	echo gtOperator # Maybe you want Operators to use a specific color?.
	echo substr(code, toknizr.start, toknizr.length + toknizr.start - 1)
  # of gtSomeSymbol: syntaxHighlight("Comic Sans", "bold", "99px", "pink")
  else:
	echo toknizr.kind # All the kinds of tokens can be processed here.
	echo substr(code, toknizr.start, toknizr.length + toknizr.start - 1)

The proc getSourceLanguage can get the language enum from a string:

for l in ["C", "c++", "jAvA", "Nim", "c#"]: echo getSourceLanguage(l)

There is also a Cmd pseudo-language supported, which is a simple generic shell/cmdline tokenizer (UNIX shell/Powershell/Windows Command): no escaping, no programming language constructs besides variable definition at the beginning of line. It supports these operators:

&  &&  |  ||  (  )  ''  ""  ;  # for comments

Instead of escaping always use quotes like here nimgrep --ext:'nim|nims' file.name shows how to input |. Any argument that contains . or / or \ will be treated as a file or directory.

In addition to Cmd there is also Console language for displaying interactive sessions. Lines with a command should start with $, other lines are considered as program output.

Imports

strutils, algorithm

Types

GeneralTokenizer = object of RootObj
  kind*: TokenClass
  start*, length*: int

	Source   Edit   

SourceLanguage = enum
  langNone, langNim, langCpp, langCsharp, langC, langJava, langYaml, langPython,
  langCmd, langConsole

	Source   Edit   

TokenClass = enum
  gtEof, gtNone, gtWhitespace, gtDecNumber, gtBinNumber, gtHexNumber,
  gtOctNumber, gtFloatNumber, gtIdentifier, gtKeyword, gtStringLit,
  gtLongStringLit, gtCharLit, gtEscapeSequence, gtOperator, gtPunctuation,
  gtComment, gtLongComment, gtRegularExpression, gtTagStart, gtTagEnd, gtKey,
  gtValue, gtRawData, gtAssembler, gtPreprocessor, gtDirective, gtCommand,
  gtRule, gtHyperlink, gtLabel, gtReference, gtPrompt, gtProgramOutput,
  gtProgram, gtOption, gtOther

	Source   Edit   

Consts

sourceLanguageToAlpha: array[SourceLanguage, string] = ["none", "Nim", "cpp",
	"csharp", "C", "Java", "Yaml", "Python", "Cmd", "Console"]

	list of languages spelled with alpabetic characters Source   Edit   

sourceLanguageToStr: array[SourceLanguage, string] = ["none", "Nim", "C++",
	"C#", "C", "Java", "Yaml", "Python", "Cmd", "Console"]

	Source   Edit   

tokenClassToStr: array[TokenClass, string] = ["Eof", "None", "Whitespace",
	"DecNumber", "BinNumber", "HexNumber", "OctNumber", "FloatNumber",
	"Identifier", "Keyword", "StringLit", "LongStringLit", "CharLit",
	"EscapeSequence", "Operator", "Punctuation", "Comment", "LongComment",
	"RegularExpression", "TagStart", "TagEnd", "Key", "Value", "RawData",
	"Assembler", "Preprocessor", "Directive", "Command", "Rule", "Hyperlink",
	"Label", "Reference", "Prompt", "ProgramOutput", "program", "option",
	"Other"]

	Source   Edit   

Procs

proc deinitGeneralTokenizer(g: var GeneralTokenizer) {.....}

	Source   Edit   

proc getNextToken(g: var GeneralTokenizer; lang: SourceLanguage) {.....}

	Source   Edit   

proc getSourceLanguage(name: string): SourceLanguage {.....}

	Source   Edit   

proc initGeneralTokenizer(g: var GeneralTokenizer; buf: cstring) {.....}

	Source   Edit   

proc initGeneralTokenizer(g: var GeneralTokenizer; buf: string) {.....}

	Source   Edit   

proc tokenize(text: string; lang: SourceLanguage): seq[(string, TokenClass)] {.
	....}

	Source   Edit   

packages/docutils/rst


packages/docutils/rst
Source   Edit  

This module implements a reStructuredText (RST) and Markdown parser. User's manual on supported markup syntax and command line usage can be found in Nim-flavored Markdown and reStructuredText.

	See also Nim DocGen Tools Guide for handling of .nim files.
	See also packages/docutils/rstgen module to know how to generate HTML or Latex strings (for embedding them into custom documents).

Choice between Markdown and RST as well as optional additional features are turned on by passing options: RstParseOptions to proc rstParse.

Imports

os, strutils, rstast, dochelpers, enumutils, algorithm, lists, sequtils, miscdollars, tables, strscans, rstidx, highlite

Types

EParseError = object of ValueError

	Source   Edit   

FindFileHandler = proc (filename: string): string {.closure, ....}

	Source   Edit   

FindRefFileHandler = proc (targetRelPath: string): tuple[targetPath: string,
	linkRelPath: string] {.closure, ....}

	returns where .html or .idx file should be found by its relative path; linkRelPath is a prefix to be added before a link anchor from such file Source   Edit   

MsgClass = enum
  mcHint = "Hint", mcWarning = "Warning", mcError = "Error"

	Source   Edit   

MsgHandler = proc (filename: string; line, col: int; msgKind: MsgKind;
               	arg: string) {.closure, ....}

	what to do in case of an error Source   Edit   

MsgKind = enum
  meCannotOpenFile = "cannot open \'$1\'", meExpected = "\'$1\' expected",
  meMissingClosing = "$1",
  meGridTableNotImplemented = "grid table is not implemented",
  meMarkdownIllformedTable = "illformed delimiter row of a Markdown table",
  meIllformedTable = "Illformed table: $1",
  meNewSectionExpected = "new section expected $1",
  meGeneralParseError = "general parse error",
  meInvalidDirective = "invalid directive: \'$1\'",
  meInvalidField = "invalid field: $1",
  meFootnoteMismatch = "mismatch in number of footnotes and their refs: $1",
  mwRedefinitionOfLabel = "redefinition of label \'$1\'",
  mwUnknownSubstitution = "unknown substitution \'$1\'",
  mwAmbiguousLink = "ambiguous doc link $1",
  mwBrokenLink = "broken link \'$1\'",
  mwUnsupportedLanguage = "language \'$1\' not supported",
  mwUnsupportedField = "field \'$1\' not supported",
  mwRstStyle = "RST style: $1",
  mwUnusedImportdoc = "importdoc for \'$1\' is not used",
  meSandboxedDirective = "disabled directive: \'$1\'"

	the possible messages Source   Edit   

PRstSharedState = ref RstSharedState

	Source   Edit   

RstFileTable = object
  filenameToIdx*: Table[string, FileIndex]
  idxToFilename*: seq[string]

	Source   Edit   

RstParseOption = enum
  roSupportSmilies,     	## make the RST parser support smilies like ``:)``
  roSupportRawDirective,	## support the ``raw`` directive (don't support
                         	## it for sandboxing)
  roSupportMarkdown,    	## support additional features of Markdown
  roPreferMarkdown,     	## parse as Markdown (keeping RST as "extension"
                         	## to Markdown) -- implies `roSupportMarkdown`
  roNimFile,            	## set for Nim files where default interpreted
                         	## text role should be :nim:
  roSandboxDisabled      	## this option enables certain options
                         	## (e.g. raw, include, importdoc)
                         	## which are disabled by default as they can
                         	## enable users to read arbitrary data and
                         	## perform XSS if the parser is used in a web
                         	## app.

	options for the RST parser Source   Edit   

RstParseOptions = set[RstParseOption]

	Source   Edit   

Consts

ColRstInit = 0

	Initial column number for standalone RST text (Nim global reporting adds ColOffset=1) Source   Edit   

ColRstOffset = 1

	1: a replica of ColOffset for internal use Source   Edit   

LineRstInit = 1

	Initial line number for standalone RST text Source   Edit   

Procs

proc addAnchorNim(s: var PRstSharedState; external: bool; refn: string;
              	tooltip: string; langSym: LangSymbol; priority: int;
              	info: TLineInfo; module: FileIndex) {.....}

	Adds an anchor refn, which follows the rule arNim (i.e. a symbol in *.nim file) Source   Edit   

proc addFilename(s: PRstSharedState; file1: string): FileIndex {.....}

	Returns index of filename, adding it if it has not been used before Source   Edit   

proc addNodes(n: PRstNode): string {.....}

	Source   Edit   

proc completePass2(s: PRstSharedState) {.....}

	Source   Edit   

proc defaultFindFile(filename: string): string {.....}

	Source   Edit   

proc defaultFindRefFile(filename: string): (string, string) {.....}

	Source   Edit   

proc defaultMsgHandler(filename: string; line, col: int; msgkind: MsgKind;
                   	arg: string) {.....}

	Source   Edit   

proc getArgument(n: PRstNode): string {.....}

	Source   Edit   

proc getFieldValue(n: PRstNode): string {.....}

	Returns the value of a specific rnField node.

	This proc will assert if the node is not of the expected type. The empty string will be returned as a minimum. Any value in the rst will be stripped form leading/trailing whitespace.
	Source   Edit   

proc getFieldValue(n: PRstNode; fieldname: string): string {.....}

	Source   Edit   

proc newRstSharedState(options: RstParseOptions; filename: string;
                   	findFile: FindFileHandler;
                   	findRefFile: FindRefFileHandler; msgHandler: MsgHandler;
                   	hasToc: bool): PRstSharedState {.....}

	Source   Edit   

proc preparePass2(s: var PRstSharedState; mainNode: PRstNode; importdoc = true) {.
	....}

	Records titles in node mainNode and orders footnotes. Source   Edit   

proc resolveSubs(s: PRstSharedState; n: PRstNode): PRstNode {.
	....}

	Makes pass 2 of RST parsing. Resolves substitutions and anchor aliases, groups footnotes. Takes input node n and returns the same node with recursive substitutions in n.sons to result. Source   Edit   

proc rstMessage(filenames: RstFileTable; f: MsgHandler; info: TLineInfo;
            	msgKind: MsgKind; arg: string) {.
	....}

	Print warnings using info, i.e. in 2nd-pass warnings for footnotes/substitutions/references or from rstgen.nim. Source   Edit   

proc rstnodeToRefname(n: PRstNode): string {.....}

	Source   Edit   

proc rstParse(text, filename: string; line, column: int;
          	options: RstParseOptions; findFile: FindFileHandler = nil;
          	findRefFile: FindRefFileHandler = nil;
          	msgHandler: MsgHandler = nil): tuple[node: PRstNode,
	filenames: RstFileTable, hasToc: bool] {.
	....}

	Parses the whole text. The result is ready for rstgen.renderRstToOut, note that 2nd tuple element should be fed to initRstGenerator argument filenames (it is being filled here at least with filename and possibly with other files from RST .. include:: statement). Source   Edit   

proc rstParsePass1(fragment: string; line, column: int;
               	sharedState: PRstSharedState): PRstNode {.
	....}

	Parses an RST fragment. The result should be further processed by preparePass2 and resolveSubs (which is pass 2). Source   Edit   

proc safeProtocol(linkStr: var string): string {.....}

	Source   Edit   

proc setCurrFilename(s: PRstSharedState; file1: string) {.....}

	Source   Edit   

proc whichMsgClass(k: MsgKind): MsgClass {.....}

	returns which message class k belongs to. Source   Edit   



packages/docutils/rstast


packages/docutils/rstast
Source   Edit  

This module implements an AST for the reStructuredText parser.
Imports

strutils, json

Types

FileIndex = distinct int32

	Source   Edit   

PRstNode = ref RstNode

	an RST node Source   Edit   

RstNode {.acyclic, final.} = object
  case kind*: RstNodeKind	## the node's kind
  of rnLeaf, rnSmiley:
	text*: string        	## string that is expected to be displayed
  of rnEnumList:
	labelFmt*: string    	## label format like "(1)"
  of rnLineBlockItem:
	lineIndent*: string  	## a few spaces or newline at the line beginning
  of rnAdmonition:
	adType*: string      	## admonition type: "note", "caution", etc. This
                         	## text will set the style and also be displayed
  of rnOverline, rnHeadline, rnMarkdownHeadline:
	level*: int          	## level of headings starting from 1 (main
                         	## chapter) to larger ones (minor sub-sections)
                         	## level=0 means it's document title or subtitle
  of rnFootnote, rnCitation, rnOptionListItem:
	order*: int          	## footnote order (for auto-symbol footnotes and
                         	## auto-numbered ones without a label)
  of rnMarkdownBlockQuoteItem:
	quotationDepth*: int 	## number of characters in line prefix
  of rnRstRef, rnPandocRef, rnSubstitutionReferences, rnInterpretedText,
 	rnField, rnInlineCode, rnCodeBlock, rnFootnoteRef:
	info*: TLineInfo     	## To have line/column info for warnings at
                         	## nodes that are post-processed after parsing
  of rnNimdocRef:
	tooltip*: string
  of rnTable, rnGridTable, rnMarkdownTable:
	colCount*: int       	## Number of (not-united) cells in the table
  of rnTableRow:
	endsHeader*: bool    	## Is last row in the header of table?
  of rnTableHeaderCell, rnTableDataCell:
	span*: int           	## Number of table columns that the cell occupies
  else:
	nil
  anchor*: string        	## anchor, internal link target
                         	## (aka HTML id tag, aka Latex label/hypertarget)
  sons*: RstNodeSeq      	## the node's sons

	AST node (result of RST parsing) Source   Edit   

RstNodeKind = enum
  rnInner, rnHeadline, rnOverline, rnMarkdownHeadline, rnTransition,
  rnParagraph, rnBulletList, rnBulletItem, rnEnumList, rnEnumItem, rnDefList,
  rnMdDefList, rnDefItem, rnDefName, rnDefBody, rnFieldList, rnField,
  rnFieldName, rnFieldBody, rnOptionList, rnOptionListItem, rnOptionGroup,
  rnOption, rnOptionString, rnOptionArgument, rnDescription, rnLiteralBlock,
  rnMarkdownBlockQuote, rnMarkdownBlockQuoteItem, rnLineBlock, rnLineBlockItem,
  rnBlockQuote, rnTable, rnGridTable, rnMarkdownTable, rnTableRow,
  rnTableHeaderCell, rnTableDataCell, rnFootnote, rnCitation, rnFootnoteGroup,
  rnStandaloneHyperlink, rnHyperlink, rnRstRef, rnPandocRef, rnInternalRef,
  rnFootnoteRef, rnNimdocRef, rnDirective, rnDirArg, rnRaw, rnTitle, rnContents,
  rnImage, rnFigure, rnCodeBlock, rnAdmonition, rnRawHtml, rnRawLatex,
  rnContainer, rnIndex, rnSubstitutionDef, rnInlineCode, rnCodeFragment,
  rnUnknownRole, rnSub, rnSup, rnIdx, rnEmphasis, rnStrongEmphasis,
  rnTripleEmphasis, rnInterpretedText, rnInlineLiteral, rnInlineTarget,
  rnSubstitutionReferences, rnSmiley, rnDefaultRole, rnLeaf

	the possible node kinds of an PRstNode Source   Edit   

RstNodeSeq = seq[PRstNode]

	Source   Edit   

TLineInfo = object
  line*: uint16
  col*: int16
  fileIndex*: FileIndex

	Source   Edit   

Procs

proc `==`(a, b: FileIndex): bool {.borrow, ....}

	Source   Edit   

proc add(father, son: PRstNode) {.....}

	Source   Edit   

proc add(father: PRstNode; s: string) {.....}

	Source   Edit   

proc addIfNotNil(father, son: PRstNode) {.....}

	Source   Edit   

proc lastSon(n: PRstNode): PRstNode {.....}

	Source   Edit   

proc len(n: PRstNode): int {.....}

	Source   Edit   

proc newRstLeaf(s: string): PRstNode {.....}

	Source   Edit   

proc newRstNode(kind: RstNodeKind; info: TLineInfo; sons: seq[PRstNode] = @[]): PRstNode {.
	....}

	Source   Edit   

proc newRstNode(kind: RstNodeKind; s: string): PRstNode {.....}

	Deprecated
	Source   Edit   

proc newRstNode(kind: RstNodeKind; sons: seq[PRstNode] = @[]; anchor = ""): PRstNode {.
	....}

	Source   Edit   

proc renderRstToJson(node: PRstNode): string {.....}

Writes the given RST node as JSON that is in the form

{
  "kind":string node.kind,
  "text":optional string node.text,
  "level":optional int node.level,
  "sons":optional node array
}

	Source   Edit   

proc renderRstToRst(n: PRstNode; result: var string) {.....}

	renders n into its string representation and appends to result. Source   Edit   

proc renderRstToText(node: PRstNode): string {.....}

	minimal text representation of markup node Source   Edit   

proc treeRepr(node: PRstNode; indent = 0): string {.....}

	Writes the parsed RST node into an AST tree with compact string representation in the format (one line per every sub-node): indent - kind - [text|level|order|adType] - anchor (if non-zero) (suitable for debugging of RST parsing). Source   Edit   

packages/docutils/rstgen


packages/docutils/rstgen
Source   Edit  

This module implements a generator of HTML/Latex from reStructuredText (see http://docutils.sourceforge.net/rst.html for information on this markup syntax) and is used by the compiler's docgen tools.

You can generate HTML output through the convenience proc rstToHtml, which provided an input string with rst markup returns a string with the generated HTML. The final output is meant to be embedded inside a full document you provide yourself, so it won't contain the usual <header> or <body> parts.

You can also create a RstGenerator structure and populate it with the other lower level methods to finally build complete documents. This requires many options and tweaking, but you are not limited to snippets and can generate LaTeX documents too.

Docutils configuration files are not supported. Instead HTML generation can be tweaked by editing file config/nimdoc.cfg.

There are stylistic difference between how this module renders some elements and how original Python Docutils does:

	Backreferences to TOC in section headings are not generated. In HTML each section is also a link that points to the section itself: this is done for user to be able to copy the link into clipboard.
	The same goes for footnotes/citations links: they point to themselves. No backreferences are generated since finding all references of a footnote can be done by simply searching for [footnoteName].

Imports

strutils, os, hashes, strtabs, rstast, rst, rstidx, highlite, tables, sequtils, algorithm, parseutils, strbasics, since

Types

EscapeMode = enum
  emText, emOption, emUrl

	Source   Edit   

IndexedDocs = Table[IndexEntry, seq[IndexEntry]]

	Contains the index sequences for doc types.

	The key is a fake IndexEntry which will contain the title of the document in the keyword field and link will contain the html filename for the document. linkTitle and linkDesc will be empty.

	The value indexed by this IndexEntry is a sequence with the real index entries found in the .idx file.
	Source   Edit   

MetaEnum = enum
  metaNone, metaTitleRaw, metaTitle, metaSubtitle, metaAuthor, metaVersion

	Source   Edit   

OutputTarget = enum
  outHtml, outLatex

	which document type to generate Source   Edit   

RstGenerator = object of RootObj
  target*: OutputTarget
  config*: StringTableRef
  splitAfter*: int
  listingCounter*: int
  tocPart*: seq[PRstNode]
  hasToc*: bool
  findFile*: FindFileHandler
  msgHandler*: MsgHandler
  outDir*: string        	## output directory, initialized by docgen.nim
  destFile*: string      	## output (HTML) file, initialized by docgen.nim
  filenames*: RstFileTable
  filename*: string      	## source Nim or Rst file
  meta*: array[MetaEnum, string]
  ## \
  ## Stores the empty string or the last headline/overline found in the rst
  ## document, so it can be used as a prettier name for term index generation.
  ## \
  ## Keeps count of same text index terms to generate different identifiers
  ## for hyperlinks. See renderIndexTerm proc for details.
  id*: int               	## A counter useful for generating IDs.
  onTestSnippet*: proc (d: var RstGenerator; filename, cmd: string; status: int;
                    	content: string) {.....}
  escMode*: EscapeMode

	Source   Edit   

Consts

IndexExt = ".idx"

	Source   Edit   

Procs

proc defaultConfig(): StringTableRef {.....}

	Returns a default configuration for embedded HTML generation.

	The returned StringTableRef contains the parameters used by the HTML engine to build the final output. For information on what these parameters are and their purpose, please look up the file config/nimdoc.cfg bundled with the compiler.

	The only difference between the contents of that file and the values provided by this proc is the doc.file variable. The doc.file variable of the configuration file contains HTML to build standalone pages, while this proc returns just the content for procs like rstToHtml to generate the bare minimum HTML.
	Source   Edit   

proc esc(target: OutputTarget; s: string; splitAfter = -1; escMode = emText): string {.
	....}

	Escapes the HTML. Source   Edit   

proc escChar(target: OutputTarget; dest: var string; c: char;
         	escMode: EscapeMode) {.inline, ....}

	Source   Edit   

proc formatNamedVars(frmt: string; varnames: openArray[string];
                 	varvalues: openArray[string]): string {.
	....}

	Source   Edit   

proc initRstGenerator(g: var RstGenerator; target: OutputTarget;
                  	config: StringTableRef; filename: string;
                  	findFile: FindFileHandler = nil;
                  	msgHandler: MsgHandler = nil;
                  	filenames = default(RstFileTable); hasToc = false) {.
	....}

Initializes a RstGenerator.

You need to call this before using a RstGenerator with any other procs in this module. Pass a non nil StringTableRef value as config with parameters used by the HTML output generator. If you don't know what to use, pass the results of the defaultConfig() <#defaultConfig>_ proc.

The filename parameter will be used for error reporting and creating index hyperlinks to the file, but you can pass an empty string here if you are parsing a stream in memory. If filename ends with the .nim extension, the title for the document will be set by default to Module filename. This default title can be overridden by the embedded rst, but it helps to prettify the generated index if no title is found.

The RstParseOptions, FindFileHandler and MsgHandler types are defined in the packages/docutils/rst module. options selects the behaviour of the rst parser.

findFile is a proc used by the rst include directive among others. The purpose of this proc is to mangle or filter paths. It receives paths specified in the rst document and has to return a valid path to existing files or the empty string otherwise. If you pass nil, a default proc will be used which given a path returns the input path only if the file exists. One use for this proc is to transform relative paths found in the document to absolute path, useful if the rst file and the resources it references are not in the same directory as the current working directory.

The msgHandler is a proc used for user error reporting. It will be called with the filename, line, col, and type of any error found during parsing. If you pass nil, a default message handler will be used which writes the messages to the standard output.

Example:

import packages/docutils/rstgen

var gen: RstGenerator
gen.initRstGenerator(outHtml, defaultConfig(), "filename", {})

	Source   Edit   

proc mergeIndexes(dir: string): string {.....}

	Merges all index files in dir and returns the generated index as HTML.

	This proc will first scan dir for index files with the .idx extension previously created by commands like nim doc|rst2html which use the --index:on switch. These index files are the result of calls to setIndexTerm() and writeIndexFile(), so they are simple tab separated files.

	As convention this proc will split index files into two categories: documentation and API. API indices will be all joined together into a single big sorted index, making the bulk of the final index. This is good for API documentation because many symbols are repeated in different modules. On the other hand, documentation indices are essentially table of contents plus a few special markers. These documents will be rendered in a separate section which tries to maintain the order and hierarchy of the symbols in the index file.

	To differentiate between a documentation and API file a convention is used: indices which contain one entry without the HTML hash character (#) will be considered documentation, since this hash-less entry is the explicit title of the document. Indices without this explicit entry will be considered generated API extracted out of a source .nim file.

	Returns the merged and sorted indices into a single HTML block which can be further embedded into nimdoc templates.
	Source   Edit   

proc nextSplitPoint(s: string; start: int): int {.....}

	Source   Edit   

proc prettyLink(file: string): string {.....}

	Source   Edit   

proc readIndexDir(dir: string): tuple[modules: seq[string],
                                  	symbols: seq[IndexEntry],
                                  	docs: IndexedDocs] {.
	....}

	Walks dir reading .idx files converting them in IndexEntry items.

	Returns the list of found module names, the list of free symbol entries and the different documentation indexes. The list of modules is sorted. See the documentation of mergeIndexes for details.
	Source   Edit   

proc renderCodeLang(result: var string; lang: SourceLanguage; code: string;
                	target: OutputTarget) {.....}

	Source   Edit   

proc renderIndexTerm(d: PDoc; n: PRstNode; result: var string) {.
	....}

	Renders the string decorated within `foobar`:idx: markers.

	Additionally adds the enclosed text to the index as a term. Since we are interested in different instances of the same term to have different entries, a table is used to keep track of the amount of times a term has previously appeared to give a different identifier value for each.
	Source   Edit   

proc renderNimCode(result: var string; code: string; target: OutputTarget) {.
	....}

	Source   Edit   

proc renderRstToOut(d: var RstGenerator; n: PRstNode; result: var string) {.
	....}

Writes into result the rst ast n using the d configuration.

Before using this proc you need to initialise a RstGenerator with initRstGenerator and parse a rst file with rstParse from the packages/docutils/rst module. Example:

# ...configure gen and rst vars...
var generatedHtml = ""
renderRstToOut(gen, rst, generatedHtml)
echo generatedHtml

	Source   Edit   

proc renderTocEntries(d: var RstGenerator; j: var int; lvl: int;
                  	result: var string) {.....}

	Source   Edit   

proc rstToHtml(s: string; options: RstParseOptions; config: StringTableRef;
           	msgHandler: MsgHandler = rst.defaultMsgHandler): string {.....}

Converts an input rst string into embeddable HTML.

This convenience proc parses any input string using rst markup (it doesn't have to be a full document!) and returns an embeddable piece of HTML. The proc is meant to be used in online environments without access to a meaningful filesystem, and therefore rst include like directives won't work. For an explanation of the config parameter see the initRstGenerator proc. Example:

import packages/docutils/rstgen, strtabs

echo rstToHtml("*Hello* **world**!", {},
  newStringTable(modeStyleInsensitive))
# --> <em>Hello</em> <strong>world</strong>!

	If you need to allow the rst include directive or tweak the generated output you have to create your own RstGenerator with initRstGenerator and related procs.
	Source   Edit   

proc rstToLatex(rstSource: string; options: RstParseOptions): string {.inline,
	....}

Convenience proc for renderRstToOut and initRstGenerator.

Example:

doAssert rstToLatex("*Hello* **world**", {}) == """\emph{Hello} \textbf{world}"""

	Source   Edit   

proc setIndexTerm(d: var RstGenerator; k: IndexEntryKind;
              	htmlFile, id, term: string; linkTitle, linkDesc = ""; line = 0) {.
	....}

	Adds a term to the index using the specified hyperlink identifier.

	A new entry will be added to the index using the format term<tab>file#id. The file part will come from the htmlFile parameter.

	The id will be appended with a hash character only if its length is not zero, otherwise no specific anchor will be generated. In general you should only pass an empty id value for the title of standalone rst documents (they are special for the mergeIndexes() proc, see Index (idx) file format for more information). Unlike other index terms, title entries are inserted at the beginning of the accumulated buffer to maintain a logical order of entries.

	If linkTitle or linkDesc are not the empty string, two additional columns with their contents will be added.

	The index won't be written to disk unless you call writeIndexFile(). The purpose of the index is documented in the docgen tools guide.
	Source   Edit   

proc traverseForIndex(d: PDoc; n: PRstNode) {.....}

	A version of renderRstToOut that only fills entries for .idx files. Source   Edit   

proc writeIndexFile(g: var RstGenerator; outfile: string) {.....}

	Writes the current index buffer to the specified output file.

	You previously need to add entries to the index with the setIndexTerm() proc. If the index is empty the file won't be created.
	Source   Edit   


XML Processing

std/xmltree


std/xmltree
Source   Edit  

A simple XML tree generator.

Example:

import std/xmltree
var g = newElement("myTag")
g.add newText("some text")
g.add newComment("this is comment")

var h = newElement("secondTag")
h.add newEntity("some entity")

let att = {"key1": "first value", "key2": "second value"}.toXmlAttributes
let k = newXmlTree("treeTag", [g, h], att)

doAssert $k == """<treeTag key1="first value" key2="second value">
  <myTag>some text<!-- this is comment --></myTag>
  <secondTag>&some entity;</secondTag>
</treeTag>"""

See also:

	xmlparser module for high-level XML parsing
	parsexml module for low-level XML parsing
	htmlgen module for html code generator

Imports

since, macros, strtabs, strutils, sequtils

Types

XmlAttributes = StringTableRef

	An alias for a string to string mapping.

	Use toXmlAttributes proc to create XmlAttributes.
	Source   Edit   

XmlNode = ref XmlNodeObj

	An XML tree consisting of XML nodes.

	Use newXmlTree proc for creating a new tree.
	Source   Edit   

XmlNodeKind = enum
  xnText,               	## a text element
  xnVerbatimText, xnElement, ## an element with 0 or more children
  xnCData,              	## a CDATA node
  xnEntity,             	## an entity (like ``&thing;``)
  xnComment              	## an XML comment

	Different kinds of XML nodes. Source   Edit   

Consts

xmlHeader = "<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n"

	Header to use for complete XML output. Source   Edit   

Procs

proc `$`(n: XmlNode): string {.....}

	Converts n into its string representation.

	No <$xml ...$> declaration is produced, so that the produced XML fragments are composable.
	Source   Edit   

proc `[]`(n: var XmlNode; i: int): var XmlNode {.inline, ....}

	Returns the i'th child of n so that it can be modified. Source   Edit   

proc `[]`(n: XmlNode; i: int): XmlNode {.inline, ....}

Returns the i'th child of n.

Example:

var f = newElement("myTag")
f.add newElement("first")
f.insert(newElement("second"), 0)
assert $f[1] == "<first />"
assert $f[0] == "<second />"

	Source   Edit   

proc add(father, son: XmlNode) {.inline, ....}

Adds the child son to father. father must be of xnElement type

See also:

	add proc
	insert proc
	insert proc
	delete proc
	delete proc
	replace proc
	replace proc

Example:

var f = newElement("myTag")
f.add newText("my text")
f.add newElement("sonTag")
f.add newEntity("my entity")
assert $f == "<myTag>my text<sonTag />&my entity;</myTag>"

	Source   Edit   

proc add(father: XmlNode; sons: openArray[XmlNode]) {.inline, ....}

Adds the children sons to father. father must be of xnElement type

See also:

	add proc
	insert proc
	insert proc
	delete proc
	delete proc
	replace proc
	replace proc

Example:

var f = newElement("myTag")
f.add(@[newText("my text"), newElement("sonTag"), newEntity("my entity")])
assert $f == "<myTag>my text<sonTag />&my entity;</myTag>"

	Source   Edit   

proc add(result: var string; n: XmlNode; indent = 0; indWidth = 2;
     	addNewLines = true) {.inline, ....}

Adds the textual representation of n to string result.

Example:

var
  a = newElement("firstTag")
  b = newText("my text")
  c = newComment("my comment")
  s = ""
s.add(c)
s.add(a)
s.add(b)
assert s == "<!-- my comment --><firstTag />my text"

	Source   Edit   

proc addEscaped(result: var string; s: string) {.....}

	The same as result.add(escape(s)), but more efficient. Source   Edit   

proc attr(n: XmlNode; name: string): string {.....}

Finds the first attribute of n with a name of name. Returns "" on failure.

See also:

	attrs proc for XmlAttributes getter
	attrs= proc for XmlAttributes setter
	attrsLen proc for number of attributes

Example:

var j = newElement("myTag")
let att = {"key1": "first value", "key2": "second value"}.toXmlAttributes
j.attrs = att
assert j.attr("key1") == "first value"
assert j.attr("key2") == "second value"

	Source   Edit   

proc attrs(n: XmlNode): XmlAttributes {.inline, ....}

Gets the attributes belonging to n.

Returns nil if attributes have not been initialised for this node.

See also:

	attrs= proc for XmlAttributes setter
	attrsLen proc for number of attributes
	attr proc for finding an attribute

Example:

var j = newElement("myTag")
assert j.attrs == nil
let att = {"key1": "first value", "key2": "second value"}.toXmlAttributes
j.attrs = att
assert j.attrs == att

	Source   Edit   

proc attrs=(n: XmlNode; attr: XmlAttributes) {.inline, ....}

Sets the attributes belonging to n.

See also:

	attrs proc for XmlAttributes getter
	attrsLen proc for number of attributes
	attr proc for finding an attribute

Example:

var j = newElement("myTag")
assert j.attrs == nil
let att = {"key1": "first value", "key2": "second value"}.toXmlAttributes
j.attrs = att
assert j.attrs == att

	Source   Edit   

proc attrsLen(n: XmlNode): int {.inline, ....}

Returns the number of n's attributes.

See also:

	attrs proc for XmlAttributes getter
	attrs= proc for XmlAttributes setter
	attr proc for finding an attribute

Example:

var j = newElement("myTag")
assert j.attrsLen == 0
let att = {"key1": "first value", "key2": "second value"}.toXmlAttributes
j.attrs = att
assert j.attrsLen == 2

	Source   Edit   

proc child(n: XmlNode; name: string): XmlNode {.....}

Finds the first child element of n with a name of name. Returns nil on failure.

Example:

var f = newElement("myTag")
f.add newElement("firstSon")
f.add newElement("secondSon")
f.add newElement("thirdSon")
assert $(f.child("secondSon")) == "<secondSon />"

	Source   Edit   

proc clear(n: var XmlNode) {.....}

Recursively clears all children of an XmlNode.

Example:

var g = newElement("myTag")
g.add newText("some text")
g.add newComment("this is comment")

var h = newElement("secondTag")
h.add newEntity("some entity")

let att = {"key1": "first value", "key2": "second value"}.toXmlAttributes
var k = newXmlTree("treeTag", [g, h], att)

doAssert $k == """<treeTag key1="first value" key2="second value">
  <myTag>some text<!-- this is comment --></myTag>
  <secondTag>&some entity;</secondTag>
</treeTag>"""

clear(k)
doAssert $k == """<treeTag key1="first value" key2="second value" />"""

	Source   Edit   

proc clientData(n: XmlNode): int {.inline, ....}

	Gets the client data of n.

	The client data field is used by the HTML parser and generator.
	Source   Edit   

proc clientData=(n: XmlNode; data: int) {.inline, ....}

	Sets the client data of n.

	The client data field is used by the HTML parser and generator.
	Source   Edit   

proc delete(n: XmlNode; i: Natural) {.....}

Deletes the i'th child of n.

See also:

	delete proc
	add proc
	add proc
	insert proc
	insert proc
	replace proc
	replace proc

Example:

var f = newElement("myTag")
f.add newElement("first")
f.insert(newElement("second"), 0)
f.delete(0)
assert $f == """<myTag>
  <first />
</myTag>"""

	Source   Edit   

proc delete(n: XmlNode; slice: Slice[int]) {.....}

Deletes the items n[slice] of n.

See also:

	delete proc
	add proc
	add proc
	insert proc
	insert proc
	replace proc
	replace proc

Example:

var f = newElement("myTag")
f.add newElement("first")
f.insert([newElement("second"), newElement("third")], 0)
f.delete(0..1)
assert $f == """<myTag>
  <first />
</myTag>"""

	Source   Edit   

proc escape(s: string): string {.....}

	Escapes s for inclusion into an XML document.

	Escapes these characters:
	char	is converted to
	<	&lt;
	>	&gt;
	&	&amp;
	"	&quot;
	'	&apos;

	You can also use addEscaped proc.
	Source   Edit   

proc findAll(n: XmlNode; tag: string; caseInsensitive = false): seq[XmlNode] {.
	....}

A shortcut version to assign in let blocks.

Example:

var
  b = newElement("good")
  c = newElement("bad")
  d = newElement("BAD")
  e = newElement("GOOD")
b.add newText("b text")
c.add newText("c text")
d.add newText("d text")
e.add newText("e text")
let a = newXmlTree("father", [b, c, d, e])
assert $(a.findAll("good")) == "@[<good>b text</good>]"
assert $(a.findAll("BAD")) == "@[<BAD>d text</BAD>]"
assert $(a.findAll("good", caseInsensitive = true)) == "@[<good>b text</good>, <GOOD>e text</GOOD>]"
assert $(a.findAll("BAD", caseInsensitive = true)) == "@[<bad>c text</bad>, <BAD>d text</BAD>]"

	Source   Edit   

proc findAll(n: XmlNode; tag: string; result: var seq[XmlNode];
         	caseInsensitive = false) {.....}

Iterates over all the children of n returning those matching tag.

Found nodes satisfying the condition will be appended to the result sequence.

Example:

var
  b = newElement("good")
  c = newElement("bad")
  d = newElement("BAD")
  e = newElement("GOOD")
b.add newText("b text")
c.add newText("c text")
d.add newText("d text")
e.add newText("e text")
let a = newXmlTree("father", [b, c, d, e])
var s = newSeq[XmlNode]()
a.findAll("good", s)
assert $s == "@[<good>b text</good>]"
s.setLen(0)
a.findAll("good", s, caseInsensitive = true)
assert $s == "@[<good>b text</good>, <GOOD>e text</GOOD>]"
s.setLen(0)
a.findAll("BAD", s)
assert $s == "@[<BAD>d text</BAD>]"
s.setLen(0)
a.findAll("BAD", s, caseInsensitive = true)
assert $s == "@[<bad>c text</bad>, <BAD>d text</BAD>]"

	Source   Edit   

proc innerText(n: XmlNode): string {.....}

Gets the inner text of n:

	If n is xnText or xnEntity, returns its content.
	If n is xnElement, runs recursively on each child node and concatenates the results.
	Otherwise returns an empty string.

See also:

	text proc

Example:

var f = newElement("myTag")
f.add newText("my text")
f.add newComment("my comment")
f.add newEntity("my entity")
assert $f == "<myTag>my text<!-- my comment -->&my entity;</myTag>"
assert innerText(f) == "my textmy entity"

	Source   Edit   

proc insert(father, son: XmlNode; index: int) {.inline, ....}

Inserts the child son to a given position in father.

father must be of xnElement kind.

See also:

	insert proc
	add proc
	add proc
	delete proc
	delete proc
	replace proc
	replace proc

Example:

var f = newElement("myTag")
f.add newElement("first")
f.insert(newElement("second"), 0)
assert $f == """<myTag>
  <second />
  <first />
</myTag>"""

	Source   Edit   

proc insert(father: XmlNode; sons: openArray[XmlNode]; index: int) {.inline,
	....}

Inserts the children openArray`sons` to a given position in father.

father must be of xnElement kind.

See also:

	insert proc
	add proc
	add proc
	delete proc
	delete proc
	replace proc
	replace proc

Example:

var f = newElement("myTag")
f.add newElement("first")
f.insert([newElement("second"), newElement("third")], 0)
assert $f == """<myTag>
  <second />
  <third />
  <first />
</myTag>"""

	Source   Edit   

proc kind(n: XmlNode): XmlNodeKind {.inline, ....}

Returns n's kind.

Example:

var a = newElement("firstTag")
assert a.kind == xnElement
var b = newText("my text")
assert b.kind == xnText

	Source   Edit   

proc len(n: XmlNode): int {.inline, ....}

Returns the number of n's children.

Example:

var f = newElement("myTag")
f.add newElement("first")
f.insert(newElement("second"), 0)
assert len(f) == 2

	Source   Edit   

proc newCData(cdata: sink string): XmlNode {.....}

Creates a new XmlNode of kind xnCData with the text cdata.

Example:

var d = newCData("my cdata")
assert d.kind == xnCData
assert $d == "<![CDATA[my cdata]]>"

	Source   Edit   

proc newComment(comment: sink string): XmlNode {.....}

Creates a new XmlNode of kind xnComment with the text comment.

Example:

var c = newComment("my comment")
assert c.kind == xnComment
assert $c == "<!-- my comment -->"

	Source   Edit   

proc newElement(tag: sink string): XmlNode {.....}

Creates a new XmlNode of kind xnElement with the given tag.

See also:

	newXmlTree proc
	<> macro

Example:

var a = newElement("firstTag")
a.add newElement("childTag")
assert a.kind == xnElement
assert $a == """<firstTag>
  <childTag />
</firstTag>"""

	Source   Edit   

proc newEntity(entity: string): XmlNode {.....}

Creates a new XmlNode of kind xnEntity with the text entity.

Example:

var e = newEntity("my entity")
assert e.kind == xnEntity
assert $e == "&my entity;"

	Source   Edit   

proc newText(text: sink string): XmlNode {.....}

Creates a new XmlNode of kind xnText with the text text.

Example:

var b = newText("my text")
assert b.kind == xnText
assert $b == "my text"

	Source   Edit   

proc newVerbatimText(text: sink string): XmlNode {.....}

	Creates a new XmlNode of kind xnVerbatimText with the text text. Since: Version 1.3. Source   Edit   

proc newXmlTree(tag: sink string; children: openArray[XmlNode];
            	attributes: XmlAttributes = nil): XmlNode {.....}

Creates a new XML tree with tag, children and attributes.

See also:

	newElement proc
	<> macro

Example:

var g = newElement("myTag")
g.add newText("some text")
g.add newComment("this is comment")
var h = newElement("secondTag")
h.add newEntity("some entity")
let att = {"key1": "first value", "key2": "second value"}.toXmlAttributes
let k = newXmlTree("treeTag", [g, h], att)

doAssert $k == """<treeTag key1="first value" key2="second value">
  <myTag>some text<!-- this is comment --></myTag>
  <secondTag>&some entity;</secondTag>
</treeTag>"""

	Source   Edit   

proc rawTag(n: XmlNode): string {.inline, ....}

	Returns the underlying 'tag' string by reference.

	This is only used for speed hacks.
	Source   Edit   

proc rawText(n: XmlNode): string {.inline, ....}

	Returns the underlying 'text' string by reference.

	This is only used for speed hacks.
	Source   Edit   

proc replace(n: XmlNode; i: Natural; replacement: openArray[XmlNode]) {.
	....}

Replaces the i'th child of n with replacement openArray.

n must be of xnElement kind.

See also:

	replace proc
	add proc
	add proc
	delete proc
	delete proc
	insert proc
	insert proc

Example:

var f = newElement("myTag")
f.add newElement("first")
f.insert(newElement("second"), 0)
f.replace(0, @[newElement("third"), newElement("fourth")])
assert $f == """<myTag>
  <third />
  <fourth />
  <first />
</myTag>"""

	Source   Edit   

proc replace(n: XmlNode; slice: Slice[int]; replacement: openArray[XmlNode]) {.
	....}

Deletes the items n[slice] of n.

n must be of xnElement kind.

See also:

	replace proc
	add proc
	add proc
	delete proc
	delete proc
	insert proc
	insert proc

Example:

var f = newElement("myTag")
f.add newElement("first")
f.insert([newElement("second"), newElement("fifth")], 0)
f.replace(0..1, @[newElement("third"), newElement("fourth")])
assert $f == """<myTag>
  <third />
  <fourth />
  <first />
</myTag>"""

	Source   Edit   

proc tag(n: XmlNode): lent string {.inline, ....}

Gets the tag name of n.

n has to be an xnElement node.

See also:

	text proc for text getter
	text= proc for text setter
	tag= proc for tag setter
	innerText proc

Example:

var a = newElement("firstTag")
a.add newElement("childTag")
assert $a == """<firstTag>
  <childTag />
</firstTag>"""
assert a.tag == "firstTag"

	Source   Edit   

proc tag=(n: XmlNode; tag: sink string) {.inline, ....}

Sets the tag name of n.

n has to be an xnElement node.

See also:

	text proc for text getter
	text= proc for text setter
	tag proc for tag getter

Example:

var a = newElement("firstTag")
a.add newElement("childTag")
assert $a == """<firstTag>
  <childTag />
</firstTag>"""
a.tag = "newTag"
assert $a == """<newTag>
  <childTag />
</newTag>"""

	Source   Edit   

proc text(n: XmlNode): lent string {.inline, ....}

Gets the associated text with the node n.

n can be a CDATA, Text, comment, or entity node.

See also:

	text= proc for text setter
	tag proc for tag getter
	tag= proc for tag setter
	innerText proc

Example:

var c = newComment("my comment")
assert $c == "<!-- my comment -->"
assert c.text == "my comment"

	Source   Edit   

proc text=(n: XmlNode; text: sink string) {.inline, ....}

Sets the associated text with the node n.

n can be a CDATA, Text, comment, or entity node.

See also:

	text proc for text getter
	tag proc for tag getter
	tag= proc for tag setter

Example:

var e = newEntity("my entity")
assert $e == "&my entity;"
e.text = "a new entity text"
assert $e == "&a new entity text;"

	Source   Edit   

proc toXmlAttributes(keyValuePairs: varargs[tuple[key, val: string]]): XmlAttributes {.
	....}

Converts {key: value} pairs into XmlAttributes.

Example:

let att = {"key1": "first value", "key2": "second value"}.toXmlAttributes
var j = newElement("myTag")
j.attrs = att

doAssert $j == """<myTag key1="first value" key2="second value" />"""

	Source   Edit   

Iterators

iterator items(n: XmlNode): XmlNode {.inline, ....}

Iterates over all direct children of n.

Example:

var g = newElement("myTag")
g.add newText("some text")
g.add newComment("this is comment")

var h = newElement("secondTag")
h.add newEntity("some entity")
g.add h

assert $g == "<myTag>some text<!-- this is comment --><secondTag>&some entity;</secondTag></myTag>"

# for x in g: # the same as `for x in items(g):`
#   echo x

# some text
# <!-- this is comment -->
# <secondTag>&some entity;<![CDATA[some cdata]]></secondTag>

	Source   Edit   

iterator mitems(n: var XmlNode): var XmlNode {.inline, ....}

	Iterates over all direct children of n so that they can be modified. Source   Edit   

Macros

macro `<>`(x: untyped): untyped

Constructor macro for XML. Example usage:

<>a(href="http://nim-lang.org", newText("Nim rules."))

Produces an XML tree for:

<a href="http://nim-lang.org">Nim rules.</a>

	Source   Edit   


std/xmlparser


std/xmlparser
Source   Edit  

This module parses an XML document and creates its XML tree representation.
Imports

streams, parsexml, strtabs, xmltree, os

Types

XmlError = object of ValueError
  errors*: seq[string]   	## All detected parsing errors.

	Exception that is raised for invalid XML. Source   Edit   

Procs

proc loadXml(path: string; errors: var seq[string];
         	options: set[XmlParseOption] = {reportComments}): XmlNode {.
	....}

	Loads and parses XML from file specified by path, and returns a XmlNode. Every occurred parsing error is added to the errors sequence. Source   Edit   

proc loadXml(path: string; options: set[XmlParseOption] = {reportComments}): XmlNode {.
	....}

	Loads and parses XML from file specified by path, and returns a XmlNode. All parsing errors are turned into an XmlError exception. Source   Edit   

proc parseXml(s: Stream; filename: string; errors: var seq[string];
          	options: set[XmlParseOption] = {reportComments}): XmlNode {.
	....}

	Parses the XML from stream s and returns a XmlNode. Every occurred parsing error is added to the errors sequence. Source   Edit   

proc parseXml(s: Stream; options: set[XmlParseOption] = {reportComments}): XmlNode {.
	....}

	Parses the XML from stream s and returns a XmlNode. All parsing errors are turned into an XmlError exception. Source   Edit   

proc parseXml(str: string; options: set[XmlParseOption] = {reportComments}): XmlNode {.
	....}

	Parses the XML from string str and returns a XmlNode. All parsing errors are turned into an XmlError exception. Source   Edit   


Generators

std/genasts


std/genasts
Source   Edit  

This module implements AST generation using captured variables for macros.
Imports

macros

Types

GenAstOpt = enum
  kDirtyTemplate, kNoNewLit

	Source   Edit   

Macros

macro genAstOpt(options: static set[GenAstOpt]; args: varargs[untyped]): untyped

Accepts a list of captured variables a=b or a and a block and returns the AST that represents it. Local {.inject.} symbols (e.g. procs) are captured unless kDirtyTemplate in options.

Example:

# This example shows how one could write a simplified version of `unittest.check`.
import std/[macros, strutils]
macro check2(cond: bool): untyped =
  assert cond.kind == nnkInfix, "$# not implemented" % $cond.kind
  result = genAst(cond, s = repr(cond), lhs = cond[1], rhs = cond[2]):
	# each local symbol we access must be explicitly captured
	if not cond:
  	doAssert false, "'$#'' failed: lhs: '$#', rhs: '$#'" % [s, $lhs, $rhs]
let a = 3
check2 a*2 == a+3
if false: check2 a*2 < a+1 # would error with: 'a * 2 < a + 1'' failed: lhs: '6', rhs: '4'

Example:

# This example goes in more details about the capture semantics.
macro fun(a: string, b: static bool): untyped =
  let c = 'z'
  var d = 11 # implicitly {.gensym.} and needs to be captured for use in `genAst`.
  proc localFun(): auto = 12 # implicitly {.inject.}, doesn't need to be captured.
  genAst(a, b, c = true):
	# `a`, `b` are captured explicitly, `c` is a local definition masking `c = 'z'`.
	const b2 = b # macro static param `b` is forwarded here as a static param.
	# `echo d` would give: `var not init` because `d` is not captured.
	(a & a, b, c, localFun()) # localFun can be called without capture.
assert fun("ab", false) == ("abab", false, true, 12)

	Source   Edit   

Templates

template genAst(args: varargs[untyped]): untyped

	Convenience wrapper around genAstOpt. Source   Edit   

std/htmlgen


std/htmlgen
Source   Edit  

Do yourself a favor and import the module as from htmlgen import nil and then fully qualify the macros.

Note: The Karax project (nimble install karax) has a better way to achieve the same, see https://github.com/pragmagic/karax/blob/master/tests/nativehtmlgen.nim for an example.

This module implements a simple XML and HTML code generator. Each commonly used HTML tag has a corresponding macro that generates a string with its HTML representation.
MathML

MathML is supported, MathML is part of HTML5. MathML is an Standard ISO/IEC 40314 from year 2015. MathML allows you to draw advanced math on the web, visually similar to Latex math.
Examples

var nim = "Nim"
echo h1(a(href="https://nim-lang.org", nim))

Writes the string:

<h1><a href="https://nim-lang.org">Nim</a></h1>

Example:

import std/htmlgen
let nim = "Nim"
assert h1(a(href = "https://nim-lang.org", nim)) ==
  """<h1><a href="https://nim-lang.org">Nim</a></h1>"""
assert form(action = "test", `accept-charset` = "Content-Type") ==
  """<form action="test" accept-charset="Content-Type"></form>"""


assert math(
  semantics(
	mrow(
  	msup(
    	mi("x"),
    	mn("42")
  	)
	)
  )
) == "<math><semantics><mrow><msup><mi>x</mi><mn>42</mn></msup></mrow></semantics></math>"

assert math(
  semantics(
	annotation(encoding = "application/x-tex", title = "Latex on Web", r"x^{2} + y")
  )
) == """<math><semantics><annotation encoding="application/x-tex" title="Latex on Web">x^{2} + y</annotation></semantics></math>"""

Imports

macros, strutils

Consts

ariaAttr = " role "

	HTML DOM Aria Attributes Source   Edit   

commonAttr = " accesskey class contenteditable dir hidden id lang spellcheck style tabindex title translate onabort onblur oncancel oncanplay oncanplaythrough onchange onclick oncuechange ondblclick ondurationchange onemptied onended onerror onfocus oninput oninvalid onkeydown onkeypress onkeyup onload onloadeddata onloadedmetadata onloadstart onmousedown onmouseenter onmouseleave onmousemove onmouseout onmouseover onmouseup onmousewheel onpause onplay onplaying onprogress onratechange onreset onresize onscroll onseeked onseeking onselect onshow onstalled onsubmit onsuspend ontimeupdate ontoggle onvolumechange onwaiting  role "

	HTML DOM Common Attributes Source   Edit   

coreAttr = " accesskey class contenteditable dir hidden id lang spellcheck style tabindex title translate "

	HTML DOM Core Attributes Source   Edit   

eventAttr = "onabort onblur oncancel oncanplay oncanplaythrough onchange onclick oncuechange ondblclick ondurationchange onemptied onended onerror onfocus oninput oninvalid onkeydown onkeypress onkeyup onload onloadeddata onloadedmetadata onloadstart onmousedown onmouseenter onmouseleave onmousemove onmouseout onmouseover onmouseup onmousewheel onpause onplay onplaying onprogress onratechange onreset onresize onscroll onseeked onseeking onselect onshow onstalled onsubmit onsuspend ontimeupdate ontoggle onvolumechange onwaiting "

	HTML DOM Event Attributes Source   Edit   

Procs

proc xmlCheckedTag(argsList: NimNode; tag: string; optAttr = ""; reqAttr = "";
               	isLeaf = false): NimNode {.....}

	use this procedure to define a new XML tag Source   Edit   

Macros

macro a(e: varargs[untyped]): untyped

	Generates the HTML a element. Source   Edit   

macro abbr(e: varargs[untyped]): untyped

	Generates the HTML abbr element. Source   Edit   

macro address(e: varargs[untyped]): untyped

	Generates the HTML address element. Source   Edit   

macro annotation(e: varargs[untyped]): untyped

	Generates the HTML annotation element. MathML https://wikipedia.org/wiki/MathML https://developer.mozilla.org/en-US/docs/Web/MathML/Element/semantics Source   Edit   

macro annotation-xml(e: varargs[untyped]): untyped

	Generates the HTML annotation-xml element. MathML https://wikipedia.org/wiki/MathML https://developer.mozilla.org/en-US/docs/Web/MathML/Element/semantics Source   Edit   

macro area(e: varargs[untyped]): untyped

	Generates the HTML area element. Source   Edit   

macro article(e: varargs[untyped]): untyped

	Generates the HTML article element. Source   Edit   

macro aside(e: varargs[untyped]): untyped

	Generates the HTML aside element. Source   Edit   

macro audio(e: varargs[untyped]): untyped

	Generates the HTML audio element. Source   Edit   

macro b(e: varargs[untyped]): untyped

	Generates the HTML b element. Source   Edit   

macro base(e: varargs[untyped]): untyped

	Generates the HTML base element. Source   Edit   

macro bdi(e: varargs[untyped]): untyped

	Generates the HTML bdi element. Source   Edit   

macro bdo(e: varargs[untyped]): untyped

	Generates the HTML bdo element. Source   Edit   

macro big(e: varargs[untyped]): untyped

	Generates the HTML big element. Source   Edit   

macro blockquote(e: varargs[untyped]): untyped

	Generates the HTML blockquote element. Source   Edit   

macro body(e: varargs[untyped]): untyped

	Generates the HTML body element. Source   Edit   

macro br(e: varargs[untyped]): untyped

	Generates the HTML br element. Source   Edit   

macro button(e: varargs[untyped]): untyped

	Generates the HTML button element. Source   Edit   

macro canvas(e: varargs[untyped]): untyped

	Generates the HTML canvas element. Source   Edit   

macro caption(e: varargs[untyped]): untyped

	Generates the HTML caption element. Source   Edit   

macro center(e: varargs[untyped]): untyped

	Generates the HTML center element. Source   Edit   

macro cite(e: varargs[untyped]): untyped

	Generates the HTML cite element. Source   Edit   

macro code(e: varargs[untyped]): untyped

	Generates the HTML code element. Source   Edit   

macro col(e: varargs[untyped]): untyped

	Generates the HTML col element. Source   Edit   

macro colgroup(e: varargs[untyped]): untyped

	Generates the HTML colgroup element. Source   Edit   

macro data(e: varargs[untyped]): untyped

	Generates the HTML data element. Source   Edit   

macro datalist(e: varargs[untyped]): untyped

	Generates the HTML datalist element. Source   Edit   

macro dd(e: varargs[untyped]): untyped

	Generates the HTML dd element. Source   Edit   

macro del(e: varargs[untyped]): untyped

	Generates the HTML del element. Source   Edit   

macro details(e: varargs[untyped]): untyped

	Generates the HTML details element. Source   Edit   

macro dfn(e: varargs[untyped]): untyped

	Generates the HTML dfn element. Source   Edit   

macro dialog(e: varargs[untyped]): untyped

	Generates the HTML dialog element. Source   Edit   

macro `div`(e: varargs[untyped]): untyped

	Generates the HTML div element. Source   Edit   

macro dl(e: varargs[untyped]): untyped

	Generates the HTML dl element. Source   Edit   

macro dt(e: varargs[untyped]): untyped

	Generates the HTML dt element. Source   Edit   

macro em(e: varargs[untyped]): untyped

	Generates the HTML em element. Source   Edit   

macro embed(e: varargs[untyped]): untyped

	Generates the HTML embed element. Source   Edit   

macro fieldset(e: varargs[untyped]): untyped

	Generates the HTML fieldset element. Source   Edit   

macro figcaption(e: varargs[untyped]): untyped

	Generates the HTML figcaption element. Source   Edit   

macro figure(e: varargs[untyped]): untyped

	Generates the HTML figure element. Source   Edit   

macro footer(e: varargs[untyped]): untyped

	Generates the HTML footer element. Source   Edit   

macro form(e: varargs[untyped]): untyped

	Generates the HTML form element. Source   Edit   

macro h1(e: varargs[untyped]): untyped

	Generates the HTML h1 element. Source   Edit   

macro h2(e: varargs[untyped]): untyped

	Generates the HTML h2 element. Source   Edit   

macro h3(e: varargs[untyped]): untyped

	Generates the HTML h3 element. Source   Edit   

macro h4(e: varargs[untyped]): untyped

	Generates the HTML h4 element. Source   Edit   

macro h5(e: varargs[untyped]): untyped

	Generates the HTML h5 element. Source   Edit   

macro h6(e: varargs[untyped]): untyped

	Generates the HTML h6 element. Source   Edit   

macro head(e: varargs[untyped]): untyped

	Generates the HTML head element. Source   Edit   

macro header(e: varargs[untyped]): untyped

	Generates the HTML header element. Source   Edit   

macro hr(): untyped

	Generates the HTML hr element. Source   Edit   

macro html(e: varargs[untyped]): untyped

	Generates the HTML html element. Source   Edit   

macro i(e: varargs[untyped]): untyped

	Generates the HTML i element. Source   Edit   

macro iframe(e: varargs[untyped]): untyped

	Generates the HTML iframe element. Source   Edit   

macro img(e: varargs[untyped]): untyped

	Generates the HTML img element. Source   Edit   

macro input(e: varargs[untyped]): untyped

	Generates the HTML input element. Source   Edit   

macro ins(e: varargs[untyped]): untyped

	Generates the HTML ins element. Source   Edit   

macro kbd(e: varargs[untyped]): untyped

	Generates the HTML kbd element. Source   Edit   

macro keygen(e: varargs[untyped]): untyped

	Generates the HTML keygen element. Source   Edit   

macro label(e: varargs[untyped]): untyped

	Generates the HTML label element. Source   Edit   

macro legend(e: varargs[untyped]): untyped

	Generates the HTML legend element. Source   Edit   

macro li(e: varargs[untyped]): untyped

	Generates the HTML li element. Source   Edit   

macro link(e: varargs[untyped]): untyped

	Generates the HTML link element. Source   Edit   

macro maction(e: varargs[untyped]): untyped

	Generates the HTML maction element. MathML https://wikipedia.org/wiki/MathML https://developer.mozilla.org/en-US/docs/Web/MathML/Element/maction Source   Edit   

macro main(e: varargs[untyped]): untyped

	Generates the HTML main element. Source   Edit   

macro map(e: varargs[untyped]): untyped

	Generates the HTML map element. Source   Edit   

macro mark(e: varargs[untyped]): untyped

	Generates the HTML mark element. Source   Edit   

macro marquee(e: varargs[untyped]): untyped

	Generates the HTML marquee element. Source   Edit   

macro math(e: varargs[untyped]): untyped

	Generates the HTML math element. MathML https://wikipedia.org/wiki/MathML https://developer.mozilla.org/en-US/docs/Web/MathML/Element/math#Examples Source   Edit   

macro menclose(e: varargs[untyped]): untyped

	Generates the HTML menclose element. MathML https://wikipedia.org/wiki/MathML https://developer.mozilla.org/en-US/docs/Web/MathML/Element/menclose Source   Edit   

macro merror(e: varargs[untyped]): untyped

	Generates the HTML merror element. MathML https://wikipedia.org/wiki/MathML https://developer.mozilla.org/en-US/docs/Web/MathML/Element/merror Source   Edit   

macro meta(e: varargs[untyped]): untyped

	Generates the HTML meta element. Source   Edit   

macro meter(e: varargs[untyped]): untyped

	Generates the HTML meter element. Source   Edit   

macro mfenced(e: varargs[untyped]): untyped

	Generates the HTML mfenced element. MathML https://wikipedia.org/wiki/MathML https://developer.mozilla.org/en-US/docs/Web/MathML/Element/mfenced Source   Edit   

macro mfrac(e: varargs[untyped]): untyped

	Generates the HTML mfrac element. MathML https://wikipedia.org/wiki/MathML https://developer.mozilla.org/en-US/docs/Web/MathML/Element/mfrac Source   Edit   

macro mglyph(e: varargs[untyped]): untyped

	Generates the HTML mglyph element. MathML https://wikipedia.org/wiki/MathML https://developer.mozilla.org/en-US/docs/Web/MathML/Element/mglyph Source   Edit   

macro mi(e: varargs[untyped]): untyped

	Generates the HTML mi element. MathML https://wikipedia.org/wiki/MathML https://developer.mozilla.org/en-US/docs/Web/MathML/Element/mi Source   Edit   

macro mlabeledtr(e: varargs[untyped]): untyped

	Generates the HTML mlabeledtr element. MathML https://wikipedia.org/wiki/MathML https://developer.mozilla.org/en-US/docs/Web/MathML/Element/mlabeledtr Source   Edit   

macro mmultiscripts(e: varargs[untyped]): untyped

	Generates the HTML mmultiscripts element. MathML https://wikipedia.org/wiki/MathML https://developer.mozilla.org/en-US/docs/Web/MathML/Element/mmultiscripts Source   Edit   

macro mn(e: varargs[untyped]): untyped

	Generates the HTML mn element. MathML https://wikipedia.org/wiki/MathML https://developer.mozilla.org/en-US/docs/Web/MathML/Element/mn Source   Edit   

macro mo(e: varargs[untyped]): untyped

	Generates the HTML mo element. MathML https://wikipedia.org/wiki/MathML https://developer.mozilla.org/en-US/docs/Web/MathML/Element/mo Source   Edit   

macro mover(e: varargs[untyped]): untyped

	Generates the HTML mover element. MathML https://wikipedia.org/wiki/MathML https://developer.mozilla.org/en-US/docs/Web/MathML/Element/mover Source   Edit   

macro mpadded(e: varargs[untyped]): untyped

	Generates the HTML mpadded element. MathML https://wikipedia.org/wiki/MathML https://developer.mozilla.org/en-US/docs/Web/MathML/Element/mpadded Source   Edit   

macro mphantom(e: varargs[untyped]): untyped

	Generates the HTML mphantom element. MathML https://wikipedia.org/wiki/MathML https://developer.mozilla.org/en-US/docs/Web/MathML/Element/mphantom Source   Edit   

macro mroot(e: varargs[untyped]): untyped

	Generates the HTML mroot element. MathML https://wikipedia.org/wiki/MathML https://developer.mozilla.org/en-US/docs/Web/MathML/Element/mroot Source   Edit   

macro mrow(e: varargs[untyped]): untyped

	Generates the HTML mrow element. MathML https://wikipedia.org/wiki/MathML https://developer.mozilla.org/en-US/docs/Web/MathML/Element/mrow Source   Edit   

macro ms(e: varargs[untyped]): untyped

	Generates the HTML ms element. MathML https://wikipedia.org/wiki/MathML https://developer.mozilla.org/en-US/docs/Web/MathML/Element/ms Source   Edit   

macro mspace(e: varargs[untyped]): untyped

	Generates the HTML mspace element. MathML https://wikipedia.org/wiki/MathML https://developer.mozilla.org/en-US/docs/Web/MathML/Element/mspace Source   Edit   

macro msqrt(e: varargs[untyped]): untyped

	Generates the HTML msqrt element. MathML https://wikipedia.org/wiki/MathML https://developer.mozilla.org/en-US/docs/Web/MathML/Element/msqrt Source   Edit   

macro mstyle(e: varargs[untyped]): untyped

	Generates the HTML mstyle element. MathML https://wikipedia.org/wiki/MathML https://developer.mozilla.org/en-US/docs/Web/MathML/Element/mstyle Source   Edit   

macro msub(e: varargs[untyped]): untyped

	Generates the HTML msub element. MathML https://wikipedia.org/wiki/MathML https://developer.mozilla.org/en-US/docs/Web/MathML/Element/msub Source   Edit   

macro msubsup(e: varargs[untyped]): untyped

	Generates the HTML msubsup element. MathML https://wikipedia.org/wiki/MathML https://developer.mozilla.org/en-US/docs/Web/MathML/Element/msubsup Source   Edit   

macro msup(e: varargs[untyped]): untyped

	Generates the HTML msup element. MathML https://wikipedia.org/wiki/MathML https://developer.mozilla.org/en-US/docs/Web/MathML/Element/msup Source   Edit   

macro mtable(e: varargs[untyped]): untyped

	Generates the HTML mtable element. MathML https://wikipedia.org/wiki/MathML https://developer.mozilla.org/en-US/docs/Web/MathML/Element/mtable Source   Edit   

macro mtd(e: varargs[untyped]): untyped

	Generates the HTML mtd element. MathML https://wikipedia.org/wiki/MathML https://developer.mozilla.org/en-US/docs/Web/MathML/Element/mtd Source   Edit   

macro mtext(e: varargs[untyped]): untyped

	Generates the HTML mtext element. MathML https://wikipedia.org/wiki/MathML https://developer.mozilla.org/en-US/docs/Web/MathML/Element/mtext Source   Edit   

macro munder(e: varargs[untyped]): untyped

	Generates the HTML munder element. MathML https://wikipedia.org/wiki/MathML https://developer.mozilla.org/en-US/docs/Web/MathML/Element/munder Source   Edit   

macro munderover(e: varargs[untyped]): untyped

	Generates the HTML munderover element. MathML https://wikipedia.org/wiki/MathML https://developer.mozilla.org/en-US/docs/Web/MathML/Element/munderover Source   Edit   

macro nav(e: varargs[untyped]): untyped

	Generates the HTML nav element. Source   Edit   

macro noscript(e: varargs[untyped]): untyped

	Generates the HTML noscript element. Source   Edit   

macro `object`(e: varargs[untyped]): untyped

	Generates the HTML object element. Source   Edit   

macro ol(e: varargs[untyped]): untyped

	Generates the HTML ol element. Source   Edit   

macro optgroup(e: varargs[untyped]): untyped

	Generates the HTML optgroup element. Source   Edit   

macro option(e: varargs[untyped]): untyped

	Generates the HTML option element. Source   Edit   

macro output(e: varargs[untyped]): untyped

	Generates the HTML output element. Source   Edit   

macro p(e: varargs[untyped]): untyped

	Generates the HTML p element. Source   Edit   

macro param(e: varargs[untyped]): untyped

	Generates the HTML param element. Source   Edit   

macro picture(e: varargs[untyped]): untyped

	Generates the HTML picture element. Source   Edit   

macro portal(e: varargs[untyped]): untyped

	Generates the HTML portal element. Source   Edit   

macro pre(e: varargs[untyped]): untyped

	Generates the HTML pre element. Source   Edit   

macro progress(e: varargs[untyped]): untyped

	Generates the HTML progress element. Source   Edit   

macro q(e: varargs[untyped]): untyped

	Generates the HTML q element. Source   Edit   

macro rb(e: varargs[untyped]): untyped

	Generates the HTML rb element. Source   Edit   

macro rp(e: varargs[untyped]): untyped

	Generates the HTML rp element. Source   Edit   

macro rt(e: varargs[untyped]): untyped

	Generates the HTML rt element. Source   Edit   

macro rtc(e: varargs[untyped]): untyped

	Generates the HTML rtc element. Source   Edit   

macro ruby(e: varargs[untyped]): untyped

	Generates the HTML ruby element. Source   Edit   

macro s(e: varargs[untyped]): untyped

	Generates the HTML s element. Source   Edit   

macro samp(e: varargs[untyped]): untyped

	Generates the HTML samp element. Source   Edit   

macro script(e: varargs[untyped]): untyped

	Generates the HTML script element. Source   Edit   

macro section(e: varargs[untyped]): untyped

	Generates the HTML section element. Source   Edit   

macro select(e: varargs[untyped]): untyped

	Generates the HTML select element. Source   Edit   

macro semantics(e: varargs[untyped]): untyped

	Generates the HTML semantics element. MathML https://wikipedia.org/wiki/MathML https://developer.mozilla.org/en-US/docs/Web/MathML/Element/semantics Source   Edit   

macro slot(e: varargs[untyped]): untyped

	Generates the HTML slot element. Source   Edit   

macro small(e: varargs[untyped]): untyped

	Generates the HTML small element. Source   Edit   

macro source(e: varargs[untyped]): untyped

	Generates the HTML source element. Source   Edit   

macro span(e: varargs[untyped]): untyped

	Generates the HTML span element. Source   Edit   

macro strong(e: varargs[untyped]): untyped

	Generates the HTML strong element. Source   Edit   

macro style(e: varargs[untyped]): untyped

	Generates the HTML style element. Source   Edit   

macro sub(e: varargs[untyped]): untyped

	Generates the HTML sub element. Source   Edit   

macro summary(e: varargs[untyped]): untyped

	Generates the HTML summary element. Source   Edit   

macro sup(e: varargs[untyped]): untyped

	Generates the HTML sup element. Source   Edit   

macro table(e: varargs[untyped]): untyped

	Generates the HTML table element. Source   Edit   

macro tbody(e: varargs[untyped]): untyped

	Generates the HTML tbody element. Source   Edit   

macro td(e: varargs[untyped]): untyped

	Generates the HTML td element. Source   Edit   

macro `template`(e: varargs[untyped]): untyped

	Generates the HTML template element. Source   Edit   

macro textarea(e: varargs[untyped]): untyped

	Generates the HTML textarea element. Source   Edit   

macro tfoot(e: varargs[untyped]): untyped

	Generates the HTML tfoot element. Source   Edit   

macro th(e: varargs[untyped]): untyped

	Generates the HTML th element. Source   Edit   

macro thead(e: varargs[untyped]): untyped

	Generates the HTML thead element. Source   Edit   

macro time(e: varargs[untyped]): untyped

	Generates the HTML time element. Source   Edit   

macro title(e: varargs[untyped]): untyped

	Generates the HTML title element. Source   Edit   

macro tr(e: varargs[untyped]): untyped

	Generates the HTML tr element. Source   Edit   

macro track(e: varargs[untyped]): untyped

	Generates the HTML track element. Source   Edit   

macro tt(e: varargs[untyped]): untyped

	Generates the HTML tt element. Source   Edit   

macro u(e: varargs[untyped]): untyped

	Generates the HTML u element. Source   Edit   

macro ul(e: varargs[untyped]): untyped

	Generates the HTML ul element. Source   Edit   

macro `var`(e: varargs[untyped]): untyped

	Generates the HTML var element. Source   Edit   

macro video(e: varargs[untyped]): untyped

	Generates the HTML video element. Source   Edit   

macro wbr(e: varargs[untyped]): untyped

	Generates the HTML wbr element. Source   Edit   


Hashing

std/base64


std/base64
Source   Edit  

This module implements a base64 encoder and decoder.

Unstable API.

Base64 is an encoding and decoding technique used to convert binary data to an ASCII string format. Each Base64 digit represents exactly 6 bits of data. Three 8-bit bytes (i.e., a total of 24 bits) can therefore be represented by four 6-bit Base64 digits.
Basic usage
Encoding data

Example:

import std/base64
let encoded = encode("Hello World")
assert encoded == "SGVsbG8gV29ybGQ="

Apart from strings you can also encode lists of integers or characters:

Example:

import std/base64
let encodedInts = encode([1'u8,2,3])
assert encodedInts == "AQID"
let encodedChars = encode(['h','e','y'])
assert encodedChars == "aGV5"

Decoding data

Example:

import std/base64
let decoded = decode("SGVsbG8gV29ybGQ=")
assert decoded == "Hello World"

URL Safe Base64

Example:

import std/base64
assert encode("c\xf7>", safe = true) == "Y_c-"
assert encode("c\xf7>", safe = false) == "Y/c+"

See also

	hashes module for efficient computations of hash values for diverse Nim types
	md5 module for the MD5 checksum algorithm
	sha1 module for the SHA-1 checksum algorithm

Procs

proc decode(s: string): string {.....}

Decodes string s in base64 representation back into its original form. The initial whitespace is skipped.

See also:

	encode proc for encoding an openarray

Example:

assert decode("SGVsbG8gV29ybGQ=") == "Hello World"
assert decode("  SGVsbG8gV29ybGQ=") == "Hello World"

	Source   Edit   

proc encode[T: byte | char](s: openArray[T]; safe = false): string

Encodes s into base64 representation.

If safe is true then it will encode using the URL-Safe and Filesystem-safe standard alphabet characters, which substitutes - instead of + and _ instead of /.

	https://en.wikipedia.org/wiki/Base64#URL_applications
	https://tools.ietf.org/html/rfc4648#page-7

See also:

	decode proc for decoding a string

Example:

assert encode("Hello World") == "SGVsbG8gV29ybGQ="
assert encode(['n', 'i', 'm']) == "bmlt"
assert encode(@['n', 'i', 'm']) == "bmlt"
assert encode([1'u8, 2, 3, 4, 5]) == "AQIDBAU="

	Source   Edit   

proc encode[T: SomeInteger and not byte](s: openArray[T]; safe = false): string {.
	....}

	Deprecated: use `byte` or `char` instead
	Source   Edit   

proc encodeMime(s: string; lineLen = 75.Positive; newLine = "\r\n"; safe = false): string {.
	....}

Encodes s into base64 representation as lines. Used in email MIME format, use lineLen and newline.

This procedure encodes a string according to MIME spec.

If safe is true then it will encode using the URL-Safe and Filesystem-safe standard alphabet characters, which substitutes - instead of + and _ instead of /.

	https://en.wikipedia.org/wiki/Base64#URL_applications
	https://tools.ietf.org/html/rfc4648#page-7

See also:

	encode proc for encoding an openArray
	decode proc for decoding a string

Example:

assert encodeMime("Hello World", 4, "\n") == "SGVs\nbG8g\nV29y\nbGQ="

	Source   Edit   

proc initDecodeTable(): array[256, char] {.....}

	Source   Edit   


std/hashes


std/hashes
Source   Edit  

This module implements efficient computations of hash values for diverse Nim types. All the procs are based on these two building blocks:

	!& proc used to start or mix a hash value, and
	!$ proc used to finish the hash value.

If you want to implement hash procs for your custom types, you will end up writing the following kind of skeleton of code:

Example:

import std/hashes
type
  Something = object
	foo: int
	bar: string

iterator items(x: Something): Hash =
  yield hash(x.foo)
  yield hash(x.bar)

proc hash(x: Something): Hash =
  ## Computes a Hash from `x`.
  var h: Hash = 0
  # Iterate over parts of `x`.
  for xAtom in x:
	# Mix the atom with the partial hash.
	h = h !& xAtom
  # Finish the hash.
  result = !$h

If your custom types contain fields for which there already is a hash proc, you can simply hash together the hash values of the individual fields:

Example:

import std/hashes
type
  Something = object
	foo: int
	bar: string

proc hash(x: Something): Hash =
  ## Computes a Hash from `x`.
  var h: Hash = 0
  h = h !& hash(x.foo)
  h = h !& hash(x.bar)
  result = !$h

Important: Use -d:nimPreviewHashRef to enable hashing refs. It is expected that this behavior becomes the new default in upcoming versions.
Note: If the type has a == operator, the following must hold: If two values compare equal, their hashes must also be equal.
See also

	md5 module for the MD5 checksum algorithm
	base64 module for a Base64 encoder and decoder
	sha1 module for the SHA-1 checksum algorithm
	tables module for hash tables

Imports

since

Types

Hash = int

	A hash value. Hash tables using these values should always have a size of a power of two so they can use the and operator instead of mod for truncation of the hash value. Source   Edit   

Procs

proc `!$`(h: Hash): Hash {.inline, ....}

	Finishes the computation of the hash value.

	This is only needed if you need to implement a hash proc for a new datatype.
	Source   Edit   

proc `!&`(h: Hash; val: int): Hash {.inline, ....}

	Mixes a hash value h with val to produce a new hash value.

	This is only needed if you need to implement a hash proc for a new datatype.
	Source   Edit   

proc hash(sBuf: string; sPos, ePos: int): Hash {.....}

Efficient hashing of a string buffer, from starting position sPos to ending position ePos (included).

hash(myStr, 0, myStr.high) is equivalent to hash(myStr).

Example:

var a = "abracadabra"
doAssert hash(a, 0, 3) == hash(a, 7, 10)

	Source   Edit   

proc hash(x: cstring): Hash {.....}

Efficient hashing of null-terminated strings.

Example:

doAssert hash(cstring"abracadabra") == hash("abracadabra")
doAssert hash(cstring"AbracadabrA") == hash("AbracadabrA")
doAssert hash(cstring"abracadabra") != hash(cstring"AbracadabrA")

	Source   Edit   

proc hash(x: float): Hash {.inline, ....}

	Efficient hashing of floats. Source   Edit   

proc hash(x: pointer): Hash {.inline, ....}

	Efficient hash overload. Source   Edit   

proc hash(x: string): Hash {.....}

Efficient hashing of strings.

See also:

	hashIgnoreStyle
	hashIgnoreCase

Example:

doAssert hash("abracadabra") != hash("AbracadabrA")

	Source   Edit   

proc hash[A](aBuf: openArray[A]; sPos, ePos: int): Hash

Efficient hashing of portions of arrays and sequences, from starting position sPos to ending position ePos (included). There must be a hash proc defined for the element type A.

hash(myBuf, 0, myBuf.high) is equivalent to hash(myBuf).

Example:

let a = [1, 2, 5, 1, 2, 6]
doAssert hash(a, 0, 1) == hash(a, 3, 4)

	Source   Edit   

proc hash[A](x: openArray[A]): Hash

	Source   Edit   

proc hash[A](x: set[A]): Hash

	Source   Edit   

proc hash[T: Ordinal | enum](x: T): Hash {.inline.}

	Efficient hashing of integers. Source   Edit   

proc hash[T: tuple | object | proc | iterator {.closure.}](x: T): Hash

Efficient hash overload.

Example:

# for `tuple|object`, `hash` must be defined for each component of `x`.
type Obj = object
  x: int
  y: string
type Obj2[T] = object
  x: int
  y: string
assert hash(Obj(x: 520, y: "Nim")) != hash(Obj(x: 520, y: "Nim2"))
# you can define custom hashes for objects (even if they're generic):
proc hash(a: Obj2): Hash = hash((a.x))
assert hash(Obj2[float](x: 520, y: "Nim")) == hash(Obj2[float](x: 520, y: "Nim2"))

Example:

# proc
proc fn1() = discard
const fn1b = fn1
assert hash(fn1b) == hash(fn1)

# closure
proc outer =
  var a = 0
  proc fn2() = a.inc
  assert fn2 is "closure"
  let fn2b = fn2
  assert hash(fn2b) == hash(fn2)
  assert hash(fn2) != hash(fn1)
outer()

	Source   Edit   

proc hash[T](x: ptr [T]): Hash {.inline.}

Efficient hash overload.

Example:

var a: array[10, uint8]
assert a[0].addr.hash != a[1].addr.hash
assert cast[pointer](a[0].addr).hash == a[0].addr.hash

	Source   Edit   

proc hash[T](x: ref [T]): Hash {.inline.}

Efficient hash overload.
Important: Use -d:nimPreviewHashRef to enable hashing refs. It is expected that this behavior becomes the new default in upcoming versions.

Example: cmd: -d:nimPreviewHashRef

type A = ref object
  x: int
let a = A(x: 3)
let ha = a.hash
assert ha != A(x: 3).hash # A(x: 3) is a different ref object from `a`.
a.x = 4
assert ha == a.hash # the hash only depends on the address

Example: cmd: -d:nimPreviewHashRef

# you can overload `hash` if you want to customize semantics
type A[T] = ref object
  x, y: T
proc hash(a: A): Hash = hash(a.x)
assert A[int](x: 3, y: 4).hash == A[int](x: 3, y: 5).hash

	Source   Edit   

proc hashData(data: pointer; size: int): Hash {.....}

	Hashes an array of bytes of size size. Source   Edit   

proc hashIdentity[T: Ordinal | enum](x: T): Hash {.inline.}

	The identity hash, i.e. hashIdentity(x) = x. Source   Edit   

proc hashIgnoreCase(sBuf: string; sPos, ePos: int): Hash {.....}

Efficient hashing of a string buffer, from starting position sPos to ending position ePos (included); case is ignored.

Note: This uses a different hashing algorithm than hash(string).

hashIgnoreCase(myBuf, 0, myBuf.high) is equivalent to hashIgnoreCase(myBuf).

Example:

var a = "ABracadabRA"
doAssert hashIgnoreCase(a, 0, 3) == hashIgnoreCase(a, 7, 10)

	Source   Edit   

proc hashIgnoreCase(x: string): Hash {.....}

Efficient hashing of strings; case is ignored.

Note: This uses a different hashing algorithm than hash(string).

See also:

	hashIgnoreStyle

Example:

doAssert hashIgnoreCase("ABRAcaDABRA") == hashIgnoreCase("abRACAdabra")
doAssert hashIgnoreCase("abcdefghi") != hash("abcdefghi")

	Source   Edit   

proc hashIgnoreStyle(sBuf: string; sPos, ePos: int): Hash {.....}

Efficient hashing of a string buffer, from starting position sPos to ending position ePos (included); style is ignored.

Note: This uses a different hashing algorithm than hash(string).

hashIgnoreStyle(myBuf, 0, myBuf.high) is equivalent to hashIgnoreStyle(myBuf).

Example:

var a = "ABracada_b_r_a"
doAssert hashIgnoreStyle(a, 0, 3) == hashIgnoreStyle(a, 7, a.high)

	Source   Edit   

proc hashIgnoreStyle(x: string): Hash {.....}

Efficient hashing of strings; style is ignored.

Note: This uses a different hashing algorithm than hash(string).

See also:

	hashIgnoreCase

Example:

doAssert hashIgnoreStyle("aBr_aCa_dAB_ra") == hashIgnoreStyle("abracadabra")
doAssert hashIgnoreStyle("abcdefghi") != hash("abcdefghi")

	Source   Edit   

proc hashWangYi1(x: int64 | uint64 | Hash): Hash {.inline.}

	Wang Yi's hash_v1 for 64-bit ints (see https://github.com/rurban/smhasher for more details). This passed all scrambling tests in Spring 2019 and is simple.

	Note: It's ok to define proc(x: int16): Hash = hashWangYi1(Hash(x)).
	Source   Edit   

Md5


src/checksums/md5

Note: In order to use this module, run nimble install checksums.

Module for computing MD5 checksums.

Be aware that using MD5 for cryptographic purposes is strongly discouraged as it is no longer deemed secure enough even against consumer grade computational resources.

This module also works at compile time and in JavaScript.
See also

	base64 module for a Base64 encoder and decoder
	std/sha1 module for the SHA-1 checksum algorithm
	std/sha2 module for the SHA-2 checksum algorithm
	std/sha3 module for the SHA-3 checksum algorithm
	hashes module for efficient computations of hash values for diverse Nim types

Types

MD5Context {.final.} = object

MD5Digest = array[0 .. 15, uint8]

	MD5 checksum of a string, obtained with the toMD5 proc.

Procs

proc `$`(d: MD5Digest): string {.....}

	Converts a MD5Digest value into its string representation.

proc `==`(D1, D2: MD5Digest): bool {.....}

	Checks if two MD5Digest values are identical.

proc getMD5(s: string): string {.....}

Computes an MD5 value of s and returns its string representation.

See also:

	toMD5 proc which returns the MD5Digest of a string

Example:

assert getMD5("abc") == "900150983cd24fb0d6963f7d28e17f72"

proc md5Final(c: var MD5Context; digest: var MD5Digest) {.....}

proc md5Init(c: var MD5Context) {.....}

proc md5Update(c: var MD5Context; input: cstring; len: int) {.....}

	Updates the MD5Context with the input data of length len.

	If you use the toMD5 proc, there's no need to call this function explicitly.

proc md5Update(c: var MD5Context; input: openArray[uint8]) {.....}

proc toMD5(s: string): MD5Digest {.....}

Computes the MD5Digest value for a string s.

See also:

	getMD5 proc which returns a string representation of the MD5Digest
	$ proc for converting MD5Digest to string

Example:

assert $toMD5("abc") == "900150983cd24fb0d6963f7d28e17f72"


std/oids


std/oids
Source   Edit  

Nim OID support. An OID is a global ID that consists of a timestamp, a unique counter and a random value. This combination should suffice to produce a globally distributed unique ID.

This implementation calls initRand() for the first call of genOid.

Imports

hashes, times, endians, random, decode_helpers

Types

Oid = object

	An OID. Source   Edit   

Procs

proc `$`(oid: Oid): string {.....}

	Converts an OID to a string. Source   Edit   

proc `==`(oid1: Oid; oid2: Oid): bool {.inline, ....}

	Compares two OIDs for equality. Source   Edit   

proc generatedTime(oid: Oid): Time {.....}

	Returns the generated timestamp of the OID. Source   Edit   

proc genOid(): Oid {.....}

Generates a new OID.

Example:

doAssert ($genOid()).len == 24

Example: cmd: -r:off

echo $genOid() # for example, "5fc7f546ddbbc84800006aaf"

	Source   Edit   

proc hash(oid: Oid): Hash {.....}

	Generates the hash of an OID for use in hashtables. Source   Edit   

proc hexbyte(hex: char): int {.inline, ....}

	Source   Edit   

proc parseOid(str: cstring): Oid {.....}

	Parses an OID. Source   Edit   

Sha1


src/checksums/sha1

Note: In order to use this module, run nimble install checksums.

SHA-1 (Secure Hash Algorithm 1) is a cryptographic hash function which takes an input and produces a 160-bit (20-byte) hash value known as a message digest.

Please note that SHA-1 has been formally deprecated since 2011 and it is strongly recommended to switch to stronger hash functions such as the SHA-2 or SHA-3 family.

Even though SHA-1 is formally deprecated, this module itself is not deprecated and will continue to be usable.
See also

	base64 module for a Base64 encoder and decoder
	hashes module for efficient computations of hash values for diverse Nim types
	md5 module for the MD5 checksum algorithm
	sha2 module for the newer hash familiy SHA-2
	sha3 module for the newest hash family SHA-3

Example:

import src/checksums/sha1
let accessName = secureHash("John Doe")
assert $accessName == "AE6E4D1209F17B460503904FAD297B31E9CF6362"

Example: cmd: -r:off

import src/checksums/sha1
let
  a = secureHashFile("myFile.nim")
  b = parseSecureHash("10DFAEBF6BFDBC7939957068E2EFACEC4972933C")
assert a == b, "files don't match"

Types

SecureHash = distinct Sha1Digest

Sha1Digest = array[0 .. 20 - 1, uint8]

Sha1State = object

Procs

proc `$`(self: SecureHash): string {.....}

Returns the string representation of a SecureHash.

See also:

	secureHash proc for generating a SecureHash from a string

Example:

let hash = secureHash("Hello World")
assert $hash == "0A4D55A8D778E5022FAB701977C5D840BBC486D0"

proc `==`(a, b: SecureHash): bool {.....}

Checks if two SecureHash values are identical.

Example:

let
  a = secureHash("Hello World")
  b = secureHash("Goodbye World")
  c = parseSecureHash("0A4D55A8D778E5022FAB701977C5D840BBC486D0")
assert a != b
assert a == c

proc finalize(ctx: var Sha1State): Sha1Digest {.....}

	Finalizes the Sha1State and returns a Sha1Digest.

	If you use the secureHash proc, there's no need to call this function explicitly.

proc isValidSha1Hash(s: string): bool {.....}

	Checks if a string is a valid sha1 hash sum.

proc newSha1State(): Sha1State {.....}

	Creates a Sha1State.

	If you use the secureHash proc, there's no need to call this function explicitly.

proc parseSecureHash(hash: string): SecureHash {.....}

Converts a string hash to a SecureHash.

See also:

	secureHash proc for generating a SecureHash from a string
	secureHashFile proc for generating a SecureHash from a file

Example:

let
  hashStr = "0A4D55A8D778E5022FAB701977C5D840BBC486D0"
  secureHash = secureHash("Hello World")
assert secureHash == parseSecureHash(hashStr)

proc secureHash(str: openArray[char]): SecureHash {.....}

Generates a SecureHash from str.

See also:

	secureHashFile proc for generating a SecureHash from a file
	parseSecureHash proc for converting a string hash to SecureHash

Example:

let hash = secureHash("Hello World")
assert hash == parseSecureHash("0A4D55A8D778E5022FAB701977C5D840BBC486D0")

proc secureHashFile(filename: string): SecureHash {.....}

	Generates a SecureHash from a file.

	See also:

    	secureHash proc for generating a SecureHash from a string
    	parseSecureHash proc for converting a string hash to SecureHash

proc update(ctx: var Sha1State; data: openArray[char]) {.....}

	Updates the Sha1State with data.

	If you use the secureHash proc, there's no need to call this function explicitly.


Serialization

std/jsonutils


std/jsonutils
Source   Edit  

This module implements a hookable (de)serialization for arbitrary types using JSON. Design goal: avoid importing modules where a custom serialization is needed; see strtabs.fromJsonHook,toJsonHook for an example.

Example:

import std/jsonutils
import std/[strtabs,json]
type Foo = ref object
  t: bool
  z1: int8
let a = (1.5'f32, (b: "b2", a: "a2"), 'x', @[Foo(t: true, z1: -3), nil], [{"name": "John"}.newStringTable])
let j = a.toJson
assert j.jsonTo(typeof(a)).toJson == j
assert $[NaN, Inf, -Inf, 0.0, -0.0, 1.0, 1e-2].toJson == """["nan","inf","-inf",0.0,-0.0,1.0,0.01]"""
assert 0.0.toJson.kind == JFloat
assert Inf.toJson.kind == JString

Imports

json, strutils, tables, sets, strtabs, options, strformat, macros, enumutils, typetraits

Types

EnumMode = enum
  joptEnumOrd, joptEnumSymbol, joptEnumString

	Source   Edit   

Joptions = object
  allowExtraKeys*: bool ## If `true` Nim's object to which the JSON is parsed is not required to
                    	## have a field for every JSON key.
  allowMissingKeys*: bool ## If `true` Nim's object to which JSON is parsed is allowed to have
                      	## fields without corresponding JSON keys.

	Options controlling the behavior of fromJson. Source   Edit   

JsonNodeMode = enum
  joptJsonNodeAsRef,    	## returns the ref as is
  joptJsonNodeAsCopy,   	## returns a deep copy of the JsonNode
  joptJsonNodeAsObject   	## treats JsonNode as a regular ref object

	controls toJson for JsonNode types Source   Edit   

ToJsonOptions = object
  enumMode*: EnumMode
  jsonNodeMode*: JsonNodeMode

	Source   Edit   

Procs

proc fromJson[T](a: var T; b: JsonNode; opt = Joptions())

	Source   Edit   

proc fromJsonHook(a: var StringTableRef; b: JsonNode) {.
	....}

Enables fromJson for StringTableRef type.

See also:

	toJsonHook proc

Example:

import std/[strtabs, json]
var t = newStringTable(modeCaseSensitive)
let jsonStr = """{"mode": 0, "table": {"name": "John", "surname": "Doe"}}"""
fromJsonHook(t, parseJson(jsonStr))
assert t[] == newStringTable("name", "John", "surname", "Doe",
                         	modeCaseSensitive)[]

	Source   Edit   

proc fromJsonHook[A](s: var SomeSet[A]; jsonNode: JsonNode; opt = Joptions())

Enables fromJson for HashSet and OrderedSet types.

See also:

	toJsonHook proc

Example:

import std/[sets, json]
var foo: tuple[hs: HashSet[string], os: OrderedSet[string]]
fromJson(foo, parseJson("""
  	{"hs": ["hash", "set"], "os": ["ordered", "set"]}"""))
assert foo.hs == ["hash", "set"].toHashSet
assert foo.os == ["ordered", "set"].toOrderedSet

	Source   Edit   

proc fromJsonHook[K: string | cstring; V](
	t: var (Table[K, V] | OrderedTable[K, V]); jsonNode: JsonNode;
	opt = Joptions())

Enables fromJson for Table and OrderedTable types.

See also:

	toJsonHook proc

Example:

import std/[tables, json]
var foo: tuple[t: Table[string, int], ot: OrderedTable[string, int]]
fromJson(foo, parseJson("""
  	{"t":{"two":2,"one":1},"ot":{"one":1,"three":3}}"""))
assert foo.t == [("one", 1), ("two", 2)].toTable
assert foo.ot == [("one", 1), ("three", 3)].toOrderedTable

	Source   Edit   

proc fromJsonHook[T](self: var Option[T]; jsonNode: JsonNode; opt = Joptions())

Enables fromJson for Option types.

See also:

	toJsonHook proc

Example:

import std/[options, json]
var opt: Option[string]
fromJsonHook(opt, parseJson("\"test\""))
assert get(opt) == "test"
fromJson(opt, parseJson("null"))
assert isNone(opt)

	Source   Edit   

proc initToJsonOptions(): ToJsonOptions {.....}

	initializes ToJsonOptions with sane options. Source   Edit   

proc jsonTo(b: JsonNode; T: typedesc; opt = Joptions()): T:type

	reverse of toJson Source   Edit   

proc toJson[T](a: T; opt = initToJsonOptions()): JsonNode

	serializes a to json; uses toJsonHook(a: T) if it's in scope to customize serialization, see strtabs.toJsonHook for an example.
	Note: With -d:nimPreviewJsonutilsHoleyEnum, toJson now can serialize/deserialize holey enums as regular enums (via ord) instead of as strings. It is expected that this behavior becomes the new default in upcoming versions.
	Source   Edit   

proc toJsonHook(a: StringTableRef): JsonNode {.....}

Enables toJson for StringTableRef type.

See also:

	fromJsonHook proc

Example:

import std/[strtabs, json]
let t = newStringTable("name", "John", "surname", "Doe", modeCaseSensitive)
let jsonStr = """{"mode": "modeCaseSensitive",
                  	"table": {"name": "John", "surname": "Doe"}}"""
assert toJson(t) == parseJson(jsonStr)

	Source   Edit   

proc toJsonHook[A](s: SomeSet[A]; opt = initToJsonOptions()): JsonNode

Enables toJson for HashSet and OrderedSet types.

See also:

	fromJsonHook proc

Example:

import std/[sets, json]
let foo = (hs: ["hash"].toHashSet, os: ["ordered", "set"].toOrderedSet)
assert $toJson(foo) == """{"hs":["hash"],"os":["ordered","set"]}"""

	Source   Edit   

proc toJsonHook[K: string | cstring; V](t: (Table[K, V] | OrderedTable[K, V]);
                                    	opt = initToJsonOptions()): JsonNode

Enables toJson for Table and OrderedTable types.

See also:

	fromJsonHook proc

Example:

import std/[tables, json, sugar]
let foo = (
  t: [("two", 2)].toTable,
  ot: [("one", 1), ("three", 3)].toOrderedTable)
assert $toJson(foo) == """{"t":{"two":2},"ot":{"one":1,"three":3}}"""
# if keys are not string|cstring, you can use this:
let a = {10: "foo", 11: "bar"}.newOrderedTable
let a2 = collect: (for k,v in a: (k,v))
assert $toJson(a2) == """[[10,"foo"],[11,"bar"]]"""

	Source   Edit   

proc toJsonHook[T](self: Option[T]; opt = initToJsonOptions()): JsonNode

Enables toJson for Option types.

See also:

	fromJsonHook proc

Example:

import std/[options, json]
let optSome = some("test")
assert $toJson(optSome) == "\"test\""
let optNone = none[string]()
assert $toJson(optNone) == "null"

	Source   Edit   

std/marshal


std/marshal
Source   Edit  

This module contains procs for serialization and deserialization of arbitrary Nim data structures. The serialization format uses JSON.

Restriction: For objects, their type is not serialized. This means essentially that it does not work if the object has some other runtime type than its compiletime type.
Basic usage

Example:

import std/marshal
type
  A = object of RootObj
  B = object of A
	f: int

let a: ref A = new(B)
assert $$a[] == "{}" # not "{f: 0}"

# unmarshal
let c = to[B]("""{"f": 2}""")
assert typeof(c) is B
assert c.f == 2

# marshal
assert $$c == """{"f": 2}"""

Note: The to and $$ operations are available at compile-time!
See also

	streams module
	json module

Imports

streams, typeinfo, json, intsets, tables, unicode

Procs

proc `$$`[T](x: sink T): string

Returns a string representation of x (serialization, marshalling).

Note: to serialize x to JSON use %x from the json module or jsonutils.toJson(x).

Example:

type
  Foo = object
	id: int
	bar: string
let x = Foo(id: 1, bar: "baz")
## serialize:
let y = $$x
assert y == """{"id": 1, "bar": "baz"}"""

	Source   Edit   

proc load[T](s: Stream; data: var T)

Loads data from the stream s. Raises IOError in case of an error.

Example:

import std/streams

var s = newStringStream("[1, 3, 5]")
var a: array[3, int]
load(s, a)
assert a == [1, 3, 5]

	Source   Edit   

proc store[T](s: Stream; data: sink T)

Stores data into the stream s. Raises IOError in case of an error.

Example:

import std/streams

var s = newStringStream("")
var a = [1, 3, 5]
store(s, a)
s.setPosition(0)
assert s.readAll() == "[1, 3, 5]"

	Source   Edit   

proc to[T](data: string): T

Reads data and transforms it to a type T (deserialization, unmarshalling).

Example:

type
  Foo = object
	id: int
	bar: string
let y = """{"id": 1, "bar": "baz"}"""
assert typeof(y) is string
## deserialize to type 'Foo':
let z = y.to[:Foo]
assert typeof(z) is Foo
assert z.id == 1
assert z.bar == "baz"

	Source   Edit   
Miscellaneous

std/assertions


std/assertions
Source   Edit  

This module implements assertion handling.
Imports

ctypes, miscdollars

Procs

proc failedAssertImpl(msg: string) {.....}

	Raises an AssertionDefect with msg, but this is hidden from the effect system. Called when an assertion failed. Source   Edit   

proc raiseAssert(msg: string) {.noinline, noreturn, nosinks, ....}

	Raises an AssertionDefect with msg. Source   Edit   

Templates

template assert(cond: untyped; msg = "")

Raises AssertionDefect with msg if cond is false. Note that AssertionDefect is hidden from the effect system, so it doesn't produce {.raises: [AssertionDefect].}. This exception is only supposed to be caught by unit testing frameworks.

No code will be generated for assert when passing -d:danger (implied by --assertions:off). See command line switches.

Example:

assert 1 == 1

Example: cmd: --assertions:off

assert 1 == 2 # no code generated, no failure here

Example: cmd: -d:danger

assert 1 == 2 # ditto

	Source   Edit   

template doAssert(cond: untyped; msg = "")

Similar to assert but is always turned on regardless of --assertions.

Example:

doAssert 1 == 1 # generates code even when built with `-d:danger` or `--assertions:off`

	Source   Edit   

template doAssertRaises(exception: typedesc; code: untyped)

Raises AssertionDefect if specified code does not raise exception.

Example:

doAssertRaises(ValueError): raise newException(ValueError, "Hello World")
doAssertRaises(CatchableError): raise newException(ValueError, "Hello World")
doAssertRaises(AssertionDefect): doAssert false

	Source   Edit   

template onFailedAssert(msg, code: untyped): untyped {.dirty.}

Sets an assertion failure handler that will intercept any assert statements following onFailedAssert in the current scope.

Example:

type MyError = object of CatchableError
  lineinfo: tuple[filename: string, line: int, column: int]
# block-wide policy to change the failed assert exception type in order to
# include a lineinfo
onFailedAssert(msg):
  raise (ref MyError)(msg: msg, lineinfo: instantiationInfo(-2))
doAssertRaises(MyError): doAssert false

	std/browsers


std/browsers
Source   Edit  

This module implements a simple proc for opening URLs with the user's default browser.

Unstable API.

Imports

since, strutils, winlean, os

Consts

osOpenCmd = "open"

	Source   Edit   

Procs

proc openDefaultBrowser() {.....}

Opens the user's default browser without any url (blank page). This does not block. Implements IETF RFC-6694 Section 3, "about:blank" must be reserved for a blank page.

Under Windows, ShellExecute is used. Under Mac OS X the open command is used. Under Unix, it is checked if xdg-open exists and used if it does. Otherwise the environment variable BROWSER is used to determine the default browser to use.

This proc doesn't raise an exception on error, beware.

block: openDefaultBrowser()

	See also:

    	https://tools.ietf.org/html/rfc6694#section-3

	Source   Edit   

proc openDefaultBrowser(url: string) {.....}

Opens url with the user's default browser. This does not block. The URL must not be empty string, to open on a blank page see openDefaultBrowser().

Under Windows, ShellExecute is used. Under Mac OS X the open command is used. Under Unix, it is checked if xdg-open exists and used if it does. Otherwise the environment variable BROWSER is used to determine the default browser to use.

This proc doesn't raise an exception on error, beware.

block: openDefaultBrowser("https://nim-lang.org")

	Source   Edit   

std/colors


std/colors
Source   Edit  

This module implements color handling for Nim, namely color mixing and parsing the CSS color names.
Imports

strutils, algorithm

Types

Color = distinct int

	A color stored as RGB, e.g. 0xff00cc. Source   Edit   

Consts

colAliceBlue = 15792383

	Source   Edit   

colAntiqueWhite = 16444375

	Source   Edit   

colAqua = 65535

	Source   Edit   

colAquamarine = 8388564

	Source   Edit   

colAzure = 15794175

	Source   Edit   

colBeige = 16119260

	Source   Edit   

colBisque = 16770244

	Source   Edit   

colBlack = 0

	Source   Edit   

colBlanchedAlmond = 16772045

	Source   Edit   

colBlue = 255

	Source   Edit   

colBlueViolet = 9055202

	Source   Edit   

colBrown = 10824234

	Source   Edit   

colBurlyWood = 14596231

	Source   Edit   

colCadetBlue = 6266528

	Source   Edit   

colChartreuse = 8388352

	Source   Edit   

colChocolate = 13789470

	Source   Edit   

colCoral = 16744272

	Source   Edit   

colCornflowerBlue = 6591981

	Source   Edit   

colCornsilk = 16775388

	Source   Edit   

colCrimson = 14423100

	Source   Edit   

colCyan = 65535

	Source   Edit   

colDarkBlue = 139

	Source   Edit   

colDarkCyan = 35723

	Source   Edit   

colDarkGoldenRod = 12092939

	Source   Edit   

colDarkGray = 11119017

	Source   Edit   

colDarkGreen = 25600

	Source   Edit   

colDarkGrey = 11119017

	Source   Edit   

colDarkKhaki = 12433259

	Source   Edit   

colDarkMagenta = 9109643

	Source   Edit   

colDarkOliveGreen = 5597999

	Source   Edit   

colDarkorange = 16747520

	Source   Edit   

colDarkOrchid = 10040012

	Source   Edit   

colDarkRed = 9109504

	Source   Edit   

colDarkSalmon = 15308410

	Source   Edit   

colDarkSeaGreen = 9419919

	Source   Edit   

colDarkSlateBlue = 4734347

	Source   Edit   

colDarkSlateGray = 3100495

	Source   Edit   

colDarkSlateGrey = 3100495

	Source   Edit   

colDarkTurquoise = 52945

	Source   Edit   

colDarkViolet = 9699539

	Source   Edit   

colDeepPink = 16716947

	Source   Edit   

colDeepSkyBlue = 49151

	Source   Edit   

colDimGray = 6908265

	Source   Edit   

colDimGrey = 6908265

	Source   Edit   

colDodgerBlue = 2003199

	Source   Edit   

colFireBrick = 11674146

	Source   Edit   

colFloralWhite = 16775920

	Source   Edit   

colForestGreen = 2263842

	Source   Edit   

colFuchsia = 16711935

	Source   Edit   

colGainsboro = 14474460

	Source   Edit   

colGhostWhite = 16316671

	Source   Edit   

colGold = 16766720

	Source   Edit   

colGoldenRod = 14329120

	Source   Edit   

colGray = 8421504

	Source   Edit   

colGreen = 32768

	Source   Edit   

colGreenYellow = 11403055

	Source   Edit   

colGrey = 8421504

	Source   Edit   

colHoneyDew = 15794160

	Source   Edit   

colHotPink = 16738740

	Source   Edit   

colIndianRed = 13458524

	Source   Edit   

colIndigo = 4915330

	Source   Edit   

colIvory = 16777200

	Source   Edit   

colKhaki = 15787660

	Source   Edit   

colLavender = 15132410

	Source   Edit   

colLavenderBlush = 16773365

	Source   Edit   

colLawnGreen = 8190976

	Source   Edit   

colLemonChiffon = 16775885

	Source   Edit   

colLightBlue = 11393254

	Source   Edit   

colLightCoral = 15761536

	Source   Edit   

colLightCyan = 14745599

	Source   Edit   

colLightGoldenRodYellow = 16448210

	Source   Edit   

colLightGray = 13882323

	Source   Edit   

colLightGreen = 9498256

	Source   Edit   

colLightGrey = 13882323

	Source   Edit   

colLightPink = 16758465

	Source   Edit   

colLightSalmon = 16752762

	Source   Edit   

colLightSeaGreen = 2142890

	Source   Edit   

colLightSkyBlue = 8900346

	Source   Edit   

colLightSlateGray = 7833753

	Source   Edit   

colLightSlateGrey = 7833753

	Source   Edit   

colLightSteelBlue = 11584734

	Source   Edit   

colLightYellow = 16777184

	Source   Edit   

colLime = 65280

	Source   Edit   

colLimeGreen = 3329330

	Source   Edit   

colLinen = 16445670

	Source   Edit   

colMagenta = 16711935

	Source   Edit   

colMaroon = 8388608

	Source   Edit   

colMediumAquaMarine = 6737322

	Source   Edit   

colMediumBlue = 205

	Source   Edit   

colMediumOrchid = 12211667

	Source   Edit   

colMediumPurple = 9662683

	Source   Edit   

colMediumSeaGreen = 3978097

	Source   Edit   

colMediumSlateBlue = 8087790

	Source   Edit   

colMediumSpringGreen = 64154

	Source   Edit   

colMediumTurquoise = 4772300

	Source   Edit   

colMediumVioletRed = 13047173

	Source   Edit   

colMidnightBlue = 1644912

	Source   Edit   

colMintCream = 16121850

	Source   Edit   

colMistyRose = 16770273

	Source   Edit   

colMoccasin = 16770229

	Source   Edit   

colNavajoWhite = 16768685

	Source   Edit   

colNavy = 128

	Source   Edit   

colOldLace = 16643558

	Source   Edit   

colOlive = 8421376

	Source   Edit   

colOliveDrab = 7048739

	Source   Edit   

colOrange = 16753920

	Source   Edit   

colOrangeRed = 16729344

	Source   Edit   

colOrchid = 14315734

	Source   Edit   

colPaleGoldenRod = 15657130

	Source   Edit   

colPaleGreen = 10025880

	Source   Edit   

colPaleTurquoise = 11529966

	Source   Edit   

colPaleVioletRed = 14381203

	Source   Edit   

colPapayaWhip = 16773077

	Source   Edit   

colPeachPuff = 16767673

	Source   Edit   

colPeru = 13468991

	Source   Edit   

colPink = 16761035

	Source   Edit   

colPlum = 14524637

	Source   Edit   

colPowderBlue = 11591910

	Source   Edit   

colPurple = 8388736

	Source   Edit   

colRebeccaPurple = 6697881

	Source   Edit   

colRed = 16711680

	Source   Edit   

colRosyBrown = 12357519

	Source   Edit   

colRoyalBlue = 4286945

	Source   Edit   

colSaddleBrown = 9127187

	Source   Edit   

colSalmon = 16416882

	Source   Edit   

colSandyBrown = 16032864

	Source   Edit   

colSeaGreen = 3050327

	Source   Edit   

colSeaShell = 16774638

	Source   Edit   

colSienna = 10506797

	Source   Edit   

colSilver = 12632256

	Source   Edit   

colSkyBlue = 8900331

	Source   Edit   

colSlateBlue = 6970061

	Source   Edit   

colSlateGray = 7372944

	Source   Edit   

colSlateGrey = 7372944

	Source   Edit   

colSnow = 16775930

	Source   Edit   

colSpringGreen = 65407

	Source   Edit   

colSteelBlue = 4620980

	Source   Edit   

colTan = 13808780

	Source   Edit   

colTeal = 32896

	Source   Edit   

colThistle = 14204888

	Source   Edit   

colTomato = 16737095

	Source   Edit   

colTurquoise = 4251856

	Source   Edit   

colViolet = 15631086

	Source   Edit   

colWheat = 16113331

	Source   Edit   

colWhite = 16777215

	Source   Edit   

colWhiteSmoke = 16119285

	Source   Edit   

colYellow = 16776960

	Source   Edit   

colYellowGreen = 10145074

	Source   Edit   

Procs

proc `$`(c: Color): string {.....}

Converts a color into its textual representation.

Example:

assert $colFuchsia == "#FF00FF"

	Source   Edit   

proc `+`(a, b: Color): Color {.....}

Adds two colors.

This uses saturated arithmetic, so that each color component cannot overflow (255 is used as a maximum).

Example:

var
  a = Color(0xaa_00_ff)
  b = Color(0x11_cc_cc)
assert a + b == Color(0xbb_cc_ff)

	Source   Edit   

proc `-`(a, b: Color): Color {.....}

Subtracts two colors.

This uses saturated arithmetic, so that each color component cannot underflow (0 is used as a minimum).

Example:

var
  a = Color(0xff_33_ff)
  b = Color(0x11_ff_cc)
assert a - b == Color(0xee_00_33)

	Source   Edit   

proc `==`(a, b: Color): bool {.borrow, ....}

Compares two colors.

var
  a = Color(0xff_00_ff)
  b = colFuchsia
  c = Color(0x00_ff_cc)
assert a == b
assert not (a == c)

	Source   Edit   

proc extractRGB(a: Color): tuple[r, g, b: range[0 .. 255]] {.....}

Extracts the red/green/blue components of the color a.

Example:

var
  a = Color(0xff_00_ff)
  b = Color(0x00_ff_cc)
type
  Col = range[0..255]
# assert extractRGB(a) == (r: 255.Col, g: 0.Col, b: 255.Col)
# assert extractRGB(b) == (r: 0.Col, g: 255.Col, b: 204.Col)
echo extractRGB(a)
echo typeof(extractRGB(a))
echo extractRGB(b)
echo typeof(extractRGB(b))

	Source   Edit   

proc intensity(a: Color; f: float): Color {.....}

Returns a with intensity f. f should be a float from 0.0 (completely dark) to 1.0 (full color intensity).

Example:

var
  a = Color(0xff_00_ff)
  b = Color(0x00_42_cc)
assert a.intensity(0.5) == Color(0x80_00_80)
assert b.intensity(0.5) == Color(0x00_21_66)

	Source   Edit   

proc isColor(name: string): bool {.....}

Returns true if name is a known color name or a hexadecimal color prefixed with #. Case insensitive.

Example:

var
  a = "silver"
  b = "#0179fc"
  c = "#zzmmtt"
assert a.isColor
assert b.isColor
assert not c.isColor

	Source   Edit   

proc parseColor(name: string): Color {.....}

Parses name to a color value.

If no valid color could be parsed ValueError is raised. Case insensitive.

Example:

var
  a = "silver"
  b = "#0179fc"
  c = "#zzmmtt"
assert parseColor(a) == Color(0xc0_c0_c0)
assert parseColor(b) == Color(0x01_79_fc)
doAssertRaises(ValueError): discard parseColor(c)

	Source   Edit   

proc rgb(r, g, b: range[0 .. 255]): Color {.....}

Constructs a color from RGB values.

Example:

assert rgb(0, 255, 128) == Color(0x00_ff_80)

	Source   Edit   

Templates

template mix(a, b: Color; fn: untyped): untyped

Uses fn to mix the colors a and b.

fn is invoked for each component R, G, and B. If fn's result is not in the range[0..255], it will be saturated to be so.

Example:

var
  a = Color(0x0a2814)
  b = Color(0x050a03)

proc myMix(x, y: int): int =
  2 * x - 3 * y

assert mix(a, b, myMix) == Color(0x05_32_1f)

	Source   Edit   

std/coro


std/coro
Source   Edit  

Nim coroutines implementation, supports several context switching methods:
ucontext	available on unix and alike (default)
setjmp	available on unix and alike (x86/64 only)
fibers	available and required on windows.
-d:nimCoroutines
Required to build this module.
-d:nimCoroutinesUcontext
Use ucontext backend.
-d:nimCoroutinesSetjmp
Use setjmp backend.
-d:nimCoroutinesSetjmpBundled
Use bundled setjmp implementation.

Unstable API.
Timer support for the realtime GC. Based on https://github.com/jckarter/clay/blob/master/compiler/hirestimer.cpp

Imports

coro_detection, os, lists, winlean

Types

CoroutineRef = ref object

	CoroutineRef holds a pointer to actual coroutine object. Public API always returns CoroutineRef instead of CoroutinePtr in order to allow holding a reference to coroutine object while it can be safely deallocated by coroutine scheduler loop. In this case Coroutine.reference.coro is set to nil. Public API checks for it being nil and gracefully fails if it is nil. Source   Edit   

Procs

proc alive(c: CoroutineRef): bool {.....}

	Returns true if coroutine has not returned, false otherwise. Source   Edit   

proc run() {.....}

	Starts main coroutine scheduler loop which exits when all coroutines exit. Calling this proc starts execution of first coroutine. Source   Edit   

proc start(c: proc (); stacksize: int = defaultStackSize): CoroutineRef {.
	discardable, ....}

	Schedule coroutine for execution. It does not run immediately. Source   Edit   

proc suspend(sleepTime: float = 0.0) {.....}

	Stops coroutine execution and resumes no sooner than after sleeptime seconds. Until then other coroutines are executed. Source   Edit   

proc wait(c: CoroutineRef; interval = 0.01) {.....}

	Returns only after coroutine c has returned. interval is time in seconds how often. Source   Edit   

std/decls


std/decls
Source   Edit  

This module implements syntax sugar for some declarations.
Imports

macros

Macros

macro byaddr(sect)

Allows a syntax for l-value references, being an exact analog to auto& a = ex; in C++.
Warning: This makes use of 2 experimental features, namely nullary templates instantiated as symbols and variable macro pragmas. For this reason, its behavior is not stable. The current implementation allows redefinition, but this is not an intended consequence.

Example:

var s = @[10, 11, 12]
var a {.byaddr.} = s[0]
a += 100
assert s == @[110, 11, 12]
assert a is int
var b {.byaddr.}: int = s[0]
assert a.addr == b.addr

	Source   Edit   

std/enumerate


std/enumerate
Source   Edit  

This module implements enumerate syntactic sugar based on Nim's macro system.
Imports

since, macros

Macros

macro enumerate(x: ForLoopStmt): untyped

Enumerating iterator for collections.

It yields (count, value) tuples (which must be immediately unpacked). The default starting count 0 can be manually overridden if needed.

Example:

let a = [10, 20, 30]
var b: seq[(int, int)] = @[]
for i, x in enumerate(a):
  b.add((i, x))
assert b == @[(0, 10), (1, 20), (2, 30)]

let c = "abcd"
var d: seq[(int, char)]
for (i, x) in enumerate(97, c):
  d.add((i, x))
assert d == @[(97, 'a'), (98, 'b'), (99, 'c'), (100, 'd')]

	Source   Edit   

std/importutils


std/importutils
Source   Edit  

Utilities related to import and symbol resolution.

Experimental API, subject to change.

Procs

proc privateAccess(t: typedesc) {.magic: "PrivateAccess", ....}

Enables access to private fields of t in current scope.

Example: cmd: -d:nimImportutilsExample

# here we're importing a module containing:
# type
#   Foo = object
# 	f0: int # private
#   Goo*[T] = object
# 	g0: int # private
# proc initFoo*(): auto = Foo()
var f = initFoo()
block:
  assert not compiles(f.f0)
  privateAccess(f.type)
  f.f0 = 1 # accessible in this scope
  block:
	assert f.f0 == 1 # still in scope
assert not compiles(f.f0)

# this also works with generics
privateAccess(Goo)
assert Goo[float](g0: 1).g0 == 1

	Source   Edit   

std/logging


std/logging
Source   Edit  

This module implements a simple logger.

It has been designed to be as simple as possible to avoid bloat. If this library does not fulfill your needs, write your own.
Basic usage

To get started, first create a logger:

import std/logging

var logger = newConsoleLogger()

The logger that was created above logs to the console, but this module also provides loggers that log to files, such as the FileLogger. Creating custom loggers is also possible by inheriting from the Logger type.

Once a logger has been created, call its log proc to log a message:

logger.log(lvlInfo, "a log message")
# Output: INFO a log message

The INFO within the output is the result of a format string being prepended to the message, and it will differ depending on the message's level. Format strings are explained in more detail here.

There are six logging levels: debug, info, notice, warn, error, and fatal. They are described in more detail within the Level enum's documentation. A message is logged if its level is at or above both the logger's levelThreshold field and the global log filter. The latter can be changed with the setLogFilter proc.
Warning: For loggers that log to a console or to files, only error and fatal messages will cause their output buffers to be flushed immediately by default. set flushThreshold when creating the logger to change this.
Handlers

When using multiple loggers, calling the log proc for each logger can become repetitive. Instead of doing that, register each logger that will be used with the addHandler proc, which is demonstrated in the following example:

import std/logging

var consoleLog = newConsoleLogger()
var fileLog = newFileLogger("errors.log", levelThreshold=lvlError)
var rollingLog = newRollingFileLogger("rolling.log")

addHandler(consoleLog)
addHandler(fileLog)
addHandler(rollingLog)

After doing this, use either the log template or one of the level-specific templates, such as the error template, to log messages to all registered handlers at once.

# This example uses the loggers created above
log(lvlError, "an error occurred")
error("an error occurred")  # Equivalent to the above line
info("something normal happened")  # Will not be written to errors.log

Note that a message's level is still checked against each handler's levelThreshold and the global log filter.
Format strings

Log messages are prefixed with format strings. These strings contain placeholders for variables, such as $time, that are replaced with their corresponding values, such as the current time, before they are prepended to a log message. Characters that are not part of variables are unaffected.

The format string used by a logger can be specified by providing the fmtStr argument when creating the logger or by setting its fmtStr field afterward. If not specified, the default format string is used.

The following variables, which must be prefixed with a dollar sign ($), are available:
Variable	Output
$date	Current date
$time	Current time
$datetime	$dateT$time
$app	os.getAppFilename()
$appname	Base name of $app
$appdir	Directory name of $app
$levelid	First letter of log level
$levelname	Log level name

Note that $app, $appname, and $appdir are not supported when using the JavaScript backend.

The following example illustrates how to use format strings:

import std/logging

var logger = newConsoleLogger(fmtStr="[$time] - $levelname: ")
logger.log(lvlInfo, "this is a message")
# Output: [19:50:13] - INFO: this is a message

Notes when using multiple threads

There are a few details to keep in mind when using this module within multiple threads:

	The global log filter is actually a thread-local variable, so it needs to be set in each thread that uses this module.
	The list of registered handlers is also a thread-local variable. If a handler will be used in multiple threads, it needs to be registered in each of those threads.

See also

	strutils module for common string functions
	strformat module for string interpolation and formatting
	strscans module for scanf and scanp macros, which offer easier substring extraction than regular expressions

Imports

strutils, times, os

Types

ConsoleLogger = ref object of Logger
  useStderr*: bool       	## If true, writes to stderr; otherwise, writes to stdout
  flushThreshold*: Level 	## Only messages that are at or above this
                         	## threshold will be flushed immediately

	A logger that writes log messages to the console.

	Create a new ConsoleLogger with the newConsoleLogger proc.

	See also:

    	FileLogger
    	RollingFileLogger

	Source   Edit   

FileLogger = ref object of Logger
  file*: File            	## The wrapped file
  flushThreshold*: Level 	## Only messages that are at or above this
                         	## threshold will be flushed immediately

	A logger that writes log messages to a file.

	Create a new FileLogger with the newFileLogger proc.

	Note: This logger is not available for the JavaScript backend.

	See also:

    	ConsoleLogger
    	RollingFileLogger

	Source   Edit   

Level = enum
  lvlAll,               	## All levels active
  lvlDebug,             	## Debug level and above are active
  lvlInfo,              	## Info level and above are active
  lvlNotice,            	## Notice level and above are active
  lvlWarn,              	## Warn level and above are active
  lvlError,             	## Error level and above are active
  lvlFatal,             	## Fatal level and above are active
  lvlNone                	## No levels active; nothing is logged

	Enumeration of logging levels.

	Debug messages represent the lowest logging level, and fatal error messages represent the highest logging level. lvlAll can be used to enable all messages, while lvlNone can be used to disable all messages.

	Typical usage for each logging level, from lowest to highest, is described below:

    	Debug - debugging information helpful only to developers
    	Info - anything associated with normal operation and without any particular importance
    	Notice - more important information that users should be notified about
    	Warn - impending problems that require some attention
    	Error - error conditions that the application can recover from
    	Fatal - fatal errors that prevent the application from continuing

	It is completely up to the application how to utilize each level.

	Individual loggers have a levelThreshold field that filters out any messages with a level lower than the threshold. There is also a global filter that applies to all log messages, and it can be changed using the setLogFilter proc.
	Source   Edit   

Logger = ref object of RootObj
  levelThreshold*: Level 	## Only messages that are at or above this
                         	## threshold will be logged
  fmtStr*: string        	## Format string to prepend to each log message;
                         	## defaultFmtStr is the default

	The abstract base type of all loggers.

	Custom loggers should inherit from this type. They should also provide their own implementation of the log method.

	See also:

    	ConsoleLogger
    	FileLogger
    	RollingFileLogger

	Source   Edit   

RollingFileLogger = ref object of FileLogger

	A logger that writes log messages to a file while performing log rotation.

	Create a new RollingFileLogger with the newRollingFileLogger proc.

	Note: This logger is not available for the JavaScript backend.

	See also:

    	ConsoleLogger
    	FileLogger

	Source   Edit   

Consts

defaultFmtStr = "$levelname "

	The default format string. Source   Edit   

LevelNames: array[Level, string] = ["DEBUG", "DEBUG", "INFO", "NOTICE", "WARN",
                                	"ERROR", "FATAL", "NONE"]

	Array of strings representing each logging level. Source   Edit   

verboseFmtStr = "$levelid, [$datetime] -- $appname: "

	A more verbose format string.

	This string can be passed as the frmStr argument to procs that create new loggers, such as the newConsoleLogger proc.

	If a different format string is preferred, refer to the documentation about format strings for more information, including a list of available variables.
	Source   Edit   

Procs

proc addHandler(handler: Logger) {.....}

Adds a logger to the list of registered handlers.
Warning: The list of handlers is a thread-local variable. If the given handler will be used in multiple threads, this proc should be called in each of those threads.

See also:

	getHandlers proc

Example:

var logger = newConsoleLogger()
addHandler(logger)
doAssert logger in getHandlers()

	Source   Edit   

proc defaultFilename(): string {.....}

	Returns the filename that is used by default when naming log files.

	Note: This proc is not available for the JavaScript backend.
	Source   Edit   

proc getHandlers(): seq[Logger] {.....}

	Returns a list of all the registered handlers.

	See also:

    	addHandler proc

	Source   Edit   

proc getLogFilter(): Level {.....}

	Gets the global log filter.

	See also:

    	setLogFilter proc

	Source   Edit   

proc newConsoleLogger(levelThreshold = lvlAll; fmtStr = defaultFmtStr;
                  	useStderr = false; flushThreshold = defaultFlushThreshold): ConsoleLogger {.
	....}

Creates a new ConsoleLogger.

By default, log messages are written to stdout. If useStderr is true, they are written to stderr instead.

For the JavaScript backend, log messages are written to the console, and useStderr is ignored.

See also:

	newFileLogger proc that uses a file handle
	newFileLogger proc that accepts a filename
	newRollingFileLogger proc

Examples:

var normalLog = newConsoleLogger()
var formatLog = newConsoleLogger(fmtStr=verboseFmtStr)
var errorLog = newConsoleLogger(levelThreshold=lvlError, useStderr=true)

	Source   Edit   

proc newFileLogger(file: File; levelThreshold = lvlAll; fmtStr = defaultFmtStr;
               	flushThreshold = defaultFlushThreshold): FileLogger {.
	....}

Creates a new FileLogger that uses the given file handle.

Note: This proc is not available for the JavaScript backend.

See also:

	newConsoleLogger proc
	newFileLogger proc that accepts a filename
	newRollingFileLogger proc

Examples:

var messages = open("messages.log", fmWrite)
var formatted = open("formatted.log", fmWrite)
var errors = open("errors.log", fmWrite)

var normalLog = newFileLogger(messages)
var formatLog = newFileLogger(formatted, fmtStr=verboseFmtStr)
var errorLog = newFileLogger(errors, levelThreshold=lvlError)

	Source   Edit   

proc newFileLogger(filename = defaultFilename(); mode: FileMode = fmAppend;
               	levelThreshold = lvlAll; fmtStr = defaultFmtStr;
               	bufSize: int = -1; flushThreshold = defaultFlushThreshold): FileLogger {.
	....}

Creates a new FileLogger that logs to a file with the given filename.

bufSize controls the size of the output buffer that is used when writing to the log file. The following values can be provided:

	-1 - use system defaults
	0 - unbuffered
	> 0 - fixed buffer size

Note: This proc is not available for the JavaScript backend.

See also:

	newConsoleLogger proc
	newFileLogger proc that uses a file handle
	newRollingFileLogger proc

Examples:

var normalLog = newFileLogger("messages.log")
var formatLog = newFileLogger("formatted.log", fmtStr=verboseFmtStr)
var errorLog = newFileLogger("errors.log", levelThreshold=lvlError)

	Source   Edit   

proc newRollingFileLogger(filename = defaultFilename();
                      	mode: FileMode = fmReadWrite; levelThreshold = lvlAll;
                      	fmtStr = defaultFmtStr; maxLines: Positive = 1000;
                      	bufSize: int = -1;
                      	flushThreshold = defaultFlushThreshold): RollingFileLogger {.
	....}

Creates a new RollingFileLogger.

Once the current log file being written to contains maxLines lines, a new log file will be created, and the old log file will be renamed.

bufSize controls the size of the output buffer that is used when writing to the log file. The following values can be provided:

	-1 - use system defaults
	0 - unbuffered
	> 0 - fixed buffer size

Note: This proc is not available in the JavaScript backend.

See also:

	newConsoleLogger proc
	newFileLogger proc that uses a file handle
	newFileLogger proc that accepts a filename

Examples:

var normalLog = newRollingFileLogger("messages.log")
var formatLog = newRollingFileLogger("formatted.log", fmtStr=verboseFmtStr)
var shortLog = newRollingFileLogger("short.log", maxLines=200)
var errorLog = newRollingFileLogger("errors.log", levelThreshold=lvlError)

	Source   Edit   

proc setLogFilter(lvl: Level) {.....}

Sets the global log filter.

Messages below the provided level will not be logged regardless of an individual logger's levelThreshold. By default, all messages are logged.
Warning: The global log filter is a thread-local variable. If logging is being performed in multiple threads, this proc should be called in each thread unless it is intended that different threads should log at different logging levels.

See also:

	getLogFilter proc

Example:

setLogFilter(lvlError)
doAssert getLogFilter() == lvlError

	Source   Edit   

proc substituteLog(frmt: string; level: Level; args: varargs[string, `$`]): string {.
	....}

Formats a log message at the specified level with the given format string.

The format variables present within frmt will be replaced with the corresponding values before being prepended to args and returned.

Unless you are implementing a custom logger, there is little need to call this directly. Use either a logger's log method or one of the logging templates.

See also:

	log method for the ConsoleLogger
	log method for the FileLogger
	log method for the RollingFileLogger
	log template

Example:

doAssert substituteLog(defaultFmtStr, lvlInfo, "a message") == "INFO a message"
doAssert substituteLog("$levelid - ", lvlError, "an error") == "E - an error"
doAssert substituteLog("$levelid", lvlDebug, "error") == "Derror"

	Source   Edit   

Methods

method log(logger: ConsoleLogger; level: Level; args: varargs[string, `$`]) {.
	....}

Logs to the console with the given ConsoleLogger only.

This method ignores the list of registered handlers.

Whether the message is logged depends on both the ConsoleLogger's levelThreshold field and the global log filter set using the setLogFilter proc.

Note: Only error and fatal messages will cause the output buffer to be flushed immediately by default. Set flushThreshold when creating the logger to change this.

See also:

	log method for the FileLogger
	log method for the RollingFileLogger
	log template

Examples:

var consoleLog = newConsoleLogger()
consoleLog.log(lvlInfo, "this is a message")
consoleLog.log(lvlError, "error code is: ", 404)

	Source   Edit   

method log(logger: FileLogger; level: Level; args: varargs[string, `$`]) {.
	....}

Logs a message at the specified level using the given FileLogger only.

This method ignores the list of registered handlers.

Whether the message is logged depends on both the FileLogger's levelThreshold field and the global log filter set using the setLogFilter proc.

Notes:

	Only error and fatal messages will cause the output buffer to be flushed immediately by default. Set flushThreshold when creating the logger to change this.
	This method is not available for the JavaScript backend.

See also:

	log method for the ConsoleLogger
	log method for the RollingFileLogger
	log template

Examples:

var fileLog = newFileLogger("messages.log")
fileLog.log(lvlInfo, "this is a message")
fileLog.log(lvlError, "error code is: ", 404)

	Source   Edit   

method log(logger: Logger; level: Level; args: varargs[string, `$`]) {.
	...base, ....}

	Override this method in custom loggers. The default implementation does nothing.

	See also:

    	log method for the ConsoleLogger
    	log method for the FileLogger
    	log method for the RollingFileLogger
    	log template

	Source   Edit   

method log(logger: RollingFileLogger; level: Level; args: varargs[string, `$`]) {.
	....}

Logs a message at the specified level using the given RollingFileLogger only.

This method ignores the list of registered handlers.

Whether the message is logged depends on both the RollingFileLogger's levelThreshold field and the global log filter set using the setLogFilter proc.

Notes:

	Only error and fatal messages will cause the output buffer to be flushed immediately by default. Set flushThreshold when creating the logger to change this.
	This method is not available for the JavaScript backend.

See also:

	log method for the ConsoleLogger
	log method for the FileLogger
	log template

Examples:

var rollingLog = newRollingFileLogger("messages.log")
rollingLog.log(lvlInfo, "this is a message")
rollingLog.log(lvlError, "error code is: ", 404)

	Source   Edit   

Templates

template debug(args: varargs[string, `$`])

Logs a debug message to all registered handlers.

Debug messages are typically useful to the application developer only, and they are usually disabled in release builds, although this template does not make that distinction.

Examples:

var logger = newConsoleLogger()
addHandler(logger)

debug("myProc called with arguments: foo, 5")

	See also:

    	log template
    	info template
    	notice template

	Source   Edit   

template error(args: varargs[string, `$`])

Logs an error message to all registered handlers.

Error messages are for application-level error conditions, such as when some user input generated an exception. Typically, the application will continue to run, but with degraded functionality or loss of data, and these effects might be visible to users.

Examples:

var logger = newConsoleLogger()
addHandler(logger)

error("An exception occurred while processing the form.")

	See also:

    	log template
    	warn template
    	fatal template

	Source   Edit   

template fatal(args: varargs[string, `$`])

Logs a fatal error message to all registered handlers.

Fatal error messages usually indicate that the application cannot continue to run and will exit due to a fatal condition. This template only logs the message, and it is the application's responsibility to exit properly.

Examples:

var logger = newConsoleLogger()
addHandler(logger)

fatal("Can't open database -- exiting.")

	See also:

    	log template
    	warn template
    	error template

	Source   Edit   

template info(args: varargs[string, `$`])

Logs an info message to all registered handlers.

Info messages are typically generated during the normal operation of an application and are of no particular importance. It can be useful to aggregate these messages for later analysis.

Examples:

var logger = newConsoleLogger()
addHandler(logger)

info("Application started successfully.")

	See also:

    	log template
    	debug template
    	notice template

	Source   Edit   

template log(level: Level; args: varargs[string, `$`])

Logs a message at the specified level to all registered handlers.

Whether the message is logged depends on both the FileLogger's levelThreshold field and the global log filter set using the setLogFilter proc.

Examples:

var logger = newConsoleLogger()
addHandler(logger)

log(lvlInfo, "This is an example.")

	See also:

    	debug template
    	info template
    	notice template
    	warn template
    	error template
    	fatal template

	Source   Edit   

template notice(args: varargs[string, `$`])

Logs an notice to all registered handlers.

Notices are semantically very similar to info messages, but they are meant to be messages that the user should be actively notified about, depending on the application.

Examples:

var logger = newConsoleLogger()
addHandler(logger)

notice("An important operation has completed.")

	See also:

    	log template
    	debug template
    	info template

	Source   Edit   

template warn(args: varargs[string, `$`])

Logs a warning message to all registered handlers.

A warning is a non-error message that may indicate impending problems or degraded performance.

Examples:

var logger = newConsoleLogger()
addHandler(logger)

warn("The previous operation took too long to process.")

	See also:

    	log template
    	error template
    	fatal template

	Source   Edit   

std/segfaults


std/segfaults
Source   Edit  

This modules registers a signal handler that turns access violations / segfaults into a NilAccessDefect exception. To be able to catch a NilAccessDefect all you have to do is to import this module.

Tested on these OSes: Linux, Windows, OSX

Imports

winlean

Types

C_JmpBuf {.importc: "jmp_buf", header: "<setjmp.h>".} = object

	Source   Edit   

CFilePtr = ptr CFile

	The type representing a file handle. Source   Edit   

Vars

cstderr {.importc: "stderr", header: "<stdio.h>".}: CFilePtr

	Source   Edit   

cstdin {.importc: "stdin", header: "<stdio.h>".}: CFilePtr

	Source   Edit   

cstdout {.importc: "stdout", header: "<stdio.h>".}: CFilePtr

	Source   Edit   

Consts

SIG_DFL = 0

	Source   Edit   

SIGABRT = 22'i32

	Source   Edit   

SIGFPE = 8'i32

	Source   Edit   

SIGILL = 4'i32

	Source   Edit   

SIGINT = 2'i32

	Source   Edit   

SIGSEGV = 11'i32

	Source   Edit   

Procs

proc c_abort() {.importc: "abort", header: "<stdlib.h>", noSideEffect, noreturn,
             	....}

	Source   Edit   

proc c_calloc(nmemb, size: csize_t): pointer {.importc: "calloc",
	header: "<stdlib.h>", ....}

	Source   Edit   

proc c_fflush(f: CFilePtr): cint {.importc: "fflush", header: "<stdio.h>",
                               	....}

	Source   Edit   

proc c_fprintf(f: CFilePtr; frmt: cstring): cint {.importc: "fprintf",
	header: "<stdio.h>", varargs, discardable, ....}

	Source   Edit   

proc c_fputc(c: char; f: CFilePtr): cint {.importc: "fputc",
	header: "<stdio.h>", discardable, ....}

	Source   Edit   

proc c_fputs(c: cstring; f: CFilePtr): cint {.importc: "fputs",
	header: "<stdio.h>", discardable, ....}

	Source   Edit   

proc c_free(p: pointer) {.importc: "free", header: "<stdlib.h>", ....}

	Source   Edit   

proc c_fwrite(buf: pointer; size, n: csize_t; f: CFilePtr): csize_t {.
	importc: "fwrite", header: "<stdio.h>", ....}

	Source   Edit   

proc c_longjmp(jmpb: C_JmpBuf; retval: cint) {.header: "<setjmp.h>",
	importc: "longjmp", ....}

	Source   Edit   

proc c_malloc(size: csize_t): pointer {.importc: "malloc", header: "<stdlib.h>",
                                    	....}

	Source   Edit   

proc c_memchr(s: pointer; c: cint; n: csize_t): pointer {.importc: "memchr",
	header: "<string.h>", ....}

	Source   Edit   

proc c_memcmp(a, b: pointer; size: csize_t): cint {.importc: "memcmp",
	header: "<string.h>", noSideEffect, ....}

	Source   Edit   

proc c_memcpy(a, b: pointer; size: csize_t): pointer {.importc: "memcpy",
	header: "<string.h>", discardable, ....}

	Source   Edit   

proc c_memmove(a, b: pointer; size: csize_t): pointer {.importc: "memmove",
	header: "<string.h>", discardable, ....}

	Source   Edit   

proc c_memset(p: pointer; value: cint; size: csize_t): pointer {.
	importc: "memset", header: "<string.h>", discardable, ....}

	Source   Edit   

proc c_printf(frmt: cstring): cint {.importc: "printf", header: "<stdio.h>",
                                 	varargs, discardable, ....}

	Source   Edit   

proc c_raise(sign: cint): cint {.importc: "raise", header: "<signal.h>",
                             	....}

	Source   Edit   

proc c_realloc(p: pointer; newsize: csize_t): pointer {.importc: "realloc",
	header: "<stdlib.h>", ....}

	Source   Edit   

proc c_setjmp(jmpb: C_JmpBuf): cint {.header: "<setjmp.h>", importc: "setjmp",
                                  	....}

	Source   Edit   

proc c_signal(sign: cint; handler: CSighandlerT): CSighandlerT {.
	importc: "signal", header: "<signal.h>", discardable, ....}

	Source   Edit   

proc c_snprintf(buf: cstring; n: csize_t; frmt: cstring): cint {.
	importc: "snprintf", header: "<stdio.h>", varargs, noSideEffect, ....}

	Source   Edit   

proc c_sprintf(buf, frmt: cstring): cint {.importc: "sprintf",
	header: "<stdio.h>", varargs, noSideEffect, ....}

	Source   Edit   

proc c_strcmp(a, b: cstring): cint {.importc: "strcmp", header: "<string.h>",
                                 	noSideEffect, ....}

	Source   Edit   

proc c_strlen(a: cstring): csize_t {.importc: "strlen", header: "<string.h>",
                                 	noSideEffect, ....}

	Source   Edit   

proc rawWrite(f: CFilePtr; s: cstring) {.compilerproc, nonReloadable, inline,
	....}

	Source   Edit   

proc rawWriteString(f: CFilePtr; s: cstring; length: int) {.compilerproc,
	nonReloadable, inline, ....}

	Source   Edit   


std/sugar


std/sugar
Source   Edit  

This module implements nice syntactic sugar based on Nim's macro system.
Imports

since, macros, underscored_calls

Macros

macro `->`(p, b: untyped): untyped

Syntax sugar for procedure types. It also supports pragmas.
Warning: Semicolons can not be used to separate procedure arguments.

Example:

proc passTwoAndTwo(f: (int, int) -> int): int = f(2, 2)
# is the same as:
# proc passTwoAndTwo(f: proc (x, y: int): int): int = f(2, 2)

assert passTwoAndTwo((x, y) => x + y) == 4

proc passOne(f: (int {.noSideEffect.} -> int)): int = f(1)
# is the same as:
# proc passOne(f: proc (x: int): int {.noSideEffect.}): int = f(1)

assert passOne(x {.noSideEffect.} => x + 1) == 2

	Source   Edit   

macro `=>`(p, b: untyped): untyped

Syntax sugar for anonymous procedures. It also supports pragmas.
Warning: Semicolons can not be used to separate procedure arguments.

Example:

proc passTwoAndTwo(f: (int, int) -> int): int = f(2, 2)

assert passTwoAndTwo((x, y) => x + y) == 4

type
  Bot = object
	call: (string {.noSideEffect.} -> string)

var myBot = Bot()

myBot.call = (name: string) {.noSideEffect.} => "Hello " & name & ", I'm a bot."
assert myBot.call("John") == "Hello John, I'm a bot."

let f = () => (discard) # simplest proc that returns void
f()

	Source   Edit   

macro capture(locals: varargs[typed]; body: untyped): untyped

Useful when creating a closure in a loop to capture some local loop variables by their current iteration values.

Example:

import std/strformat

var myClosure: () -> string
for i in 5..7:
  for j in 7..9:
	if i * j == 42:
  	capture i, j:
    	myClosure = () => fmt"{i} * {j} = 42"
assert myClosure() == "6 * 7 = 42"

	Source   Edit   

macro collect(body: untyped): untyped

Same as collect but without an init parameter.

See also:

	sequtils.toSeq proc
	sequtils.mapIt template

Example:

import std/[sets, tables]
let data = @["bird", "word"]

# seq:
let k = collect:
  for i, d in data.pairs:
	if i mod 2 == 0: d
assert k == @["bird"]

## HashSet:
let n = collect:
  for d in data.items: {d}
assert n == data.toHashSet

## Table:
let m = collect:
  for i, d in data.pairs: {i: d}
assert m == {0: "bird", 1: "word"}.toTable

	Source   Edit   

macro collect(init, body: untyped): untyped

Comprehension for seqs/sets/tables.

The last expression of body has special syntax that specifies the collection's add operation. Use {e} for set's incl, {k: v} for table's []= and e for seq's add.

Example:

import std/[sets, tables]

let data = @["bird", "word"]

## seq:
let k = collect(newSeq):
  for i, d in data.pairs:
	if i mod 2 == 0: d
assert k == @["bird"]

## seq with initialSize:
let x = collect(newSeqOfCap(4)):
  for i, d in data.pairs:
	if i mod 2 == 0: d
assert x == @["bird"]

## HashSet:
let y = collect(initHashSet()):
  for d in data.items: {d}
assert y == data.toHashSet

## Table:
let z = collect(initTable(2)):
  for i, d in data.pairs: {i: d}
assert z == {0: "bird", 1: "word"}.toTable

	Source   Edit   

macro dump(x: untyped): untyped

Dumps the content of an expression, useful for debugging. It accepts any expression and prints a textual representation of the tree representing the expression - as it would appear in source code - together with the value of the expression.

See also: dumpToString which is more convenient and useful since it expands intermediate templates/macros, returns a string instead of calling echo, and works with statements and expressions.

Example: cmd: -r:off

let
  x = 10
  y = 20
dump(x + y) # prints: `x + y = 30`

	Source   Edit   

macro dumpToString(x: untyped): string

Returns the content of a statement or expression x after semantic analysis, useful for debugging.

Example:

const a = 1
let x = 10
assert dumpToString(a + 2) == "a + 2: 3 = 3"
assert dumpToString(a + x) == "a + x: 1 + x = 11"
template square(x): untyped = x * x
assert dumpToString(square(x)) == "square(x): x * x = 100"
assert not compiles dumpToString(1 + nonexistent)
import std/strutils
assert "failedAssertImpl" in dumpToString(assert true) # example with a statement

	Source   Edit   

macro dup[T](arg: T; calls: varargs[untyped]): T

Turns an in-place algorithm into one that works on a copy and returns this copy, without modifying its input.

This macro also allows for (otherwise in-place) function chaining.

Since: Version 1.2.

Example:

import std/algorithm

let a = @[1, 2, 3, 4, 5, 6, 7, 8, 9]
assert a.dup(sort) == sorted(a)

# Chaining:
var aCopy = a
aCopy.insert(10)
assert a.dup(insert(10), sort) == sorted(aCopy)

let s1 = "abc"
let s2 = "xyz"
assert s1 & s2 == s1.dup(&= s2)

# An underscore (_) can be used to denote the place of the argument you're passing:
assert "".dup(addQuoted(_, "foo")) == "\"foo\""
# but `_` is optional here since the substitution is in 1st position:
assert "".dup(addQuoted("foo")) == "\"foo\""

proc makePalindrome(s: var string) =
  for i in countdown(s.len-2, 0):
	s.add(s[i])

let c = "xyz"

# chaining:
let d = dup c:
  makePalindrome # xyzyx
  sort(_, SortOrder.Descending) # zyyxx
  makePalindrome # zyyxxxyyz
assert d == "zyyxxxyyz"

	Source   Edit   


std/unittest


std/unittest
Source   Edit  

Author:	Zahary Karadjov

This module implements boilerplate to make unit testing easy.

The test status and name is printed after any output or traceback.

Tests can be nested, however failure of a nested test will not mark the parent test as failed. Setup and teardown are inherited. Setup can be overridden locally.

Compiled test files as well as nim c -r <testfile.nim> exit with 0 for success (no failed tests) or 1 for failure.
Testament

Instead of unittest, please consider using the Testament tool which offers process isolation for your tests.

Alternatively using when isMainModule: doAssert conditionHere is usually a much simpler solution for testing purposes.
Running a single test

Specify the test name as a command line argument.

nim c -r test "my test name" "another test"

Multiple arguments can be used.
Running a single test suite

Specify the suite name delimited by "::".

nim c -r test "my test name::"

Selecting tests by pattern

A single "*" can be used for globbing.

Delimit the end of a suite name with "::".

Tests matching any of the arguments are executed.

nim c -r test fast_suite::mytest1 fast_suite::mytest2
nim c -r test "fast_suite::mytest*"
nim c -r test "auth*::" "crypto::hashing*"
# Run suites starting with 'bug #' and standalone tests starting with '#'
nim c -r test 'bug #*::' '::#*'

Examples

suite "description for this stuff":
  echo "suite setup: run once before the tests"
 
  setup:
	echo "run before each test"
 
  teardown:
	echo "run after each test"
 
  test "essential truths":
	# give up and stop if this fails
	require(true)
 
  test "slightly less obvious stuff":
	# print a nasty message and move on, skipping
	# the remainder of this block
	check(1 != 1)
	check("asd"[2] == 'd')
 
  test "out of bounds error is thrown on bad access":
	let v = @[1, 2, 3]  # you can do initialization here
	expect(IndexDefect):
  	discard v[4]
 
  echo "suite teardown: run once after the tests"

Limitations/Bugs

Since check will rewrite some expressions for supporting checkpoints (namely assigns expressions to variables), some type conversions are not supported. For example check 4.0 == 2 + 2 won't work. But doAssert 4.0 == 2 + 2 works. Make sure both sides of the operator (such as ==, >= and so on) have the same type.

Imports

since, exitprocs, macros, strutils, streams, times, sets, sequtils, os, terminal

Types

ConsoleOutputFormatter = ref object of OutputFormatter
  ## Have test results printed in color.
  ## Default is `auto` depending on `isatty(stdout)`, or override it with
  ## `-d:nimUnittestColor:auto|on|off`.
  ##
  ## Deprecated: Setting the environment variable `NIMTEST_COLOR` to `always`
  ## or `never` changes the default for the non-js target to true or false respectively.
  ## Deprecated: the environment variable `NIMTEST_NO_COLOR`, when set, changes the
  ## default to true, if `NIMTEST_COLOR` is undefined.
  ## Set the verbosity of test results.
  ## Default is `PRINT_ALL`, or override with:
  ## `-d:nimUnittestOutputLevel:PRINT_ALL|PRINT_FAILURES|PRINT_NONE`.
  ##
  ## Deprecated: the `NIMTEST_OUTPUT_LVL` environment variable is set for the non-js target.

	Source   Edit   

JUnitOutputFormatter = ref object of OutputFormatter

	Source   Edit   

OutputFormatter = ref object of RootObj

	Source   Edit   

OutputLevel = enum
  PRINT_ALL,            	## Print as much as possible.
  PRINT_FAILURES,       	## Print only the failed tests.
  PRINT_NONE             	## Print nothing.

	The output verbosity of the tests. Source   Edit   

TestResult = object
  suiteName*: string ## Name of the test suite that contains this test case.
                 	## Can be ``nil`` if the test case is not in a suite.
  testName*: string      	## Name of the test case
  status*: TestStatus

	Source   Edit   

TestStatus = enum
  OK, FAILED, SKIPPED

	The status of a test when it is done. Source   Edit   

Vars

abortOnError {.threadvar.}: bool

	Set to true in order to quit immediately on fail. Default is false, or override with -d:nimUnittestAbortOnError:on|off.

	Deprecated: can also override depending on whether NIMTEST_ABORT_ON_ERROR environment variable is set.
	Source   Edit   

Procs

proc addOutputFormatter(formatter: OutputFormatter) {.....}

	Source   Edit   

proc checkpoint(msg: string) {.....}

Set a checkpoint identified by msg. Upon test failure all checkpoints encountered so far are printed out. Example:

checkpoint("Checkpoint A")
check((42, "the Answer to life and everything") == (1, "a"))
checkpoint("Checkpoint B")

	outputs "Checkpoint A" once it fails.
	Source   Edit   

proc close(formatter: JUnitOutputFormatter) {.....}

	Completes the report and closes the underlying stream. Source   Edit   

proc defaultConsoleFormatter(): ConsoleOutputFormatter {.....}

	Source   Edit   

proc delOutputFormatter(formatter: OutputFormatter) {.....}

	Source   Edit   

proc disableParamFiltering() {.....}

	disables filtering tests with the command line params Source   Edit   

proc newConsoleOutputFormatter(outputLevel: OutputLevel = outputLevelDefault;
                           	colorOutput = true): ConsoleOutputFormatter {.
	....}

	Source   Edit   

proc newJUnitOutputFormatter(stream: Stream): JUnitOutputFormatter {.
	....}

	Creates a formatter that writes report to the specified stream in JUnit format. The stream is NOT closed automatically when the test are finished, because the formatter has no way to know when all tests are finished. You should invoke formatter.close() to finalize the report. Source   Edit   

proc resetOutputFormatters() {.....}

	Source   Edit   

Methods

method failureOccurred(formatter: ConsoleOutputFormatter;
                   	checkpoints: seq[string]; stackTrace: string) {.
	....}

	Source   Edit   

method failureOccurred(formatter: JUnitOutputFormatter;
                   	checkpoints: seq[string]; stackTrace: string) {.
	....}

	stackTrace is provided only if the failure occurred due to an exception. checkpoints is never nil. Source   Edit   

method failureOccurred(formatter: OutputFormatter; checkpoints: seq[string];
                   	stackTrace: string) {.base, ....}

	stackTrace is provided only if the failure occurred due to an exception. checkpoints is never nil. Source   Edit   

method suiteEnded(formatter: ConsoleOutputFormatter) {.....}

	Source   Edit   

method suiteEnded(formatter: JUnitOutputFormatter) {.....}

	Source   Edit   

method suiteEnded(formatter: OutputFormatter) {.base, ....}

	Source   Edit   

method suiteStarted(formatter: ConsoleOutputFormatter; suiteName: string) {.
	....}

	Source   Edit   

method suiteStarted(formatter: JUnitOutputFormatter; suiteName: string) {.
	....}

	Source   Edit   

method suiteStarted(formatter: OutputFormatter; suiteName: string) {.base,
	....}

	Source   Edit   

method testEnded(formatter: ConsoleOutputFormatter; testResult: TestResult) {.
	....}

	Source   Edit   

method testEnded(formatter: JUnitOutputFormatter; testResult: TestResult) {.
	....}

	Source   Edit   

method testEnded(formatter: OutputFormatter; testResult: TestResult) {.base,
	....}

	Source   Edit   

method testStarted(formatter: ConsoleOutputFormatter; testName: string) {.
	....}

	Source   Edit   

method testStarted(formatter: JUnitOutputFormatter; testName: string) {.
	....}

	Source   Edit   

method testStarted(formatter: OutputFormatter; testName: string) {.base, ....}

	Source   Edit   

Macros

macro check(conditions: untyped): untyped

Verify if a statement or a list of statements is true. A helpful error message and set checkpoints are printed out on failure (if outputLevel is not PRINT_NONE).

Example:

import std/strutils

check("AKB48".toLowerAscii() == "akb48")

let teams = {'A', 'K', 'B', '4', '8'}

check:
  "AKB48".toLowerAscii() == "akb48"
  'C' notin teams

	Source   Edit   

macro expect(exceptions: varargs[typed]; body: untyped): untyped

Test if body raises an exception found in the passed exceptions. The test passes if the raised exception is part of the acceptable exceptions. Otherwise, it fails.

Example:

import std/[math, random, strutils]
proc defectiveRobot() =
  randomize()
  case rand(1..4)
  of 1: raise newException(OSError, "CANNOT COMPUTE!")
  of 2: discard parseInt("Hello World!")
  of 3: raise newException(IOError, "I can't do that Dave.")
  else: assert 2 + 2 == 5

expect IOError, OSError, ValueError, AssertionDefect:
  defectiveRobot()

	Source   Edit   

Templates

template fail()

Print out the checkpoints encountered so far and quit if abortOnError is true. Otherwise, erase the checkpoints and indicate the test has failed (change exit code and test status). This template is useful for debugging, but is otherwise mostly used internally. Example:

checkpoint("Checkpoint A")
complicatedProcInThread()
fail()

	outputs "Checkpoint A" before quitting.
	Source   Edit   

template require(conditions: untyped)

	Same as check except any failed test causes the program to quit immediately. Any teardown statements are not executed and the failed test output is not generated. Source   Edit   

template skip()

Mark the test as skipped. Should be used directly in case when it is not possible to perform test for reasons depending on outer environment, or certain application logic conditions or configurations. The test code is still executed.

if not isGLContextCreated():
  skip()

	Source   Edit   

template suite(name, body) {.dirty.}

Declare a test suite identified by name with optional setup and/or teardown section.

A test suite is a series of one or more related tests sharing a common fixture (setup, teardown). The fixture is executed for EACH test.

suite "test suite for addition":
  setup:
	let result = 4
 
  test "2 + 2 = 4":
	check(2+2 == result)
 
  test "(2 + -2) != 4":
	check(2 + -2 != result)
 
  # No teardown needed

The suite will run the individual test cases in the order in which they were listed. With default global settings the above code prints:

[Suite] test suite for addition
  [OK] 2 + 2 = 4
  [OK] (2 + -2) != 4

	Source   Edit   

template test(name, body) {.dirty.}

Define a single test case identified by name.

test "roses are red":
  let roses = "red"
  check(roses == "red")

The above code outputs:

[OK] roses are red

	Source   Edit   


std/varints


std/varints
Source   Edit  

A variable length integer encoding implementation inspired by SQLite.

Unstable API.

Consts

maxVarIntLen = 9

	the maximal number of bytes a varint can take Source   Edit   

Procs

proc decodeZigzag(x: uint64): int64 {.inline, ....}

	Source   Edit   

proc encodeZigzag(x: int64): uint64 {.inline, ....}

	Source   Edit   

proc readVu64(z: openArray[byte]; pResult: var uint64): int {.....}

	Source   Edit   

proc writeVu64(z: var openArray[byte]; x: uint64): int {.....}

	Write a varint into z. The buffer z must be at least 9 characters long to accommodate the largest possible varint. Returns the number of bytes used. Source   Edit   


std/with


std/with
Source   Edit  

This module implements the with macro for easy function chaining. See https://github.com/nim-lang/RFCs/issues/193 and https://github.com/nim-lang/RFCs/issues/192 for details leading to this particular design.

Since: version 1.2.

Imports

macros, underscored_calls

Macros

macro with(arg: typed; calls: varargs[untyped]): untyped

This macro provides chaining of function calls. It does so by patching every call in calls to use arg as the first argument.
Caution: This evaluates arg multiple times!

Example:

var x = "yay"
with x:
  add "abc"
  add "efg"
doAssert x == "yayabcefg"

var a = 44
with a:
  += 4
  -= 5
doAssert a == 43

# Nesting works for object types too!
var foo = (bar: 1, qux: (baz: 2))
with foo:
  bar = 2
  with qux:
	baz = 3
doAssert foo.bar == 2
doAssert foo.qux.baz == 3

	Source   Edit   


std/wrapnils


std/wrapnils
Source   Edit  

This module allows evaluating expressions safely against the following conditions:

	nil dereferences
	field accesses with incorrect discriminant in case objects

default(T) is returned in those cases when evaluating an expression of type T. This simplifies code by reducing need for if-else branches.

Note: experimental module, unstable API.

Example:

import std/wrapnils
type Foo = ref object
  x1: string
  x2: Foo
  x3: ref int

var f: Foo
assert ?.f.x2.x1 == "" # returns default value since `f` is nil

var f2 = Foo(x1: "a")
f2.x2 = f2
assert ?.f2.x1 == "a" # same as f2.x1 (no nil LHS in this chain)
assert ?.Foo(x1: "a").x1 == "a" # can use constructor inside

# when you know a sub-expression doesn't involve a `nil` (e.g. `f2.x2.x2`),
# you can scope it as follows:
assert ?.(f2.x2.x2).x3[] == 0

assert (?.f2.x2.x2).x3 == nil  # this terminates ?. early

Example:

import std/wrapnils
# ?. also allows case object
type B = object
  b0: int
  case cond: bool
  of false: discard
  of true:
	b1: float

var b = B(cond: false, b0: 3)
doAssertRaises(FieldDefect): discard b.b1 # wrong discriminant
doAssert ?.b.b1 == 0.0 # safe
b = B(cond: true, b1: 4.5)
doAssert ?.b.b1 == 4.5

# lvalue semantics are preserved:
if (let p = ?.b.b1.addr; p != nil): p[] = 4.7
doAssert b.b1 == 4.7

Imports

macros, options

Procs

func `[]`[T, I](a: Option[T]; i: I): auto {.inline.}

	See top-level example. Source   Edit   

func `[]`[U](a: Option[U]): auto {.inline.}

	See top-level example. Source   Edit   

Macros

macro `?.`(a: typed): auto

	Transforms a into an expression that can be safely evaluated even in presence of intermediate nil pointers/references, in which case a default value is produced. Source   Edit   

macro `??.`(a: typed): Option

Same as ?. but returns an Option.

Example:

import std/options
type Foo = ref object
  x1: ref int
  x2: int
# `?.` can't distinguish between a valid vs invalid default value, but `??.` can:
var f1 = Foo(x1: int.new, x2: 2)
doAssert (??.f1.x1[]).get == 0 # not enough to tell when the chain was valid.
doAssert (??.f1.x1[]).isSome # a nil didn't occur in the chain
doAssert (??.f1.x2).get == 2

var f2: Foo
doAssert not (??.f2.x1[]).isSome # f2 was nil

doAssertRaises(UnpackDefect): discard (??.f2.x1[]).get
doAssert ?.f2.x1[] == 0 # in contrast, this returns default(int)

	Source   Edit   

Templates

template fakeDot(a: Option; b): untyped

	See top-level example. Source   Edit   


Made with Nim. Generated: 2024-07-03 01:12:08 UTC



Modules for the JavaScript backend

std/asyncjs


std/asyncjs
Source   Edit  

This module implements types and macros for writing asynchronous code for the JS backend. It provides tools for interaction with JavaScript async API-s and libraries, writing async procedures in Nim and converting callback-based code to promises.

A Nim procedure is asynchronous when it includes the {.async.} pragma. It should always have a Future[T] return type or not have a return type at all. A Future[void] return type is assumed by default.

This is roughly equivalent to the async keyword in JavaScript code.

proc loadGame(name: string): Future[Game] {.async.} =
  # code

should be equivalent to

async function loadGame(name) {
  // code
}

A call to an asynchronous procedure usually needs await to wait for the completion of the Future.

var game = await loadGame(name)

Often, you might work with callback-based API-s. You can wrap them with asynchronous procedures using promises and newPromise:

proc loadGame(name: string): Future[Game] =
  var promise = newPromise() do (resolve: proc(response: Game)):
	cbBasedLoadGame(name) do (game: Game):
  	resolve(game)
  return promise

Forward definitions work properly, you just need to always add the {.async.} pragma:

proc loadGame(name: string): Future[Game] {.async.}

JavaScript compatibility

Nim currently generates async/await JavaScript code which is supported in modern EcmaScript and most modern versions of browsers, Node.js and Electron. If you need to use this module with older versions of JavaScript, you can use a tool that backports the resulting JavaScript code, as babel.

Imports

jsffi, macros, since

Types

Error {.importjs: "Error".} = ref object of JsRoot
  message*: cstring
  name*: cstring

	https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error Source   Edit   

Future[T] = ref object
  future*: T

	Source   Edit   

OnReject = proc (reason: Error)

	Source   Edit   

PromiseJs {.importjs: "Promise".} = ref object

	Source   Edit   

Procs

proc catch[T](future: Future[T]; onReject: OnReject): Future[void]

See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/catch

Example: cmd: -r:off

from std/sugar import `=>`
from std/strutils import contains

proc fn(n: int): Future[int] {.async.} =
  if n >= 7: raise newException(ValueError, "foobar: " & $n)
  else: result = n * 2

proc main() {.async.} =
  var reason: Error
  await fn(6).catch((r: Error) => (reason = r)) # note: `()` are needed, `=> reason = r` would not work
  assert reason == nil
  await fn(7).catch((r: Error) => (reason = r))
  assert reason != nil
  assert  "foobar: 7" in $reason.message

discard main()

	Source   Edit   

proc newPromise(handler: proc (resolve: proc ())): Future[void] {.
	importjs: "(new Promise(#))", ....}

	A helper for wrapping callback-based functions into promises and async procedures. Source   Edit   

proc newPromise[T](handler: proc (resolve: proc (response: T))): Future[T] {.
	importjs: "(new Promise(#))", ....}

	A helper for wrapping callback-based functions into promises and async procedures. Source   Edit   

proc then[T](future: Future[T]; onSuccess: proc; onReject: OnReject = nil): auto

See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/then Returns a Future from the return type of onSuccess(T.default).

Example: cmd: -r:off

from std/sugar import `=>`

proc fn(n: int): Future[int] {.async.} =
  if n >= 7: raise newException(ValueError, "foobar: " & $n)
  else: result = n * 2

proc asyncFact(n: int): Future[int] {.async.} =
  if n > 0: result = n * await asyncFact(n-1)
  else: result = 1

proc main() {.async.} =
  block: # then
	assert asyncFact(3).await == 3*2
	assert asyncFact(3).then(asyncFact).await == 6*5*4*3*2
	let x1 = await fn(3)
	assert x1 == 3 * 2
	let x2 = await fn(4)
  	.then((a: int) => a.float)
  	.then((a: float) => $a)
	assert x2 == "8.0"

  block: # then with `onReject` callback
	var witness = 1
	await fn(6).then((a: int) => (witness = 2), (r: Error) => (witness = 3))
	assert witness == 2
	await fn(7).then((a: int) => (witness = 2), (r: Error) => (witness = 3))
	assert witness == 3

	Source   Edit   

Macros

macro async(arg: untyped): untyped

	Macro which converts normal procedures into javascript-compatible async procedures. Source   Edit   

std/dom


std/dom
Source   Edit  

Declaration of the Document Object Model for the JavaScript backend.
Document Ready

	Basic example of a document ready:

Example: cmd: -b:js -r:off

import std/dom
proc example(e: Event) = echo "Document is ready"
document.addEventListener("DOMContentLoaded", example)  # You can also use "load" event.

	This example runs 5 seconds after the document ready:

Example: cmd: -b:js -r:off

import std/dom
proc example() = echo "5 seconds after document ready"
proc domReady(e: Event) = discard setTimeout(example, 5_000) # Document is ready.
document.addEventListener("DOMContentLoaded", domReady)

Document onUnload

	Simple example of how to implement code that runs when the page unloads:

Example: cmd: -b:js -r:off

import std/dom
proc example(e: Event) = echo "Document is unloaded"
document.addEventListener("unload", example)  # You can also use "beforeunload".

Document Autorefresh

	Minimal example of a document autorefresh:

Example: cmd: -b:js -r:off

import std/dom
proc example() = window.location.reload()
discard setTimeout(example, 5_000)

	For more examples, see https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener

Imports

since

Types

AddEventListenerOptions = object
  capture*: bool
  once*: bool
  passive*: bool

	Source   Edit   

AnchorElement {.importc.} = ref object of Element
  text*: cstring
  x*, y*: int

	Source   Edit   

Blob {.importc.} = ref object of RootObj
  size*: int

	see docs Source   Edit   

BoundingRect {.importc.} = object
  top*, bottom*, left*, right*, x*, y*, width*, height*: float

	Source   Edit   

ClassList {.importc.} = ref object of RootObj

	Source   Edit   

ClipboardEvent {.importc.} = object of Event
  clipboardData*: DataTransfer

	see docs Source   Edit   

DataTransfer {.importc.} = ref object of RootObj
  dropEffect*: cstring
  effectAllowed*: cstring
  files*: seq[Element]
  items*: seq[DataTransferItem]
  types*: seq[cstring]

	see docs Source   Edit   

DataTransferDropEffect {.pure.} = enum
  None = "none", Copy = "copy", Link = "link", Move = "move"

	Source   Edit   

DataTransferEffectAllowed {.pure.} = enum
  None = "none", Copy = "copy", CopyLink = "copyLink", CopyMove = "copyMove",
  Link = "link", LinkMove = "linkMove", Move = "move", All = "all",
  Uninitialized = "uninitialized"

	Source   Edit   

DataTransferItem {.importc.} = ref object of RootObj
  kind*: cstring

	see docs Source   Edit   

DataTransferItemKind {.pure.} = enum
  File = "file", String = "string"

	Source   Edit   

Document {.importc.} = ref object of Node
  activeElement*: Element
  documentElement*: Element
  alinkColor*: cstring
  bgColor*: cstring
  body*: Element
  charset*: cstring
  cookie*: cstring
  defaultCharset*: cstring
  fgColor*: cstring
  head*: Element
  hidden*: bool
  lastModified*: cstring
  linkColor*: cstring
  referrer*: cstring
  title*: cstring
  URL*: cstring
  visibilityState*: cstring
  vlinkColor*: cstring
  anchors*: seq[AnchorElement]
  forms*: seq[FormElement]
  images*: seq[ImageElement]
  applets*: seq[Element]
  embeds*: seq[EmbedElement]
  links*: seq[LinkElement]
  fonts*: FontFaceSet

	Source   Edit   

DocumentOrShadowRoot {.importc.} = object of RootObj
  activeElement*: Element

	Source   Edit   

DomEvent {.pure.} = enum
  Abort = "abort", BeforeInput = "beforeinput", Blur = "blur", Click = "click",
  CompositionEnd = "compositionend", CompositionStart = "compositionstart",
  CompositionUpdate = "compositionupdate", DblClick = "dblclick",
  Error = "error", Focus = "focus", FocusIn = "focusin", FocusOut = "focusout",
  Input = "input", KeyDown = "keydown", KeyPress = "keypress", KeyUp = "keyup",
  Load = "load", MouseDown = "mousedown", MouseEnter = "mouseenter",
  MouseLeave = "mouseleave", MouseMove = "mousemove", MouseOut = "mouseout",
  MouseOver = "mouseover", MouseUp = "mouseup", Resize = "resize",
  Scroll = "scroll", Select = "select", Storage = "storage", Unload = "unload",
  Wheel = "wheel"

	see docs Source   Edit   

DomException {.importc.} = ref object

	The DOMException interface represents an abnormal event (called an exception) which occurs as a result of calling a method or accessing a property of a web API. Each exception has a name, which is a short "CamelCase" style string identifying the error or abnormal condition. https://developer.mozilla.org/en-US/docs/Web/API/DOMException Source   Edit   

DomParser = ref object

DOM Parser object (defined on browser only, may not be on NodeJS).

	https://developer.mozilla.org/en-US/docs/Web/API/DOMParser

	let prsr = newDomParser()
	discard prsr.parseFromString("<html><marquee>Hello World</marquee></html>".cstring, "text/html".cstring)

	Source   Edit   

DragEvent {.importc.} = object of MouseEvent
  dataTransfer*: DataTransfer

	see docs Source   Edit   

DragEventTypes = enum
  Drag = "drag", DragEnd = "dragend", DragEnter = "dragenter",
  DragExit = "dragexit", DragLeave = "dragleave", DragOver = "dragover",
  DragStart = "dragstart", Drop = "drop"

	Source   Edit   

Element {.importc.} = ref object of Node
  className*: cstring
  classList*: ClassList
  checked*: bool
  defaultChecked*: bool
  defaultValue*: cstring
  disabled*: bool
  form*: FormElement
  name*: cstring
  readOnly*: bool
  options*: seq[OptionElement]
  selectedOptions*: seq[OptionElement]
  clientWidth*, clientHeight*: int
  contentEditable*: cstring
  isContentEditable*: bool
  dir*: cstring
  offsetHeight*: int
  offsetWidth*: int
  offsetLeft*: int
  offsetTop*: int

	Source   Edit   

EmbedElement {.importc.} = ref object of Element
  height*: int
  hspace*: int
  src*: cstring
  width*: int
  vspace*: int

	Source   Edit   

Event {.importc.} = ref object of RootObj
  bubbles*: bool
  cancelBubble*: bool
  cancelable*: bool
  composed*: bool
  currentTarget*: Node
  defaultPrevented*: bool
  eventPhase*: int
  target*: Node
  isTrusted*: bool

	see docs Source   Edit   

EventPhase = enum
  None = 0, CapturingPhase, AtTarget, BubblingPhase

	Source   Edit   

EventTarget {.importc.} = ref object of RootObj
  onabort*: proc (event: Event) {.closure.}
  onblur*: proc (event: Event) {.closure.}
  onchange*: proc (event: Event) {.closure.}
  onclick*: proc (event: Event) {.closure.}
  ondblclick*: proc (event: Event) {.closure.}
  onerror*: proc (event: Event) {.closure.}
  onfocus*: proc (event: Event) {.closure.}
  onkeydown*: proc (event: Event) {.closure.}
  onkeypress*: proc (event: Event) {.closure.}
  onkeyup*: proc (event: Event) {.closure.}
  onload*: proc (event: Event) {.closure.}
  onmousedown*: proc (event: Event) {.closure.}
  onmousemove*: proc (event: Event) {.closure.}
  onmouseout*: proc (event: Event) {.closure.}
  onmouseover*: proc (event: Event) {.closure.}
  onmouseup*: proc (event: Event) {.closure.}
  onreset*: proc (event: Event) {.closure.}
  onselect*: proc (event: Event) {.closure.}
  onstorage*: proc (event: Event) {.closure.}
  onsubmit*: proc (event: Event) {.closure.}
  onunload*: proc (event: Event) {.closure.}
  onloadstart*: proc (event: Event) {.closure.}
  onprogress*: proc (event: Event) {.closure.}
  onloadend*: proc (event: Event) {.closure.}

	Source   Edit   

File {.importc.} = ref object of Blob
  lastModified*: int
  name*: cstring

	see docs Source   Edit   

FileReader {.importc.} = ref object of EventTarget

	The FileReader object lets web applications asynchronously read the contents of files (or raw data buffers) stored on the user's computer, using File or Blob objects to specify the file or data to read. https://developer.mozilla.org/en-US/docs/Web/API/FileReader Source   Edit   

FileReaderState = distinct range[0'u16 .. 2'u16]

	Source   Edit   

FontFaceSet {.importc.} = ref object
  ready*: FontFaceSetReady
  onloadingdone*: proc (event: Event)

	see: docs Source   Edit   

FontFaceSetReady {.importc.} = ref object
  then*: proc (cb: proc ())

	see: docs Source   Edit   

FormElement {.importc.} = ref object of Element
  acceptCharset*: cstring
  action*: cstring
  autocomplete*: cstring
  elements*: seq[Element]
  encoding*: cstring
  enctype*: cstring
  length*: int
  noValidate*: bool
  target*: cstring

	see docs Source   Edit   

Frame {.importc.} = ref object of Window

	Source   Edit   

History {.importc.} = ref object of RootObj
  length*: int

	Source   Edit   

HTMLSlotElement {.importc.} = ref object of RootObj
  name*: cstring

	Source   Edit   

ImageElement {.importc.} = ref object of Element
  border*: int
  complete*: bool
  height*: int
  hspace*: int
  lowsrc*: cstring
  src*: cstring
  vspace*: int
  width*: int

	Source   Edit   

InputElement {.importc.} = ref object of Element
  formAction*: cstring
  formEncType*: cstring
  formMethod*: cstring
  formNoValidate*: bool
  formTarget*: cstring
  autofocus*: bool
  required*: bool
  value*: cstring
  validity*: ValidityState
  validationMessage*: cstring
  willValidate*: bool
  indeterminate*: bool
  alt*: cstring
  height*: cstring
  src*: cstring
  width*: cstring
  accept*: cstring
  files*: seq[Blob]
  autocomplete*: cstring
  maxLength*: int
  size*: int
  pattern*: cstring
  placeholder*: cstring
  min*: cstring
  max*: cstring
  selectionStart*: int
  selectionEnd*: int
  selectionDirection*: cstring
  dirName*: cstring
  accessKey*: cstring
  list*: Element
  multiple*: bool
  labels*: seq[Element]
  step*: cstring
  valueAsDate*: cstring
  valueAsNumber*: float

	see docs Source   Edit   

Interval {.importc.} = ref object of RootObj

	Source   Edit   

KeyboardEvent {.importc.} = ref object of UIEvent
  altKey*, ctrlKey*, metaKey*, shiftKey*: bool
  code*: cstring
  isComposing*: bool
  key*: cstring
  keyCode*: int
  location*: int

	see docs Source   Edit   

KeyboardEventKey {.pure.} = enum
  Alt, AltGraph, CapsLock, Control, Fn, FnLock, Hyper, Meta, NumLock,
  ScrollLock, Shift, Super, Symbol, SymbolLock, ArrowDown, ArrowLeft,
  ArrowRight, ArrowUp, End, Home, PageDown, PageUp, Backspace, Clear, Copy,
  CrSel, Cut, Delete, EraseEof, ExSel, Insert, Paste, Redo, Undo, Accept, Again,
  Attn, Cancel, ContextMenu, Escape, Execute, Find, Finish, Help, Pause, Play,
  Props, Select, ZoomIn, ZoomOut, BrigtnessDown, BrigtnessUp, Eject, LogOff,
  Power, PowerOff, PrintScreen, Hibernate, Standby, WakeUp, AllCandidates,
  Alphanumeric, CodeInput, Compose, Convert, Dead, FinalMode, GroupFirst,
  GroupLast, GroupNext, GroupPrevious, ModeChange, NextCandidate, NonConvert,
  PreviousCandidate, Process, SingleCandidate, HangulMode, HanjaMode, JunjaMode,
  Eisu, Hankaku, Hiragana, HiraganaKatakana, KanaMode, KanjiMode, Katakana,
  Romaji, Zenkaku, ZenkakuHanaku, F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, F11,
  F12, F13, F14, F15, F16, F17, F18, F19, F20, Soft1, Soft2, Soft3, Soft4,
  AppSwitch, Call, Camera, CameraFocus, EndCall, GoBack, GoHome, HeadsetHook,
  LastNumberRedial, Notification, MannerMode, VoiceDial, ChannelDown, ChannelUp,
  MediaFastForward, MediaPause, MediaPlay, MediaPlayPause, MediaRecord,
  MediaRewind, MediaStop, MediaTrackNext, MediaTrackPrevious, AudioBalanceLeft,
  AudioBalanceRight, AudioBassDown, AudioBassBoostDown, AudioBassBoostToggle,
  AudioBassBoostUp, AudioBassUp, AudioFaderFront, AudioFaderRear,
  AudioSurroundModeNext, AudioTrebleDown, AudioTrebleUp, AudioVolumeDown,
  AUdioVolumeMute, AudioVolumeUp, MicrophoneToggle, MicrophoneVolumeDown,
  MicrophoneVolumeMute, MicrophoneVolumeUp, TV, TV3DMode, TVAntennaCable,
  TVAudioDescription, TVAudioDescriptionMixDown, TVAudioDescriptionMixUp,
  TVContentsMenu, TVDataService, TVInput, TVInputComponent1, TVInputComponent2,
  TVInputComposite1, TVInputComposite2, TVInputHDMI1, TVInputHDMI2,
  TVInputHDMI3, TVInputHDMI4, TVInputVGA1, TVMediaContext, TVNetwork,
  TVNumberEntry, TVPower, TVRadioService, TVSatellite, TVSatelliteBS,
  TVSatelliteCS, TVSatelliteToggle, TVTerrestrialAnalog, TVTerrestrialDigital,
  TVTimer, AVRInput, AVRPower, ColorF0Red, ColorF1Green, ColorF2Yellow,
  ColorF3Blue, ColorF4Grey, ColorF5Brown, ClosedCaptionToggle, Dimmer,
  DisplaySwap, DVR, Exit, FavoriteClear0, FavoriteClear1, FavoriteClear2,
  FavoriteClear3, FavoriteRecall0, FavoriteRecall1, FavoriteRecall2,
  FavoriteRecall3, FavoriteStore0, FavoriteStore1, FavoriteStore2,
  FavoriteStore3, Guide, GuideNextDay, GuidePreviousDay, Info, InstantReplay,
  Link, ListProgram, LiveContent, Lock, MediaApps, MediaAudioTrack, MediaLast,
  MediaSkipBackward, MediaSkipForward, MediaStepBackward, MediaStepForward,
  MediaTopMenu, NavigateIn, NavigateNext, NavigateOut, NavigatePrevious,
  NextFavoriteChannel, NextUserProfile, OnDemand, Pairing, PinPDown, PinPMove,
  PinPUp, PlaySpeedDown, PlaySpeedReset, PlaySpeedUp, RandomToggle,
  RcLowBattery, RecordSpeedNext, RfBypass, ScanChannelsToggle, ScreenModeNext,
  Settings, SplitScreenToggle, STBInput, STBPower, Subtitle, Teletext,
  VideoModeNext, Wink, ZoomToggle, SpeechCorrectionList, SpeechInputToggle,
  Close, New, Open, Print, Save, SpellCheck, MailForward, MailReply, MailSend,
  LaunchCalculator, LaunchCalendar, LaunchContacts, LaunchMail,
  LaunchMediaPlayer, LaunchMusicPlayer, LaunchMyComputer, LaunchPhone,
  LaunchScreenSaver, LaunchSpreadsheet, LaunchWebBrowser, LaunchWebCam,
  LaunchWordProcessor, LaunchApplication1, LaunchApplication2,
  LaunchApplication3, LaunchApplication4, LaunchApplication5,
  LaunchApplication6, LaunchApplication7, LaunchApplication8,
  LaunchApplication9, LaunchApplication10, LaunchApplication11,
  LaunchApplication12, LaunchApplication13, LaunchApplication14,
  LaunchApplication15, LaunchApplication16, BrowserBack, BrowserFavorites,
  BrowserForward, BrowserHome, BrowserRefresh, BrowserSearch, BrowserStop,
  Key11, Key12, Separator

	see docs Source   Edit   

LinkElement {.importc.} = ref object of Element
  target*: cstring
  text*: cstring
  x*: int
  y*: int

	Source   Edit   

Location {.importc.} = ref object of RootObj
  hash*: cstring
  host*: cstring
  hostname*: cstring
  href*: cstring
  pathname*: cstring
  port*: cstring
  protocol*: cstring
  search*: cstring
  origin*: cstring

	Source   Edit   

LocationBar {.importc.} = object of RootObj
  visible*: bool

	Source   Edit   

MediaQueryList {.importc.} = ref object of EventTarget
  matches*: bool
  media*: cstring

	Source   Edit   

MenuBar = LocationBar

	Source   Edit   

MimeType {.importc.} = object of RootObj
  description*: cstring
  enabledPlugin*: ref Plugin
  suffixes*: seq[cstring]

	Source   Edit   

MouseButtons = enum
  NoButton = 0, PrimaryButton = 1, SecondaryButton = 2, AuxilaryButton = 4,
  FourthButton = 8, FifthButton = 16

	Source   Edit   

MouseEvent {.importc.} = ref object of UIEvent
  altKey*, ctrlKey*, metaKey*, shiftKey*: bool
  button*: int
  buttons*: int
  clientX*, clientY*: int
  movementX*, movementY*: int
  offsetX*, offsetY*: int
  pageX*, pageY*: int
  relatedTarget*: EventTarget
  screenX*, screenY*: int
  x*, y*: int

	see docs Source   Edit   

Navigator {.importc.} = ref object of RootObj
  appCodeName*: cstring
  appName*: cstring
  appVersion*: cstring
  buildID*: cstring      	## https://developer.mozilla.org/en-US/docs/Web/API/Navigator/buildID
  cookieEnabled*: bool
  deviceMemory*: float   	## https://developer.mozilla.org/en-US/docs/Web/API/Navigator/deviceMemory
  doNotTrack*: cstring   	## https://developer.mozilla.org/en-US/docs/Web/API/Navigator/doNotTrack
  language*: cstring
  languages*: seq[cstring]   ## https://developer.mozilla.org/en-US/docs/Web/API/NavigatorLanguage/languages
  maxTouchPoints*: cint  	## https://developer.mozilla.org/en-US/docs/Web/API/Navigator/maxTouchPoints
  onLine*: bool          	## https://developer.mozilla.org/en-US/docs/Web/API/NavigatorOnLine/onLine
  oscpu*: cstring        	## https://developer.mozilla.org/en-US/docs/Web/API/Navigator/oscpu
  platform*: cstring
  userAgent*: cstring
  vendor*: cstring       	## https://developer.mozilla.org/en-US/docs/Web/API/Navigator/vendor
  webdriver*: bool       	## https://developer.mozilla.org/en-US/docs/Web/API/Navigator/webdriver
  mimeTypes*: seq[ref MimeType]

	Source   Edit   

Node {.importc.} = ref object of EventTarget
  attributes*: seq[Node]
  childNodes*: seq[Node]
  children*: seq[Node]
  data*: cstring
  firstChild*: Node
  lastChild*: Node
  nextSibling*: Node
  nodeName*: cstring
  nodeType*: NodeType
  nodeValue*: cstring
  parentNode*: Node
  content*: Node
  previousSibling*: Node
  ownerDocument*: Document
  innerHTML*: cstring
  outerHTML*: cstring
  innerText*: cstring
  textContent*: cstring
  style*: Style
  baseURI*: cstring
  parentElement*: Element
  isConnected*: bool

	Source   Edit   

NodeType = enum
  ElementNode = 1, AttributeNode, TextNode, CDATANode, EntityRefNode,
  EntityNode, ProcessingInstructionNode, CommentNode, DocumentNode,
  DocumentTypeNode, DocumentFragmentNode, NotationNode

	Source   Edit   

OptionElement {.importc.} = ref object of Element
  defaultSelected*: bool
  selected*: bool
  selectedIndex*: int
  text*: cstring
  value*: cstring

	Source   Edit   

Performance {.importc.} = ref object
  memory*: PerformanceMemory
  timing*: PerformanceTiming

	Source   Edit   

PerformanceMemory {.importc.} = ref object
  jsHeapSizeLimit*: float
  totalJSHeapSize*: float
  usedJSHeapSize*: float

	Source   Edit   

PerformanceTiming {.importc.} = ref object
  connectStart*: float
  domComplete*: float
  domContentLoadedEventEnd*: float
  domContentLoadedEventStart*: float
  domInteractive*: float
  domLoading*: float
  domainLookupEnd*: float
  domainLookupStart*: float
  fetchStart*: float
  loadEventEnd*: float
  loadEventStart*: float
  navigationStart*: float
  redirectEnd*: float
  redirectStart*: float
  requestStart*: float
  responseEnd*: float
  responseStart*: float
  secureConnectionStart*: float
  unloadEventEnd*: float
  unloadEventStart*: float

	Source   Edit   

PersonalBar = LocationBar

	Source   Edit   

Plugin {.importc.} = object of RootObj
  description*: cstring
  filename*: cstring
  name*: cstring

	Source   Edit   

Range {.importc.} = ref object
  collapsed*: bool
  commonAncestorContainer*: Node
  endContainer*: Node
  endOffset*: int
  startContainer*: Node
  startOffset*: int

	see docs Source   Edit   

RootNodeOptions = object of RootObj
  composed*: bool

	Source   Edit   

Screen {.importc.} = ref object of RootObj
  availHeight*: int
  availWidth*: int
  colorDepth*: int
  height*: int
  pixelDepth*: int
  width*: int

	Source   Edit   

ScrollBars = LocationBar

	Source   Edit   

ScrollIntoViewOptions = object
  behavior*: cstring
  inline*: cstring

	Source   Edit   

Selection {.importc.} = ref object
  anchorNode*: Node
  anchorOffset*: int
  focusNode*: Node
  focusOffset*: int
  isCollapsed*: bool
  rangeCount*: int

	see docs Source   Edit   

ShadowRoot {.importc.} = ref object of DocumentOrShadowRoot
  delegatesFocus*: bool
  host*: Element
  innerHTML*: cstring
  mode*: cstring

	Source   Edit   

ShadowRootInit = object of RootObj
  mode*: cstring
  delegatesFocus*: bool

	Source   Edit   

SlotOptions = object of RootObj
  flatten*: bool

	Source   Edit   

StatusBar = LocationBar

	Source   Edit   

Storage {.importc.} = ref object

	Source   Edit   

StorageEvent {.importc.} = ref object of Event
  key*: cstring
  newValue*, oldValue*: cstring
  storageArea*: Storage
  url*: cstring

	see docs Source   Edit   

Style {.importc.} = ref object of RootObj
  alignContent*: cstring
  alignItems*: cstring
  alignSelf*: cstring
  all*: cstring
  animation*: cstring
  animationDelay*: cstring
  animationDirection*: cstring
  animationDuration*: cstring
  animationFillMode*: cstring
  animationIterationCount*: cstring
  animationName*: cstring
  animationPlayState*: cstring
  animationTimingFunction*: cstring
  backdropFilter*: cstring
  backfaceVisibility*: cstring
  background*: cstring
  backgroundAttachment*: cstring
  backgroundBlendMode*: cstring
  backgroundClip*: cstring
  backgroundColor*: cstring
  backgroundImage*: cstring
  backgroundOrigin*: cstring
  backgroundPosition*: cstring
  backgroundRepeat*: cstring
  backgroundSize*: cstring
  blockSize*: cstring
  border*: cstring
  borderBlock*: cstring
  borderBlockColor*: cstring
  borderBlockEnd*: cstring
  borderBlockEndColor*: cstring
  borderBlockEndStyle*: cstring
  borderBlockEndWidth*: cstring
  borderBlockStart*: cstring
  borderBlockStartColor*: cstring
  borderBlockStartStyle*: cstring
  borderBlockStartWidth*: cstring
  borderBlockStyle*: cstring
  borderBlockWidth*: cstring
  borderBottom*: cstring
  borderBottomColor*: cstring
  borderBottomLeftRadius*: cstring
  borderBottomRightRadius*: cstring
  borderBottomStyle*: cstring
  borderBottomWidth*: cstring
  borderCollapse*: cstring
  borderColor*: cstring
  borderEndEndRadius*: cstring
  borderEndStartRadius*: cstring
  borderImage*: cstring
  borderImageOutset*: cstring
  borderImageRepeat*: cstring
  borderImageSlice*: cstring
  borderImageSource*: cstring
  borderImageWidth*: cstring
  borderInline*: cstring
  borderInlineColor*: cstring
  borderInlineEnd*: cstring
  borderInlineEndColor*: cstring
  borderInlineEndStyle*: cstring
  borderInlineEndWidth*: cstring
  borderInlineStart*: cstring
  borderInlineStartColor*: cstring
  borderInlineStartStyle*: cstring
  borderInlineStartWidth*: cstring
  borderInlineStyle*: cstring
  borderInlineWidth*: cstring
  borderLeft*: cstring
  borderLeftColor*: cstring
  borderLeftStyle*: cstring
  borderLeftWidth*: cstring
  borderRadius*: cstring
  borderRight*: cstring
  borderRightColor*: cstring
  borderRightStyle*: cstring
  borderRightWidth*: cstring
  borderSpacing*: cstring
  borderStartEndRadius*: cstring
  borderStartStartRadius*: cstring
  borderStyle*: cstring
  borderTop*: cstring
  borderTopColor*: cstring
  borderTopLeftRadius*: cstring
  borderTopRightRadius*: cstring
  borderTopStyle*: cstring
  borderTopWidth*: cstring
  borderWidth*: cstring
  bottom*: cstring
  boxDecorationBreak*: cstring
  boxShadow*: cstring
  boxSizing*: cstring
  breakAfter*: cstring
  breakBefore*: cstring
  breakInside*: cstring
  captionSide*: cstring
  caretColor*: cstring
  clear*: cstring
  clip*: cstring
  clipPath*: cstring
  color*: cstring
  colorAdjust*: cstring
  columnCount*: cstring
  columnFill*: cstring
  columnGap*: cstring
  columnRule*: cstring
  columnRuleColor*: cstring
  columnRuleStyle*: cstring
  columnRuleWidth*: cstring
  columnSpan*: cstring
  columnWidth*: cstring
  columns*: cstring
  contain*: cstring
  content*: cstring
  counterIncrement*: cstring
  counterReset*: cstring
  counterSet*: cstring
  cursor*: cstring
  direction*: cstring
  display*: cstring
  emptyCells*: cstring
  filter*: cstring
  flex*: cstring
  flexBasis*: cstring
  flexDirection*: cstring
  flexFlow*: cstring
  flexGrow*: cstring
  flexShrink*: cstring
  flexWrap*: cstring
  cssFloat*: cstring
  font*: cstring
  fontFamily*: cstring
  fontFeatureSettings*: cstring
  fontKerning*: cstring
  fontLanguageOverride*: cstring
  fontOpticalSizing*: cstring
  fontSize*: cstring
  fontSizeAdjust*: cstring
  fontStretch*: cstring
  fontStyle*: cstring
  fontSynthesis*: cstring
  fontVariant*: cstring
  fontVariantAlternates*: cstring
  fontVariantCaps*: cstring
  fontVariantEastAsian*: cstring
  fontVariantLigatures*: cstring
  fontVariantNumeric*: cstring
  fontVariantPosition*: cstring
  fontVariationSettings*: cstring
  fontWeight*: cstring
  gap*: cstring
  grid*: cstring
  gridArea*: cstring
  gridAutoColumns*: cstring
  gridAutoFlow*: cstring
  gridAutoRows*: cstring
  gridColumn*: cstring
  gridColumnEnd*: cstring
  gridColumnStart*: cstring
  gridRow*: cstring
  gridRowEnd*: cstring
  gridRowStart*: cstring
  gridTemplate*: cstring
  gridTemplateAreas*: cstring
  gridTemplateColumns*: cstring
  gridTemplateRows*: cstring
  hangingPunctuation*: cstring
  height*: cstring
  hyphens*: cstring
  imageOrientation*: cstring
  imageRendering*: cstring
  inlineSize*: cstring
  inset*: cstring
  insetBlock*: cstring
  insetBlockEnd*: cstring
  insetBlockStart*: cstring
  insetInline*: cstring
  insetInlineEnd*: cstring
  insetInlineStart*: cstring
  isolation*: cstring
  justifyContent*: cstring
  justifyItems*: cstring
  justifySelf*: cstring
  left*: cstring
  letterSpacing*: cstring
  lineBreak*: cstring
  lineHeight*: cstring
  listStyle*: cstring
  listStyleImage*: cstring
  listStylePosition*: cstring
  listStyleType*: cstring
  margin*: cstring
  marginBlock*: cstring
  marginBlockEnd*: cstring
  marginBlockStart*: cstring
  marginBottom*: cstring
  marginInline*: cstring
  marginInlineEnd*: cstring
  marginInlineStart*: cstring
  marginLeft*: cstring
  marginRight*: cstring
  marginTop*: cstring
  mask*: cstring
  maskBorder*: cstring
  maskBorderMode*: cstring
  maskBorderOutset*: cstring
  maskBorderRepeat*: cstring
  maskBorderSlice*: cstring
  maskBorderSource*: cstring
  maskBorderWidth*: cstring
  maskClip*: cstring
  maskComposite*: cstring
  maskImage*: cstring
  maskMode*: cstring
  maskOrigin*: cstring
  maskPosition*: cstring
  maskRepeat*: cstring
  maskSize*: cstring
  maskType*: cstring
  maxBlockSize*: cstring
  maxHeight*: cstring
  maxInlineSize*: cstring
  maxWidth*: cstring
  minBlockSize*: cstring
  minHeight*: cstring
  minInlineSize*: cstring
  minWidth*: cstring
  mixBlendMode*: cstring
  objectFit*: cstring
  objectPosition*: cstring
  offset*: cstring
  offsetAnchor*: cstring
  offsetDistance*: cstring
  offsetPath*: cstring
  offsetRotate*: cstring
  opacity*: cstring
  order*: cstring
  orphans*: cstring
  outline*: cstring
  outlineColor*: cstring
  outlineOffset*: cstring
  outlineStyle*: cstring
  outlineWidth*: cstring
  overflow*: cstring
  overflowAnchor*: cstring
  overflowBlock*: cstring
  overflowInline*: cstring
  overflowWrap*: cstring
  overflowX*: cstring
  overflowY*: cstring
  overscrollBehavior*: cstring
  overscrollBehaviorBlock*: cstring
  overscrollBehaviorInline*: cstring
  overscrollBehaviorX*: cstring
  overscrollBehaviorY*: cstring
  padding*: cstring
  paddingBlock*: cstring
  paddingBlockEnd*: cstring
  paddingBlockStart*: cstring
  paddingBottom*: cstring
  paddingInline*: cstring
  paddingInlineEnd*: cstring
  paddingInlineStart*: cstring
  paddingLeft*: cstring
  paddingRight*: cstring
  paddingTop*: cstring
  pageBreakAfter*: cstring
  pageBreakBefore*: cstring
  pageBreakInside*: cstring
  paintOrder*: cstring
  perspective*: cstring
  perspectiveOrigin*: cstring
  placeContent*: cstring
  placeItems*: cstring
  placeSelf*: cstring
  pointerEvents*: cstring
  position*: cstring
  quotes*: cstring
  resize*: cstring
  right*: cstring
  rotate*: cstring
  rowGap*: cstring
  scale*: cstring
  scrollBehavior*: cstring
  scrollMargin*: cstring
  scrollMarginBlock*: cstring
  scrollMarginBlockEnd*: cstring
  scrollMarginBlockStart*: cstring
  scrollMarginBottom*: cstring
  scrollMarginInline*: cstring
  scrollMarginInlineEnd*: cstring
  scrollMarginInlineStart*: cstring
  scrollMarginLeft*: cstring
  scrollMarginRight*: cstring
  scrollMarginTop*: cstring
  scrollPadding*: cstring
  scrollPaddingBlock*: cstring
  scrollPaddingBlockEnd*: cstring
  scrollPaddingBlockStart*: cstring
  scrollPaddingBottom*: cstring
  scrollPaddingInline*: cstring
  scrollPaddingInlineEnd*: cstring
  scrollPaddingInlineStart*: cstring
  scrollPaddingLeft*: cstring
  scrollPaddingRight*: cstring
  scrollPaddingTop*: cstring
  scrollSnapAlign*: cstring
  scrollSnapStop*: cstring
  scrollSnapType*: cstring
  scrollbar3dLightColor*: cstring
  scrollbarArrowColor*: cstring
  scrollbarBaseColor*: cstring
  scrollbarColor*: cstring
  scrollbarDarkshadowColor*: cstring
  scrollbarFaceColor*: cstring
  scrollbarHighlightColor*: cstring
  scrollbarShadowColor*: cstring
  scrollbarTrackColor*: cstring
  scrollbarWidth*: cstring
  shapeImageThreshold*: cstring
  shapeMargin*: cstring
  shapeOutside*: cstring
  tabSize*: cstring
  tableLayout*: cstring
  textAlign*: cstring
  textAlignLast*: cstring
  textCombineUpright*: cstring
  textDecoration*: cstring
  textDecorationColor*: cstring
  textDecorationLine*: cstring
  textDecorationSkipInk*: cstring
  textDecorationStyle*: cstring
  textDecorationThickness*: cstring
  textEmphasis*: cstring
  textEmphasisColor*: cstring
  textEmphasisPosition*: cstring
  textEmphasisStyle*: cstring
  textIndent*: cstring
  textJustify*: cstring
  textOrientation*: cstring
  textOverflow*: cstring
  textRendering*: cstring
  textShadow*: cstring
  textTransform*: cstring
  textUnderlineOffset*: cstring
  textUnderlinePosition*: cstring
  top*: cstring
  touchAction*: cstring
  transform*: cstring
  transformBox*: cstring
  transformOrigin*: cstring
  transformStyle*: cstring
  transition*: cstring
  transitionDelay*: cstring
  transitionDuration*: cstring
  transitionProperty*: cstring
  transitionTimingFunction*: cstring
  translate*: cstring
  unicodeBidi*: cstring
  verticalAlign*: cstring
  visibility*: cstring
  whiteSpace*: cstring
  widows*: cstring
  width*: cstring
  willChange*: cstring
  wordBreak*: cstring
  wordSpacing*: cstring
  writingMode*: cstring
  zIndex*: cstring

	Source   Edit   

TextAreaElement {.importc.} = ref object of Element
  value*: cstring
  selectionStart*, selectionEnd*: int
  selectionDirection*: cstring
  rows*, cols*: int

	see docs Source   Edit   

TimeOut {.importc.} = ref object of RootObj

	Source   Edit   

ToolBar = LocationBar

	Source   Edit   

Touch {.importc.} = ref object of RootObj
  identifier*: int
  screenX*, screenY*, clientX*, clientY*, pageX*, pageY*: int
  target*: Element
  radiusX*, radiusY*: int
  rotationAngle*: int
  force*: float

	Source   Edit   

TouchEvent {.importc.} = ref object of UIEvent
  changedTouches*, targetTouches*, touches*: seq[Touch]

	Source   Edit   

TouchList {.importc.} = ref object of RootObj
  length*: int

	Source   Edit   

UIEvent {.importc.} = ref object of Event
  detail*: int64
  view*: Window

	see docs Source   Edit   

ValidityState {.importc.} = ref object
  badInput*: bool
  customError*: bool
  patternMismatch*: bool
  rangeOverflow*: bool
  rangeUnderflow*: bool
  stepMismatch*: bool
  tooLong*: bool
  tooShort*: bool
  typeMismatch*: bool
  valid*: bool
  valueMissing*: bool

	see docs Source   Edit   

VisualViewport {.importc.} = ref object of EventTarget
  offsetLeft*, offsetTop*, pageLeft*, pageTop*, width*, height*, scale*: float
  onResize*, onScroll*: proc (event: Event) {.closure.}

	Source   Edit   

Window {.importc.} = ref object of EventTarget
  document*: Document
  event*: Event
  history*: History
  location*: Location
  closed*: bool
  defaultStatus*: cstring
  devicePixelRatio*: float
  innerHeight*, innerWidth*: int
  locationbar*: ref LocationBar
  menubar*: ref MenuBar
  name*: cstring
  outerHeight*, outerWidth*: int
  pageXOffset*, pageYOffset*: int
  scrollX*: float
  scrollY*: float
  personalbar*: ref PersonalBar
  scrollbars*: ref ScrollBars
  statusbar*: ref StatusBar
  status*: cstring
  toolbar*: ref ToolBar
  frames*: seq[Frame]
  screen*: Screen
  performance*: Performance
  onpopstate*: proc (event: Event)
  localStorage*: Storage
  sessionStorage*: Storage
  parent*: Window

	Source   Edit   

Vars

document {.importc, nodecl.}: Document

	Source   Edit   

navigator {.importc, nodecl.}: Navigator

	Source   Edit   

screen {.importc, nodecl.}: Screen

	Source   Edit   

window {.importc, nodecl.}: Window

	Source   Edit   

Consts

DomApiVersion = 3

	the version of DOM API we try to follow. No guarantees though. Source   Edit   

fileReaderDone = 2'u

	Source   Edit   

fileReaderEmpty = 0'u

	Source   Edit   

fileReaderLoading = 1'u

	Source   Edit   

Procs

proc `$`(s: Selection): string {.importcpp, ....}

	Source   Edit   

proc `[]`(x: Node; idx: int): Element {.importcpp: "#.childNodes[#]",
                                    	....}

	Source   Edit   

proc abort(f: FileReader) {.importcpp: "#.abort()", ....}

	https://developer.mozilla.org/en-US/docs/Web/API/FileReader/abort Source   Edit   

proc add(c: ClassList; class: cstring) {.importcpp, ....}

	Source   Edit   

proc addEventListener(et: EventTarget; ev: cstring; cb: proc (ev: Event);
                  	options: AddEventListenerOptions) {.importcpp, ....}

	Source   Edit   

proc addEventListener(et: EventTarget; ev: cstring; cb: proc (ev: Event);
                  	useCapture: bool = false) {.importcpp, ....}

	Source   Edit   

proc after(self: Node; element: Node): Node {.importjs: "#.$1(@)", varargs,
	....}

	https://developer.mozilla.org/en-US/docs/Web/API/Element/after Source   Edit   

proc alert(w: Window; msg: cstring) {.importcpp, ....}

	Source   Edit   

proc append(self: Node; element: Node): Node {.importjs: "#.$1(@)", varargs,
	....}

	https://developer.mozilla.org/en-US/docs/Web/API/Element/append Source   Edit   

proc appendChild(n, child: Node) {.importcpp, ....}

	Source   Edit   

proc appendData(n: Node; data: cstring) {.importcpp, ....}

	Source   Edit   

proc assignedElements(n: HTMLSlotElement; options: SlotOptions): seq[Element] {.
	importcpp, ....}

	Source   Edit   

proc assignedNodes(n: HTMLSlotElement; options: SlotOptions): seq[Node] {.
	importcpp, ....}

	Source   Edit   

proc attachShadow(n: Element): ShadowRoot {.importcpp, ....}

	Source   Edit   

proc back(h: History) {.importcpp, ....}

	Source   Edit   

proc back(w: Window) {.importcpp, ....}

	Source   Edit   

proc before(self: Node; element: Node): Node {.importjs: "#.$1(@)", varargs,
	....}

	https://developer.mozilla.org/en-US/docs/Web/API/Element/before Source   Edit   

proc blur(e: Element) {.importcpp, ....}

	Source   Edit   

proc blur(w: Window) {.importcpp, ....}

	Source   Edit   

proc cancelAnimationFrame(w: Window; id: int) {.importcpp, ....}

	Source   Edit   

proc canShare(self: Navigator; data: cstring): bool {.importcpp, ....}

	https://developer.mozilla.org/en-US/docs/Web/API/Navigator/canShare Source   Edit   

proc checked(n: Node): bool {.importcpp: "#.checked", nodecl, ....}

	Source   Edit   

proc checked=(n: Node; v: bool) {.importcpp: "#.checked = #", nodecl,
                              	....}

	Source   Edit   

proc checkValidity(e: FormElement): bool {.importcpp, ....}

	Source   Edit   

proc checkValidity(e: InputElement): bool {.importcpp, ....}

	Source   Edit   

proc class(n: Node): cstring {.importcpp: "#.className", nodecl, ....}

	Source   Edit   

proc class=(n: Node; v: cstring) {.importcpp: "#.className = #", nodecl,
                               	....}

	Source   Edit   

proc clear(s: Storage) {.importcpp, ....}

	Source   Edit   

proc clearData(dt: DataTransfer; format: cstring) {.importcpp, ....}

	Source   Edit   

proc clearInterval(i: Interval) {.importc, nodecl, ....}

	Source   Edit   

proc clearInterval(w: Window; interval: Interval) {.importcpp, ....}

	Source   Edit   

proc clearTimeout(t: TimeOut) {.importc, nodecl, ....}

	Source   Edit   

proc clearTimeout(w: Window; timeout: TimeOut) {.importcpp, ....}

	Source   Edit   

proc click(e: Element) {.importcpp, ....}

	Source   Edit   

proc clientHeight(): int {.importcpp: "(window.innerHeight || document.documentElement.clientHeight)@",
                       	nodecl, ....}

	Source   Edit   

proc clientWidth(): int {.importcpp: "(window.innerWidth || document.documentElement.clientWidth)@",
                      	nodecl, ....}

	Source   Edit   

proc cloneNode(n: Node; copyContent: bool): Node {.importcpp, ....}

	Source   Edit   

proc close(w: Window) {.importcpp, ....}

	Source   Edit   

proc closest(self: Node; cssSelector: cstring): Node {.importjs: "#.$1(#)",
	....}

	https://developer.mozilla.org/en-US/docs/Web/API/Element/closest Source   Edit   

proc compareDocumentPosition(n: Node; otherNode: Node): int {.importcpp,
	....}

	Source   Edit   

proc confirm(w: Window; msg: cstring): bool {.importcpp, ....}

	Source   Edit   

proc contains(c: ClassList; class: cstring): bool {.importcpp, ....}

	Source   Edit   

proc contains(n: Node): bool {.importcpp, ....}

	Source   Edit   

proc createAttribute(d: Document; identifier: cstring): Node {.importcpp,
	....}

	Source   Edit   

proc createComment(d: Document; data: cstring): Node {.importcpp, ....}

	Source   Edit   

proc createElement(d: Document; identifier: cstring): Element {.importcpp,
	....}

	Source   Edit   

proc createElementNS(d: Document; namespaceURI, qualifiedIdentifier: cstring): Element {.
	importcpp, ....}

	Source   Edit   

proc createTextNode(d: Document; identifier: cstring): Node {.importcpp,
	....}

	Source   Edit   

proc decodeURI(uri: cstring): cstring {.importc, nodecl, ....}

	Source   Edit   

proc decodeURIComponent(uri: cstring): cstring {.importc, nodecl, ....}

	Source   Edit   

proc deleteData(n: Node; start, len: int) {.importcpp, ....}

	Source   Edit   

proc deleteFromDocument(s: Selection) {.importcpp, ....}

	Source   Edit   

proc disabled=(n: Node; v: bool) {.importcpp: "#.disabled = #", nodecl,
                               	....}

	Source   Edit   

proc disableExternalCapture(w: Window) {.importcpp, ....}

	Source   Edit   

proc dispatchEvent(et: EventTarget; ev: Event) {.importcpp, ....}

	Source   Edit   

proc elementFromPoint(n: DocumentOrShadowRoot; x, y: float): Element {.
	importcpp, ....}

	Source   Edit   

proc elementsFromPoint(n: DocumentOrShadowRoot; x, y: float): seq[Element] {.
	importcpp, ....}

	Source   Edit   

proc enableExternalCapture(w: Window) {.importcpp, ....}

	Source   Edit   

proc encodeURI(uri: cstring): cstring {.importc, nodecl, ....}

	Source   Edit   

proc encodeURIComponent(uri: cstring): cstring {.importc, nodecl, ....}

	Source   Edit   

proc error(f: FileReader): DomException {.importcpp: "#.error", nodecl,
	....}

	https://developer.mozilla.org/en-US/docs/Web/API/FileReader/error Source   Edit   

proc escape(uri: cstring): cstring {.importc, nodecl, ....}

	Source   Edit   

proc find(w: Window; text: cstring; caseSensitive = false; backwards = false): bool {.
	importcpp, ....}

	Source   Edit   

proc focus(e: Element) {.importcpp, ....}

	Source   Edit   

proc focus(e: Node) {.importcpp, ....}

	Source   Edit   

proc focus(w: Window) {.importcpp, ....}

	Source   Edit   

proc forward(h: History) {.importcpp, ....}

	Source   Edit   

proc forward(w: Window) {.importcpp, ....}

	Source   Edit   

proc getAsFile(dti: DataTransferItem): File {.importcpp, ....}

	Source   Edit   

proc getAttribute(n: Node; attr: cstring): cstring {.importcpp, ....}

	Source   Edit   

proc getAttributeNode(n: Node; attr: cstring): Node {.importcpp, ....}

	Source   Edit   

proc getBoundingClientRect(e: Node): BoundingRect {.
	importcpp: "getBoundingClientRect", nodecl, ....}

	Source   Edit   

proc getComputedStyle(w: Window; e: Node; pe: Node = nil): Style {.importcpp,
	....}

	Warning: The returned Style may or may not be read-only at run-time in the browser. getComputedStyle is performance costly.
	Source   Edit   

proc getData(dt: DataTransfer; format: cstring): cstring {.importcpp,
	....}

	Source   Edit   

proc getElementById(d: Document; id: cstring): Element {.importcpp, ....}

	Source   Edit   

proc getElementById(id: cstring): Element {.importc: "document.getElementById",
	nodecl, ....}

	Source   Edit   

proc getElementsByClass(n: Node; name: cstring): seq[Node] {.
	importcpp: "#.getElementsByClassName(#)", nodecl, ....}

	Source   Edit   

proc getElementsByClassName(d: Document; name: cstring): seq[Element] {.
	importcpp, ....}

	Source   Edit   

proc getElementsByClassName(e: Element; name: cstring): seq[Element] {.
	importcpp, ....}

	Source   Edit   

proc getElementsByName(d: Document; name: cstring): seq[Element] {.importcpp,
	....}

	Source   Edit   

proc getElementsByTagName(d: Document; name: cstring): seq[Element] {.importcpp,
	....}

	Source   Edit   

proc getElementsByTagName(e: Element; name: cstring): seq[Element] {.importcpp,
	....}

	Source   Edit   

proc getItem(s: Storage; key: cstring): cstring {.importcpp, ....}

	Source   Edit   

proc getModifierState(ev: KeyboardEvent; keyArg: cstring): bool {.importcpp,
	....}

	Source   Edit   

proc getModifierState(ev: MouseEvent; keyArg: cstring): bool {.importcpp,
	....}

	Source   Edit   

proc getPropertyPriority(s: Style; property: cstring): cstring {.importcpp,
	....}

	Source   Edit   

proc getPropertyValue(s: Style; property: cstring): cstring {.importcpp,
	....}

	Source   Edit   

proc getRangeAt(s: Selection; index: int): Range {.importcpp, ....}

	Source   Edit   

proc getRootNode(n: Node; options: RootNodeOptions): Node {.importcpp,
	....}

	Source   Edit   

proc getSelection(d: Document): Selection {.importcpp, ....}

	Source   Edit   

proc getSelection(n: DocumentOrShadowRoot): Selection {.importcpp, ....}

	Source   Edit   

proc go(h: History; pagesToJump: int) {.importcpp, ....}

	Source   Edit   

proc handleEvent(d: Document; event: Event) {.importcpp, ....}

	Source   Edit   

proc handleEvent(e: Element; event: Event) {.importcpp, ....}

	Source   Edit   

proc handleEvent(w: Window; e: Event) {.importcpp, ....}

	Source   Edit   

proc hasAttribute(n: Node; attr: cstring): bool {.importcpp, ....}

	Source   Edit   

proc hasAttributeNS(self: Node; namespace, localName: cstring): bool {.
	importjs: "(#.$1(#, #) || false)", ....}

	https://developer.mozilla.org/en-US/docs/Web/API/Element/hasAttributeNS Source   Edit   

proc hasChildNodes(n: Node): bool {.importcpp, ....}

	Source   Edit   

proc hasPointerCapture(self: Node; pointerId: SomeNumber): bool {.
	importjs: "(#.$1(#) || false)", ....}

	https://developer.mozilla.org/en-US/docs/Web/API/Element/hasPointerCapture Source   Edit   

proc home(w: Window) {.importcpp, ....}

	Source   Edit   

proc id(n: Node): cstring {.importcpp: "#.id", nodecl, ....}

	Source   Edit   

proc id=(n: Node; x: cstring) {.importcpp: "#.id = #", nodecl, ....}

	Source   Edit   

proc identifiedTouch(list: TouchList): Touch {.importcpp, ....}

	Source   Edit   

proc insertAdjacentElement(self: Node; position: cstring; element: Node) {.
	importjs: "#.$1(#, #)", ....}

	https://developer.mozilla.org/en-US/docs/Web/API/Element/insertAdjacentElement Source   Edit   

proc insertAdjacentHTML(self: Node; position, html: cstring) {.
	importjs: "#.$1(#, #)", ....}

	https://developer.mozilla.org/en-US/docs/Web/API/Element/insertAdjacentHTML Source   Edit   

proc insertAdjacentText(self: Node; position, data: cstring) {.
	importjs: "#.$1(#, #)", ....}

	https://developer.mozilla.org/en-US/docs/Web/API/Element/insertAdjacentText Source   Edit   

proc insertBefore(n, newNode, before: Node) {.importcpp, ....}

	Source   Edit   

proc insertData(n: Node; position: int; data: cstring) {.importcpp, ....}

	Source   Edit   

proc insertNode(range: Range; node: Node) {.importcpp, ....}

	Source   Edit   

proc inViewport(el: Node): bool {.....}

	Source   Edit   

proc isDefaultNamespace(n: Node): bool {.importcpp, ....}

	Source   Edit   

proc isEqualNode(n: Node): bool {.importcpp, ....}

	Source   Edit   

proc isFinite(x: BiggestFloat): bool {.importc, nodecl, ....}

	Source   Edit   

proc isNaN(x: BiggestFloat): bool {.importc, nodecl, ....}

	see also math.isNaN. Source   Edit   

proc isSameNode(n: Node): bool {.importcpp, ....}

	Source   Edit   

proc item(list: TouchList; i: int): Touch {.importcpp, ....}

	Source   Edit   

proc javaEnabled(h: Navigator): bool {.importcpp, ....}

	Source   Edit   

proc len(x: Node): int {.importcpp: "#.childNodes.length", ....}

	Source   Edit   

proc lookupNamespaceURI(n: Node): cstring {.importcpp, ....}

	Source   Edit   

proc lookupPrefix(n: Node): cstring {.importcpp, ....}

	Source   Edit   

proc matches(self: Node; cssSelector: cstring): bool {.
	importjs: "(#.$1(#) || false)", ....}

	https://developer.mozilla.org/en-US/docs/Web/API/Element/matches Source   Edit   

proc matchMedia(w: Window; mediaQueryString: cstring): MediaQueryList {.
	importcpp, ....}

	Source   Edit   

proc message(ex: DomException): cstring {.importcpp: "#.message", nodecl,
	....}

	https://developer.mozilla.org/en-US/docs/Web/API/DOMException/message Source   Edit   

proc moveBy(w: Window; x, y: int) {.importcpp, ....}

	Source   Edit   

proc moveTo(w: Window; x, y: int) {.importcpp, ....}

	Source   Edit   

proc name(ex: DomException): cstring {.importcpp: "#.name", nodecl, ....}

	https://developer.mozilla.org/en-US/docs/Web/API/DOMException/name Source   Edit   

proc newDomException(): DomException {.importcpp: "new DomException()",
                                   	constructor, ....}

	DOM Exception constructor Source   Edit   

func newDomParser(): DomParser {.importcpp: "new DOMParser()", ....}

	DOM Parser constructor. Source   Edit   

proc newEvent(name: cstring): Event {.importcpp: "new Event(@)", constructor,
                                  	....}

	Source   Edit   

proc newFileReader(): FileReader {.importcpp: "new FileReader()", constructor,
                               	....}

	File Reader constructor Source   Edit   

proc normalize(n: Node) {.importcpp, ....}

	Source   Edit   

proc now(p: Performance): float {.importcpp, ....}

	Source   Edit   

proc offsetHeight(e: Node): int {.importcpp: "#.offsetHeight", nodecl,
                              	....}

	Source   Edit   

proc offsetLeft(e: Node): int {.importcpp: "#.offsetLeft", nodecl, ....}

	Source   Edit   

proc offsetTop(e: Node): int {.importcpp: "#.offsetTop", nodecl, ....}

	Source   Edit   

proc offsetWidth(e: Node): int {.importcpp: "#.offsetWidth", nodecl, ....}

	Source   Edit   

proc open(d: Document) {.importcpp, ....}

	Source   Edit   

proc open(w: Window; uri, windowname: cstring; properties: cstring = nil): Window {.
	importcpp, ....}

	Source   Edit   

func parseFromString(this: DomParser; str: cstring; mimeType: cstring): Document {.
	importcpp, ....}

	Parse from string to Document. Source   Edit   

proc play(e: EmbedElement) {.importcpp, ....}

	Source   Edit   

proc preventDefault(ev: Event) {.importcpp, ....}

	Source   Edit   

proc print(w: Window) {.importcpp, ....}

	Source   Edit   

proc prompt(w: Window; text, default: cstring): cstring {.importcpp, ....}

	Source   Edit   

proc pushState[T](h: History; stateObject: T; title, url: cstring) {.importcpp,
	....}

	Source   Edit   

proc querySelector(d: Document; selectors: cstring): Element {.importcpp,
	....}

	Source   Edit   

proc querySelector(n: Node; selectors: cstring): Element {.importcpp,
	....}

	Source   Edit   

proc querySelectorAll(d: Document; selectors: cstring): seq[Element] {.
	importcpp, ....}

	Source   Edit   

proc querySelectorAll(n: Node; selectors: cstring): seq[Element] {.importcpp,
	....}

	Source   Edit   

proc readAsBinaryString(f: FileReader; b: Blob) {.
	importcpp: "#.readAsBinaryString(#)", ....}

	https://developer.mozilla.org/en-US/docs/Web/API/FileReader/readAsBinaryString Source   Edit   

proc readAsDataURL(f: FileReader; b: Blob) {.importcpp: "#.readAsDataURL(#)",
	....}

	https://developer.mozilla.org/en-US/docs/Web/API/FileReader/readAsDataURL Source   Edit   

proc readAsText(f: FileReader; b: Blob | File; encoding = cstring"UTF-8") {.
	importcpp: "#.readAsText(#, #)", ....}

	https://developer.mozilla.org/en-US/docs/Web/API/FileReader/readAsText Source   Edit   

proc readyState(f: FileReader): FileReaderState {.importcpp: "#.readyState",
	nodecl, ....}

	https://developer.mozilla.org/en-US/docs/Web/API/FileReader/readyState Source   Edit   

proc registerProtocolHandler(self: Navigator; scheme, url, title: cstring) {.
	importcpp, ....}

	https://developer.mozilla.org/en-US/docs/Web/API/Navigator/registerProtocolHandler Source   Edit   

proc releasePointerCapture(self: Node; pointerId: SomeNumber) {.
	importjs: "#.$1(#)", ....}

	https://developer.mozilla.org/en-US/docs/Web/API/Element/releasePointerCapture Source   Edit   

proc reload(loc: Location) {.importcpp, ....}

	Source   Edit   

proc remove(c: ClassList; class: cstring) {.importcpp, ....}

	Source   Edit   

proc remove(child: Node) {.importcpp, ....}

	Source   Edit   

proc removeAllRanges(s: Selection) {.importcpp, ....}

	Source   Edit   

proc removeAttribute(n: Node; attr: cstring) {.importcpp, ....}

	Source   Edit   

proc removeAttributeNode(n, attr: Node) {.importcpp, ....}

	Source   Edit   

proc removeAttributeNS(self: Node; namespace, attributeName: cstring) {.
	importjs: "#.$1(#, #)", ....}

	https://developer.mozilla.org/en-US/docs/Web/API/Element/removeAttributeNS Source   Edit   

proc removeChild(n, child: Node) {.importcpp, ....}

	Source   Edit   

proc removeEventListener(et: EventTarget; ev: cstring; cb: proc (ev: Event)) {.
	importcpp, ....}

	Source   Edit   

proc removeItem(s: Storage; key: cstring) {.importcpp, ....}

	Source   Edit   

proc removeProperty(s: Style; property: cstring) {.importcpp, ....}

	Source   Edit   

proc replace(loc: Location; s: cstring) {.importcpp, ....}

	Source   Edit   

proc replaceChild(n, newNode, oldNode: Node) {.importcpp, ....}

	Source   Edit   

proc replaceChildren(self: Node; replacements: Node) {.importjs: "#.$1(@)",
	varargs, ....}

	https://developer.mozilla.org/en-US/docs/Web/API/Element/replaceChildren Source   Edit   

proc replaceData(n: Node; start, len: int; text: cstring) {.importcpp,
	....}

	Source   Edit   

proc replaceWith(self: Node; replacements: Node) {.importjs: "#.$1(@)", varargs,
	....}

	https://developer.mozilla.org/en-US/docs/Web/API/Element/replaceWith Source   Edit   

proc reportValidity(e: FormElement): bool {.importcpp, ....}

	Source   Edit   

proc requestAnimationFrame(w: Window; function: proc (time: float)): int {.
	importcpp, ....}

	Source   Edit   

proc requestPointerLock(self: Node) {.importjs: "#.$1()", ....}

	https://developer.mozilla.org/en-US/docs/Web/API/Element/requestPointerLock Source   Edit   

proc reset(f: FormElement) {.importcpp, ....}

	Source   Edit   

proc resizeBy(w: Window; x, y: int) {.importcpp, ....}

	Source   Edit   

proc resizeTo(w: Window; x, y: int) {.importcpp, ....}

	Source   Edit   

proc resultAsString(f: FileReader): cstring {.importcpp: "#.result", nodecl,
	....}

	https://developer.mozilla.org/en-US/docs/Web/API/FileReader/result Source   Edit   

proc routeEvent(d: Document; event: Event) {.importcpp, ....}

	Source   Edit   

proc routeEvent(w: Window; event: Event) {.importcpp, ....}

	Source   Edit   

proc scrollBy(w: Window; x, y: int) {.importcpp, ....}

	Source   Edit   

proc scrollHeight(e: Node): int {.importcpp: "#.scrollHeight", nodecl,
                              	....}

	Source   Edit   

proc scrollIntoView(n: Node) {.importcpp, ....}

	Source   Edit   

proc scrollIntoView(n: Node; options: ScrollIntoViewOptions) {.importcpp,
	....}

	Source   Edit   

proc scrollIntoViewIfNeeded(self: Node; centerIfNeeded: bool) {.
	importjs: "#.$1(#)", ....}

	https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollIntoViewIfNeeded Source   Edit   

proc scrollLeft(e: Node): int {.importcpp: "#.scrollLeft", nodecl, ....}

	Source   Edit   

proc scrollTo(w: Window; x, y: int) {.importcpp, ....}

	Source   Edit   

proc scrollTop(e: Node): int {.importcpp: "#.scrollTop", nodecl, ....}

	Source   Edit   

proc scrollTop=(e: Node; value: int) {.importcpp: "#.scrollTop = #", nodecl,
                                   	....}

	Source   Edit   

proc scrollWidth(e: Node): int {.importcpp: "#.scrollWidth", nodecl, ....}

	Source   Edit   

proc select(e: Element) {.importcpp, ....}

	Source   Edit   

proc sendBeacon(self: Navigator; url, data: cstring): bool {.importcpp,
	....}

	https://developer.mozilla.org/en-US/docs/Web/API/Navigator/sendBeacon Source   Edit   

proc setAttr(n: Node; key, val: cstring) {.importcpp: "#.setAttribute(@)",
	....}

	Source   Edit   

proc setAttribute(n: Node; name, value: cstring) {.importcpp, ....}

	Source   Edit   

proc setAttributeNode(n: Node; attr: Node) {.importcpp, ....}

	Source   Edit   

proc setCustomValidity(e: InputElement; error: cstring) {.importcpp, ....}

	Source   Edit   

proc setData(dt: DataTransfer; format: cstring; data: cstring) {.importcpp,
	....}

	Source   Edit   

proc setDragImage(dt: DataTransfer; img: Element; xOffset: int; yOffset: int) {.
	importcpp, ....}

	Source   Edit   

proc setHTML(self: Node; html: cstring) {.importjs: "#.$1(#)", ....}

	https://developer.mozilla.org/en-US/docs/Web/API/Element/setHTML Source   Edit   

proc setInterval(action: proc (); ms: int): Interval {.importc, nodecl,
	....}

	Source   Edit   

proc setInterval(w: Window; code: cstring; pause: int): Interval {.importcpp,
	....}

	Source   Edit   

proc setInterval(w: Window; function: proc (); pause: int): Interval {.
	importcpp, ....}

	Source   Edit   

proc setItem(s: Storage; key, value: cstring) {.importcpp, ....}

	Source   Edit   

proc setProperty(s: Style; property, value: cstring; priority = "") {.importcpp,
	....}

	Source   Edit   

proc setRangeText(e: InputElement; replacement: cstring; startindex: int = 0;
              	endindex: int = 0; selectionMode: cstring = "preserve") {.
	importcpp, ....}

	Source   Edit   

proc setSelectionRange(e: InputElement; selectionStart: int; selectionEnd: int;
                   	selectionDirection: cstring = "none") {.importcpp,
	....}

	Source   Edit   

proc setTimeout(action: proc (); ms: int): TimeOut {.importc, nodecl,
	....}

	Source   Edit   

proc setTimeout(w: Window; code: cstring; pause: int): TimeOut {.importcpp,
	....}

	Source   Edit   

proc setTimeout(w: Window; function: proc (); pause: int): Interval {.importcpp,
	....}

	Source   Edit   

proc slice(e: Blob; startindex: int = 0; endindex: int = e.size;
       	contentType: cstring = "") {.importcpp, ....}

	Source   Edit   

proc stop(e: EmbedElement) {.importcpp, ....}

	Source   Edit   

proc stop(w: Window) {.importcpp, ....}

	Source   Edit   

proc stopImmediatePropagation(ev: Event) {.importcpp, ....}

	Source   Edit   

proc stopPropagation(ev: Event) {.importcpp, ....}

	Source   Edit   

proc submit(f: FormElement) {.importcpp, ....}

	Source   Edit   

proc toggle(c: ClassList; class: cstring) {.importcpp, ....}

	Source   Edit   

proc toggleAttribute(self: Node; name: cstring; force = false): bool {.
	importjs: "(#.$1(#, #) || false)", ....}

	https://developer.mozilla.org/en-US/docs/Web/API/Element/toggleAttribute Source   Edit   

proc unescape(uri: cstring): cstring {.importc, nodecl, ....}

	Source   Edit   

proc value(n: Node): cstring {.importcpp: "#.value", nodecl, ....}

	Source   Edit   

proc value=(n: Node; v: cstring) {.importcpp: "#.value = #", nodecl, ....}

	Source   Edit   

proc vibrate(self: Navigator; pattern: cint): bool {.importcpp, ....}

	https://developer.mozilla.org/en-US/docs/Web/API/Navigator/vibrate Source   Edit   

proc vibrate(self: Navigator; pattern: openArray[cint]): bool {.importcpp,
	....}

	https://developer.mozilla.org/en-US/docs/Web/API/Navigator/vibrate Source   Edit   

func visualViewport(self: Window): VisualViewport {.importjs: "#.$1", nodecl,
	....}

	Source   Edit   

proc write(d: Document; text: cstring) {.importcpp, ....}

	Source   Edit   

proc writeln(d: Document; text: cstring) {.importcpp, ....}

	Source   Edit   

Converters

converter toString(s: Selection): cstring {.importcpp, ....}

std/jsbigints


std/jsbigints
Source   Edit  

Arbitrary precision integers.

	https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt

Example:

import std/jsbigints
block:
  let big1: JsBigInt = big"2147483647"
  let big2: JsBigInt = big"666"
  doAssert JsBigInt isnot int
  doAssert big1 != big2
  doAssert big1 > big2
  doAssert big1 >= big2
  doAssert big2 < big1
  doAssert big2 <= big1
  doAssert not(big1 == big2)
  let z = JsBigInt.default
  doAssert $z == "0n"
block:
  var a: seq[JsBigInt]
  a.setLen 2
  doAssert a == @[big"0", big"0"]
  doAssert a[^1] == big"0"
  var b: JsBigInt
  doAssert b == big"0"
  doAssert b == JsBigInt.default

Types

JsBigInt = distinct JsBigIntImpl

	Arbitrary precision integer for JavaScript target. Source   Edit   

Procs

func `$`(this: JsBigInt): string {.....}

Returns a string representation of JsBigInt.

Example:

doAssert $big"1024" == "1024n"

	Source   Edit   

func `'big`(num: cstring): JsBigInt {.importjs: "BigInt(#)", ....}

Constructor for JsBigInt.

Example:

doAssert -1'big == 1'big - 2'big
# supports decimal, binary, octal, hex:
doAssert -12'big == big"-12"
doAssert 12'big == 12.big
doAssert 0b101'big == 0b101.big
doAssert 0o701'big == 0o701.big
doAssert 0xdeadbeaf'big == 0xdeadbeaf.big
doAssert 0xffffffffffffffff'big == (1'big shl 64'big) - 1'big
doAssert not compiles(static(12'big))

	Source   Edit   

func `*`(x, y: JsBigInt): JsBigInt {.importjs: "(# $1 #)", ....}

Example:

doAssert (big"42" * big"9") == big"378"

	Source   Edit   

func `**`(x, y: JsBigInt): JsBigInt {.importjs: "((#) $1 #)", ....}

Example:

doAssert big"2" ** big"64" == big"18446744073709551616"
doAssert big"-2" ** big"3" == big"-8"
doAssert -big"2" ** big"2" == big"4" # parsed as: (-2n) ** 2n
doAssert big"0" ** big"0" == big"1" # edge case
var ok = false
try: discard big"2" ** big"-1" # raises foreign `RangeError`
except: ok = true
doAssert ok

	Source   Edit   

func `*=`(x: var JsBigInt; y: JsBigInt) {.importjs: "([#][0][0] $1 #)",
	....}

Example:

var big1: JsBigInt = big"2"
big1 *= big"4"
doAssert big1 == big"8"

	Source   Edit   

proc `+`(_: JsBigInt): JsBigInt {.error: "See https://github.com/tc39/proposal-bigint/blob/master/ADVANCED.md#dont-break-asmjs".}

	Do NOT use. https://github.com/tc39/proposal-bigint/blob/master/ADVANCED.md#dont-break-asmjs Source   Edit   

func `+`(x, y: JsBigInt): JsBigInt {.importjs: "(# $1 #)", ....}

Example:

doAssert (big"9" + big"1") == big"10"

	Source   Edit   

func `+=`(x: var JsBigInt; y: JsBigInt) {.importjs: "([#][0][0] $1 #)",
	....}

Example:

var big1: JsBigInt = big"1"
big1 += big"2"
doAssert big1 == big"3"

	Source   Edit   

func `-`(this: JsBigInt): JsBigInt {.importjs: "($1#)", ....}

Example:

doAssert -(big"10101010101") == big"-10101010101"

	Source   Edit   

func `-`(x, y: JsBigInt): JsBigInt {.importjs: "(# $1 #)", ....}

Example:

doAssert (big"9" - big"1") == big"8"

	Source   Edit   

func `-=`(x: var JsBigInt; y: JsBigInt) {.importjs: "([#][0][0] $1 #)",
	....}

Example:

var big1: JsBigInt = big"1"
big1 -= big"2"
doAssert big1 == big"-1"

	Source   Edit   

func `/=`(x: var JsBigInt; y: JsBigInt) {.importjs: "([#][0][0] $1 #)",
	....}

Same as x = x div y.

Example:

var big1: JsBigInt = big"11"
big1 /= big"2"
doAssert big1 == big"5"

	Source   Edit   

func `<`(x, y: JsBigInt): bool {.importjs: "(# $1 #)", ....}

Example:

doAssert big"2" < big"9"

	Source   Edit   

func `<=`(x, y: JsBigInt): bool {.importjs: "(# $1 #)", ....}

Example:

doAssert big"1" <= big"5"

	Source   Edit   

func `==`(x, y: JsBigInt): bool {.importjs: "(# == #)", ....}

Example:

doAssert big"42" == big"42"

	Source   Edit   

func `and`(x, y: JsBigInt): JsBigInt {.importjs: "(# & #)", ....}

Example:

doAssert (big"555" and big"2") == big"2"

	Source   Edit   

func big(integer: cstring): JsBigInt {.importjs: "BigInt(#)", ....}

	Alias for 'big Source   Edit   

func big(integer: SomeInteger): JsBigInt {.importjs: "BigInt(#)", ....}

Constructor for JsBigInt.

Example:

doAssert big(1234567890) == big"1234567890"
doAssert 0b1111100111.big == 0o1747.big and 0o1747.big == 999.big

	Source   Edit   

func dec(this: var JsBigInt) {.importjs: "(--[#][0][0])", ....}

Example:

var big1: JsBigInt = big"2"
dec big1
doAssert big1 == big"1"

	Source   Edit   

func dec(this: var JsBigInt; amount: JsBigInt) {.importjs: "([#][0][0] -= #)",
	....}

Example:

var big1: JsBigInt = big"1"
dec big1, big"2"
doAssert big1 == big"-1"

	Source   Edit   

func `div`(x, y: JsBigInt): JsBigInt {.importjs: "(# / #)", ....}

Same as div but for JsBigInt(uses JavaScript BigInt() / BigInt()).

Example:

doAssert big"13" div big"3" == big"4"
doAssert big"-13" div big"3" == big"-4"
doAssert big"13" div big"-3" == big"-4"
doAssert big"-13" div big"-3" == big"4"

	Source   Edit   

proc high(_: typedesc[JsBigInt]): JsBigInt {.
	error: "Arbitrary precision integers do not have a known high.".}

	Do NOT use. Source   Edit   

func inc(this: var JsBigInt) {.importjs: "(++[#][0][0])", ....}

Example:

var big1: JsBigInt = big"1"
inc big1
doAssert big1 == big"2"

	Source   Edit   

func inc(this: var JsBigInt; amount: JsBigInt) {.importjs: "([#][0][0] += #)",
	....}

Example:

var big1: JsBigInt = big"1"
inc big1, big"2"
doAssert big1 == big"3"

	Source   Edit   

proc low(_: typedesc[JsBigInt]): JsBigInt {.
	error: "Arbitrary precision integers do not have a known low.".}

	Do NOT use. Source   Edit   

func `mod`(x, y: JsBigInt): JsBigInt {.importjs: "(# % #)", ....}

Same as mod but for JsBigInt (uses JavaScript BigInt() % BigInt()).

Example:

doAssert big"13" mod big"3" == big"1"
doAssert big"-13" mod big"3" == big"-1"
doAssert big"13" mod big"-3" == big"1"
doAssert big"-13" mod big"-3" == big"-1"

	Source   Edit   

func `or`(x, y: JsBigInt): JsBigInt {.importjs: "(# | #)", ....}

Example:

doAssert (big"555" or big"2") == big"555"

	Source   Edit   

func `shl`(a, b: JsBigInt): JsBigInt {.importjs: "(# << #)", ....}

Example:

doAssert (big"999" shl big"2") == big"3996"

	Source   Edit   

func `shr`(a, b: JsBigInt): JsBigInt {.importjs: "(# >> #)", ....}

Example:

doAssert (big"999" shr big"2") == big"249"

	Source   Edit   

func toCstring(this: JsBigInt): cstring {.importjs: "#.toString()", ....}

	Converts from JsBigInt to cstring representation. https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt/toString Source   Edit   

func toCstring(this: JsBigInt; radix: 2 .. 36): cstring {.
	importjs: "#.toString(#)", ....}

Converts from JsBigInt to cstring representation.

	radix Base to use for representing numeric values.

https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt/toString

Example:

doAssert big"2147483647".toCstring(2) == "1111111111111111111111111111111".cstring

	Source   Edit   

func toNumber(this: JsBigInt): int {.importjs: "Number(#)", ....}

Does not do any bounds check and may or may not return an inexact representation.

Example:

doAssert toNumber(big"2147483647") == 2147483647.int

	Source   Edit   

func wrapToInt(this: JsBigInt; bits: Natural): JsBigInt {.
	importjs: "(() => { const i = #, b = #; return BigInt.asIntN(b, i) })()",
	....}

Wraps this to a signed JsBigInt of bits bits in -2 ^ (bits - 1) .. 2 ^ (bits - 1) - 1. https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt/asIntN

Example:

doAssert (big("3") + big("2") ** big("66")).wrapToInt(13) == big("3")

	Source   Edit   

func wrapToUint(this: JsBigInt; bits: Natural): JsBigInt {.
	importjs: "(() => { const i = #, b = #; return BigInt.asUintN(b, i) })()",
	....}

Wraps this to an unsigned JsBigInt of bits bits in 0 .. 2 ^ bits - 1. https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt/asUintN

Example:

doAssert (big("3") + big("2") ** big("66")).wrapToUint(66) == big("3")

	Source   Edit   

func `xor`(x, y: JsBigInt): JsBigInt {.importjs: "(# ^ #)", ....}

Example:

doAssert (big"555" xor big"2") == big"553"

std/jsconsole


std/jsconsole
Source   Edit  

Wrapper for the console object for the JavaScript backend.
Styled Messages

CSS-styled messages in the browser are useful for debugging purposes. To use them, prefix the message with one or more %c, and provide the CSS style as the last argument. The amount of %c's must match the amount of CSS-styled strings.

Example: cmd: -r:off

import std/jsconsole
console.log "%c My Debug Message", "color: red" # Notice the "%c"
console.log "%c My Debug %c Message", "color: red", "font-size: 2em"

Imports

since, miscdollars

Types

Console = ref object of JsRoot

	Source   Edit   

Vars

console {.importc, nodecl.}: Console

	Source   Edit   

Procs

proc clear(console: Console) {.importcpp, varargs, ....}

	https://developer.mozilla.org/docs/Web/API/Console/clear Source   Edit   

proc count(console: Console; label = "".cstring) {.importcpp, ....}

	https://developer.mozilla.org/docs/Web/API/Console/count Source   Edit   

proc countReset(console: Console; label = "".cstring) {.importcpp, ....}

	https://developer.mozilla.org/docs/Web/API/Console/countReset Source   Edit   

proc debug(console: Console) {.importcpp, varargs, ....}

	https://developer.mozilla.org/docs/Web/API/Console/debug Source   Edit   

func dir(console: Console; obj: auto) {.importcpp, ....}

	https://developer.mozilla.org/en-US/docs/Web/API/Console/dir Source   Edit   

func dirxml(console: Console; obj: auto) {.importcpp, ....}

	https://developer.mozilla.org/en-US/docs/Web/API/Console/dirxml Source   Edit   

proc error(console: Console) {.importcpp, varargs, ....}

	https://developer.mozilla.org/docs/Web/API/Console/error Source   Edit   

proc group(console: Console; label = "".cstring) {.importcpp, ....}

	https://developer.mozilla.org/docs/Web/API/Console/group Source   Edit   

proc groupCollapsed(console: Console; label = "".cstring) {.importcpp,
	....}

	https://developer.mozilla.org/en-US/docs/Web/API/Console/groupCollapsed Source   Edit   

proc groupEnd(console: Console) {.importcpp, ....}

	https://developer.mozilla.org/docs/Web/API/Console/groupEnd Source   Edit   

proc info(console: Console) {.importcpp, varargs, ....}

	https://developer.mozilla.org/docs/Web/API/Console/info Source   Edit   

proc log(console: Console) {.importcpp, varargs, ....}

	https://developer.mozilla.org/docs/Web/API/Console/log Source   Edit   

proc table(console: Console) {.importcpp, varargs, ....}

	https://developer.mozilla.org/docs/Web/API/Console/table Source   Edit   

proc time(console: Console; label = "".cstring) {.importcpp, ....}

	https://developer.mozilla.org/docs/Web/API/Console/time Source   Edit   

proc timeEnd(console: Console; label = "".cstring) {.importcpp, ....}

	https://developer.mozilla.org/docs/Web/API/Console/timeEnd Source   Edit   

proc timeLog(console: Console; label = "".cstring) {.importcpp, ....}

	https://developer.mozilla.org/docs/Web/API/Console/timeLog Source   Edit   

func timeStamp(console: Console; label: cstring) {.importcpp, ....}

	https://developer.mozilla.org/en-US/docs/Web/API/Console/timeStamp

	..warning:: non-standard
	Source   Edit   

proc trace(console: Console) {.importcpp, varargs, ....}

	https://developer.mozilla.org/docs/Web/API/Console/trace Source   Edit   

proc warn(console: Console) {.importcpp, varargs, ....}

	https://developer.mozilla.org/docs/Web/API/Console/warn Source   Edit   

Templates

template exception(console: Console; args: varargs[untyped])

	Alias for console.error(). Source   Edit   

template jsAssert(console: Console; assertion)

JavaScript console.assert, for NodeJS this prints to stderr, assert failure just prints to console and do not quit the program, this is not meant to be better or even equal than normal assertions, is just for when you need faster performance and assertions, otherwise use the normal assertions for better user experience. https://developer.mozilla.org/en-US/docs/Web/API/Console/assert

Example:

console.jsAssert(42 == 42) # OK
console.jsAssert(42 != 42) # Fail, prints "Assertion failed" and continues
console.jsAssert('`' == '\n' and '\t' == '\0') # Message correctly formatted
assert 42 == 42  # Normal assertions keep working


std/jscore


std/jscore
Source   Edit  

This module wraps core JavaScript functions.

Unless your application has very specific requirements and solely targets JavaScript, you should be using the relevant functions in the math, json, and times stdlib modules instead.

Imports

since, jsutils

Types

DateLib = ref object

	Source   Edit   

DateTime = ref object

	Source   Edit   

JsonLib = ref object

	Source   Edit   

MathLib = ref object

	Source   Edit   

Vars

Date {.importc, nodecl.}: DateLib

	Source   Edit   

JSON {.importc, nodecl.}: JsonLib

	Source   Edit   

Math {.importc, nodecl.}: MathLib

	Source   Edit   

Procs

proc abs(m: MathLib; a: SomeNumber): SomeNumber {.importcpp, ....}

	Source   Edit   

proc acos(m: MathLib; a: SomeNumber): float {.importcpp, ....}

	Source   Edit   

proc acosh(m: MathLib; a: SomeNumber): float {.importcpp, ....}

	Source   Edit   

proc asin(m: MathLib; a: SomeNumber): float {.importcpp, ....}

	Source   Edit   

proc asinh(m: MathLib; a: SomeNumber): float {.importcpp, ....}

	Source   Edit   

proc atan(m: MathLib; a: SomeNumber): float {.importcpp, ....}

	Source   Edit   

proc atan2(m: MathLib; a: SomeNumber): float {.importcpp, ....}

	Source   Edit   

proc atanh(m: MathLib; a: SomeNumber): float {.importcpp, ....}

	Source   Edit   

proc cbrt(m: MathLib; f: SomeFloat): SomeFloat {.importcpp, ....}

	Source   Edit   

proc ceil(m: MathLib; f: SomeFloat): SomeFloat {.importcpp, ....}

	Source   Edit   

proc clz32(m: MathLib; f: SomeInteger): int {.importcpp, ....}

	Source   Edit   

func copyWithin[T](self: openArray[T]; target, start, ends: int): seq[T] {.
	importjs: "#.copyWithin(#, #, #)", ....}

https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin copyWithin uses shallow copy.

Example:

assert ['a', 'b', 'c', 'd', 'e'].copyWithin(0, 3, 4) == @['d', 'b', 'c', 'd', 'e']
assert ['a', 'b', 'c', 'd', 'e'].copyWithin(1, 3) == @['a', 'd', 'e', 'd', 'e']
assert [1, 2, 3, 4, 5].copyWithin(-2) == @[1, 2, 3, 1, 2]
assert [1, 2, 3, 4, 5].copyWithin(0, 3) == @[4, 5, 3, 4, 5]
assert [1, 2, 3, 4, 5].copyWithin(0, 3, 4) == @[4, 2, 3, 4, 5]
assert [1, 2, 3, 4, 5].copyWithin(-2, -3, -1) == @[1, 2, 3, 3, 4]

	Source   Edit   

func copyWithin[T](self: openArray[T]; target, start: int): seq[T] {.
	importjs: "#.copyWithin(#, #)", ....}

	Source   Edit   

func copyWithin[T](self: openArray[T]; target: int): seq[T] {.
	importjs: "#.copyWithin(#)", ....}

	Source   Edit   

proc cos(m: MathLib; a: SomeNumber): float {.importcpp, ....}

	Source   Edit   

proc cosh(m: MathLib; a: SomeNumber): float {.importcpp, ....}

	Source   Edit   

func debugger() {.importjs: "debugger@", ....}

	https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/debugger Source   Edit   

proc exp(m: MathLib; a: SomeNumber): float {.importcpp, ....}

	Source   Edit   

proc expm1(m: MathLib; a: SomeNumber): float {.importcpp, ....}

	Source   Edit   

proc floor(m: MathLib; f: SomeFloat): int {.importcpp, ....}

	Source   Edit   

proc fround(m: MathLib; f: SomeFloat): float32 {.importcpp, ....}

	Source   Edit   

proc getDay(d: DateTime): int {.importcpp, ....}

	Source   Edit   

proc getFullYear(d: DateTime): int {.importcpp, ....}

	Source   Edit   

proc getHours(d: DateTime): int {.importcpp, ....}

	Source   Edit   

proc getMilliseconds(d: DateTime): int {.importcpp, ....}

	Source   Edit   

proc getMinutes(d: DateTime): int {.importcpp, ....}

	Source   Edit   

proc getMonth(d: DateTime): int {.importcpp, ....}

	Source   Edit   

proc getSeconds(d: DateTime): int {.importcpp, ....}

	Source   Edit   

proc getTime(d: DateTime): int {.importcpp, ....}

	Source   Edit   

proc getTimezoneOffset(d: DateTime): int {.importcpp, ....}

	Source   Edit   

proc getUTCDate(d: DateTime): int {.importcpp, ....}

	Source   Edit   

proc getUTCDay(d: DateTime): int {.importcpp, ....}

	Source   Edit   

proc getUTCFullYear(d: DateTime): int {.importcpp, ....}

	Source   Edit   

proc getUTCHours(d: DateTime): int {.importcpp, ....}

	Source   Edit   

proc getUTCMilliseconds(d: DateTime): int {.importcpp, ....}

	Source   Edit   

proc getUTCMinutes(d: DateTime): int {.importcpp, ....}

	Source   Edit   

proc getUTCMonth(d: DateTime): int {.importcpp, ....}

	Source   Edit   

proc getUTCSeconds(d: DateTime): int {.importcpp, ....}

	Source   Edit   

proc getYear(d: DateTime): int {.importcpp, ....}

	Source   Edit   

proc hypot(m: MathLib; args: varargs[distinct SomeNumber]): float {.importcpp,
	....}

	Source   Edit   

proc imul(m: MathLib; a, b: int32): int32 {.importcpp, ....}

	Source   Edit   

proc log(m: MathLib; a: SomeNumber): float {.importcpp, ....}

	Source   Edit   

proc log1p(m: MathLib; a: SomeNumber): float {.importcpp, ....}

	Source   Edit   

proc log2(m: MathLib; a: SomeNumber): float {.importcpp, ....}

	Source   Edit   

proc log10(m: MathLib; a: SomeNumber): float {.importcpp, ....}

	Source   Edit   

proc max(m: MathLib; a, b: SomeNumber): SomeNumber {.importcpp, ....}

	Source   Edit   

proc min[T: SomeNumber | JsRoot](m: MathLib; a, b: T): T {.importcpp,
	....}

	Source   Edit   

proc newDate(): DateTime {.importcpp: "new Date()", ....}

	Source   Edit   

proc newDate(date: int | string): DateTime {.importcpp: "new Date(#)",
	....}

	Source   Edit   

proc newDate(date: int64): DateTime {.importcpp: "new Date(Number(#))",
                                  	....}

	Source   Edit   

proc newDate(year, month, day, hours, minutes, seconds, milliseconds: int): DateTime {.
	importcpp: "new Date(#,#,#,#,#,#,#)", ....}

	Source   Edit   

proc now(d: DateLib): int {.importcpp, ....}

	Source   Edit   

proc parse(d: DateLib; s: cstring): int {.importcpp, ....}

	Source   Edit   

proc parse(l: JsonLib; s: cstring): JsRoot {.importcpp, ....}

	Source   Edit   

proc pow(m: MathLib; a, b: distinct SomeNumber): float {.importcpp, ....}

	Source   Edit   

func queueMicrotask(function: proc) {.importjs: "$1(#)", ....}

	https://developer.mozilla.org/en-US/docs/Web/API/queueMicrotask
	https://developer.mozilla.org/en-US/docs/Web/API/HTML_DOM_API/Microtask_guide

Example: cmd: -r:off

queueMicrotask(proc() = echo "Microtask")

	Source   Edit   

proc random(m: MathLib): float {.importcpp, ....}

	Source   Edit   

proc round(m: MathLib; f: SomeFloat): int {.importcpp, ....}

	Source   Edit   

proc setFullYear(d: DateTime; year: int) {.importcpp, ....}

	Source   Edit   

func shift[T](self: seq[T]): T {.importjs: "#.$1()", ....}

https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/shift

Example:

var arrai = @[1, 2, 3]
assert arrai.shift() == 1
assert arrai == @[2, 3]

	Source   Edit   

proc sign(m: MathLib; f: SomeNumber): int {.importcpp, ....}

	Source   Edit   

proc sin(m: MathLib; a: SomeNumber): float {.importcpp, ....}

	Source   Edit   

proc sinh(m: MathLib; a: SomeNumber): float {.importcpp, ....}

	Source   Edit   

proc sqrt(m: MathLib; f: SomeFloat): SomeFloat {.importcpp, ....}

	Source   Edit   

proc stringify(l: JsonLib; s: JsRoot): cstring {.importcpp, ....}

	Source   Edit   

proc tan(m: MathLib; a: SomeNumber): float {.importcpp, ....}

	Source   Edit   

proc tanh(m: MathLib; a: SomeNumber): float {.importcpp, ....}

	Source   Edit   

func toDateString(d: DateTime): cstring {.importcpp, ....}

	Source   Edit   

func toISOString(d: DateTime): cstring {.importcpp, ....}

	Source   Edit   

func toJSON(d: DateTime): cstring {.importcpp, ....}

	Source   Edit   

proc toString(d: DateTime): cstring {.importcpp, ....}

	Source   Edit   

func toTimeString(d: DateTime): cstring {.importcpp, ....}

	Source   Edit   

func toUTCString(d: DateTime): cstring {.importcpp, ....}

	Source   Edit   

proc trunc(m: MathLib; f: SomeFloat): int {.importcpp, ....}

	Source   Edit   

proc UTC(d: DateLib): int {.importcpp, ....}


std/jsfetch


std/jsfetch
Source   Edit  

	Fetch for the JavaScript target: https://developer.mozilla.org/docs/Web/API/Fetch_API

Example: cmd: -r:off

import std/jsfetch
import std/[asyncjs, jsconsole, jsformdata, jsheaders]
from std/httpcore import HttpMethod
from std/jsffi import JsObject
from std/sugar import `=>`

block:
  let options0: FetchOptions = unsafeNewFetchOptions(
	metod = "POST".cstring,
	body = """{"key": "value"}""".cstring,
	mode = "no-cors".cstring,
	credentials = "omit".cstring,
	cache = "no-cache".cstring,
	referrerPolicy = "no-referrer".cstring,
	keepalive = false,
	redirect = "follow".cstring,
	referrer = "client".cstring,
	integrity = "".cstring,
	headers = newHeaders()
  )
  assert options0.keepalive == false
  assert options0.metod == "POST".cstring
  assert options0.body == """{"key": "value"}""".cstring
  assert options0.mode == "no-cors".cstring
  assert options0.credentials == "omit".cstring
  assert options0.cache == "no-cache".cstring
  assert options0.referrerPolicy == "no-referrer".cstring
  assert options0.redirect == "follow".cstring
  assert options0.referrer == "client".cstring
  assert options0.integrity == "".cstring
  assert options0.headers.len == 0

block:
  let options1: FetchOptions = newFetchOptions(
	metod =  HttpPost,
	body = """{"key": "value"}""".cstring,
	mode = fmNoCors,
	credentials = fcOmit,
	cache = fchNoCache,
	referrerPolicy = frpNoReferrer,
	keepalive = false,
	redirect = frFollow,
	referrer = "client".cstring,
	integrity = "".cstring,
	headers = newHeaders()
  )
  assert options1.keepalive == false
  assert options1.metod == $HttpPost
  assert options1.body == """{"key": "value"}""".cstring
  assert options1.mode == $fmNoCors
  assert options1.credentials == $fcOmit
  assert options1.cache == $fchNoCache
  assert options1.referrerPolicy == $frpNoReferrer
  assert options1.redirect == $frFollow
  assert options1.referrer == "client".cstring
  assert options1.integrity == "".cstring
  assert options1.headers.len == 0

block:
  let response: Response = newResponse(body = "-. .. --".cstring)
  let request: Request = newRequest(url = "http://nim-lang.org".cstring)

if not defined(nodejs):
  block:
	proc doFetch(): Future[Response] {.async.} =
  	fetch "https://httpbin.org/get".cstring

	proc example() {.async.} =
  	let response: Response = await doFetch()
  	assert response.ok
  	assert response.status == 200.cint
  	assert response.headers is Headers
  	assert response.body is cstring

	discard example()

  block:
	proc example2 {.async.} =
  	await fetch("https://api.github.com/users/torvalds".cstring)
    	.then((response: Response) => response.json())
    	.then((json: JsObject) => console.log(json))
    	.catch((err: Error) => console.log("Request Failed", err))

	discard example2()

Imports

asyncjs, jsformdata, jsheaders, httpcore, jsffi

Types

FetchCaches = enum
  fchDefault = "default", fchNoStore = "no-store", fchReload = "reload",
  fchNoCache = "no-cache", fchForceCache = "force-cache"

	https://developer.mozilla.org/docs/Web/API/Request/cache Source   Edit   

FetchCredentials = enum
  fcInclude = "include", fcSameOrigin = "same-origin", fcOmit = "omit"

	Credential options. See https://developer.mozilla.org/en-US/docs/Web/API/Request/credentials Source   Edit   

FetchModes = enum
  fmCors = "cors", fmNoCors = "no-cors", fmSameOrigin = "same-origin"

	Mode options. Source   Edit   

FetchOptions = ref object of JsRoot
  keepalive*: bool
  metod* {.importjs: "method".}: cstring
  body*, integrity*, referrer*, mode*, credentials*, cache*, redirect*,
  referrerPolicy*: cstring
  headers*: Headers

	Options for Fetch API. Source   Edit   

FetchRedirects = enum
  frFollow = "follow", frError = "error", frManual = "manual"

	Redirects options. Source   Edit   

FetchReferrerPolicies = enum
  frpNoReferrer = "no-referrer",
  frpNoReferrerWhenDowngrade = "no-referrer-when-downgrade",
  frpOrigin = "origin", frpOriginWhenCrossOrigin = "origin-when-cross-origin",
  frpUnsafeUrl = "unsafe-url"

	Referrer Policy options. Source   Edit   

Request = ref object of JsRoot
  bodyUsed*, ok*, redirected*: bool
  typ* {.importjs: "type".}: cstring
  url*, statusText*: cstring
  status*: cint
  headers*: Headers
  body*: cstring

	https://developer.mozilla.org/en-US/docs/Web/API/Request Source   Edit   

Response = ref object of JsRoot
  bodyUsed*, ok*, redirected*: bool
  typ* {.importjs: "type".}: cstring
  url*, statusText*: cstring
  status*: cint
  headers*: Headers
  body*: cstring

	https://developer.mozilla.org/en-US/docs/Web/API/Response Source   Edit   

Procs

func `$`(self: Request | Response | FetchOptions): string

	Source   Edit   

func clone(self: Response | Request): Response {.importjs: "#.$1()", ....}

	https://developer.mozilla.org/en-US/docs/Web/API/Response/clone Source   Edit   

proc fetch(url: cstring | Request): Future[Response] {.importjs: "$1(#)",
	....}

	fetch() API, simple GET only, returns a Future[Response]. Source   Edit   

proc fetch(url: cstring | Request; options: FetchOptions): Future[Response] {.
	importjs: "$1(#, #)", ....}

	fetch() API that takes a FetchOptions, returns a Future[Response]. Source   Edit   

proc formData(self: Response): Future[FormData] {.importjs: "#.$1()",
	....}

	https://developer.mozilla.org/en-US/docs/Web/API/Response/formData Source   Edit   

proc json(self: Response): Future[JsObject] {.importjs: "#.$1()", ....}

	https://developer.mozilla.org/en-US/docs/Web/API/Response/json Source   Edit   

func newfetchOptions(metod = HttpGet; body: cstring = nil; mode = fmCors;
                 	credentials = fcSameOrigin; cache = fchDefault;
                 	referrerPolicy = frpNoReferrerWhenDowngrade;
                 	keepalive = false; redirect = frFollow;
                 	referrer = "client".cstring; integrity = "".cstring;
                 	headers: Headers = newHeaders()): FetchOptions {.
	....}

	Constructor for FetchOptions. Source   Edit   

func newRequest(url: cstring): Request {.importjs: "(new Request(#))",
	....}

	Constructor for Request. This does not call fetch(). Same as new Request(). Source   Edit   

func newRequest(url: cstring; fetchOptions: FetchOptions): Request {.
	importjs: "(new Request(#, #))", ....}

	Constructor for Request with fetchOptions. Same as fetch(url, fetchOptions). Source   Edit   

func newResponse(body: cstring | FormData): Response {.
	importjs: "(new Response(#))", ....}

	Constructor for Response. This does not call fetch(). Same as new Response(). Source   Edit   

proc text(self: Response): Future[cstring] {.importjs: "#.$1()", ....}

	https://developer.mozilla.org/en-US/docs/Web/API/Response/text Source   Edit   

func toCstring(self: Request | Response | FetchOptions): cstring {.
	importjs: "JSON.stringify(#)", ....}

	Source   Edit   

proc unsafeNewFetchOptions(metod, body, mode, credentials, cache, referrerPolicy: cstring;
                       	keepalive: bool; redirect = "follow".cstring;
                       	referrer = "client".cstring; integrity = "".cstring;
                       	headers: Headers = newHeaders()): FetchOptions {.importjs: "{method: #, body: #, mode: #, credentials: #, cache: #, referrerPolicy: #, keepalive: #, redirect: #, referrer: #, integrity: #, headers: #}",
	....}

	Warning: Unsafe newfetchOptions.


std/jsffi


std/jsffi
Source   Edit  

This Module implements types and macros to facilitate the wrapping of, and interaction with JavaScript libraries. Using the provided types JsObject and JsAssoc together with the provided macros allows for smoother interfacing with JavaScript, allowing for example quick and easy imports of JavaScript variables:

Example:

import std/jsffi
# Here, we are using jQuery for just a few calls and do not want to wrap the
# whole library:

# import the document object and the console
var document {.importc, nodecl.}: JsObject
var console {.importc, nodecl.}: JsObject
# import the "$" function
proc jq(selector: JsObject): JsObject {.importjs: "$$(#)".}

# Use jQuery to make the following code run, after the document is ready.
# This uses an experimental `.()` operator for `JsObject`, to emit
# JavaScript calls, when no corresponding proc exists for `JsObject`.
proc main =
  jq(document).ready(proc() =
	console.log("Hello JavaScript!")
  )

Imports

macros, tables

Types

js = JsObject

	Source   Edit   

JsAssoc[K; V] = ref object of JsRoot

	Statically typed wrapper around a JavaScript object. Source   Edit   

JsError {.importc: "Error".} = object of JsRoot
  message*: cstring

	Source   Edit   

JsEvalError {.importc: "EvalError".} = object of JsError

	Source   Edit   

JsKey = concept atypeof(T)
	cstring.toJsKey(T) is T

	Source   Edit   

JsObject = ref object of JsRoot

	Dynamically typed wrapper around a JavaScript object. Source   Edit   

JsRangeError {.importc: "RangeError".} = object of JsError

	Source   Edit   

JsReferenceError {.importc: "ReferenceError".} = object of JsError

	Source   Edit   

JsSyntaxError {.importc: "SyntaxError".} = object of JsError

	Source   Edit   

JsTypeError {.importc: "TypeError".} = object of JsError

	Source   Edit   

JsURIError {.importc: "URIError".} = object of JsError

	Source   Edit   

Vars

jsArguments {.importc: "arguments", nodecl.}: JsObject

	JavaScript's arguments pseudo-variable. Source   Edit   

jsDirname {.importc: "__dirname", nodecl.}: cstring

	JavaScript's __dirname pseudo-variable. Source   Edit   

jsFilename {.importc: "__filename", nodecl.}: cstring

	JavaScript's __filename pseudo-variable. Source   Edit   

jsNull {.importc: "null", nodecl.}: JsObject

	JavaScript's null literal. Source   Edit   

jsUndefined {.importc: "undefined", nodecl.}: JsObject

	JavaScript's undefined literal. Source   Edit   

Procs

proc `%`(x, y: JsObject): JsObject {.importjs: "(# % #)", ....}

	Source   Edit   

proc `%=`(x, y: JsObject): JsObject {.importjs: "(# %= #)", discardable,
                                  	....}

	Source   Edit   

proc `&`(a, b: cstring): cstring {.importjs: "(# + #)", ....}

	Concatenation operator for JavaScript strings. Source   Edit   

proc `*`(x, y: JsObject): JsObject {.importjs: "(# * #)", ....}

	Source   Edit   

proc `**`(x, y: JsObject): JsObject {.importjs: "((#) ** #)", ....}

	Source   Edit   

proc `*=`(x, y: JsObject): JsObject {.importjs: "(# *= #)", discardable,
                                  	....}

	Source   Edit   

proc `+`(x, y: JsObject): JsObject {.importjs: "(# + #)", ....}

	Source   Edit   

proc `++`(x: JsObject): JsObject {.importjs: "(++#)", ....}

	Source   Edit   

proc `+=`(x, y: JsObject): JsObject {.importjs: "(# += #)", discardable,
                                  	....}

	Source   Edit   

proc `-`(x, y: JsObject): JsObject {.importjs: "(# - #)", ....}

	Source   Edit   

proc `--`(x: JsObject): JsObject {.importjs: "(--#)", ....}

	Source   Edit   

proc `-=`(x, y: JsObject): JsObject {.importjs: "(# -= #)", discardable,
                                  	....}

	Source   Edit   

proc `/`(x, y: JsObject): JsObject {.importjs: "(# / #)", ....}

	Source   Edit   

proc `/=`(x, y: JsObject): JsObject {.importjs: "(# /= #)", discardable,
                                  	....}

	Source   Edit   

proc `<`(x, y: JsObject): JsObject {.importjs: "(# < #)", ....}

	Source   Edit   

proc `<=`(x, y: JsObject): JsObject {.importjs: "(# <= #)", ....}

	Source   Edit   

proc `==`(x, y: JsRoot): bool {.importjs: "(# === #)", ....}

	Compares two JsObjects or JsAssocs. Be careful though, as this is comparison like in JavaScript, so if your JsObjects are in fact JavaScript Objects, and not strings or numbers, this is a comparison of references. Source   Edit   

proc `>`(x, y: JsObject): JsObject {.importjs: "(# > #)", ....}

	Source   Edit   

proc `>=`(x, y: JsObject): JsObject {.importjs: "(# >= #)", ....}

	Source   Edit   

proc `[]`(obj: JsObject; field: cstring): JsObject {.importjs: "#[#]",
	....}

	Returns the value of a property of name field from a JsObject obj. Source   Edit   

proc `[]`(obj: JsObject; field: int): JsObject {.importjs: "#[#]", ....}

	Returns the value of a property of name field from a JsObject obj. Source   Edit   

proc `[]`[K: JsKey; V](obj: JsAssoc[K, V]; field: K): V {.importjs: "#[#]",
	....}

	Returns the value of a property of name field from a JsAssoc obj. Source   Edit   

proc `[]`[V](obj: JsAssoc[cstring, V]; field: string): V

	Source   Edit   

proc `[]=`[K: JsKey; V](obj: JsAssoc[K, V]; field: K; val: V) {.
	importjs: "#[#] = #", ....}

	Sets the value of a property of name field in a JsAssoc obj to v. Source   Edit   

proc `[]=`[T](obj: JsObject; field: cstring; val: T) {.importjs: "#[#] = #",
	....}

	Sets the value of a property of name field in a JsObject obj to v. Source   Edit   

proc `[]=`[T](obj: JsObject; field: int; val: T) {.importjs: "#[#] = #",
	....}

	Sets the value of a property of name field in a JsObject obj to v. Source   Edit   

proc `[]=`[V](obj: JsAssoc[cstring, V]; field: string; val: V)

	Source   Edit   

proc `and`(x, y: JsObject): JsObject {.importjs: "(# && #)", ....}

	Source   Edit   

proc hasOwnProperty(x: JsObject; prop: cstring): bool {.
	importjs: "#.hasOwnProperty(#)", ....}

	Checks, whether x has a property of name prop. Source   Edit   

proc `in`(x, y: JsObject): JsObject {.importjs: "(# in #)", ....}

	Source   Edit   

proc isNull[T](x: T): bool {.noSideEffect, importjs: "(# === null)", ....}

	Checks if a value is exactly null. Source   Edit   

proc isUndefined[T](x: T): bool {.noSideEffect, importjs: "(# === undefined)",
                              	....}

	Checks if a value is exactly undefined. Source   Edit   

proc jsDelete(x: auto): JsObject {.importjs: "(delete #)", ....}

	JavaScript's delete operator. Source   Edit   

proc jsNew(x: auto): JsObject {.importjs: "(new #)", ....}

	Turns a regular function call into an invocation of the JavaScript's new operator. Source   Edit   

proc jsTypeOf(x: JsObject): cstring {.importjs: "typeof(#)", ....}

	Returns the name of the JsObject's JavaScript type as a cstring. Source   Edit   

proc newJsAssoc[K: JsKey; V](): JsAssoc[K, V] {.importjs: "{@}", ....}

	Creates a new empty JsAssoc with key type K and value type V. Source   Edit   

proc newJsObject(): JsObject {.importjs: "{@}", ....}

	Creates a new empty JsObject. Source   Edit   

proc `not`(x: JsObject): JsObject {.importjs: "(!#)", ....}

	Source   Edit   

proc `or`(x, y: JsObject): JsObject {.importjs: "(# || #)", ....}

	Source   Edit   

proc require(module: cstring): JsObject {.importc, ....}

	JavaScript's require function. Source   Edit   

proc to(x: JsObject; T: typedesc): T:type {.importjs: "(#)", ....}

	Converts a JsObject x to type T. Source   Edit   

proc toJs[T](val: T): JsObject {.importjs: "(#)", ....}

	Converts a value of any type to type JsObject. Source   Edit   

proc toJsKey(text: cstring; t: type cstring): cstring

	Source   Edit   

proc toJsKey[T: enum](text: cstring; t: type T): T

	Source   Edit   

proc toJsKey[T: SomeFloat](text: cstring; t: type T): T {.
	importjs: "parseFloat(#)", ....}

	Source   Edit   

proc toJsKey[T: SomeInteger](text: cstring; t: type T): T {.
	importjs: "parseInt(#)", ....}

	Source   Edit   

Iterators

iterator items(obj: JsObject): JsObject {.....}

	Yields the values of each field in a JsObject, wrapped into a JsObject. Source   Edit   

iterator items[K, V](assoc: JsAssoc[K, V]): V

	Yields the values in a JsAssoc. Source   Edit   

iterator keys(obj: JsObject): cstring {.....}

	Yields the names of each field in a JsObject. Source   Edit   

iterator keys[K: JsKey; V](assoc: JsAssoc[K, V]): K

	Yields the keys in a JsAssoc. Source   Edit   

iterator pairs(obj: JsObject): (cstring, JsObject) {.....}

	Yields tuples of type (cstring, JsObject), with the first entry being the name of a fields in the JsObject and the second being its value wrapped into a JsObject. Source   Edit   

iterator pairs[K: JsKey; V](assoc: JsAssoc[K, V]): (K, V)

	Yields tuples of type (K, V), with the first entry being a key in the JsAssoc and the second being its corresponding value. Source   Edit   

Macros

macro `.`(obj: JsObject; field: untyped): JsObject

Experimental dot accessor (get) for type JsObject. Returns the value of a property of name field from a JsObject x.

Example:

let obj = newJsObject()
obj.a = 20
assert obj.a.to(int) == 20

	Source   Edit   

macro `.`[K: cstring; V](obj: JsAssoc[K, V]; field: untyped): V

	Experimental dot accessor (get) for type JsAssoc. Returns the value of a property of name field from a JsObject x. Source   Edit   

macro `.()`(obj: JsObject; field: untyped; args: varargs[JsObject, jsFromAst]): JsObject

Experimental "method call" operator for type JsObject. Takes the name of a method of the JavaScript object (field) and calls it with args as arguments, returning a JsObject (which may be discarded, and may be undefined, if the method does not return anything, so be careful when using this.)

Example:

# Let's get back to the console example:
var console {.importc, nodecl.}: JsObject
let res = console.log("I return undefined!")
console.log(res) # This prints undefined, as console.log always returns
             	# undefined. Thus one has to be careful, when using
             	# JsObject calls.

	Source   Edit   

macro `.()`[K: cstring; V: proc](obj: JsAssoc[K, V]; field: untyped;
                             	args: varargs[untyped]): auto

	Experimental "method call" operator for type JsAssoc. Takes the name of a method of the JavaScript object (field) and calls it with args as arguments. Here, everything is typechecked, so you do not have to worry about undefined return values. Source   Edit   

macro `.=`(obj: JsObject; field, value: untyped): untyped

	Experimental dot accessor (set) for type JsObject. Sets the value of a property of name field in a JsObject x to value. Source   Edit   

macro `.=`[K: cstring; V](obj: JsAssoc[K, V]; field: untyped; value: V): untyped

	Experimental dot accessor (set) for type JsAssoc. Sets the value of a property of name field in a JsObject x to value. Source   Edit   

macro bindMethod(procedure: typed): auto {.
	....}

Deprecated: Don't use it with closures

Takes the name of a procedure and wraps it into a lambda missing the first argument, which passes the JavaScript builtin this as the first argument to the procedure. Returns the resulting lambda.

Example:

We want to generate roughly this JavaScript:

var obj = {a: 10};
obj.someMethod = function() {
  return this.a + 42;
};

We can achieve this using the bindMethod macro:

let obj = JsObject{ a: 10 }
proc someMethodImpl(that: JsObject): int =
  that.a.to(int) + 42
obj.someMethod = bindMethod someMethodImpl

# Alternatively:
obj.someMethod = bindMethod
  proc(that: JsObject): int = that.a.to(int) + 42

	Source   Edit   

macro jsFromAst(n: untyped): untyped

	Source   Edit   

macro `{}`(typ: typedesc; xs: varargs[untyped]): auto

Takes a typedesc as its first argument, and a series of expressions of type key: value, and returns a value of the specified type with each field key set to value, as specified in the arguments of {}.

Example:

# Let's say we have a type with a ton of fields, where some fields do not
# need to be set, and we do not want those fields to be set to `nil`:
type
  ExtremelyHugeType = ref object
	a, b, c, d, e, f, g: int
	h, i, j, k, l: cstring
	# And even more fields ...

let obj = ExtremelyHugeType{ a: 1, k: "foo".cstring, d: 42 }

# This generates roughly the same JavaScript as:
{.emit: "var obj = {a: 1, k: "foo", d: 42};".}

	Source   Edit   

Templates

template toJs(s: string): JsObject

	
std/jsre


std/jsre
Source   Edit  

Regular Expressions for the JavaScript target.

	https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions

Example:

import std/jsre
let jsregex: RegExp = newRegExp(r"\s+", r"i")
jsregex.compile(r"\w+", r"i")
assert "nim javascript".contains jsregex
assert jsregex.exec(r"nim javascript") == @["nim".cstring]
assert jsregex.toCstring() == r"/\w+/i"
jsregex.compile(r"[0-9]", r"i")
assert "0123456789abcd".contains jsregex
assert $jsregex == "/[0-9]/i"
jsregex.compile(r"abc", r"i")
assert "abcd".startsWith jsregex
assert "dabc".endsWith jsregex
jsregex.compile(r"\d", r"i")
assert "do1ne".split(jsregex) == @["do".cstring, "ne".cstring]
jsregex.compile(r"[lw]", r"i")
assert "hello world".replace(jsregex,"X") == "heXlo world"
jsregex.compile(r"([a-z])\1*", r"g")
assert "abbcccdddd".replace(jsregex, proc (m: varargs[cstring]): cstring = ($m[0] & $(m.len)).cstring) == "a1b2c3d4"
let digitsRegex: RegExp = newRegExp(r"\d")
assert "foo".match(digitsRegex) == @[]

Types

RegExp = ref object of JsRoot
  flags*: cstring        	## cstring that contains the flags of the RegExp object.
  dotAll*: bool          	## Whether `.` matches newlines or not.
  global*: bool          	## Whether to test against all possible matches in a string, or only against the first.
  ignoreCase*: bool      	## Whether to ignore case while attempting a match in a string.
  multiline*: bool       	## Whether to search in strings across multiple lines.
  source*: cstring       	## The text of the pattern.
  sticky*: bool          	## Whether the search is sticky.
  unicode*: bool         	## Whether Unicode features are enabled.
  lastIndex*: cint       	## Index at which to start the next match (read/write property).
  input*: cstring        	## Read-only and modified on successful match.
  lastMatch*: cstring    	## Ditto.
  lastParen*: cstring    	## Ditto.
  leftContext*: cstring  	## Ditto.
  rightContext*: cstring 	## Ditto.
  hasIndices*: bool      	## https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/hasIndices

	Regular Expressions for JavaScript target. See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp Source   Edit   

Procs

func `$`(self: RegExp): string {.....}

	Source   Edit   

func compile(self: RegExp; pattern: cstring; flags: cstring) {.
	importjs: "#.compile(@)", ....}

	Recompiles a regular expression during execution of a script. Source   Edit   

func contains(pattern: cstring; self: RegExp): bool {.....}

Tests for a substring match in its string parameter.

Example:

let jsregex: RegExp = newRegExp(r"bc$", r"i")
assert jsregex in r"abc"
assert jsregex notin r"abcd"
assert "xabc".contains jsregex

	Source   Edit   

func endsWith(pattern: cstring; self: RegExp): bool {.....}

Tests if string ends with given RegExp

Example:

let jsregex: RegExp = newRegExp(r"bcd", r"i")
assert "abcd".endsWith jsregex

	Source   Edit   

func exec(self: RegExp; pattern: cstring): seq[cstring] {.
	importjs: "(#.exec(#) || [])", ....}

	Executes a search for a match in its string parameter. Source   Edit   

func match(pattern: cstring; self: RegExp): seq[cstring] {.
	importjs: "(#.match(#) || [])", ....}

	Returns an array of matches of a RegExp against given string Source   Edit   

func newRegExp(pattern: cstring): RegExp {.importjs: "new RegExp(@)",
	....}

	Source   Edit   

func newRegExp(pattern: cstring; flags: cstring): RegExp {.
	importjs: "new RegExp(@)", ....}

	Creates a new RegExp object. Source   Edit   

func replace(pattern: cstring; self: RegExp;
         	cb: proc (args: varargs[cstring]): cstring): cstring {.importcpp,
	....}

	Returns a new string with some or all matches of a pattern replaced by given callback function Source   Edit   

func replace(pattern: cstring; self: RegExp; replacement: cstring): cstring {.
	importjs: "#.replace(#, #)", ....}

	Returns a new string with some or all matches of a pattern replaced by given replacement Source   Edit   

func split(pattern: cstring; self: RegExp): seq[cstring] {.
	importjs: "(#.split(#) || [])", ....}

	Divides a string into an ordered list of substrings and returns the array Source   Edit   

func startsWith(pattern: cstring; self: RegExp): bool {.....}

Tests if string starts with given RegExp

Example:

let jsregex: RegExp = newRegExp(r"abc", r"i")
assert "abcd".startsWith jsregex

	Source   Edit   

func toCstring(self: RegExp): cstring {.importjs: "#.toString()", ....}

	Returns a string representing the RegExp object. Source   Edit   



Impure libraries

Regular expressions

std/re



std/re
Source   Edit  

Regular expression support for Nim.

This module is implemented by providing a wrapper around the PCRE (Perl-Compatible Regular Expressions) C library. This means that your application will depend on the PCRE library's licence when using this module, which should not be a problem though.
Note: There are also alternative nimble packages such as tinyre and regex.

PCRE's licence follows:
Licence of the PCRE library

PCRE is a library of functions to support regular expressions whose syntax and semantics are as close as possible to those of the Perl 5 language.

Written by Philip Hazel
Copyright (c) 1997-2005 University of Cambridge

Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

	Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
	Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
	Neither the name of the University of Cambridge nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
Regular expression syntax and semantics

As the regular expressions supported by this module are enormous, the reader is referred to http://perldoc.perl.org/perlre.html for the full documentation of Perl's regular expressions.

Because the backslash \ is a meta character both in the Nim programming language and in regular expressions, it is strongly recommended that one uses the raw strings of Nim, so that backslashes are interpreted by the regular expression engine:

  r"\S"  # matches any character that is not whitespace

A regular expression is a pattern that is matched against a subject string from left to right. Most characters stand for themselves in a pattern, and match the corresponding characters in the subject. As a trivial example, the pattern:

The quick brown fox

matches a portion of a subject string that is identical to itself. The power of regular expressions comes from the ability to include alternatives and repetitions in the pattern. These are encoded in the pattern by the use of metacharacters, which do not stand for themselves but instead are interpreted in some special way.

There are two different sets of metacharacters: those that are recognized anywhere in the pattern except within square brackets, and those that are recognized in square brackets. Outside square brackets, the metacharacters are as follows:
meta character	meaning
\	general escape character with several uses
^	assert start of string (or line, in multiline mode)
$	assert end of string (or line, in multiline mode)
.	match any character except newline (by default)
[	start character class definition
|	start of alternative branch
(	start subpattern
)	end subpattern
{	start min/max quantifier
?	extends the meaning of (

also 0 or 1 quantifier (equal to {0,1})
also quantifier minimizer
*	0 or more quantifier (equal to {0,})
+	1 or more quantifier (equal to {1,})

also "possessive quantifier"

Part of a pattern that is in square brackets is called a "character class". In a character class the only metacharacters are:
meta character	meaning
\	general escape character
^	negate the class, but only if the first character
-	indicates character range
[	POSIX character class (only if followed by POSIX syntax)
]	terminates the character class

The following sections describe the use of each of the metacharacters.
Backslash

The backslash character has several uses. Firstly, if it is followed by a non-alphanumeric character, it takes away any special meaning that character may have. This use of backslash as an escape character applies both inside and outside character classes.

For example, if you want to match a * character, you write \* in the pattern. This escaping action applies whether or not the following character would otherwise be interpreted as a metacharacter, so it is always safe to precede a non-alphanumeric with backslash to specify that it stands for itself. In particular, if you want to match a backslash, you write \\.
Non-printing characters

A second use of backslash provides a way of encoding non-printing characters in patterns in a visible manner. There is no restriction on the appearance of non-printing characters, apart from the binary zero that terminates a pattern, but when a pattern is being prepared by text editing, it is usually easier to use one of the following escape sequences than the binary character it represents:
character	meaning
\a	alarm, that is, the BEL character (hex 07)
\e	escape (hex 1B)
\f	formfeed (hex 0C)
\n	newline (hex 0A)
\r	carriage return (hex 0D)
\t	tab (hex 09)
\ddd	character with octal code ddd, or backreference
\xhh	character with hex code hh

After \x, from zero to two hexadecimal digits are read (letters can be in upper or lower case). In UTF-8 mode, any number of hexadecimal digits may appear between \x{ and }, but the value of the character code must be less than 2^31 (that is, the maximum hexadecimal value is 7FFFFFFF). If characters other than hexadecimal digits appear between \x{ and }, or if there is no terminating }, this form of escape is not recognized. Instead, the initial \x will be interpreted as a basic hexadecimal escape, with no following digits, giving a character whose value is zero.

After \0 up to two further octal digits are read. In both cases, if there are fewer than two digits, just those that are present are used. Thus the sequence \0\x\07 specifies two binary zeros followed by a BEL character (code value 7). Make sure you supply two digits after the initial zero if the pattern character that follows is itself an octal digit.

The handling of a backslash followed by a digit other than 0 is complicated. Outside a character class, PCRE reads it and any following digits as a decimal number. If the number is less than 10, or if there have been at least that many previous capturing left parentheses in the expression, the entire sequence is taken as a back reference. A description of how this works is given later, following the discussion of parenthesized subpatterns.

Inside a character class, or if the decimal number is greater than 9 and there have not been that many capturing subpatterns, PCRE re-reads up to three octal digits following the backslash, and generates a single byte from the least significant 8 bits of the value. Any subsequent digits stand for themselves. For example:
example	meaning
\040	is another way of writing a space
\40	is the same, provided there are fewer than 40 previous capturing subpatterns
\7	is always a back reference
\11	might be a back reference, or another way of writing a tab
\011	is always a tab
\0113	is a tab followed by the character "3"
\113	might be a back reference, otherwise the character with octal code 113
\377	might be a back reference, otherwise the byte consisting entirely of 1 bits
\81	is either a back reference, or a binary zero followed by the two characters "8" and "1"

Note that octal values of 100 or greater must not be introduced by a leading zero, because no more than three octal digits are ever read.

All the sequences that define a single byte value or a single UTF-8 character (in UTF-8 mode) can be used both inside and outside character classes. In addition, inside a character class, the sequence \b is interpreted as the backspace character (hex 08), and the sequence \X is interpreted as the character "X". Outside a character class, these sequences have different meanings (see below).
Generic character types

The third use of backslash is for specifying generic character types. The following are always recognized:
character type	meaning
\d	any decimal digit
\D	any character that is not a decimal digit
\s	any whitespace character
\S	any character that is not a whitespace character
\w	any "word" character
\W	any "non-word" character

Each pair of escape sequences partitions the complete set of characters into two disjoint sets. Any given character matches one, and only one, of each pair.

These character type sequences can appear both inside and outside character classes. They each match one character of the appropriate type. If the current matching point is at the end of the subject string, all of them fail, since there is no character to match.

For compatibility with Perl, \s does not match the VT character (code 11). This makes it different from the POSIX "space" class. The \s characters are HT (9), LF (10), FF (12), CR (13), and space (32).

A "word" character is an underscore or any character less than 256 that is a letter or digit. The definition of letters and digits is controlled by PCRE's low-valued character tables, and may vary if locale-specific matching is taking place (see "Locale support" in the pcreapi page). For example, in the "fr_FR" (French) locale, some character codes greater than 128 are used for accented letters, and these are matched by \w.

In UTF-8 mode, characters with values greater than 128 never match \d, \s, or \w, and always match \D, \S, and \W. This is true even when Unicode character property support is available.
Simple assertions

The fourth use of backslash is for certain simple assertions. An assertion specifies a condition that has to be met at a particular point in a match, without consuming any characters from the subject string. The use of subpatterns for more complicated assertions is described below. The backslashed assertions are:
assertion	meaning
\b	matches at a word boundary
\B	matches when not at a word boundary
\A	matches at start of subject
\Z	matches at end of subject or before newline at end
\z	matches at end of subject
\G	matches at first matching position in subject

These assertions may not appear in character classes (but note that \b has a different meaning, namely the backspace character, inside a character class).

A word boundary is a position in the subject string where the current character and the previous character do not both match \w or \W (i.e. one matches \w and the other matches \W), or the start or end of the string if the first or last character matches \w, respectively.

The \A, \Z, and \z assertions differ from the traditional circumflex and dollar in that they only ever match at the very start and end of the subject string, whatever options are set. The difference between \Z and \z is that \Z matches before a newline that is the last character of the string as well as at the end of the string, whereas \z matches only at the end.

Example:

import std/re
## Unless specified otherwise, `start` parameter in each proc indicates
## where the scan starts, but outputs are relative to the start of the input
## string, not to `start`:
doAssert find("uxabc", re"(?<=x|y)ab", start = 1) == 2 # lookbehind assertion
doAssert find("uxabc", re"ab", start = 3) == -1 # we're past `start` => not found
doAssert not match("xabc", re"^abc$", start = 1)
  # can't match start of string since we're starting at 1

Imports

pcre, strutils, rtarrays

Types

Regex = ref RegexDesc

	a compiled regular expression Source   Edit   

RegexError = object of ValueError

	is raised if the pattern is no valid regular expression. Source   Edit   

RegexFlag = enum
  reIgnoreCase = 0,     	## do caseless matching
  reMultiLine = 1,      	## `^` and `$` match newlines within data
  reDotAll = 2,         	## `.` matches anything including NL
  reExtended = 3,       	## ignore whitespace and `#` comments
  reStudy = 4            	## study the expression (may be omitted if the
                         	## expression will be used only once)

	options for regular expressions Source   Edit   

Consts

MaxReBufSize = 2147483647'i32

	Maximum PCRE (API 1) buffer start/size equal to high(cint), which even for 64-bit systems can be either 231-1 or 263-1. Source   Edit   

MaxSubpatterns = 20

	defines the maximum number of subpatterns that can be captured. This limit still exists for replacef and parallelReplace. Source   Edit   

Procs

proc contains(s: string; pattern: Regex; matches: var openArray[string];
          	start = 0): bool {.inline, ....}

	same as find(s, pattern, matches, start) >= 0
	Note: The memory for matches needs to be allocated before this function is called, otherwise it will just remain empty.
	Source   Edit   

proc contains(s: string; pattern: Regex; start = 0): bool {.inline, ....}

	same as find(s, pattern, start) >= 0 Source   Edit   

proc endsWith(s: string; suffix: Regex): bool {.inline, ....}

	returns true if s ends with the pattern suffix Source   Edit   

proc escapeRe(s: string): string {.....}

	escapes s so that it is matched verbatim when used as a regular expression. Source   Edit   

proc find(buf: cstring; pattern: Regex; matches: var openArray[string];
      	start = 0; bufSize: int): int {.....}

	returns the starting position of pattern in buf and the captured substrings in the array matches. If it does not match, nothing is written into matches and -1 is returned. buf has length bufSize (not necessarily '\0' terminated).
	Note: The memory for matches needs to be allocated before this function is called, otherwise it will just remain empty.
	Source   Edit   

proc find(buf: cstring; pattern: Regex; start = 0; bufSize: int): int {.
	....}

	returns the starting position of pattern in buf, where buf has length bufSize (not necessarily '\0' terminated). If it does not match, -1 is returned. Source   Edit   

proc find(s: string; pattern: Regex; matches: var openArray[string]; start = 0): int {.
	inline, ....}

	returns the starting position of pattern in s and the captured substrings in the array matches. If it does not match, nothing is written into matches and -1 is returned.
	Note: The memory for matches needs to be allocated before this function is called, otherwise it will just remain empty.
	Source   Edit   

proc find(s: string; pattern: Regex; start = 0): int {.inline, ....}

returns the starting position of pattern in s. If it does not match, -1 is returned. We start the scan at start.

Example:

doAssert find("abcdefg", re"cde") == 2
doAssert find("abcdefg", re"abc") == 0
doAssert find("abcdefg", re"zz") == -1 # not found
doAssert find("abcdefg", re"cde", start = 2) == 2 # still 2
doAssert find("abcdefg", re"cde", start = 3) == -1 # we're past the start position
doAssert find("xabc", re"(?<=x|y)abc", start = 1) == 1
  # lookbehind assertion `(?<=x|y)` can look behind `start`

	Source   Edit   

proc findAll(s: string; pattern: Regex; start = 0): seq[string] {.inline,
	....}

	returns all matching substrings of s that match pattern. If it does not match, @[] is returned. Source   Edit   

proc findBounds(buf: cstring; pattern: Regex;
            	matches: var openArray[tuple[first, last: int]]; start = 0;
            	bufSize: int): tuple[first, last: int] {.....}

	returns the starting position and end position of pattern in buf (where buf has length bufSize and is not necessarily '\0' terminated), and the captured substrings in the array matches. If it does not match, nothing is written into matches and (-1,0) is returned.
	Note: The memory for matches needs to be allocated before this function is called, otherwise it will just remain empty.
	Source   Edit   

proc findBounds(buf: cstring; pattern: Regex; matches: var openArray[string];
            	start = 0; bufSize: int): tuple[first, last: int] {.....}

	returns the starting position and end position of pattern in buf (where buf has length bufSize and is not necessarily '\0' terminated), and the captured substrings in the array matches. If it does not match, nothing is written into matches and (-1,0) is returned.

	Note: The memory for matches needs to be allocated before this function is called, otherwise it will just remain empty.
	Source   Edit   

proc findBounds(buf: cstring; pattern: Regex; start = 0; bufSize: int): tuple[
	first, last: int] {.....}

	returns the first and last position of pattern in buf, where buf has length bufSize (not necessarily '\0' terminated). If it does not match, (-1,0) is returned. Source   Edit   

proc findBounds(s: string; pattern: Regex;
            	matches: var openArray[tuple[first, last: int]]; start = 0): tuple[
	first, last: int] {.inline, ....}

returns the starting position and end position of pattern in s and the captured substrings in the array matches. If it does not match, nothing is written into matches and (-1,0) is returned.
Note: The memory for matches needs to be allocated before this function is called, otherwise it will just remain empty.

Example:

var matches = newSeq[tuple[first, last: int]](1)
let (first, last) = findBounds("Hello World", re"(\w+)", matches)
doAssert first == 0
doAssert last == 4
doAssert matches[0] == (0, 4)

	Source   Edit   

proc findBounds(s: string; pattern: Regex; matches: var openArray[string];
            	start = 0): tuple[first, last: int] {.inline, ....}

returns the starting position and end position of pattern in s and the captured substrings in the array matches. If it does not match, nothing is written into matches and (-1,0) is returned.
Note: The memory for matches needs to be allocated before this function is called, otherwise it will just remain empty.

Example:

var matches = newSeq[string](1)
let (first, last) = findBounds("Hello World", re"(W\w+)", matches)
doAssert first == 6
doAssert last == 10
doAssert matches[0] == "World"

	Source   Edit   

proc findBounds(s: string; pattern: Regex; start = 0): tuple[first, last: int] {.
	inline, ....}

returns the first and last position of pattern in s. If it does not match, (-1,0) is returned.

Note: there is a speed improvement if the matches do not need to be captured.

Example:

assert findBounds("01234abc89", re"abc") == (5,7)

	Source   Edit   

proc match(buf: cstring; pattern: Regex; matches: var openArray[string];
       	start = 0; bufSize: int): bool {.inline, ....}

	returns true if buf[start..<bufSize] matches the pattern and the captured substrings in the array matches. If it does not match, nothing is written into matches and false is returned. buf has length bufSize (not necessarily '\0' terminated).
	Note: The memory for matches needs to be allocated before this function is called, otherwise it will just remain empty.
	Source   Edit   

proc match(s: string; pattern: Regex; matches: var openArray[string]; start = 0): bool {.
	inline, ....}

returns true if s[start..] matches the pattern and the captured substrings in the array matches. If it does not match, nothing is written into matches and false is returned.
Note: The memory for matches needs to be allocated before this function is called, otherwise it will just remain empty.

Example:

import std/sequtils
var matches: array[2, string]
if match("abcdefg", re"c(d)ef(g)", matches, 2):
  doAssert toSeq(matches) == @["d", "g"]

	Source   Edit   

proc match(s: string; pattern: Regex; start = 0): bool {.inline, ....}

	returns true if s[start..] matches the pattern. Source   Edit   

proc matchLen(buf: cstring; pattern: Regex; matches: var openArray[string];
          	start = 0; bufSize: int): int {.inline, ....}

	the same as match, but it returns the length of the match, if there is no match, -1 is returned. Note that a match length of zero can happen.
	Note: The memory for matches needs to be allocated before this function is called, otherwise it will just remain empty.
	Source   Edit   

proc matchLen(buf: cstring; pattern: Regex; start = 0; bufSize: int): int {.
	inline, ....}

	the same as match, but it returns the length of the match, if there is no match, -1 is returned. Note that a match length of zero can happen. Source   Edit   

proc matchLen(s: string; pattern: Regex; matches: var openArray[string];
          	start = 0): int {.inline, ....}

	the same as match, but it returns the length of the match, if there is no match, -1 is returned. Note that a match length of zero can happen.
	Note: The memory for matches needs to be allocated before this function is called, otherwise it will just remain empty.
	Source   Edit   

proc matchLen(s: string; pattern: Regex; start = 0): int {.inline, ....}

the same as match, but it returns the length of the match, if there is no match, -1 is returned. Note that a match length of zero can happen.

Example:

doAssert matchLen("abcdefg", re"cde", 2) == 3
doAssert matchLen("abcdefg", re"abcde") == 5
doAssert matchLen("abcdefg", re"cde") == -1

	Source   Edit   

proc multiReplace(s: string;
              	subs: openArray[tuple[pattern: Regex, repl: string]]): string {.
	....}

	Returns a modified copy of s with the substitutions in subs applied in parallel. Source   Edit   

proc re(s: string; flags = {reStudy}): Regex {.....}

	Constructor of regular expressions.

	Note that Nim's extended raw string literals support the syntax re"[abc]" as a short form for re(r"[abc]"). Also note that since this compiles the regular expression, which is expensive, you should avoid putting it directly in the arguments of the functions like the examples show below if you plan to use it a lot of times, as this will hurt performance immensely. (e.g. outside a loop, ...)
	Source   Edit   

proc replace(s: string; sub: Regex; by = ""): string {.....}

Replaces sub in s by the string by. Captures cannot be accessed in by.

Example:

doAssert "var1=key; var2=key2".replace(re"(\w+)=(\w+)") == "; "
doAssert "var1=key; var2=key2".replace(re"(\w+)=(\w+)", "?") == "?; ?"

	Source   Edit   

proc replacef(s: string; sub: Regex; by: string): string {.....}

Replaces sub in s by the string by. Captures can be accessed in by with the notation $i and $# (see strutils.`%`).

Example:

doAssert "var1=key; var2=key2".replacef(re"(\w+)=(\w+)", "$1<-$2$2") ==
  "var1<-keykey; var2<-key2key2"

	Source   Edit   

proc rex(s: string; flags = {reStudy, reExtended}): Regex {.
	....}

	Constructor for extended regular expressions.

	The extended means that comments starting with # and whitespace are ignored.
	Source   Edit   

proc split(s: string; sep: Regex; maxsplit = -1): seq[string] {.inline,
	....}

	Splits the string s into a seq of substrings.

	The portion matched by sep is not returned.
	Source   Edit   

proc startsWith(s: string; prefix: Regex): bool {.inline, ....}

	returns true if s starts with the pattern prefix Source   Edit   

proc transformFile(infile, outfile: string;
               	subs: openArray[tuple[pattern: Regex, repl: string]]) {.
	....}

	reads in the file infile, performs a parallel replacement (calls parallelReplace) and writes back to outfile. Raises IOError if an error occurs. This is supposed to be used for quick scripting. Source   Edit   

Iterators

iterator findAll(buf: cstring; pattern: Regex; start = 0; bufSize: int): string {.
	....}

	Yields all matching substrings of s that match pattern.

	Note that since this is an iterator you should not modify the string you are iterating over: bad things could happen.
	Source   Edit   

iterator findAll(s: string; pattern: Regex; start = 0): string {.....}

	Yields all matching substrings of s that match pattern.

	Note that since this is an iterator you should not modify the string you are iterating over: bad things could happen.
	Source   Edit   

iterator split(s: string; sep: Regex; maxsplit = -1): string {.....}

Splits the string s into substrings.

Substrings are separated by the regular expression sep (and the portion matched by sep is not returned).

Example:

import std/sequtils
doAssert toSeq(split("00232this02939is39an22example111", re"\d+")) ==
  @["", "this", "is", "an", "example", ""]

	Source   Edit   

Templates

template `=~`(s: string; pattern: Regex): untyped

This calls match with an implicit declared matches array that can be used in the scope of the =~ call:

Example:

proc parse(line: string): string =
  if line =~ re"\s*(\w+)\s*\=\s*(\w+)": # matches a key=value pair:
	result = $(matches[0], matches[1])
  elif line =~ re"\s*(\#.*)": # matches a comment
	# note that the implicit `matches` array is different from 1st branch
	result = $(matches[0],)
  else: raiseAssert "unreachable"
  doAssert not declared(matches)
doAssert parse("NAME = LENA") == """("NAME", "LENA")"""
doAssert parse("   # comment ... ") == """("# comment ... ",)"""


std/nre


std/nre
Source   Edit  

What is NRE?

A regular expression library for Nim using PCRE to do the hard work.

For documentation on how to write patterns, there exists the official PCRE pattern documentation. You can also search the internet for a wide variety of third-party documentation and tools.
Warning: If you love sequtils.toSeq we have bad news for you. This library doesn't work with it due to documented compiler limitations. As a workaround, use this:

Example:

import std/nre
# either `import std/nre except toSeq` or fully qualify `sequtils.toSeq`:
import std/sequtils
iterator iota(n: int): int =
  for i in 0..<n: yield i
assert sequtils.toSeq(iota(3)) == @[0, 1, 2]

Note: There are also alternative nimble packages such as tinyre and regex.
Licencing

PCRE has some additional terms that you must agree to in order to use this module.

Example:

import std/nre
import std/sugar
let vowels = re"[aeoui]"
let bounds = collect:
  for match in "moiga".findIter(vowels): match.matchBounds
assert bounds == @[1 .. 1, 2 .. 2, 4 .. 4]
from std/sequtils import toSeq
let s = sequtils.toSeq("moiga".findIter(vowels))
  # fully qualified to avoid confusion with nre.toSeq
assert s.len == 3

let firstVowel = "foo".find(vowels)
let hasVowel = firstVowel.isSome()
assert hasVowel
let matchBounds = firstVowel.get().captureBounds[-1]
assert matchBounds.a == 1

# as with module `re`, unless specified otherwise, `start` parameter in each
# proc indicates where the scan starts, but outputs are relative to the start
# of the input string, not to `start`:
assert find("uxabc", re"(?<=x|y)ab", start = 1).get.captures[-1] == "ab"
assert find("uxabc", re"ab", start = 3).isNone

Imports

pcre, util, tables, strutils, options, unicode

Types

CaptureBounds = distinct RegexMatch

	Source   Edit   

Captures = distinct RegexMatch

	Source   Edit   

InvalidUnicodeError = ref object of RegexError
  pos*: int              	## the location of the invalid unicode in bytes

	Thrown when matching fails due to invalid unicode in strings Source   Edit   

Regex = ref object
  pattern*: string
  ## not nil
  ## nil

	Represents the pattern that things are matched against, constructed with re(string). Examples: re"foo", re(r"(*ANYCRLF)(?x)foo # comment".

	pattern: string
    	the string that was used to create the pattern. For details on how to write a pattern, please see the official PCRE pattern documentation.
	captureCount: int
    	the number of captures that the pattern has.
	captureNameId: Table[string, int]
    	a table from the capture names to their numeric id.

	Options

	The following options may appear anywhere in the pattern, and they affect the rest of it.

    	(?i) - case insensitive
    	(?m) - multi-line: ^ and $ match the beginning and end of lines, not of the subject string
    	(?s) - . also matches newline (dotall)
    	(?U) - expressions are not greedy by default. ? can be added to a qualifier to make it greedy
    	(?x) - whitespace and comments (#) are ignored (extended)
    	(?X) - character escapes without special meaning (\w vs. \a) are errors (extra)

	One or a combination of these options may appear only at the beginning of the pattern:

    	(*UTF8) - treat both the pattern and subject as UTF-8
    	(*UCP) - Unicode character properties; \w matches я
    	(*U) - a combination of the two options above
    	(*FIRSTLINE*) - fails if there is not a match on the first line
    	(*NO_AUTO_CAPTURE) - turn off auto-capture for groups; (?<name>...) can be used to capture
    	(*CR) - newlines are separated by \r
    	(*LF) - newlines are separated by \n (UNIX default)
    	(*CRLF) - newlines are separated by \r\n (Windows default)
    	(*ANYCRLF) - newlines are separated by any of the above

    	(*ANY) - newlines are separated by any of the above and Unicode newlines:

    	single characters VT (vertical tab, U+000B), FF (form feed, U+000C), NEL (next line, U+0085), LS (line separator, U+2028), and PS (paragraph separator, U+2029). For the 8-bit library, the last two are recognized only in UTF-8 mode. — man pcre
    	(*JAVASCRIPT_COMPAT) - JavaScript compatibility
    	(*NO_STUDY) - turn off studying; study is enabled by default

	For more details on the leading option groups, see the Option Setting and the Newline Convention sections of the PCRE syntax manual.

	Some of these options are not part of PCRE and are converted by nre into PCRE flags. These include NEVER_UTF, ANCHORED, DOLLAR_ENDONLY, FIRSTLINE, NO_AUTO_CAPTURE, JAVASCRIPT_COMPAT, U, NO_STUDY. In other PCRE wrappers, you will need to pass these as separate flags to PCRE.
	Source   Edit   

RegexError = ref object of CatchableError

	Source   Edit   

RegexInternalError = ref object of RegexError

	Internal error in the module, this probably means that there is a bug Source   Edit   

RegexMatch = object
  pattern*: Regex        	## The regex doing the matching.
                         	## Not nil.
  str*: string           	## The string that was matched against.
  ## First item is the bounds of the match
  ## Other items are the captures
  ## `a` is inclusive start, `b` is exclusive end

	Usually seen as OptionRegexMatch, it represents the result of an execution. On failure, it is none, on success, it is some.

	pattern: Regex
    	the pattern that is being matched
	str: string
    	the string that was matched against
	captures[]: string
    	the string value of whatever was captured at that id. If the value is invalid, then behavior is undefined. If the id is -1, then the whole match is returned. If the given capture was not matched, nil is returned. See examples for match.
	captureBounds[]: HSlice[int, int]
    	gets the bounds of the given capture according to the same rules as the above. If the capture is not filled, then None is returned. The bounds are both inclusive. See examples for match.
	match: string
    	the full text of the match.
	matchBounds: HSlice[int, int]
    	the bounds of the match, as in captureBounds[]
	(captureBounds|captures).toTable
    	returns a table with each named capture as a key.
	(captureBounds|captures).toSeq
    	returns all the captures by their number.
	$: string
    	same as match

	Source   Edit   

StudyError = ref object of RegexError

	Thrown when studying the regular expression fails for whatever reason. The message contains the error code. Source   Edit   

SyntaxError = ref object of RegexError
  pos*: int              	## the location of the syntax error in bytes
  pattern*: string       	## the pattern that caused the problem

	Thrown when there is a syntax error in the regular expression string passed in Source   Edit   

Procs

proc `$`(pattern: RegexMatch): string {.....}

	Source   Edit   

proc `==`(a, b: Regex): bool {.....}

	Source   Edit   

proc `==`(a, b: RegexMatch): bool {.....}

	Source   Edit   

func `[]`(pattern: CaptureBounds; i: int): HSlice[int, int] {.....}

	Source   Edit   

func `[]`(pattern: CaptureBounds; name: string): HSlice[int, int] {.
	....}

	Source   Edit   

func `[]`(pattern: Captures; i: int): string {.....}

	Source   Edit   

func `[]`(pattern: Captures; name: string): string {.....}

	Source   Edit   

func captureBounds(pattern: RegexMatch): CaptureBounds {.....}

	Source   Edit   

proc captureCount(pattern: Regex): int {.....}

	Source   Edit   

proc captureNameId(pattern: Regex): Table[string, int] {.....}

	Source   Edit   

func captures(pattern: RegexMatch): Captures {.....}

	Source   Edit   

func contains(pattern: CaptureBounds; i: int): bool {.....}

	Source   Edit   

func contains(pattern: CaptureBounds; name: string): bool {.....}

	Source   Edit   

func contains(pattern: Captures; i: int): bool {.....}

	Source   Edit   

func contains(pattern: Captures; name: string): bool {.....}

	Source   Edit   

proc contains(str: string; pattern: Regex; start = 0; endpos = int.high): bool {.
	....}

Determine if the string contains the given pattern between the end and start positions: This function is equivalent to isSome(str.find(pattern, start, endpos)).

Example:

assert "abc".contains(re"bc")
assert not "abc".contains(re"cd")
assert not "abc".contains(re"a", start = 1)

	Source   Edit   

proc escapeRe(str: string): string {.....}

Escapes the string so it doesn't match any special characters. Incompatible with the Extra flag (X).

Escaped char: \ + * ? [ ^ ] $ ( ) { } = ! < > | : -

Example:

assert escapeRe("fly+wind") == "fly\\+wind"
assert escapeRe("!") == "\\!"
assert escapeRe("nim*") == "nim\\*"

	Source   Edit   

proc find(str: string; pattern: Regex; start = 0; endpos = int.high): Option[
	RegexMatch] {.....}

	Finds the given pattern in the string between the end and start positions.

	start
    	The start point at which to start matching. |abc is 0; a|bc is 1
	endpos
    	The maximum index for a match; int.high means the end of the string, otherwise it’s an inclusive upper bound.

	Source   Edit   

proc findAll(str: string; pattern: Regex; start = 0; endpos = int.high): seq[
	string] {.....}

	Source   Edit   

func match(pattern: RegexMatch): string {.....}

	Source   Edit   

proc match(str: string; pattern: Regex; start = 0; endpos = int.high): Option[
	RegexMatch] {.....}

Like find(...), but anchored to the start of the string.

Example:

assert "foo".match(re"f").isSome
assert "foo".match(re"o").isNone

assert "abc".match(re"(\w)").get.captures[0] == "a"
assert "abc".match(re"(?<letter>\w)").get.captures["letter"] == "a"
assert "abc".match(re"(\w)\w").get.captures[-1] == "ab"

assert "abc".match(re"(\w)").get.captureBounds[0] == 0 .. 0
assert 0 in "abc".match(re"(\w)").get.captureBounds
assert "abc".match(re"").get.captureBounds[-1] == 0 .. -1
assert "abc".match(re"abc").get.captureBounds[-1] == 0 .. 2

	Source   Edit   

func matchBounds(pattern: RegexMatch): HSlice[int, int] {.....}

	Source   Edit   

proc re(pattern: string): Regex {.....}

	Source   Edit   

proc replace(str: string; pattern: Regex; sub: string): string {.
	....}

	Source   Edit   

proc replace(str: string; pattern: Regex;
         	subproc: proc (match: RegexMatch): string): string {.
	....}

	Replaces each match of Regex in the string with subproc, which should never be or return nil.

	If subproc is a proc (RegexMatch): string, then it is executed with each match and the return value is the replacement value.

	If subproc is a proc (string): string, then it is executed with the full text of the match and the return value is the replacement value.

	If subproc is a string, the syntax is as follows:

    	$$ - literal $
    	$123 - capture number 123
    	$foo - named capture foo
    	${foo} - same as above
    	$1$# - first and second captures
    	$# - first capture
    	$0 - full match

	If a given capture is missing, IndexDefect thrown for un-named captures and KeyError for named captures.
	Source   Edit   

proc replace(str: string; pattern: Regex; subproc: proc (match: string): string): string {.
	....}

	Source   Edit   

proc split(str: string; pattern: Regex; maxSplit = -1; start = 0): seq[string] {.
	....}

Splits the string with the given regex. This works according to the rules that Perl and Javascript use.

start behaves the same as in find(...).

Example:

# -  If the match is zero-width, then the string is still split:
assert "123".split(re"") == @["1", "2", "3"]

# -  If the pattern has a capture in it, it is added after the string
#	split:
assert "12".split(re"(\d)") == @["", "1", "", "2", ""]

# -  If `maxsplit != -1`, then the string will only be split
#	`maxsplit - 1` times. This means that there will be `maxsplit`
#	strings in the output seq.
assert "1.2.3".split(re"\.", maxsplit = 2) == @["1", "2.3"]

	Source   Edit   

proc toSeq(pattern: CaptureBounds; default = none(HSlice[int, int])): seq[
	Option[HSlice[int, int]]] {.....}

	Source   Edit   

proc toSeq(pattern: Captures; default: Option[string] = none(string)): seq[
	Option[string]] {.....}

	Source   Edit   

func toTable(pattern: CaptureBounds): Table[string, HSlice[int, int]] {.
	....}

	Source   Edit   

func toTable(pattern: Captures): Table[string, string] {.....}

	Source   Edit   

Iterators

iterator findIter(str: string; pattern: Regex; start = 0; endpos = int.high): RegexMatch {.
	....}

Works the same as find(...), but finds every non-overlapping match:

Example:

import std/sugar
assert collect(for a in "2222".findIter(re"22"): a.match) == @["22", "22"]
 # not @["22", "22", "22"]

	Arguments are the same as find(...)

	Variants:

    	proc findAll(...) returns a seq[string]

	Source   Edit   

iterator items(pattern: CaptureBounds; default = none(HSlice[int, int])): Option[
	HSlice[int, int]] {.....}

	Source   Edit   

iterator items(pattern: Captures; default: Option[string] = none(string)): Option[
	string] {.....}


Database support

src/db_connector/db_mysql


src/db_connector/db_mysql

Note: In order to use this module, run nimble install db_connector.

A higher level mySQL database wrapper. The same interface is implemented for other databases too.

See also: db_odbc, db_sqlite, db_postgres.
Parameter substitution

All db_* modules support the same form of parameter substitution. That is, using the ? (question mark) to signify the place where a value should be placed. For example:

sql"INSERT INTO myTable (colA, colB, colC) VALUES (?, ?, ?)"

Examples
Opening a connection to a database

import db_connector/db_mysql
let db = open("localhost", "user", "password", "dbname")
db.close()

Creating a table

db.exec(sql"DROP TABLE IF EXISTS myTable")
db.exec(sql("""CREATE TABLE myTable (
             	id integer,
             	name varchar(50) not null)"""))

Inserting data

db.exec(sql"INSERT INTO myTable (id, name) VALUES (0, ?)",
    	"Dominik")

Larger example

import db_connector/db_mysql
import std/math

let theDb = open("localhost", "nim", "nim", "test")

theDb.exec(sql"Drop table if exists myTestTbl")
theDb.exec(sql("create table myTestTbl (" &
	" Id	INT(11) 	NOT NULL AUTO_INCREMENT PRIMARY KEY, " &
	" Name  VARCHAR(50) NOT NULL, " &
	" i 	INT(11), " &
	" f 	DECIMAL(18,10))"))

theDb.exec(sql"START TRANSACTION")
for i in 1..1000:
  theDb.exec(sql"INSERT INTO myTestTbl (name,i,f) VALUES (?,?,?)",
    	"Item#" & $i, i, sqrt(i.float))
theDb.exec(sql"COMMIT")

for x in theDb.fastRows(sql"select * from myTestTbl"):
  echo x

let id = theDb.tryInsertId(sql"INSERT INTO myTestTbl (name,i,f) VALUES (?,?,?)",
    	"Item#1001", 1001, sqrt(1001.0))
echo "Inserted item: ", theDb.getValue(sql"SELECT name FROM myTestTbl WHERE id=?", id)

theDb.close()

Imports

mysql, db_common, dbutils

Types

DbConn = distinct PMySQL

	encapsulates a database connection

InstantRow = object

	a handle that can be used to get a row's column text on demand

Row = seq[string]

	a row of a dataset. NULL database values will be converted to nil.

Procs

proc `[]`(row: InstantRow; col: int): string {.inline, ....}

	Returns text for given column of the row.

proc close(db: DbConn) {.....}

	closes the database connection.

proc dbError(db: DbConn) {.noreturn, ....}

	raises a DbError exception.

proc dbQuote(s: string): string {.....}

	DB quotes the string. Note that this doesn't escape % and _.

proc exec(db: DbConn; query: SqlQuery; args: varargs[string, `$`]) {.
	....}

	executes the query and raises EDB if not successful.

proc execAffectedRows(db: DbConn; query: SqlQuery; args: varargs[string, `$`]): int64 {.
	....}

	runs the query (typically "UPDATE") and returns the number of affected rows

proc getAllRows(db: DbConn; query: SqlQuery; args: varargs[string, `$`]): seq[
	Row] {.....}

	executes the query and returns the whole result dataset.

proc getRow(db: DbConn; query: SqlQuery; args: varargs[string, `$`]): Row {.
	....}

	Retrieves a single row. If the query doesn't return any rows, this proc will return a Row with empty strings for each column.

proc getValue(db: DbConn; query: SqlQuery; args: varargs[string, `$`]): string {.
	....}

	executes the query and returns the first column of the first row of the result dataset. Returns "" if the dataset contains no rows or the database value is NULL.

proc insert(db: DbConn; query: SqlQuery; pkName: string;
        	args: varargs[string, `$`]): int64 {.....}

	same as insertId

proc insertId(db: DbConn; query: SqlQuery; args: varargs[string, `$`]): int64 {.
	....}

	executes the query (typically "INSERT") and returns the generated ID for the row.

proc len(row: InstantRow): int {.inline, ....}

	Returns number of columns in the row.

proc open(connection, user, password, database: string): DbConn {.
	....}

	opens a database connection. Raises EDb if the connection could not be established.

proc setEncoding(connection: DbConn; encoding: string): bool {.....}

	sets the encoding of a database connection, returns true for success, false for failure.

proc tryExec(db: DbConn; query: SqlQuery; args: varargs[string, `$`]): bool {.
	....}

	tries to execute the query and returns true if successful, false otherwise.

proc tryInsert(db: DbConn; query: SqlQuery; pkName: string;
           	args: varargs[string, `$`]): int64 {.....}

	same as tryInsertID

proc tryInsertId(db: DbConn; query: SqlQuery; args: varargs[string, `$`]): int64 {.
	....}

	executes the query (typically "INSERT") and returns the generated ID for the row or -1 in case of an error.

proc unsafeColumnAt(row: InstantRow; index: int): cstring {.inline, ....}

	Return cstring of given column of the row

Iterators

iterator fastRows(db: DbConn; query: SqlQuery; args: varargs[string, `$`]): Row {.
	....}

	executes the query and iterates over the result dataset.

	This is very fast, but potentially dangerous. Use this iterator only if you require ALL the rows.

	Breaking the fastRows() iterator during a loop will cause the next database query to raise an EDb exception Commands out of sync.

iterator instantRows(db: DbConn; columns: var DbColumns; query: SqlQuery;
                 	args: varargs[string, `$`]): InstantRow {.
	....}

	Same as fastRows but returns a handle that can be used to get column text on demand using []. Returned handle is valid only within the iterator body.

iterator instantRows(db: DbConn; query: SqlQuery; args: varargs[string, `$`]): InstantRow {.
	....}

	Same as fastRows but returns a handle that can be used to get column text on demand using []. Returned handle is valid only within the iterator body.

iterator rows(db: DbConn; query: SqlQuery; args: varargs[string, `$`]): Row {.
	....}

	same as fastRows, but slower and safe.



src/db_connector/db_odbc


src/db_connector/db_odbc

Note: In order to use this module, run nimble install db_connector.

A higher level ODBC database wrapper.

This is the same interface that is implemented for other databases.

This has NOT yet been (extensively) tested against ODBC drivers for Teradata, Oracle, Sybase, MSSqlvSvr, et. al. databases.

Currently all queries are ANSI calls, not Unicode.

See also: db_postgres, db_sqlite, db_mysql.
Parameter substitution

All db_* modules support the same form of parameter substitution. That is, using the ? (question mark) to signify the place where a value should be placed. For example:

sql"INSERT INTO myTable (colA, colB, colC) VALUES (?, ?, ?)"

Examples
Opening a connection to a database

import db_connector/db_odbc
var db = open("localhost", "user", "password", "dbname")
db.close()

Creating a table

db.exec(sql"DROP TABLE IF EXISTS myTable")
db.exec(sql("""CREATE TABLE myTable (
             	id integer,
             	name varchar(50) not null)"""))

Inserting data

db.exec(sql"INSERT INTO myTable (id, name) VALUES (0, ?)",
    	"Andreas")

Large example

import db_connector/db_odbc
import std/math

var theDb = open("localhost", "nim", "nim", "test")

theDb.exec(sql"Drop table if exists myTestTbl")
theDb.exec(sql("create table myTestTbl (" &
	" Id	INT(11) 	NOT NULL AUTO_INCREMENT PRIMARY KEY, " &
	" Name  VARCHAR(50) NOT NULL, " &
	" i 	INT(11), " &
	" f 	DECIMAL(18,10))"))

theDb.exec(sql"START TRANSACTION")
for i in 1..1000:
  theDb.exec(sql"INSERT INTO myTestTbl (name,i,f) VALUES (?,?,?)",
    	"Item#" & $i, i, sqrt(i.float))
theDb.exec(sql"COMMIT")

for x in theDb.fastRows(sql"select * from myTestTbl"):
  echo x

let id = theDb.tryInsertId(sql"INSERT INTO myTestTbl (name,i,f) VALUES (?,?,?)",
    	"Item#1001", 1001, sqrt(1001.0))
echo "Inserted item: ", theDb.getValue(sql"SELECT name FROM myTestTbl WHERE id=?", id)

theDb.close()

Imports

odbcsql, db_common, dbutils

Types

DbConn = OdbcConnTyp

	encapsulates a database connection

InstantRow = tuple[row: seq[string], len: int]

	a handle that can be used to get a row's column text on demand

Row = seq[string]

	a row of a dataset. NULL database values will be converted to nil.

Procs

proc `[]`(row: InstantRow; col: int): string {.inline, ....}

	Returns text for given column of the row

proc close(db: var DbConn) {.....}

	Closes the database connection.

proc dbError(db: var DbConn) {.....}

	Raises an [DbError] exception with ODBC error information

proc dbQuote(s: string): string {.noSideEffect, ....}

	DB quotes the string.

proc exec(db: var DbConn; query: SqlQuery; args: varargs[string, `$`]) {.
	....}

	Executes the query and raises EDB if not successful.

proc execAffectedRows(db: var DbConn; query: SqlQuery;
                  	args: varargs[string, `$`]): int64 {.
	....}

	Runs the query (typically "UPDATE") and returns the number of affected rows

proc getAllRows(db: var DbConn; query: SqlQuery; args: varargs[string, `$`]): seq[
	Row] {.....}

	Executes the query and returns the whole result dataset.

proc getRow(db: var DbConn; query: SqlQuery; args: varargs[string, `$`]): Row {.
	....}

	Retrieves a single row. If the query doesn't return any rows, this proc will return a Row with empty strings for each column.

proc getValue(db: var DbConn; query: SqlQuery; args: varargs[string, `$`]): string {.
	....}

	Executes the query and returns the first column of the first row of the result dataset. Returns "" if the dataset contains no rows or the database value is NULL.

proc insert(db: var DbConn; query: SqlQuery; pkName: string;
        	args: varargs[string, `$`]): int64 {.
	....}

	same as insertId

proc insertId(db: var DbConn; query: SqlQuery; args: varargs[string, `$`]): int64 {.
	....}

	Executes the query (typically "INSERT") and returns the generated ID for the row.

proc len(row: InstantRow): int {.inline, ....}

	Returns number of columns in the row

proc open(connection, user, password, database: string): DbConn {.
	....}

	Opens a database connection.

	Raises EDb if the connection could not be established.

	Currently the database parameter is ignored, but included to match open() in the other db_xxxxx library modules.

proc setEncoding(connection: DbConn; encoding: string): bool {.
	....}

	Currently not implemented for ODBC.

	Sets the encoding of a database connection, returns true for success, false for failure. result = set_character_set(connection, encoding) == 0

proc tryExec(db: var DbConn; query: SqlQuery; args: varargs[string, `$`]): bool {.
	....}

	Tries to execute the query and returns true if successful, false otherwise.

proc tryInsert(db: var DbConn; query: SqlQuery; pkName: string;
           	args: varargs[string, `$`]): int64 {.
	....}

	same as tryInsertID

proc tryInsertId(db: var DbConn; query: SqlQuery; args: varargs[string, `$`]): int64 {.
	....}

	Executes the query (typically "INSERT") and returns the generated ID for the row or -1 in case of an error.

proc unsafeColumnAt(row: InstantRow; index: int): cstring {.inline, ....}

	Return cstring of given column of the row

Iterators

iterator fastRows(db: var DbConn; query: SqlQuery; args: varargs[string, `$`]): Row {.
	....}

	Executes the query and iterates over the result dataset.

	This is very fast, but potentially dangerous. Use this iterator only if you require ALL the rows.

	Breaking the fastRows() iterator during a loop may cause a driver error for subsequent queries

	Rows are retrieved from the server at each iteration.

iterator instantRows(db: var DbConn; query: SqlQuery; args: varargs[string, `$`]): InstantRow {.
	....}

	Same as fastRows but returns a handle that can be used to get column text on demand using []. Returned handle is valid only within the iterator body.

iterator rows(db: var DbConn; query: SqlQuery; args: varargs[string, `$`]): Row {.
	....}

	Same as fastRows, but slower and safe.

	This retrieves ALL rows into memory before iterating through the rows. Large dataset queries will impact on memory usage.


src/db_connector/db_postgres


src/db_connector/db_postgres

Note: In order to use this module, run nimble install db_connector.

A higher level PostgreSQL database wrapper. This interface is implemented for other databases also.

See also: db_odbc, db_sqlite, db_mysql.
Parameter substitution

All db_* modules support the same form of parameter substitution. That is, using the ? (question mark) to signify the place where a value should be placed. For example:

sql"INSERT INTO myTable (colA, colB, colC) VALUES (?, ?, ?)"

Note: There are two approaches to parameter substitution support by this module.

	SqlQuery using ?, ?, ?, ... (same as all the db_* modules)
	SqlPrepared using $1, $2, $3, ...

prepare(db, "myExampleInsert",
    	sql"""INSERT INTO myTable
          	(colA, colB, colC)
          	VALUES ($1, $2, $3)""",
    	3)

Unix Socket

Using Unix sockets instead of TCP connection can improve performance up to 30% ~ 175% for some operations.

To use Unix sockets with db_postgres, change the server address to the socket file path:

import std/db_postgres ## Change "localhost" or "127.0.0.1" to the socket file path
let db = db_postgres.open("/run/postgresql", "user", "password", "database")
echo db.getAllRows(sql"SELECT version();")
db.close()

The socket file path is operating system specific and distribution specific, additional configuration may or may not be needed on your postgresql.conf. The Postgres server must be on the same computer and only works for Unix-like operating systems.
Examples
Opening a connection to a database

import db_connector/db_postgres
let db = open("localhost", "user", "password", "dbname")
db.close()

Creating a table

db.exec(sql"DROP TABLE IF EXISTS myTable")
db.exec(sql("""CREATE TABLE myTable (
             	id integer,
             	name varchar(50) not null)"""))

Inserting data

db.exec(sql"INSERT INTO myTable (id, name) VALUES (0, ?)",
    	"Dominik")

Imports

postgres, db_common, dbutils

Types

DbConn = PPGconn

	encapsulates a database connection

InstantRow = object
  ## used to get a row's

	a handle that can be

Row = seq[string]

	a row of a dataset. NULL database values will be converted to nil.

SqlPrepared = distinct string

	a identifier for the prepared queries

Procs

proc `[]`(row: InstantRow; col: int): string {.inline, ....}

	returns text for given column of the row

proc close(db: DbConn) {.....}

	closes the database connection.

proc dbError(db: DbConn) {.noreturn, ....}

	raises a DbError exception.

proc dbQuote(s: string): string {.....}

	DB quotes the string.

proc exec(db: DbConn; query: SqlQuery; args: varargs[string, `$`]) {.
	....}

	executes the query and raises EDB if not successful.

proc exec(db: DbConn; stmtName: SqlPrepared; args: varargs[string]) {.
	....}

proc execAffectedRows(db: DbConn; query: SqlQuery; args: varargs[string, `$`]): int64 {.
	....}

	executes the query (typically "UPDATE") and returns the number of affected rows.

proc execAffectedRows(db: DbConn; stmtName: SqlPrepared;
                  	args: varargs[string, `$`]): int64 {.
	....}

	executes the query (typically "UPDATE") and returns the number of affected rows.

proc getAllRows(db: DbConn; query: SqlQuery; args: varargs[string, `$`]): seq[
	Row] {.....}

	executes the query and returns the whole result dataset.

proc getAllRows(db: DbConn; stmtName: SqlPrepared; args: varargs[string, `$`]): seq[
	Row] {.....}

	executes the prepared query and returns the whole result dataset.

proc getRow(db: DbConn; query: SqlQuery; args: varargs[string, `$`]): Row {.
	....}

	retrieves a single row. If the query doesn't return any rows, this proc will return a Row with empty strings for each column.

proc getRow(db: DbConn; stmtName: SqlPrepared; args: varargs[string, `$`]): Row {.
	....}

proc getValue(db: DbConn; query: SqlQuery; args: varargs[string, `$`]): string {.
	....}

	executes the query and returns the first column of the first row of the result dataset. Returns "" if the dataset contains no rows or the database value is NULL.

proc getValue(db: DbConn; stmtName: SqlPrepared; args: varargs[string, `$`]): string {.
	....}

	executes the query and returns the first column of the first row of the result dataset. Returns "" if the dataset contains no rows or the database value is NULL.

proc insert(db: DbConn; query: SqlQuery; pkName: string;
        	args: varargs[string, `$`]): int64 {.....}

	executes the query (typically "INSERT") and returns the generated ID

proc insertID(db: DbConn; query: SqlQuery; args: varargs[string, `$`]): int64 {.
	....}

	executes the query (typically "INSERT") and returns the generated ID for the row. For Postgre this adds RETURNING id to the query, so it only works if your primary key is named id.

proc len(row: InstantRow): int {.inline, ....}

	returns number of columns in the row

proc open(connection, user, password, database: string): DbConn {.
	....}

opens a database connection. Raises EDb if the connection could not be established.

Clients can also use Postgres keyword/value connection strings to connect.

Example:

con = open("", "", "", "host=localhost port=5432 dbname=mydb")

	See http://www.postgresql.org/docs/current/static/libpq-connect.html#LIBPQ-CONNSTRING for more information.

proc prepare(db: DbConn; stmtName: string; query: SqlQuery; nParams: int): SqlPrepared {.
	....}

	Creates a new SqlPrepared statement. Parameter substitution is done via $1, $2, $3, etc.

proc setEncoding(connection: DbConn; encoding: string): bool {.....}

	sets the encoding of a database connection, returns true for success, false for failure.

proc tryExec(db: DbConn; query: SqlQuery; args: varargs[string, `$`]): bool {.
	....}

	tries to execute the query and returns true if successful, false otherwise.

proc tryExec(db: DbConn; stmtName: SqlPrepared; args: varargs[string, `$`]): bool {.
	....}

	tries to execute the query and returns true if successful, false otherwise.

proc tryInsert(db: DbConn; query: SqlQuery; pkName: string;
           	args: varargs[string, `$`]): int64 {.....}

	executes the query (typically "INSERT") and returns the generated ID for the row or -1 in case of an error.

proc tryInsertID(db: DbConn; query: SqlQuery; args: varargs[string, `$`]): int64 {.
	....}

	executes the query (typically "INSERT") and returns the generated ID for the row or -1 in case of an error. For Postgre this adds RETURNING id to the query, so it only works if your primary key is named id.

proc unsafeColumnAt(row: InstantRow; index: int): cstring {.inline, ....}

	Return cstring of given column of the row

Iterators

iterator fastRows(db: DbConn; query: SqlQuery; args: varargs[string, `$`]): Row {.
	....}

	executes the query and iterates over the result dataset. This is very fast, but potentially dangerous: If the for-loop-body executes another query, the results can be undefined. For Postgres it is safe though.

iterator fastRows(db: DbConn; stmtName: SqlPrepared; args: varargs[string, `$`]): Row {.
	....}

	executes the query and iterates over the result dataset. This is very fast, but potentially dangerous: If the for-loop-body executes another query, the results can be undefined. For Postgres it is safe though.

iterator instantRows(db: DbConn; columns: var DbColumns; query: SqlQuery;
                 	args: varargs[string, `$`]): InstantRow {.
	....}

iterator instantRows(db: DbConn; query: SqlQuery; args: varargs[string, `$`]): InstantRow {.
	....}

	same as fastRows but returns a handle that can be used to get column text on demand using []. Returned handle is valid only within iterator body.

iterator instantRows(db: DbConn; stmtName: SqlPrepared;
                 	args: varargs[string, `$`]): InstantRow {.
	....}

	same as fastRows but returns a handle that can be used to get column text on demand using []. Returned handle is valid only within iterator body.

iterator rows(db: DbConn; query: SqlQuery; args: varargs[string, `$`]): Row {.
	....}

	same as fastRows, but slower and safe.

iterator rows(db: DbConn; stmtName: SqlPrepared; args: varargs[string, `$`]): Row {.
	....}

	same as fastRows, but slower and safe.


src/db_connector/db_sqlite


src/db_connector/db_sqlite

Note: In order to use this module, run nimble install db_connector.

A higher level SQLite database wrapper. This interface is implemented for other databases too.
Basic usage

The basic flow of using this module is:

	Open database connection
	Execute SQL query
	Close database connection

Parameter substitution

All db_* modules support the same form of parameter substitution. That is, using the ? (question mark) to signify the place where a value should be placed. For example:

sql"INSERT INTO my_table (colA, colB, colC) VALUES (?, ?, ?)"

Opening a connection to a database

import db_connector/db_sqlite

# user, password, database name can be empty.
# These params are not used on db_sqlite module.
let db = open("mytest.db", "", "", "")
db.close()

Creating a table

db.exec(sql"DROP TABLE IF EXISTS my_table")
db.exec(sql"""CREATE TABLE my_table (
             	id   INTEGER,
             	name VARCHAR(50) NOT NULL
          	)""")

Inserting data

db.exec(sql"INSERT INTO my_table (id, name) VALUES (0, ?)",
    	"Jack")

Larger example

import db_connector/db_sqlite
import std/math

let db = open("mytest.db", "", "", "")

db.exec(sql"DROP TABLE IF EXISTS my_table")
db.exec(sql"""CREATE TABLE my_table (
             	id	INTEGER PRIMARY KEY,
             	name  VARCHAR(50) NOT NULL,
             	i 	INT(11),
             	f 	DECIMAL(18, 10)
          	)""")

db.exec(sql"BEGIN")
for i in 1..1000:
  db.exec(sql"INSERT INTO my_table (name, i, f) VALUES (?, ?, ?)",
      	"Item#" & $i, i, sqrt(i.float))
db.exec(sql"COMMIT")

for x in db.fastRows(sql"SELECT * FROM my_table"):
  echo x

let id = db.tryInsertId(sql"""INSERT INTO my_table (name, i, f)
                          	VALUES (?, ?, ?)""",
                    	"Item#1001", 1001, sqrt(1001.0))
echo "Inserted item: ", db.getValue(sql"SELECT name FROM my_table WHERE id=?", id)

db.close()

Storing binary data example

import std/random

## Generate random float datas
var orig = newSeq[float64](150)
randomize()
for x in orig.mitems:
  x = rand(1.0)/10.0

let db = open("mysqlite.db", "", "", "")
block: ## Create database
  ## Binary datas needs to be of type BLOB in SQLite
  let createTableStr = sql"""CREATE TABLE test(
	id INTEGER NOT NULL PRIMARY KEY,
	data BLOB
  )
  """
  db.exec(createTableStr)

block: ## Insert data
  var id = 1
  ## Data needs to be converted to seq[byte] to be interpreted as binary by bindParams
  var dbuf = newSeq[byte](orig.len*sizeof(float64))
  copyMem(unsafeAddr(dbuf[0]), unsafeAddr(orig[0]), dbuf.len)
 
  ## Use prepared statement to insert binary data into database
  var insertStmt = db.prepare("INSERT INTO test (id, data) VALUES (?, ?)")
  insertStmt.bindParams(id, dbuf)
  let bres = db.tryExec(insertStmt)
  ## Check insert
  doAssert(bres)
  # Destroy statement
  finalize(insertStmt)

block: ## Use getValue to select data
  var dataTest = db.getValue(sql"SELECT data FROM test WHERE id = ?", 1)
  ## Calculate sequence size from buffer size
  let seqSize = int(dataTest.len*sizeof(byte)/sizeof(float64))
  ## Copy binary string data in dataTest into a seq
  var res: seq[float64] = newSeq[float64](seqSize)
  copyMem(unsafeAddr(res[0]), addr(dataTest[0]), dataTest.len)
 
  ## Check datas obtained is identical
  doAssert res == orig

db.close()

Note

This module does not implement any ORM features such as mapping the types from the schema. Instead, a seq[string] is returned for each row.

The reasoning is as follows:

	it's close to what many DBs offer natively (char**)
	it hides the number of types that the DB supports (int? int64? decimal up to 10 places? geo coords?)
	it's convenient when all you do is to forward the data to somewhere else (echo, log, put the data into a new query)

See also

	db_odbc module for ODBC database wrapper
	db_mysql module for MySQL database wrapper
	db_postgres module for PostgreSQL database wrapper

Imports

sqlite3, db_common, dbutils

Types

DbConn = PSqlite3

	Encapsulates a database connection.

InstantRow = PStmt

	A handle that can be used to get a row's column text on demand.

Row = seq[string]

	A row of a dataset. NULL database values will be converted to an empty string.

SqlPrepared = distinct PStmt

	a identifier for the prepared queries

Procs

proc `[]`(row: InstantRow; col: int32): string {.inline, ....}

	Returns text for given column of the row.

	See also:

    	instantRows iterator example code

proc bindNull(ps: SqlPrepared; paramIdx: int) {.....}

proc bindParam(ps: SqlPrepared; paramIdx: int; val: float64) {.
	....}

proc bindParam(ps: SqlPrepared; paramIdx: int; val: int) {.....}

proc bindParam(ps: SqlPrepared; paramIdx: int; val: int32) {.....}

proc bindParam(ps: SqlPrepared; paramIdx: int; val: int64) {.....}

proc bindParam(ps: SqlPrepared; paramIdx: int; val: openArray[byte]; copy = true) {.
	....}

proc bindParam(ps: SqlPrepared; paramIdx: int; val: string; copy = true) {.
	....}

proc close(db: DbConn) {.....}

Closes the database connection.

Examples:

let db = open("mytest.db", "", "", "")
db.close()

proc dbError(db: DbConn) {.noreturn, ....}

Raises a DbError exception.

Examples:

let db = open("mytest.db", "", "", "")
if not db.tryExec(sql"SELECT * FROM not_exist_table"):
  dbError(db)
db.close()

proc dbQuote(s: string): string {.....}

Escapes the ' (single quote) char to ''. Because single quote is used for defining VARCHAR in SQL.

Example:

doAssert dbQuote("'") == "''''"
doAssert dbQuote("A Foobar's pen.") == "'A Foobar''s pen.'"

proc exec(db: DbConn; query: SqlQuery; args: varargs[string, `$`]) {.
	....}

Executes the query and raises a DbError exception if not successful.

Examples:

let db = open("mytest.db", "", "", "")
try:
  db.exec(sql"INSERT INTO my_table (id, name) VALUES (?, ?)",
      	1, "item#1")
except:
  stderr.writeLine(getCurrentExceptionMsg())
finally:
  db.close()

proc execAffectedRows(db: DbConn; query: SqlQuery; args: varargs[string, `$`]): int64 {.
	....}

Executes the query (typically "UPDATE") and returns the number of affected rows.

Examples:

let db = open("mytest.db", "", "", "")

# Records of my_table:
# | id | name 	|
# |----|----------|
# |  1 | item#1   |
# |  2 | item#2   |

doAssert db.execAffectedRows(sql"UPDATE my_table SET name = 'TEST'") == 2

db.close()

proc execAffectedRows(db: DbConn; stmtName: SqlPrepared): int64 {.
	....}

proc finalize(sqlPrepared: SqlPrepared) {.discardable, ....}

proc getAllRows(db: DbConn; query: SqlQuery; args: varargs[string, `$`]): seq[
	Row] {.....}

Executes the query and returns the whole result dataset.

Examples:

let db = open("mytest.db", "", "", "")

# Records of my_table:
# | id | name 	|
# |----|----------|
# |  1 | item#1   |
# |  2 | item#2   |

doAssert db.getAllRows(sql"SELECT id, name FROM my_table") == @[Row(@["1", "item#1"]), Row(@["2", "item#2"])]
db.close()

proc getAllRows(db: DbConn; stmtName: SqlPrepared): seq[Row] {.
	....}

proc getRow(db: DbConn; query: SqlQuery; args: varargs[string, `$`]): Row {.
	....}

Retrieves a single row. If the query doesn't return any rows, this proc will return a Row with empty strings for each column.

Examples:

let db = open("mytest.db", "", "", "")

# Records of my_table:
# | id | name 	|
# |----|----------|
# |  1 | item#1   |
# |  2 | item#2   |

doAssert db.getRow(sql"SELECT id, name FROM my_table"
               	) == Row(@["1", "item#1"])
doAssert db.getRow(sql"SELECT id, name FROM my_table WHERE id = ?",
               	2) == Row(@["2", "item#2"])

# Returns empty.
doAssert db.getRow(sql"INSERT INTO my_table (id, name) VALUES (?, ?)",
               	3, "item#3") == @[]
doAssert db.getRow(sql"DELETE FROM my_table WHERE id = ?", 3) == @[]
doAssert db.getRow(sql"UPDATE my_table SET name = 'ITEM#1' WHERE id = ?",
               	1) == @[]
db.close()

proc getValue(db: DbConn; query: SqlQuery; args: varargs[string, `$`]): string {.
	....}

Executes the query and returns the first column of the first row of the result dataset. Returns "" if the dataset contains no rows or the database value is NULL.

Examples:

let db = open("mytest.db", "", "", "")

# Records of my_table:
# | id | name 	|
# |----|----------|
# |  1 | item#1   |
# |  2 | item#2   |

doAssert db.getValue(sql"SELECT name FROM my_table WHERE id = ?",
                 	2) == "item#2"
doAssert db.getValue(sql"SELECT id, name FROM my_table") == "1"
doAssert db.getValue(sql"SELECT name, id FROM my_table") == "item#1"

db.close()

proc getValue(db: DbConn; stmtName: SqlPrepared): string {.
	....}

proc insert(db: DbConn; query: SqlQuery; pkName: string;
        	args: varargs[string, `$`]): int64 {.....}

	same as insertId

proc insertID(db: DbConn; query: SqlQuery; args: varargs[string, `$`]): int64 {.
	....}

Executes the query (typically "INSERT") and returns the generated ID for the row.

Raises a DbError exception when failed to insert row. For Postgre this adds RETURNING id to the query, so it only works if your primary key is named id.

Examples:

let db = open("mytest.db", "", "", "")
db.exec(sql"CREATE TABLE my_table (id INTEGER, name VARCHAR(50) NOT NULL)")

for i in 0..2:
  let id = db.insertID(sql"INSERT INTO my_table (id, name) VALUES (?, ?)", i, "item#" & $i)
  echo "LoopIndex = ", i, ", InsertID = ", id

# Output:
# LoopIndex = 0, InsertID = 1
# LoopIndex = 1, InsertID = 2
# LoopIndex = 2, InsertID = 3

db.close()

proc len(row: InstantRow): int32 {.inline, ....}

	Returns number of columns in a row.

	See also:

    	instantRows iterator example code

proc open(connection, user, password, database: string): DbConn {.
	....}

Opens a database connection. Raises a DbError exception if the connection could not be established.

Note: Only the connection parameter is used for sqlite.

Examples:

try:
  let db = open("mytest.db", "", "", "")
  ## do something...
  ## db.getAllRows(sql"SELECT * FROM my_table")
  db.close()
except:
  stderr.writeLine(getCurrentExceptionMsg())

proc prepare(db: DbConn; q: string): SqlPrepared {.....}

	Creates a new SqlPrepared statement.

proc setEncoding(connection: DbConn; encoding: string): bool {.....}

	Sets the encoding of a database connection, returns true for success, false for failure.

	Note: The encoding cannot be changed once it's been set. According to SQLite3 documentation, any attempt to change the encoding after the database is created will be silently ignored.

proc tryExec(db: DbConn; query: SqlQuery; args: varargs[string, `$`]): bool {.
	....}

Tries to execute the query and returns true if successful, false otherwise.

Examples:

let db = open("mytest.db", "", "", "")
if not db.tryExec(sql"SELECT * FROM my_table"):
  dbError(db)
db.close()

proc tryExec(db: DbConn; stmtName: SqlPrepared): bool {.
	....}

proc tryInsert(db: DbConn; query: SqlQuery; pkName: string;
           	args: varargs[string, `$`]): int64 {.....}

	same as tryInsertID

proc tryInsertID(db: DbConn; query: SqlQuery; args: varargs[string, `$`]): int64 {.
	....}

Executes the query (typically "INSERT") and returns the generated ID for the row or -1 in case of an error.

Examples:

let db = open("mytest.db", "", "", "")
db.exec(sql"CREATE TABLE my_table (id INTEGER, name VARCHAR(50) NOT NULL)")

doAssert db.tryInsertID(sql"INSERT INTO not_exist_table (id, name) VALUES (?, ?)",
                    	1, "item#1") == -1
db.close()

proc unsafeColumnAt(row: InstantRow; index: int32): cstring {.inline,
	....}

	Returns cstring for given column of the row.

	See also:

    	instantRows iterator example code

Iterators

iterator fastRows(db: DbConn; query: SqlQuery; args: varargs[string, `$`]): Row {.
	....}

Executes the query and iterates over the result dataset.

This is very fast, but potentially dangerous. Use this iterator only if you require ALL the rows.

Note: Breaking the fastRows() iterator during a loop will cause the next database query to raise a DbError exception unable to close due to ....

Examples:

let db = open("mytest.db", "", "", "")

# Records of my_table:
# | id | name 	|
# |----|----------|
# |  1 | item#1   |
# |  2 | item#2   |

for row in db.fastRows(sql"SELECT id, name FROM my_table"):
  echo row

# Output:
# @["1", "item#1"]
# @["2", "item#2"]

db.close()

iterator fastRows(db: DbConn; stmtName: SqlPrepared): Row {.
	....}

iterator instantRows(db: DbConn; columns: var DbColumns; query: SqlQuery;
                 	args: varargs[string, `$`]): InstantRow {.
	....}

Similar to instantRows iterator, but sets information about columns to columns.

Examples:

let db = open("mytest.db", "", "", "")

# Records of my_table:
# | id | name 	|
# |----|----------|
# |  1 | item#1   |
# |  2 | item#2   |

var columns: DbColumns
for row in db.instantRows(columns, sql"SELECT * FROM my_table"):
  discard
echo columns[0]

# Output:
# (name: "id", tableName: "my_table", typ: (kind: dbNull,
# notNull: false, name: "INTEGER", size: 0, maxReprLen: 0, precision: 0,
# scale: 0, min: 0, max: 0, validValues: @[]), primaryKey: false,
# foreignKey: false)

db.close()

iterator instantRows(db: DbConn; query: SqlQuery; args: varargs[string, `$`]): InstantRow {.
	....}

Similar to fastRows iterator but returns a handle that can be used to get column text on demand using []. Returned handle is valid only within the iterator body.

Examples:

 let db = open("mytest.db", "", "", "")
 
 # Records of my_table:
 # | id | name 	|
 # |----|----------|
 # |  1 | item#1   |
 # |  2 | item#2   |
 
 for row in db.instantRows(sql"SELECT * FROM my_table"):
   echo "id:" & row[0]
   echo "name:" & row[1]
   echo "length:" & $len(row)
 
 # Output:
 # id:1
 # name:item#1
 # length:2
 # id:2
 # name:item#2
 # length:2
 
 db.close()

iterator instantRows(db: DbConn; stmtName: SqlPrepared): InstantRow {.
	....}

iterator rows(db: DbConn; query: SqlQuery; args: varargs[string, `$`]): Row {.
	....}

Similar to fastRows iterator, but slower and safe.

Examples:

let db = open("mytest.db", "", "", "")

# Records of my_table:
# | id | name 	|
# |----|----------|
# |  1 | item#1   |
# |  2 | item#2   |

for row in db.rows(sql"SELECT id, name FROM my_table"):
  echo row

## Output:
## @["1", "item#1"]
## @["2", "item#2"]

db.close()

iterator rows(db: DbConn; stmtName: SqlPrepared): Row {.
	....}

Macros

macro bindParams(ps: SqlPrepared; params: varargs[untyped]): untyped

Templates

template dbBindParamError(paramIdx: int; val: varargs[untyped])

	Raises a DbError exception.

template exec(db: DbConn; stmtName: SqlPrepared; args: varargs[typed]): untyped


Generic Operating System Services

std/rdstdin



std/rdstdin
Source   Edit  

This module contains code for reading from stdin. On UNIX the linenoise library is wrapped and set up to provide default key bindings (e.g. you can navigate with the arrow keys). On Windows system.readLine is used. This suffices because Windows' console already provides the wanted functionality.

Example: cmd: -r:off

import std/rdstdin
echo readLineFromStdin("Is Nim awesome? (Y/n): ")
var line: string
while true:
  let ok = readLineFromStdin("How are you? ", line)
  if not ok: break # ctrl-C or ctrl-D will cause a break
  if line.len > 0: echo line
echo "exiting"

Procs

proc readLineFromStdin(prompt: string): string {.
	....}

	Reads a line from stdin. Source   Edit   

proc readLineFromStdin(prompt: string; line: var string): bool {.
	....}

	Reads a line from stdin. line must not be nil! May throw an IO exception. A line of text may be delimited by CR, LF or CRLF. The newline character(s) are not part of the returned string. Returns false if the end of the file has been reached, true otherwise. If false is returned line contains no new data. Source   Edit   


Wrappers

std/winlean


std/winlean
Source   Edit  

This module implements a small wrapper for some needed Win API procedures, so that the Nim compiler does not depend on the huge Windows module.
Imports

dynlib

Types

AddrInfo = object
  ai_flags*: cint        	## Input flags.
  ai_family*: cint       	## Address family of socket.
  ai_socktype*: cint     	## Socket type.
  ai_protocol*: cint     	## Protocol of socket.
  ai_addrlen*: csize_t   	## Length of socket address.
  ai_canonname*: cstring 	## Canonical name of service location.
  ai_addr*: ptr SockAddr 	## Socket address of socket.
  ai_next*: ptr AddrInfo 	## Pointer to next in list.

	Source   Edit   

BY_HANDLE_FILE_INFORMATION = object
  dwFileAttributes*: DWORD
  ftCreationTime*: FILETIME
  ftLastAccessTime*: FILETIME
  ftLastWriteTime*: FILETIME
  dwVolumeSerialNumber*: DWORD
  nFileSizeHigh*: DWORD
  nFileSizeLow*: DWORD
  nNumberOfLinks*: DWORD
  nFileIndexHigh*: DWORD
  nFileIndexLow*: DWORD

	Source   Edit   

BYTE = uint8

	Source   Edit   

DWORD = int32

	Source   Edit   

FILETIME = object
  dwLowDateTime*: DWORD
  dwHighDateTime*: DWORD

	CANNOT BE int64 BECAUSE OF ALIGNMENT Source   Edit   

GUID = object
  D1*: int32
  D2*: int16
  D3*: int16
  D4*: array[0 .. 7, int8]

	Source   Edit   

Handle = int

	Source   Edit   

HDC = Handle

	Source   Edit   

HGLRC = Handle

	Source   Edit   

Hostent = object
  h_name*: cstring
  h_aliases*: cstringArray
  h_addrtype*: int16
  h_length*: int16
  h_addr_list*: cstringArray

	Source   Edit   

In6_addr {.importc: "IN6_ADDR", header: "winsock2.h".} = object
  bytes* {.importc: "u.Byte".}: array[0 .. 15, char]

	Source   Edit   

InAddr {.importc: "IN_ADDR", header: "winsock2.h", union.} = object
  s_addr*: uint32

	Source   Edit   

KEY_EVENT_RECORD = object
  eventType*: int16
  bKeyDown*: WINBOOL
  wRepeatCount*: int16
  wVirtualKeyCode*: int16
  wVirtualScanCode*: int16
  uChar*: int16
  dwControlKeyState*: DWORD

	Source   Edit   

LONG = int32

	Source   Edit   

LPFIBER_START_ROUTINE = proc (param: pointer) {.stdcall.}

	Source   Edit   

LPFILETIME = ptr FILETIME

	Source   Edit   

LPINT = ptr int32

	Source   Edit   

OSVERSIONINFO = object
  dwOSVersionInfoSize*: DWORD
  dwMajorVersion*: DWORD
  dwMinorVersion*: DWORD
  dwBuildNumber*: DWORD
  dwPlatformId*: DWORD
  szCSDVersion*: array[0 .. 127, WinChar]

	Source   Edit   

OVERLAPPED {.pure, inheritable.} = object
  internal*: PULONG
  internalHigh*: PULONG
  offset*: DWORD
  offsetHigh*: DWORD
  hEvent*: Handle

	Source   Edit   

PBOOL = ptr WINBOOL

	Source   Edit   

PDWORD = ptr DWORD

	Source   Edit   

POVERLAPPED = ptr OVERLAPPED

	Source   Edit   

POVERLAPPED_COMPLETION_ROUTINE = proc (para1: DWORD; para2: DWORD;
                                   	para3: POVERLAPPED) {.stdcall.}

	Source   Edit   

PROCESS_INFORMATION = object
  hProcess*: Handle
  hThread*: Handle
  dwProcessId*: int32
  dwThreadId*: int32

	Source   Edit   

Protoent = object
  p_name*: cstring
  p_aliases*: cstringArray
  p_proto*: cshort

	Source   Edit   

PSID = ptr SID

	Source   Edit   

PULONG = ptr int

	Source   Edit   

PULONG_PTR = ptr uint

	Source   Edit   

PWOHandleArray = ptr WOHandleArray

	Source   Edit   

SECURITY_ATTRIBUTES = object
  nLength*: int32
  lpSecurityDescriptor*: pointer
  bInheritHandle*: WINBOOL

	Source   Edit   

Servent = object
  s_name*: cstring
  s_aliases*: cstringArray
  when defined(cpu64):
	s_proto*: cstring
	s_port*: int16
  else:
	s_port*: int16
	s_proto*: cstring

	Source   Edit   

SID {.importc, header: "<windows.h>".} = object

	Source   Edit   

SID_IDENTIFIER_AUTHORITY {.importc, header: "<windows.h>".} = object
  value* {.importc: "Value".}: array[6, BYTE]

	Source   Edit   

SockAddr {.importc: "SOCKADDR", header: "winsock2.h".} = object
  sa_family*: uint16
  sa_data*: array[0 .. 13, char]

	Source   Edit   

Sockaddr_in {.importc: "SOCKADDR_IN", header: "winsock2.h".} = object
  sin_family*: uint16
  sin_port*: uint16
  sin_addr*: InAddr
  sin_zero*: array[0 .. 7, char]

	Source   Edit   

Sockaddr_in6 {.importc: "SOCKADDR_IN6", header: "ws2tcpip.h".} = object
  sin6_family*: uint16
  sin6_port*: uint16
  sin6_flowinfo*: int32
  sin6_addr*: In6_addr
  sin6_scope_id*: int32

	Source   Edit   

Sockaddr_storage {.importc: "SOCKADDR_STORAGE", header: "winsock2.h".} = object
  ss_family*: uint16

	Source   Edit   

SocketHandle = distinct int

	Source   Edit   

SockLen = cuint

	Source   Edit   

STARTUPINFO = object
  cb*: int32
  lpReserved*: cstring
  lpDesktop*: cstring
  lpTitle*: cstring
  dwX*: int32
  dwY*: int32
  dwXSize*: int32
  dwYSize*: int32
  dwXCountChars*: int32
  dwYCountChars*: int32
  dwFillAttribute*: int32
  dwFlags*: int32
  wShowWindow*: int16
  cbReserved2*: int16
  lpReserved2*: pointer
  hStdInput*: Handle
  hStdOutput*: Handle
  hStdError*: Handle

	Source   Edit   

TFdSet = object
  fd_count*: cint
  fd_array*: array[0 .. 64 - 1, SocketHandle]

	Source   Edit   

Timeval = object
  tv_sec*, tv_usec*: int32

	Source   Edit   

TWSABuf {.importc: "WSABUF", header: "winsock2.h".} = object
  len*: ULONG
  buf*: cstring

	Source   Edit   

ULONG = int32

	Source   Edit   

ULONG_PTR = uint

	Source   Edit   

WAITORTIMERCALLBACK = proc (para1: pointer; para2: int32) {.stdcall.}

	Source   Edit   

WIN32_FIND_DATA {.pure.} = object
  dwFileAttributes*: int32
  ftCreationTime*: FILETIME
  ftLastAccessTime*: FILETIME
  ftLastWriteTime*: FILETIME
  nFileSizeHigh*: int32
  nFileSizeLow*: int32
  cFileName*: array[0 .. 260 - 1, WinChar]
  cAlternateFileName*: array[0 .. 13, WinChar]

	Source   Edit   

WINBOOL = int32

	WINBOOL uses opposite convention as posix, !=0 meaning success. Source   Edit   

WinChar = Utf16Char

	Source   Edit   

WinSizeT = uint64

	Source   Edit   

WOHandleArray = array[0 .. 0x00000040 - 1, Handle]

	Source   Edit   

WSAData {.importc: "WSADATA", header: "winsock2.h".} = object

	Source   Edit   

WSAPROC_ACCEPTEX = proc (sListenSocket: SocketHandle;
                     	sAcceptSocket: SocketHandle; lpOutputBuffer: pointer;
                     	dwReceiveDataLength: DWORD;
                     	dwLocalAddressLength: DWORD;
                     	dwRemoteAddressLength: DWORD;
                     	lpdwBytesReceived: ptr DWORD; lpOverlapped: POVERLAPPED): bool {.
	stdcall, ....}

	Source   Edit   

WSAPROC_CONNECTEX = proc (s: SocketHandle; name: ptr SockAddr; namelen: cint;
                      	lpSendBuffer: pointer; dwSendDataLength: DWORD;
                      	lpdwBytesSent: ptr DWORD; lpOverlapped: POVERLAPPED): bool {.
	stdcall, ....}

	Source   Edit   

WSAPROC_GETACCEPTEXSOCKADDRS = proc (lpOutputBuffer: pointer;
                                 	dwReceiveDataLength: DWORD;
                                 	dwLocalAddressLength: DWORD;
                                 	dwRemoteAddressLength: DWORD;
                                 	LocalSockaddr: ptr PSockAddr;
                                 	LocalSockaddrLength: ptr cint;
                                 	RemoteSockaddr: ptr PSockAddr;
                                 	RemoteSockaddrLength: ptr cint) {.stdcall,
	....}

	Source   Edit   

Vars

INVALID_SOCKET {.importc, header: "winsock2.h".}: SocketHandle

	Source   Edit   

SO_ACCEPTCONN {.importc, header: "winsock2.h".}: cint

	Source   Edit   

SO_BROADCAST {.importc, header: "winsock2.h".}: cint

	Source   Edit   

SO_DEBUG {.importc, header: "winsock2.h".}: cint

	turn on debugging info recording Source   Edit   

SO_DONTLINGER {.importc, header: "winsock2.h".}: cint

	Source   Edit   

SO_DONTROUTE {.importc, header: "winsock2.h".}: cint

	Source   Edit   

SO_ERROR {.importc, header: "winsock2.h".}: cint

	Source   Edit   

SO_EXCLUSIVEADDRUSE {.importc, header: "winsock2.h".}: cint

	Source   Edit   

SO_KEEPALIVE {.importc, header: "winsock2.h".}: cint

	Source   Edit   

SO_LINGER {.importc, header: "winsock2.h".}: cint

	Source   Edit   

SO_OOBINLINE {.importc, header: "winsock2.h".}: cint

	Source   Edit   

SO_REUSEADDR {.importc, header: "winsock2.h".}: cint

	Source   Edit   

SO_REUSEPORT {.importc: "SO_REUSEADDR", header: "winsock2.h".}: cint

	Source   Edit   

SO_USELOOPBACK {.importc, header: "winsock2.h".}: cint

	Source   Edit   

SOL_SOCKET {.importc, header: "winsock2.h".}: cint

	Source   Edit   

SOMAXCONN {.importc, header: "winsock2.h".}: cint

	Source   Edit   

TCP_NODELAY {.importc, header: "winsock2.h".}: cint

	Source   Edit   

WSAID_ACCEPTEX: GUID = GUID(D1: 0xB5367DF1'i32, D2: 0xCBAC'i16, D3: 0x000011CF, D4: [
	0x95'i8, 0xCA'i8, 0x00'i8, 0x80'i8, 0x5F'i8, 0x48'i8, 0xA1'i8, 0x92'i8])

	Source   Edit   

WSAID_CONNECTEX: GUID = GUID(D1: 0x25A207B9, D2: 0xDDF3'i16, D3: 0x00004660, D4: [
	0x8E'i8, 0xE9'i8, 0x76'i8, 0xE5'i8, 0x8C'i8, 0x74'i8, 0x06'i8, 0x3E'i8])

	Source   Edit   

WSAID_GETACCEPTEXSOCKADDRS: GUID = GUID(D1: 0xB5367DF2'i32, D2: 0xCBAC'i16,
                                    	D3: 0x000011CF, D4: [0x95'i8, 0xCA'i8,
	0x00'i8, 0x80'i8, 0x5F'i8, 0x48'i8, 0xA1'i8, 0x92'i8])

	Source   Edit   

Consts

AF_INET = 2

	Source   Edit   

AF_INET6 = 23

	Source   Edit   

AF_UNSPEC = 0

	Source   Edit   

AI_V4MAPPED = 0x00000008

	Source   Edit   

CREATE_ALWAYS = 2'i32

	Source   Edit   

CREATE_NEW = 1'i32

	Source   Edit   

CREATE_NO_WINDOW = 0x08000000'i32

	Source   Edit   

CREATE_UNICODE_ENVIRONMENT = 1024'i32

	Source   Edit   

DETACHED_PROCESS = 8'i32

	Source   Edit   

DOMAIN_ALIAS_RID_ADMINS = 544

	Source   Edit   

DUPLICATE_SAME_ACCESS = 2

	Source   Edit   

ERROR_ACCESS_DENIED = 5

	Source   Edit   

ERROR_BAD_ARGUMENTS = 165

	Source   Edit   

ERROR_FILE_EXISTS = 80

	Source   Edit   

ERROR_FILE_NOT_FOUND = 2

	https://docs.microsoft.com/en-us/windows/win32/debug/system-error-codes--0-499- Source   Edit   

ERROR_HANDLE_EOF = 38

	Source   Edit   

ERROR_IO_PENDING = 997

	Source   Edit   

ERROR_LOCK_VIOLATION = 33

	Source   Edit   

ERROR_NETNAME_DELETED = 64

	Source   Edit   

ERROR_NO_MORE_FILES = 18

	Source   Edit   

ERROR_PATH_NOT_FOUND = 3

	Source   Edit   

FD_ACCEPT = 0x00000008'i32

	Source   Edit   

FD_ADDRESS_LIST_CHANGE = 0x00000200'i32

	Source   Edit   

FD_ALL_EVENTS = 0x000003FF'i32

	Source   Edit   

FD_CLOSE = 0x00000020'i32

	Source   Edit   

FD_CONNECT = 0x00000010'i32

	Source   Edit   

FD_GROUP_QQS = 0x00000080'i32

	Source   Edit   

FD_OOB = 0x00000004'i32

	Source   Edit   

FD_QQS = 0x00000040'i32

	Source   Edit   

FD_READ = 0x00000001'i32

	Source   Edit   

FD_ROUTING_INTERFACE_CHANGE = 0x00000100'i32

	Source   Edit   

FD_SETSIZE = 64

	Source   Edit   

FD_WRITE = 0x00000002'i32

	Source   Edit   

FIBER_FLAG_FLOAT_SWITCH = 0x00000001

	Source   Edit   

FILE_ATTRIBUTE_ARCHIVE = 0x00000020'i32

	Source   Edit   

FILE_ATTRIBUTE_COMPRESSED = 0x00000800'i32

	Source   Edit   

FILE_ATTRIBUTE_DEVICE = 0x00000040'i32

	Source   Edit   

FILE_ATTRIBUTE_DIRECTORY = 0x00000010'i32

	Source   Edit   

FILE_ATTRIBUTE_HIDDEN = 0x00000002'i32

	Source   Edit   

FILE_ATTRIBUTE_NORMAL = 0x00000080'i32

	Source   Edit   

FILE_ATTRIBUTE_NOT_CONTENT_INDEXED = 0x00002000'i32

	Source   Edit   

FILE_ATTRIBUTE_OFFLINE = 0x00001000'i32

	Source   Edit   

FILE_ATTRIBUTE_READONLY = 0x00000001'i32

	Source   Edit   

FILE_ATTRIBUTE_REPARSE_POINT = 0x00000400'i32

	Source   Edit   

FILE_ATTRIBUTE_SPARSE_FILE = 0x00000200'i32

	Source   Edit   

FILE_ATTRIBUTE_SYSTEM = 0x00000004'i32

	Source   Edit   

FILE_ATTRIBUTE_TEMPORARY = 0x00000100'i32

	Source   Edit   

FILE_BEGIN = 0'i32

	Source   Edit   

FILE_FLAG_BACKUP_SEMANTICS = 0x02000000'i32

	Source   Edit   

FILE_FLAG_DELETE_ON_CLOSE = 0x04000000'i32

	Source   Edit   

FILE_FLAG_FIRST_PIPE_INSTANCE = 0x00080000'i32

	Source   Edit   

FILE_FLAG_NO_BUFFERING = 0x20000000'i32

	Source   Edit   

FILE_FLAG_OPEN_NO_RECALL = 0x00100000'i32

	Source   Edit   

FILE_FLAG_OPEN_REPARSE_POINT = 0x00200000'i32

	Source   Edit   

FILE_FLAG_OVERLAPPED = 0x40000000'i32

	Source   Edit   

FILE_FLAG_POSIX_SEMANTICS = 0x01000000'i32

	Source   Edit   

FILE_FLAG_RANDOM_ACCESS = 0x10000000'i32

	Source   Edit   

FILE_FLAG_SEQUENTIAL_SCAN = 0x08000000'i32

	Source   Edit   

FILE_FLAG_WRITE_THROUGH = 0x80000000'i32

	Source   Edit   

FILE_MAP_READ = 4'i32

	Source   Edit   

FILE_MAP_WRITE = 2'i32

	Source   Edit   

FILE_READ_DATA = 0x00000001

	Source   Edit   

FILE_SHARE_DELETE = 4'i32

	Source   Edit   

FILE_SHARE_READ = 1'i32

	Source   Edit   

FILE_SHARE_WRITE = 2'i32

	Source   Edit   

FILE_WRITE_DATA = 0x00000002

	Source   Edit   

GENERIC_ALL = 0x10000000'i32

	Source   Edit   

GENERIC_READ = 0x80000000'i32

	Source   Edit   

GENERIC_WRITE = 0x40000000'i32

	Source   Edit   

HANDLE_FLAG_INHERIT = 0x00000001'i32

	Source   Edit   

HIGH_PRIORITY_CLASS = 128'i32

	Source   Edit   

IDLE_PRIORITY_CLASS = 64'i32

	Source   Edit   

INADDR_ANY = 0'u32

	Source   Edit   

INADDR_BROADCAST = -1

	Source   Edit   

INADDR_LOOPBACK = 0x7F000001

	Source   Edit   

INADDR_NONE = -1

	Source   Edit   

INFINITE = -1'i32

	Source   Edit   

INVALID_FILE_SIZE = -1'i32

	Source   Edit   

INVALID_HANDLE_VALUE = -1

	Source   Edit   

INVALID_SET_FILE_POINTER = -1'i32

	Source   Edit   

IOC_IN = 0x80000000'i32

	Source   Edit   

IOC_INOUT = -1073741824'i32

	Source   Edit   

IOC_OUT = 0x40000000'i32

	Source   Edit   

IOC_WS2 = 0x08000000'i32

	Source   Edit   

MAX_PATH = 260

	Source   Edit   

MAXIMUM_WAIT_OBJECTS = 0x00000040

	Source   Edit   

MOVEFILE_COPY_ALLOWED = 0x00000002'i32

	Source   Edit   

MOVEFILE_CREATE_HARDLINK = 0x00000010'i32

	Source   Edit   

MOVEFILE_DELAY_UNTIL_REBOOT = 0x00000004'i32

	Source   Edit   

MOVEFILE_FAIL_IF_NOT_TRACKABLE = 0x00000020'i32

	Source   Edit   

MOVEFILE_REPLACE_EXISTING = 0x00000001'i32

	Source   Edit   

MOVEFILE_WRITE_THROUGH = 0x00000008'i32

	Source   Edit   

MSG_PEEK = 2

	Source   Edit   

NO_ERROR = 0'i32

	Source   Edit   

NORMAL_PRIORITY_CLASS = 32'i32

	Source   Edit   

OPEN_ALWAYS = 4'i32

	Source   Edit   

OPEN_EXISTING = 3'i32

	Source   Edit   

PAGE_EXECUTE = 0x00000010'i32

	Source   Edit   

PAGE_EXECUTE_READ = 0x00000020'i32

	Source   Edit   

PAGE_EXECUTE_READWRITE = 0x00000040'i32

	Source   Edit   

PAGE_NOACCESS = 0x00000001'i32

	Source   Edit   

PAGE_READONLY = 2'i32

	Source   Edit   

PAGE_READWRITE = 4'i32

	Source   Edit   

PIPE_ACCESS_DUPLEX = 0x00000003'i32

	Source   Edit   

PIPE_ACCESS_INBOUND = 1'i32

	Source   Edit   

PIPE_ACCESS_OUTBOUND = 2'i32

	Source   Edit   

PIPE_NOWAIT = 0x00000001'i32

	Source   Edit   

PROCESS_CREATE_PROCESS = 0x00000080'i32

	Source   Edit   

PROCESS_CREATE_THREAD = 0x00000002'i32

	Source   Edit   

PROCESS_DUP_HANDLE = 0x00000040'i32

	Source   Edit   

PROCESS_QUERY_INFORMATION = 0x00000400'i32

	Source   Edit   

PROCESS_QUERY_LIMITED_INFORMATION = 0x00001000'i32

	Source   Edit   

PROCESS_SET_INFORMATION = 0x00000200'i32

	Source   Edit   

PROCESS_SET_LIMITED_INFORMATION = 0x00002000'i32

	Source   Edit   

PROCESS_SET_QUOTA = 0x00000100'i32

	Source   Edit   

PROCESS_SET_SESSIONID = 0x00000004'i32

	Source   Edit   

PROCESS_SUSPEND_RESUME = 0x00000800'i32

	Source   Edit   

PROCESS_TERMINATE = 0x00000001'i32

	Source   Edit   

PROCESS_VM_OPERATION = 0x00000008'i32

	Source   Edit   

PROCESS_VM_READ = 0x00000010'i32

	Source   Edit   

PROCESS_VM_WRITE = 0x00000020'i32

	Source   Edit   

REALTIME_PRIORITY_CLASS = 256'i32

	Source   Edit   

SECURITY_BUILTIN_DOMAIN_RID = 32

	Source   Edit   

SECURITY_NT_AUTHORITY = [0'u, 0'u, 0'u, 0'u, 0'u, 5'u]

	Source   Edit   

SIO_GET_EXTENSION_FUNCTION_POINTER = -939524090'i32

	Source   Edit   

SO_UPDATE_ACCEPT_CONTEXT = 0x0000700B

	Source   Edit   

STARTF_USESHOWWINDOW = 1'i32

	Source   Edit   

STARTF_USESTDHANDLES = 256'i32

	Source   Edit   

STATUS_PENDING = 0x00000103

	Source   Edit   

STD_ERROR_HANDLE = -12'i32

	Source   Edit   

STD_INPUT_HANDLE = -10'i32

	Source   Edit   

STD_OUTPUT_HANDLE = -11'i32

	Source   Edit   

STILL_ACTIVE = 0x00000103'i32

	Source   Edit   

SW_SHOWNORMAL = 1'i32

	Source   Edit   

SYNCHRONIZE = 0x00100000'i32

	Source   Edit   

WAIT_FAILED = 0xFFFFFFFF'i32

	Source   Edit   

WAIT_OBJECT_0 = 0'i32

	Source   Edit   

WAIT_TIMEOUT = 0x00000102'i32

	Source   Edit   

WSADESCRIPTION_LEN = 256

	Source   Edit   

WSAEADDRINUSE = 10048

	Source   Edit   

WSAECONNABORTED = 10053

	Source   Edit   

WSAECONNRESET = 10054

	Source   Edit   

WSAEDISCON = 10101

	Source   Edit   

WSAEINPROGRESS = 10036

	Source   Edit   

WSAEINTR = 10004

	Source   Edit   

WSAENETRESET = 10052

	Source   Edit   

WSAENOTSOCK = 10038

	Source   Edit   

WSAESHUTDOWN = 10058

	Source   Edit   

WSAETIMEDOUT = 10060

	Source   Edit   

WSAEWOULDBLOCK = 10035

	Source   Edit   

WSANOTINITIALISED = 10093

	Source   Edit   

WSASYS_STATUS_LEN = 128

	Source   Edit   

WT_EXECUTEDEFAULT = 0x00000000'i32

	Source   Edit   

WT_EXECUTEINIOTHREAD = 0x00000001'i32

	Source   Edit   

WT_EXECUTEINPERSISTENTIOTHREAD = 0x00000040'i32

	Source   Edit   

WT_EXECUTEINPERSISTENTTHREAD = 0x00000080'i32

	Source   Edit   

WT_EXECUTEINTIMERTHREAD = 0x00000020'i32

	Source   Edit   

WT_EXECUTEINUITHREAD = 0x00000002'i32

	Source   Edit   

WT_EXECUTEINWAITTHREAD = 0x00000004'i32

	Source   Edit   

WT_EXECUTELONGFUNCTION = 0x00000010'i32

	Source   Edit   

WT_EXECUTEONLYONCE = 0x00000008'i32

	Source   Edit   

WT_TRANSFER_IMPERSONATION = 0x00000100'i32

	Source   Edit   

Procs

proc `==`(x, y: SocketHandle): bool {.borrow, ....}

	Source   Edit   

proc accept(s: SocketHandle; a: ptr SockAddr; addrlen: ptr SockLen): SocketHandle {.
	stdcall, importc: "accept", dynlib: ws2dll, ....}

	Source   Edit   

proc allocateAndInitializeSid(pIdentifierAuthority: ptr SID_IDENTIFIER_AUTHORITY;
                          	nSubAuthorityCount: BYTE; nSubAuthority0: DWORD;
                          	nSubAuthority1: DWORD; nSubAuthority2: DWORD;
                          	nSubAuthority3: DWORD; nSubAuthority4: DWORD;
                          	nSubAuthority5: DWORD; nSubAuthority6: DWORD;
                          	nSubAuthority7: DWORD; pSid: ptr PSID): WINBOOL {.
	stdcall, dynlib: "Advapi32", importc: "AllocateAndInitializeSid",
	....}

	Source   Edit   

proc bindSocket(s: SocketHandle; name: ptr SockAddr; namelen: SockLen): cint {.
	stdcall, importc: "bind", dynlib: ws2dll, ....}

	Source   Edit   

proc checkTokenMembership(tokenHandle: Handle; sidToCheck: PSID; isMember: PBOOL): WINBOOL {.
	stdcall, dynlib: "Advapi32", importc: "CheckTokenMembership", ....}

	Source   Edit   

proc closeHandle(hObject: Handle): WINBOOL {.stdcall, dynlib: "kernel32",
	importc: "CloseHandle", ....}

	Source   Edit   

proc closesocket(s: SocketHandle): cint {.stdcall, importc: "closesocket",
	dynlib: ws2dll, ....}

	Source   Edit   

proc connect(s: SocketHandle; name: ptr SockAddr; namelen: SockLen): cint {.
	stdcall, importc: "connect", dynlib: ws2dll, ....}

	Source   Edit   

proc ConvertThreadToFiber(param: pointer): pointer {.stdcall, discardable,
	dynlib: "kernel32", importc, ....}

	Source   Edit   

proc ConvertThreadToFiberEx(param: pointer; flags: int32): pointer {.stdcall,
	discardable, dynlib: "kernel32", importc, ....}

	Source   Edit   

proc copyFileW(lpExistingFileName, lpNewFileName: WideCString;
           	bFailIfExists: WINBOOL): WINBOOL {.importc: "CopyFileW", stdcall,
	dynlib: "kernel32", sideEffect, ....}

	Source   Edit   

proc createDirectoryW(pathName: WideCString; security: pointer = nil): int32 {.
	importc: "CreateDirectoryW", dynlib: "kernel32", stdcall, sideEffect,
	....}

	Source   Edit   

proc createEvent(lpEventAttributes: ptr SECURITY_ATTRIBUTES;
             	bManualReset: DWORD; bInitialState: DWORD;
             	lpName: ptr Utf16Char): Handle {.stdcall, dynlib: "kernel32",
	importc: "CreateEventW", ....}

	Source   Edit   

proc CreateFiber(stackSize: int; fn: LPFIBER_START_ROUTINE; param: pointer): pointer {.
	stdcall, discardable, dynlib: "kernel32", importc, ....}

	Source   Edit   

proc CreateFiberEx(stkCommit: int; stkReserve: int; flags: int32;
               	fn: LPFIBER_START_ROUTINE; param: pointer): pointer {.
	stdcall, discardable, dynlib: "kernel32", importc, ....}

	Source   Edit   

proc createFileA(lpFileName: cstring; dwDesiredAccess, dwShareMode: DWORD;
             	lpSecurityAttributes: pointer;
             	dwCreationDisposition, dwFlagsAndAttributes: DWORD;
             	hTemplateFile: Handle): Handle {.stdcall, dynlib: "kernel32",
	importc: "CreateFileA", ....}

	Source   Edit   

proc createFileMappingW(hFile: Handle; lpFileMappingAttributes: pointer;
                    	flProtect, dwMaximumSizeHigh: DWORD;
                    	dwMaximumSizeLow: DWORD; lpName: pointer): Handle {.
	stdcall, dynlib: "kernel32", importc: "CreateFileMappingW", ....}

	Source   Edit   

proc createFileW(lpFileName: WideCString; dwDesiredAccess, dwShareMode: DWORD;
             	lpSecurityAttributes: pointer;
             	dwCreationDisposition, dwFlagsAndAttributes: DWORD;
             	hTemplateFile: Handle): Handle {.stdcall, dynlib: "kernel32",
	importc: "CreateFileW", ....}

	Source   Edit   

proc createHardLinkW(lpFileName, lpExistingFileName: WideCString;
                 	security: pointer = nil): int32 {.
	importc: "CreateHardLinkW", dynlib: "kernel32", stdcall, sideEffect,
	....}

	Source   Edit   

proc createIoCompletionPort(FileHandle: Handle; ExistingCompletionPort: Handle;
                        	CompletionKey: ULONG_PTR;
                        	NumberOfConcurrentThreads: DWORD): Handle {.stdcall,
	dynlib: "kernel32", importc: "CreateIoCompletionPort", ....}

	Source   Edit   

proc createNamedPipe(lpName: WideCString; dwOpenMode, dwPipeMode, nMaxInstances,
	nOutBufferSize, nInBufferSize, nDefaultTimeOut: int32;
                 	lpSecurityAttributes: ptr SECURITY_ATTRIBUTES): Handle {.
	stdcall, dynlib: "kernel32", importc: "CreateNamedPipeW", sideEffect,
	....}

	Source   Edit   

proc createPipe(hReadPipe, hWritePipe: var Handle;
            	lpPipeAttributes: var SECURITY_ATTRIBUTES; nSize: int32): WINBOOL {.
	stdcall, dynlib: "kernel32", importc: "CreatePipe", sideEffect, ....}

	Source   Edit   

proc createProcessW(lpApplicationName, lpCommandLine: WideCString;
                	lpProcessAttributes: ptr SECURITY_ATTRIBUTES;
                	lpThreadAttributes: ptr SECURITY_ATTRIBUTES;
                	bInheritHandles: WINBOOL; dwCreationFlags: int32;
                	lpEnvironment, lpCurrentDirectory: WideCString;
                	lpStartupInfo: var STARTUPINFO;
                	lpProcessInformation: var PROCESS_INFORMATION): WINBOOL {.
	stdcall, dynlib: "kernel32", importc: "CreateProcessW", sideEffect,
	....}

	Source   Edit   

proc createSymbolicLinkW(lpSymlinkFileName, lpTargetFileName: WideCString;
                     	flags: DWORD): int32 {.importc: "CreateSymbolicLinkW",
	dynlib: "kernel32", stdcall, sideEffect, ....}

	Source   Edit   

proc DeleteFiber(fiber: pointer) {.stdcall, discardable, dynlib: "kernel32",
                               	importc, ....}

	Source   Edit   

proc deleteFileA(pathName: cstring): int32 {.importc: "DeleteFileA",
	dynlib: "kernel32", stdcall, ....}

	Source   Edit   

proc deleteFileW(pathName: WideCString): int32 {.importc: "DeleteFileW",
	dynlib: "kernel32", stdcall, ....}

	Source   Edit   

proc duplicateHandle(hSourceProcessHandle: Handle; hSourceHandle: Handle;
                 	hTargetProcessHandle: Handle; lpTargetHandle: ptr Handle;
                 	dwDesiredAccess: DWORD; bInheritHandle: WINBOOL;
                 	dwOptions: DWORD): WINBOOL {.stdcall, dynlib: "kernel32",
	importc: "DuplicateHandle", ....}

	Source   Edit   

proc FD_ISSET(socket: SocketHandle; set: var TFdSet): cint {.....}

	Source   Edit   

proc FD_SET(socket: SocketHandle; s: var TFdSet) {.....}

	Source   Edit   

proc FD_ZERO(s: var TFdSet) {.....}

	Source   Edit   

proc findClose(hFindFile: Handle) {.stdcall, dynlib: "kernel32",
                                	importc: "FindClose", ....}

	Source   Edit   

proc findFirstFileW(lpFileName: WideCString; lpFindFileData: var WIN32_FIND_DATA): Handle {.
	stdcall, dynlib: "kernel32", importc: "FindFirstFileW", sideEffect,
	....}

	Source   Edit   

proc findNextFileW(hFindFile: Handle; lpFindFileData: var WIN32_FIND_DATA): int32 {.
	stdcall, dynlib: "kernel32", importc: "FindNextFileW", sideEffect,
	....}

	Source   Edit   

proc flushFileBuffers(hFile: Handle): WINBOOL {.stdcall, dynlib: "kernel32",
	importc: "FlushFileBuffers", sideEffect, ....}

	Source   Edit   

proc flushViewOfFile(lpBaseAddress: pointer; dwNumberOfBytesToFlush: DWORD): WINBOOL {.
	stdcall, dynlib: "kernel32", importc: "FlushViewOfFile", ....}

	Source   Edit   

proc formatMessageW(dwFlags: int32; lpSource: pointer;
                	dwMessageId, dwLanguageId: int32; lpBuffer: pointer;
                	nSize: int32; arguments: pointer): int32 {.
	importc: "FormatMessageW", stdcall, dynlib: "kernel32", ....}

	Source   Edit   

proc freeAddrInfo(ai: ptr AddrInfo) {.stdcall, importc: "freeaddrinfo",
                                  	dynlib: ws2dll, ....}

	Source   Edit   

proc freeEnvironmentStringsW(para1: WideCString): int32 {.stdcall,
	dynlib: "kernel32", importc: "FreeEnvironmentStringsW", sideEffect,
	....}

	Source   Edit   

proc freeSid(pSid: PSID): PSID {.stdcall, dynlib: "Advapi32",
                             	importc: "FreeSid", ....}

	Source   Edit   

proc get_osfhandle(fd: FileHandle): Handle {.importc: "_get_osfhandle",
	header: "<io.h>", ....}

	Source   Edit   

proc getaddrinfo(nodename, servname: cstring; hints: ptr AddrInfo;
             	res: var ptr AddrInfo): cint {.stdcall, importc: "getaddrinfo",
	dynlib: ws2dll, ....}

	Source   Edit   

proc getCommandLineW(): WideCString {.importc: "GetCommandLineW", stdcall,
                                  	dynlib: "kernel32", sideEffect,
                                  	....}

	Source   Edit   

proc getCurrentDirectoryW(nBufferLength: int32; lpBuffer: WideCString): int32 {.
	importc: "GetCurrentDirectoryW", dynlib: "kernel32", stdcall, sideEffect,
	....}

	Source   Edit   

proc GetCurrentFiber(): pointer {.stdcall, importc, header: "windows.h",
                              	....}

	Source   Edit   

proc getCurrentProcess(): Handle {.stdcall, dynlib: "kernel32",
                               	importc: "GetCurrentProcess", ....}

	Source   Edit   

proc getEnvironmentStringsW(): WideCString {.stdcall, dynlib: "kernel32",
	importc: "GetEnvironmentStringsW", sideEffect, ....}

	Source   Edit   

proc getExitCodeProcess(hProcess: Handle; lpExitCode: var int32): WINBOOL {.
	stdcall, dynlib: "kernel32", importc: "GetExitCodeProcess", ....}

	Source   Edit   

proc getFileAttributesW(lpFileName: WideCString): int32 {.stdcall,
	dynlib: "kernel32", importc: "GetFileAttributesW", sideEffect, ....}

	Source   Edit   

proc getFileInformationByHandle(hFile: Handle; lpFileInformation: ptr BY_HANDLE_FILE_INFORMATION): WINBOOL {.
	stdcall, dynlib: "kernel32", importc: "GetFileInformationByHandle",
	sideEffect, ....}

	Source   Edit   

proc getFileSize(hFile: Handle; lpFileSizeHigh: ptr DWORD): DWORD {.stdcall,
	dynlib: "kernel32", importc: "GetFileSize", ....}

	Source   Edit   

proc getFullPathNameW(lpFileName: WideCString; nBufferLength: int32;
                  	lpBuffer: WideCString; lpFilePart: var WideCString): int32 {.
	stdcall, dynlib: "kernel32", importc: "GetFullPathNameW", sideEffect,
	....}

	Source   Edit   

proc getHandleInformation(hObject: Handle; lpdwFlags: ptr DWORD): WINBOOL {.
	stdcall, dynlib: "kernel32", importc: "GetHandleInformation", ....}

	Source   Edit   

proc gethostbyaddr(ip: ptr InAddr; len: cuint; theType: cint): ptr Hostent {.
	stdcall, importc: "gethostbyaddr", dynlib: ws2dll, sideEffect, ....}

	Source   Edit   

proc gethostbyname(name: cstring): ptr Hostent {.stdcall,
	importc: "gethostbyname", dynlib: ws2dll, sideEffect, ....}

	Source   Edit   

proc gethostname(hostname: cstring; len: cint): cint {.stdcall,
	importc: "gethostname", dynlib: ws2dll, sideEffect, ....}

	Source   Edit   

proc getLastError(): int32 {.importc: "GetLastError", stdcall,
                         	dynlib: "kernel32", sideEffect, ....}

	Source   Edit   

proc getModuleFileNameW(handle: Handle; buf: WideCString; size: int32): int32 {.
	importc: "GetModuleFileNameW", dynlib: "kernel32", stdcall, ....}

	Source   Edit   

proc getnameinfo(a1: ptr SockAddr; a2: SockLen; a3: cstring; a4: SockLen;
             	a5: cstring; a6: SockLen; a7: cint): cint {.stdcall,
	importc: "getnameinfo", dynlib: ws2dll, ....}

	Source   Edit   

proc getOverlappedResult(hFile: Handle; lpOverlapped: POVERLAPPED;
                     	lpNumberOfBytesTransferred: var DWORD; bWait: WINBOOL): WINBOOL {.
	stdcall, dynlib: "kernel32", importc: "GetOverlappedResult", ....}

	Source   Edit   

proc getpeername(s: SocketHandle; name: ptr SockAddr; namelen: ptr SockLen): cint {.
	stdcall, importc, dynlib: ws2dll, ....}

	Source   Edit   

proc getProcessTimes(hProcess: Handle; lpCreationTime, lpExitTime, lpKernelTime,
                                   	lpUserTime: var FILETIME): WINBOOL {.
	stdcall, dynlib: "kernel32", importc: "GetProcessTimes", ....}

	Source   Edit   

proc getprotobyname(name: cstring): ptr Protoent {.stdcall,
	importc: "getprotobyname", dynlib: ws2dll, sideEffect, ....}

	Source   Edit   

proc getprotobynumber(proto: cint): ptr Protoent {.stdcall,
	importc: "getprotobynumber", dynlib: ws2dll, sideEffect, ....}

	Source   Edit   

proc getQueuedCompletionStatus(CompletionPort: Handle;
                           	lpNumberOfBytesTransferred: PDWORD;
                           	lpCompletionKey: PULONG_PTR;
                           	lpOverlapped: ptr POVERLAPPED;
                           	dwMilliseconds: DWORD): WINBOOL {.stdcall,
	dynlib: "kernel32", importc: "GetQueuedCompletionStatus", ....}

	Source   Edit   

proc getservbyname(name, proto: cstring): ptr Servent {.stdcall,
	importc: "getservbyname", dynlib: ws2dll, sideEffect, ....}

	Source   Edit   

proc getservbyport(port: cint; proto: cstring): ptr Servent {.stdcall,
	importc: "getservbyport", dynlib: ws2dll, sideEffect, ....}

	Source   Edit   

proc getsockname(s: SocketHandle; name: ptr SockAddr; namelen: ptr SockLen): cint {.
	stdcall, importc: "getsockname", dynlib: ws2dll, ....}

	Source   Edit   

proc getsockopt(s: SocketHandle; level, optname: cint; optval: pointer;
            	optlen: ptr SockLen): cint {.stdcall, importc: "getsockopt",
	dynlib: ws2dll, ....}

	Source   Edit   

proc getStdHandle(nStdHandle: int32): Handle {.stdcall, dynlib: "kernel32",
	importc: "GetStdHandle", ....}

	Source   Edit   

proc getSystemTimeAsFileTime(lpSystemTimeAsFileTime: var FILETIME) {.
	importc: "GetSystemTimeAsFileTime", dynlib: "kernel32", stdcall, sideEffect,
	....}

	Source   Edit   

proc getSystemTimePreciseAsFileTime(lpSystemTimeAsFileTime: var FILETIME) {.
	importc: "GetSystemTimePreciseAsFileTime", dynlib: "kernel32", stdcall,
	sideEffect, ....}

	Source   Edit   

proc getSystemTimes(lpIdleTime, lpKernelTime, lpUserTime: var FILETIME): WINBOOL {.
	stdcall, dynlib: "kernel32", importc: "GetSystemTimes", ....}

	Source   Edit   

proc getVersion(): DWORD {.stdcall, dynlib: "kernel32", importc: "GetVersion",
                       	sideEffect, ....}

	Source   Edit   

proc getVersionExA(lpVersionInfo: ptr OSVERSIONINFO): WINBOOL {.stdcall,
	dynlib: "kernel32", importc: "GetVersionExA", sideEffect, ....}

	Source   Edit   

proc getVersionExW(lpVersionInfo: ptr OSVERSIONINFO): WINBOOL {.stdcall,
	dynlib: "kernel32", importc: "GetVersionExW", sideEffect, ....}

	Source   Edit   

proc inet_addr(cp: cstring): uint32 {.stdcall, importc: "inet_addr",
                                  	dynlib: ws2dll, ....}

	Source   Edit   

proc inet_ntoa(i: InAddr): cstring {.stdcall, importc, dynlib: ws2dll,
                                 	....}

	Source   Edit   

proc inet_ntop(family: cint; paddr: pointer; pStringBuffer: cstring;
           	stringBufSize: int32): cstring {.stdcall, ....}

	Source   Edit   

proc isSuccess(a: WINBOOL): bool {.inline, ....}

	Returns true if a != 0. Windows uses a different convention than POSIX, where a == 0 is commonly used on success. Source   Edit   

proc listen(s: SocketHandle; backlog: cint): cint {.stdcall, importc: "listen",
	dynlib: ws2dll, ....}

	Source   Edit   

proc localFree(p: pointer) {.importc: "LocalFree", stdcall, dynlib: "kernel32",
                         	....}

	Source   Edit   

proc mapViewOfFileEx(hFileMappingObject: Handle; dwDesiredAccess: DWORD;
                 	dwFileOffsetHigh, dwFileOffsetLow: DWORD;
                 	dwNumberOfBytesToMap: WinSizeT; lpBaseAddress: pointer): pointer {.
	stdcall, dynlib: "kernel32", importc: "MapViewOfFileEx", ....}

	Source   Edit   

proc moveFileExW(lpExistingFileName, lpNewFileName: WideCString; flags: DWORD): WINBOOL {.
	importc: "MoveFileExW", stdcall, dynlib: "kernel32", sideEffect, ....}

	Source   Edit   

proc moveFileW(lpExistingFileName, lpNewFileName: WideCString): WINBOOL {.
	importc: "MoveFileW", stdcall, dynlib: "kernel32", sideEffect, ....}

	Source   Edit   

proc openProcess(dwDesiredAccess: DWORD; bInheritHandle: WINBOOL;
             	dwProcessId: DWORD): Handle {.stdcall, dynlib: "kernel32",
	importc: "OpenProcess", ....}

	Source   Edit   

proc peekNamedPipe(hNamedPipe: Handle; lpBuffer: pointer = nil;
               	nBufferSize: int32 = 0; lpBytesRead: ptr int32 = nil;
               	lpTotalBytesAvail: ptr int32 = nil;
               	lpBytesLeftThisMessage: ptr int32 = nil): bool {.stdcall,
	dynlib: "kernel32", importc: "PeekNamedPipe", ....}

	Source   Edit   

proc postQueuedCompletionStatus(CompletionPort: Handle;
                            	dwNumberOfBytesTransferred: DWORD;
                            	dwCompletionKey: ULONG_PTR;
                            	lpOverlapped: pointer): bool {.stdcall,
	dynlib: "kernel32", importc: "PostQueuedCompletionStatus", ....}

	Source   Edit   

proc rdFileSize(f: WIN32_FIND_DATA): int64 {.....}

	Source   Edit   

proc rdFileTime(f: FILETIME): int64 {.....}

	Source   Edit   

proc readConsoleInput(hConsoleInput: Handle; lpBuffer: pointer; nLength: cint;
                  	lpNumberOfEventsRead: ptr cint): cint {.stdcall,
	dynlib: "kernel32", importc: "ReadConsoleInputW", ....}

	Source   Edit   

proc readFile(hFile: Handle; buffer: pointer; nNumberOfBytesToRead: int32;
          	lpNumberOfBytesRead: ptr int32; lpOverlapped: pointer): WINBOOL {.
	stdcall, dynlib: "kernel32", importc: "ReadFile", sideEffect, ....}

	Source   Edit   

proc recv(s: SocketHandle; buf: pointer; len, flags: cint): cint {.stdcall,
	importc: "recv", dynlib: ws2dll, ....}

	Source   Edit   

proc recvfrom(s: SocketHandle; buf: cstring; len, flags: cint;
          	fromm: ptr SockAddr; fromlen: ptr SockLen): cint {.stdcall,
	importc: "recvfrom", dynlib: ws2dll, ....}

	Source   Edit   

proc registerWaitForSingleObject(phNewWaitObject: ptr Handle; hObject: Handle;
                             	Callback: WAITORTIMERCALLBACK;
                             	Context: pointer; dwMilliseconds: ULONG;
                             	dwFlags: ULONG): bool {.stdcall,
	dynlib: "kernel32", importc: "RegisterWaitForSingleObject", ....}

	Source   Edit   

proc removeDirectoryW(lpPathName: WideCString): int32 {.
	importc: "RemoveDirectoryW", dynlib: "kernel32", stdcall, sideEffect,
	....}

	Source   Edit   

proc resumeThread(hThread: Handle): int32 {.stdcall, dynlib: "kernel32",
	importc: "ResumeThread", sideEffect, ....}

	Source   Edit   

proc select(nfds: cint; readfds, writefds, exceptfds: ptr TFdSet;
        	timeout: ptr Timeval): cint {.stdcall, importc: "select",
	dynlib: ws2dll, ....}

	Source   Edit   

proc send(s: SocketHandle; buf: pointer; len, flags: cint): cint {.stdcall,
	importc: "send", dynlib: ws2dll, ....}

	Source   Edit   

proc sendto(s: SocketHandle; buf: pointer; len, flags: cint; to: ptr SockAddr;
        	tolen: SockLen): cint {.stdcall, importc: "sendto", dynlib: ws2dll,
                                	....}

	Source   Edit   

proc setCurrentDirectoryW(lpPathName: WideCString): int32 {.
	importc: "SetCurrentDirectoryW", dynlib: "kernel32", stdcall, sideEffect,
	....}

	Source   Edit   

proc setEndOfFile(hFile: Handle): WINBOOL {.stdcall, dynlib: "kernel32",
	importc: "SetEndOfFile", ....}

	Source   Edit   

proc setEnvironmentVariableW(lpName, lpValue: WideCString): int32 {.stdcall,
	dynlib: "kernel32", importc: "SetEnvironmentVariableW", sideEffect,
	....}

	Source   Edit   

proc setEvent(hEvent: Handle): cint {.stdcall, dynlib: "kernel32",
                                  	importc: "SetEvent", ....}

	Source   Edit   

proc setFileAttributesW(lpFileName: WideCString; dwFileAttributes: int32): WINBOOL {.
	stdcall, dynlib: "kernel32", importc: "SetFileAttributesW", sideEffect,
	....}

	Source   Edit   

proc setFilePointer(hFile: Handle; lDistanceToMove: LONG;
                	lpDistanceToMoveHigh: ptr LONG; dwMoveMethod: DWORD): DWORD {.
	stdcall, dynlib: "kernel32", importc: "SetFilePointer", ....}

	Source   Edit   

proc setFileTime(hFile: Handle; lpCreationTime: LPFILETIME;
             	lpLastAccessTime: LPFILETIME; lpLastWriteTime: LPFILETIME): WINBOOL {.
	stdcall, dynlib: "kernel32", importc: "SetFileTime", ....}

	Source   Edit   

proc setHandleInformation(hObject: Handle; dwMask: DWORD; dwFlags: DWORD): WINBOOL {.
	stdcall, dynlib: "kernel32", importc: "SetHandleInformation", ....}

	Source   Edit   

proc setLastError(error: int32) {.importc: "SetLastError", stdcall,
                              	dynlib: "kernel32", sideEffect, ....}

	Source   Edit   

proc setsockopt(s: SocketHandle; level, optname: cint; optval: pointer;
            	optlen: SockLen): cint {.stdcall, importc: "setsockopt",
	dynlib: ws2dll, ....}

	Source   Edit   

proc setStdHandle(nStdHandle: int32; hHandle: Handle): WINBOOL {.stdcall,
	dynlib: "kernel32", importc: "SetStdHandle", sideEffect, ....}

	Source   Edit   

proc shellExecuteW(hwnd: Handle;
               	lpOperation, lpFile, lpParameters, lpDirectory: WideCString;
               	nShowCmd: int32): Handle {.stdcall, dynlib: "shell32.dll",
	importc: "ShellExecuteW", sideEffect, ....}

	Source   Edit   

proc shutdown(s: SocketHandle; how: cint): cint {.stdcall, importc: "shutdown",
	dynlib: ws2dll, ....}

	Source   Edit   

proc sleep(dwMilliseconds: int32) {.stdcall, dynlib: "kernel32",
                                	importc: "Sleep", sideEffect, ....}

	Source   Edit   

proc socket(af, typ, protocol: cint): SocketHandle {.stdcall, importc: "socket",
	dynlib: ws2dll, ....}

	Source   Edit   

proc suspendThread(hThread: Handle): int32 {.stdcall, dynlib: "kernel32",
	importc: "SuspendThread", sideEffect, ....}

	Source   Edit   

proc SwitchToFiber(fiber: pointer) {.stdcall, discardable, dynlib: "kernel32",
                                 	importc, ....}

	Source   Edit   

proc terminateProcess(hProcess: Handle; uExitCode: int): WINBOOL {.stdcall,
	dynlib: "kernel32", importc: "TerminateProcess", sideEffect, ....}

	Source   Edit   

proc toFILETIME(t: int64): FILETIME {.....}

	Convert the Windows file time timestamp t to FILETIME. Source   Edit   

proc unmapViewOfFile(lpBaseAddress: pointer): WINBOOL {.stdcall,
	dynlib: "kernel32", importc: "UnmapViewOfFile", ....}

	Source   Edit   

proc unregisterWait(WaitHandle: Handle): DWORD {.stdcall, dynlib: "kernel32",
	importc: "UnregisterWait", ....}

	Source   Edit   

proc waitForMultipleObjects(nCount: DWORD; lpHandles: PWOHandleArray;
                        	bWaitAll: WINBOOL; dwMilliseconds: DWORD): DWORD {.
	stdcall, dynlib: "kernel32", importc: "WaitForMultipleObjects", ....}

	Source   Edit   

proc waitForSingleObject(hHandle: Handle; dwMilliseconds: int32): int32 {.
	stdcall, dynlib: "kernel32", importc: "WaitForSingleObject", sideEffect,
	....}

	Source   Edit   

proc writeFile(hFile: Handle; buffer: pointer; nNumberOfBytesToWrite: int32;
           	lpNumberOfBytesWritten: ptr int32; lpOverlapped: pointer): WINBOOL {.
	stdcall, dynlib: "kernel32", importc: "WriteFile", sideEffect, ....}

	Source   Edit   

proc wsaCloseEvent(hEvent: Handle): bool {.stdcall, importc: "WSACloseEvent",
	dynlib: "ws2_32.dll", ....}

	Source   Edit   

proc wsaCreateEvent(): Handle {.stdcall, importc: "WSACreateEvent",
                            	dynlib: "ws2_32.dll", ....}

	Source   Edit   

proc wsaEventSelect(s: SocketHandle; hEventObject: Handle; lNetworkEvents: clong): cint {.
	stdcall, importc: "WSAEventSelect", dynlib: "ws2_32.dll", ....}

	Source   Edit   

proc wsaGetLastError(): cint {.importc: "WSAGetLastError", dynlib: ws2dll,
                           	sideEffect, ....}

	Source   Edit   

proc WSAIoctl(s: SocketHandle; dwIoControlCode: DWORD; lpvInBuffer: pointer;
          	cbInBuffer: DWORD; lpvOutBuffer: pointer; cbOutBuffer: DWORD;
          	lpcbBytesReturned: PDWORD; lpOverlapped: POVERLAPPED;
          	lpCompletionRoutine: POVERLAPPED_COMPLETION_ROUTINE): cint {.
	stdcall, importc: "WSAIoctl", dynlib: "Ws2_32.dll", ....}

	Source   Edit   

proc WSARecv(s: SocketHandle; buf: ptr TWSABuf; bufCount: DWORD;
         	bytesReceived, flags: PDWORD; lpOverlapped: POVERLAPPED;
         	completionProc: POVERLAPPED_COMPLETION_ROUTINE): cint {.stdcall,
	importc: "WSARecv", dynlib: "Ws2_32.dll", ....}

	Source   Edit   

proc WSARecvFrom(s: SocketHandle; buf: ptr TWSABuf; bufCount: DWORD;
             	bytesReceived: PDWORD; flags: PDWORD; name: ptr SockAddr;
             	namelen: ptr cint; lpOverlapped: POVERLAPPED;
             	completionProc: POVERLAPPED_COMPLETION_ROUTINE): cint {.
	stdcall, importc: "WSARecvFrom", dynlib: "Ws2_32.dll", ....}

	Source   Edit   

proc wsaResetEvent(hEvent: Handle): bool {.stdcall, importc: "WSAResetEvent",
	dynlib: "ws2_32.dll", ....}

	Source   Edit   

proc WSASend(s: SocketHandle; buf: ptr TWSABuf; bufCount: DWORD;
         	bytesSent: PDWORD; flags: DWORD; lpOverlapped: POVERLAPPED;
         	completionProc: POVERLAPPED_COMPLETION_ROUTINE): cint {.stdcall,
	importc: "WSASend", dynlib: "Ws2_32.dll", ....}

	Source   Edit   

proc WSASendTo(s: SocketHandle; buf: ptr TWSABuf; bufCount: DWORD;
           	bytesSent: PDWORD; flags: DWORD; name: ptr SockAddr;
           	namelen: cint; lpOverlapped: POVERLAPPED;
           	completionProc: POVERLAPPED_COMPLETION_ROUTINE): cint {.stdcall,
	importc: "WSASendTo", dynlib: "Ws2_32.dll", ....}

	Source   Edit   

proc wsaStartup(wVersionRequired: int16; WSData: ptr WSAData): cint {.stdcall,
	importc: "WSAStartup", dynlib: ws2dll, ....}

	Source   Edit   

Templates

template hasOverlappedIoCompleted(lpOverlapped): bool

	Source   Edit   

template WSAIORW(x, y): untyped

	Source   Edit   


std/registry



std/registry
Source   Edit  

This module is experimental and its interface may change.
Imports

oserrors

Types

HKEY = uint

	Source   Edit   

Consts

HKEY_CURRENT_USER = 2147483649'u

	Source   Edit   

HKEY_LOCAL_MACHINE = 2147483650'u

	Source   Edit   

Procs

proc getUnicodeValue(path, key: string; handle: HKEY): string {.
	....}

	Source   Edit   

proc setUnicodeValue(path, key, val: string; handle: HKEY) {.....}

	Source   Edit   


std/posix
Source   Edit  


This is a raw POSIX interface module. It does not not provide any convenience: cstrings are used instead of proper Nim strings and return codes indicate errors. If you want exceptions and a proper Nim-like interface, use the OS module or write a wrapper.
For high-level wrappers specialized for Linux and BSDs see: posix_utils
Coding conventions: ALL types are named the same as in the POSIX standard except that they start with 'T' or 'P' (if they are pointers) and without the '_t' suffix to be consistent with Nim conventions. If an identifier is a Nim keyword the `identifier` notation is used.
This library relies on the header files of your C compiler. The resulting C code will just #include <XYZ.h> and not define the symbols declared here.

std/posix_utils

std/posix_utils
Source   Edit  

A set of helpers for the POSIX module. Raw interfaces are in the other posix*.nim files.
Imports
posix, parsecfg, os, since
Types
Uname = object
  sysname*, nodename*, release*, version*, machine*: string
Source   Edit  
Procs
proc fsync(fd: int) {.....}
synchronize a file's buffer cache to the storage device Source   Edit  
proc memoryLock(a1: pointer; a2: int) {.....}
Locks pages starting from a1 for a1 bytes and prevent them from being swapped. Source   Edit  
proc memoryLockAll(flags: int) {.....}
Locks all memory for the running process to prevent swapping.
example:

memoryLockAll(MCL_CURRENT or MCL_FUTURE)

Source   Edit  
proc memoryUnlock(a1: pointer; a2: int) {.....}
Unlock pages starting from a1 for a1 bytes and allow them to be swapped. Source   Edit  
proc memoryUnlockAll() {.....}
Unlocks all memory for the running process to allow swapping. Source   Edit  
proc mkdtemp(prefix: string): string {.....}
Creates a unique temporary directory from a prefix string. Adds a six chars suffix. The directory is created with permissions 0700. Returns the directory name. Source   Edit  
proc mkstemp(prefix: string; suffix = ""): (string, File) {.....}
Creates a unique temporary file from a prefix string. A six-character string will be added. If suffix is provided it will be added to the string The file is created with perms 0600. Returns the filename and a file opened in r/w mode. Source   Edit  
proc osReleaseFile(): Config {.....}
Gets system identification from os-release file and returns it as a parsecfg.Config. You also need to import the parsecfg module to gain access to this object. The os-release file is an official Freedesktop.org open standard. Available in Linux and BSD distributions, except Android and Android-based Linux. os-release file is not available on Windows and OS X by design.
https://www.freedesktop.org/software/systemd/man/os-release.html
Example:
import std/parsecfg
when defined(linux):
  let data = osReleaseFile()
  echo "OS name: ", data.getSectionValue("", "NAME") ## the data is up to each distro.
Source   Edit  
proc sendSignal(pid: Pid; signal: int) {.....}
Sends a signal to a running process by calling kill. Raise exception in case of failure e.g. process not running. Source   Edit  
proc stat(path: string): Stat {.....}
Returns file status in a Stat structure Source   Edit  
proc uname(): Uname {.....}
Provides system information in a Uname struct with sysname, nodename, release, version and machine attributes. Source   Edit  


Regular expressions

std/pcre

std/pcre
Source   Edit  


Types
CalloutBlock = object
  version*: cint             ## Identifies version of block
  callout_number*: cint      ## Number compiled into pattern
  offset_vector*: ptr cint   ## The offset vector
  subject*: cstring          ## The subject being matched
  subject_length*: cint      ## The length of the subject
  start_match*: cint         ## Offset to start of this match attempt
  current_position*: cint    ## Where we currently are in the subject
  capture_top*: cint         ## Max current capture
  capture_last*: cint        ## Most recently closed capture
  callout_data*: pointer     ## Data passed in with the call
  pattern_position*: cint    ## Offset to next item in the pattern
  next_item_length*: cint    ## Length of next item in the pattern
  mark*: pointer             ## Pointer to current mark or NULL
Source   Edit  
ExtraData = object
  flags*: clong              ## Bits for which fields are set
  study_data*: pointer       ## Opaque data from pcre_study()
  match_limit*: clong        ## Maximum number of calls to match()
  callout_data*: pointer     ## Data passed back in callouts
  tables*: pointer           ## Pointer to character tables
  match_limit_recursion*: clong ## Max recursive calls to match()
  mark*: pointer             ## For passing back a mark pointer
  executable_jit*: pointer   ## Contains a pointer to a compiled jit code
Source   Edit  
JitCallback = proc (a: pointer): ptr JitStack {.cdecl.}
Source   Edit  
JitStack = object
Source   Edit  
JitStack16 = object
Source   Edit  
JitStack32 = object
Source   Edit  
Pcre = object
Source   Edit  
Pcre16 = object
Source   Edit  
Pcre32 = object
Source   Edit  
PJitStack {.....} = ptr JitStack
Deprecated
Source   Edit  
PPcre {.....} = ptr Pcre
Deprecated
Source   Edit  
Consts
ANCHORED = 0x00000010
Source   Edit  
AUTO_CALLOUT = 0x00004000
Source   Edit  
BSR_ANYCRLF = 0x00800000
Source   Edit  
BSR_UNICODE = 0x01000000
Source   Edit  
CASELESS = 0x00000001
Source   Edit  
CONFIG_BSR = 8
Source   Edit  
CONFIG_JIT = 9
Source   Edit  
CONFIG_JITTARGET = 11
Source   Edit  
CONFIG_LINK_SIZE = 2
Source   Edit  
CONFIG_MATCH_LIMIT = 4
Source   Edit  
CONFIG_MATCH_LIMIT_RECURSION = 7
Source   Edit  
CONFIG_NEWLINE = 1
Source   Edit  
CONFIG_PARENS_LIMIT = 13
Source   Edit  
CONFIG_POSIX_MALLOC_THRESHOLD = 3
Source   Edit  
CONFIG_STACKRECURSE = 5
Source   Edit  
CONFIG_UNICODE_PROPERTIES = 6
Source   Edit  
CONFIG_UTF8 = 0
Source   Edit  
CONFIG_UTF16 = 10
Source   Edit  
CONFIG_UTF32 = 12
Source   Edit  
DFA_RESTART = 0x00020000
Source   Edit  
DFA_SHORTEST = 0x00010000
Source   Edit  
DOLLAR_ENDONLY = 0x00000020
Source   Edit  
DOTALL = 0x00000004
Source   Edit  
DUPNAMES = 0x00080000
Source   Edit  
ERROR_BADCOUNT = -15
Source   Edit  
ERROR_BADENDIANNESS = -29
Source   Edit  
ERROR_BADLENGTH = -32
Source   Edit  
ERROR_BADMAGIC = -4
Source   Edit  
ERROR_BADMODE = -28
Source   Edit  
ERROR_BADNEWLINE = -23
Source   Edit  
ERROR_BADOFFSET = -24
Source   Edit  
ERROR_BADOPTION = -3
Source   Edit  
ERROR_BADPARTIAL = -13
Source   Edit  
ERROR_BADUTF8 = -10
Same for 8/16/32 Source   Edit  
ERROR_BADUTF8_OFFSET = -11
Same for 8/16 Source   Edit  
ERROR_BADUTF16 = -10
Same for 8/16/32 Source   Edit  
ERROR_BADUTF16_OFFSET = -11
Same for 8/16 Source   Edit  
ERROR_BADUTF32 = -10
Same for 8/16/32 Source   Edit  
ERROR_CALLOUT = -9
Never used by PCRE itself Source   Edit  
ERROR_DFA_BADRESTART = -30
Source   Edit  
ERROR_DFA_RECURSE = -20
Source   Edit  
ERROR_DFA_UCOND = -17
Source   Edit  
ERROR_DFA_UITEM = -16
Source   Edit  
ERROR_DFA_UMLIMIT = -18
Source   Edit  
ERROR_DFA_WSSIZE = -19
Source   Edit  
ERROR_INTERNAL = -14
Source   Edit  
ERROR_JIT_BADOPTION = -31
Source   Edit  
ERROR_JIT_STACKLIMIT = -27
Source   Edit  
ERROR_MATCHLIMIT = -8
Source   Edit  
ERROR_NOMATCH = -1
Source   Edit  
ERROR_NOMEMORY = -6
Source   Edit  
ERROR_NOSUBSTRING = -7
Source   Edit  
ERROR_NULL = -2
Source   Edit  
ERROR_NULLWSLIMIT = -22
No longer actually used Source   Edit  
ERROR_PARTIAL = -12
Source   Edit  
ERROR_RECURSELOOP = -26
Source   Edit  
ERROR_RECURSIONLIMIT = -21
Source   Edit  
ERROR_SHORTUTF8 = -25
Source   Edit  
ERROR_SHORTUTF16 = -25
Same for 8/16 Source   Edit  
ERROR_UNKNOWN_NODE = -5
For backward compatibility Source   Edit  
ERROR_UNKNOWN_OPCODE = -5
Source   Edit  
ERROR_UNSET = -33
Source   Edit  
EXTENDED = 0x00000008
Source   Edit  
EXTRA = 0x00000040
Source   Edit  
EXTRA_CALLOUT_DATA = 0x00000004
Source   Edit  
EXTRA_EXECUTABLE_JIT = 0x00000040
Source   Edit  
EXTRA_MARK = 0x00000020
Source   Edit  
EXTRA_MATCH_LIMIT = 0x00000002
Source   Edit  
EXTRA_MATCH_LIMIT_RECURSION = 0x00000010
Source   Edit  
EXTRA_STUDY_DATA = 0x00000001
Source   Edit  
EXTRA_TABLES = 0x00000008
Source   Edit  
FIRSTLINE = 0x00040000
Source   Edit  
INFO_BACKREFMAX = 3
Source   Edit  
INFO_CAPTURECOUNT = 2
Source   Edit  
INFO_DEFAULT_TABLES = 11
Source   Edit  
INFO_FIRSTBYTE = 4
Source   Edit  
INFO_FIRSTCHAR = 4
For backwards compatibility Source   Edit  
INFO_FIRSTCHARACTER = 19
Source   Edit  
INFO_FIRSTCHARACTERFLAGS = 20
Source   Edit  
INFO_FIRSTTABLE = 5
Source   Edit  
INFO_HASCRORLF = 14
Source   Edit  
INFO_JCHANGED = 13
Source   Edit  
INFO_JIT = 16
Source   Edit  
INFO_JITSIZE = 17
Source   Edit  
INFO_LASTLITERAL = 6
Source   Edit  
INFO_MATCH_EMPTY = 25
Source   Edit  
INFO_MATCHLIMIT = 23
Source   Edit  
INFO_MAXLOOKBEHIND = 18
Source   Edit  
INFO_MINLENGTH = 15
Source   Edit  
INFO_NAMECOUNT = 8
Source   Edit  
INFO_NAMEENTRYSIZE = 7
Source   Edit  
INFO_NAMETABLE = 9
Source   Edit  
INFO_OKPARTIAL = 12
Source   Edit  
INFO_OPTIONS = 0
Source   Edit  
INFO_RECURSIONLIMIT = 24
Source   Edit  
INFO_REQUIREDCHAR = 21
Source   Edit  
INFO_REQUIREDCHARFLAGS = 22
Source   Edit  
INFO_SIZE = 1
Source   Edit  
INFO_STUDYSIZE = 10
Source   Edit  
JAVASCRIPT_COMPAT = 0x02000000
Source   Edit  
MULTILINE = 0x00000002
Source   Edit  
NEVER_UTF = 0x00010000
Source   Edit  
NEWLINE_ANY = 0x00400000
Source   Edit  
NEWLINE_ANYCRLF = 0x00500000
Source   Edit  
NEWLINE_CR = 0x00100000
Source   Edit  
NEWLINE_CRLF = 0x00300000
Source   Edit  
NEWLINE_LF = 0x00200000
Source   Edit  
NO_AUTO_CAPTURE = 0x00001000
Source   Edit  
NO_AUTO_POSSESS = 0x00020000
Source   Edit  
NO_START_OPTIMISE = 0x04000000
Source   Edit  
NO_START_OPTIMIZE = 0x04000000
Source   Edit  
NO_UTF8_CHECK = 0x00002000
Source   Edit  
NO_UTF16_CHECK = 0x00002000
Source   Edit  
NO_UTF32_CHECK = 0x00002000
Source   Edit  
NOTBOL = 0x00000080
Source   Edit  
NOTEMPTY = 0x00000400
Source   Edit  
NOTEMPTY_ATSTART = 0x10000000
Source   Edit  
NOTEOL = 0x00000100
Source   Edit  
PARTIAL = 0x00008000
Source   Edit  
PARTIAL_HARD = 0x08000000
Source   Edit  
PARTIAL_SOFT = 0x00008000
Source   Edit  
PCRE_DATE = "2014-09-26"
Source   Edit  
PCRE_MAJOR = 8
Source   Edit  
PCRE_MINOR = 36
Source   Edit  
PCRE_PRERELEASE = true
Source   Edit  
STUDY_EXTRA_NEEDED = 0x00000008
Source   Edit  
STUDY_JIT_COMPILE = 0x00000001
Source   Edit  
STUDY_JIT_PARTIAL_HARD_COMPILE = 0x00000004
Source   Edit  
STUDY_JIT_PARTIAL_SOFT_COMPILE = 0x00000002
Source   Edit  
UCP = 0x20000000
Source   Edit  
UNGREEDY = 0x00000200
Source   Edit  
UTF8 = 0x00000800
Source   Edit  
UTF8_ERR0 = 0
Source   Edit  
UTF8_ERR1 = 1
Source   Edit  
UTF8_ERR2 = 2
Source   Edit  
UTF8_ERR3 = 3
Source   Edit  
UTF8_ERR4 = 4
Source   Edit  
UTF8_ERR5 = 5
Source   Edit  
UTF8_ERR6 = 6
Source   Edit  
UTF8_ERR7 = 7
Source   Edit  
UTF8_ERR8 = 8
Source   Edit  
UTF8_ERR9 = 9
Source   Edit  
UTF8_ERR10 = 10
Source   Edit  
UTF8_ERR11 = 11
Source   Edit  
UTF8_ERR12 = 12
Source   Edit  
UTF8_ERR13 = 13
Source   Edit  
UTF8_ERR14 = 14
Source   Edit  
UTF8_ERR15 = 15
Source   Edit  
UTF8_ERR16 = 16
Source   Edit  
UTF8_ERR17 = 17
Source   Edit  
UTF8_ERR18 = 18
Source   Edit  
UTF8_ERR19 = 19
Source   Edit  
UTF8_ERR20 = 20
Source   Edit  
UTF8_ERR21 = 21
Source   Edit  
UTF8_ERR22 = 22
Source   Edit  
UTF16 = 0x00000800
Source   Edit  
UTF16_ERR0 = 0
Source   Edit  
UTF16_ERR1 = 1
Source   Edit  
UTF16_ERR2 = 2
Source   Edit  
UTF16_ERR3 = 3
Source   Edit  
UTF16_ERR4 = 4
Source   Edit  
UTF32 = 0x00000800
Source   Edit  
UTF32_ERR0 = 0
Source   Edit  
UTF32_ERR1 = 1
Source   Edit  
UTF32_ERR2 = 2
Source   Edit  
UTF32_ERR3 = 3
Source   Edit  
Procs
proc assign_jit_stack(extra: ptr ExtraData; callback: JitCallback; data: pointer) {.
    cdecl, importc: "pcre_$1", ....}
Source   Edit  
proc compile(pattern: cstring; options: cint; errptr: ptr cstring;
             erroffset: ptr cint; tableptr: pointer): ptr Pcre {.cdecl,
    importc: "pcre_$1", ....}
Source   Edit  
proc compile2(pattern: cstring; options: cint; errorcodeptr: ptr cint;
              errptr: ptr cstring; erroffset: ptr cint; tableptr: pointer): ptr Pcre {.
    cdecl, importc: "pcre_$1", ....}
Source   Edit  
proc config(what: cint; where: pointer): cint {.cdecl, importc: "pcre_$1",
    ....}
Source   Edit  
proc copy_named_substring(code: ptr Pcre; subject: cstring; ovector: ptr cint;
                          stringcount: cint; stringname: cstring;
                          buffer: cstring; buffersize: cint): cint {.cdecl,
    importc: "pcre_$1", ....}
Source   Edit  
proc copy_substring(subject: cstring; ovector: ptr cint; stringcount: cint;
                    stringnumber: cint; buffer: cstring; buffersize: cint): cint {.
    cdecl, importc: "pcre_$1", ....}
Source   Edit  
proc dfa_exec(code: ptr Pcre; extra: ptr ExtraData; subject: cstring;
              length: cint; startoffset: cint; options: cint; ovector: ptr cint;
              ovecsize: cint; workspace: ptr cint; wscount: cint): cint {.cdecl,
    importc: "pcre_$1", ....}
Source   Edit  
proc exec(code: ptr Pcre; extra: ptr ExtraData; subject: cstring; length: cint;
          startoffset: cint; options: cint; ovector: ptr cint; ovecsize: cint): cint {.
    cdecl, importc: "pcre_$1", ....}
Source   Edit  
proc free_study(extra: ptr ExtraData) {.cdecl, importc: "pcre_$1", ....}
Source   Edit  
proc free_substring(stringptr: cstring) {.cdecl, importc: "pcre_$1", ....}
Source   Edit  
proc free_substring_list(stringptr: cstringArray) {.cdecl, importc: "pcre_$1",
    ....}
Source   Edit  
proc fullinfo(code: ptr Pcre; extra: ptr ExtraData; what: cint; where: pointer): cint {.
    cdecl, importc: "pcre_$1", ....}
Source   Edit  
proc get_named_substring(code: ptr Pcre; subject: cstring; ovector: ptr cint;
                         stringcount: cint; stringname: cstring;
                         stringptr: cstringArray): cint {.cdecl,
    importc: "pcre_$1", ....}
Source   Edit  
proc get_stringnumber(code: ptr Pcre; name: cstring): cint {.cdecl,
    importc: "pcre_$1", ....}
Source   Edit  
proc get_stringtable_entries(code: ptr Pcre; name: cstring; first: cstringArray;
                             last: cstringArray): cint {.cdecl,
    importc: "pcre_$1", ....}
Source   Edit  
proc get_substring(subject: cstring; ovector: ptr cint; stringcount: cint;
                   stringnumber: cint; stringptr: cstringArray): cint {.cdecl,
    importc: "pcre_$1", ....}
Source   Edit  
proc get_substring_list(subject: cstring; ovector: ptr cint; stringcount: cint;
                        listptr: ptr cstringArray): cint {.cdecl,
    importc: "pcre_$1", ....}
Source   Edit  
proc jit_exec(code: ptr Pcre; extra: ptr ExtraData; subject: cstring;
              length: cint; startoffset: cint; options: cint; ovector: ptr cint;
              ovecsize: cint; jstack: ptr JitStack): cint {.cdecl,
    importc: "pcre_$1", ....}
Source   Edit  
proc jit_free_unused_memory() {.cdecl, importc: "pcre_$1", ....}
Source   Edit  
proc jit_stack_alloc(startsize: cint; maxsize: cint): ptr JitStack {.cdecl,
    importc: "pcre_$1", ....}
Source   Edit  
proc jit_stack_free(stack: ptr JitStack) {.cdecl, importc: "pcre_$1",
    ....}
Source   Edit  
proc maketables(): pointer {.cdecl, importc: "pcre_$1", ....}
Source   Edit  
proc pattern_to_host_byte_order(code: ptr Pcre; extra: ptr ExtraData;
                                tables: pointer): cint {.cdecl,
    importc: "pcre_$1", ....}
Source   Edit  
proc refcount(code: ptr Pcre; adjust: cint): cint {.cdecl, importc: "pcre_$1",
    ....}
Source   Edit  
proc study(code: ptr Pcre; options: cint; errptr: ptr cstring): ptr ExtraData {.
    cdecl, importc: "pcre_$1", ....}
Source   Edit  
proc study(code: ptr Pcre; options: cint; errptr: var cstring): ptr ExtraData {.
    ...cdecl, importc: "pcre_$1", ....}
Deprecated
Source   Edit  
proc version(): cstring {.cdecl, importc: "pcre_$1", ....}
Source   Edit  

Made with Nim. Generated: 2024-10-02 02:15:30 UTC


Network Programming and Internet Protocols

std/openssl

std/openssl
Source   Edit  


OpenSSL wrapper. Supports OpenSSL >= 1.1.0 dynamically (as default) or statically linked using --dynlibOverride:ssl.
-d:sslVersion=1.2.3 can be used to force an SSL version. This version must be included in the library name. -d:useOpenssl3 may be set for OpenSSL 3 instead.
There is also limited support for OpenSSL 1.0.x which may require -d:openssl10.
Build and test examples:

./bin/nim c -d:ssl -p:. -r tests/stdlib/tssl.nim
./bin/nim c -d:ssl --threads:on -p:. -r tests/stdlib/thttpclient_ssl.nim
./bin/nim c -d:ssl -p:. -r tests/untestable/tssl.nim
./bin/nim c -d:ssl -p:. --dynlibOverride:ssl --passl:-lcrypto --passl:-lssl -r tests/untestable/tssl.nim
./bin/nim r --putenv:NIM_TESTAMENT_REMOTE_NETWORKING:1 -d:ssl -p:testament/lib --threads:on tests/untestable/thttpclient_ssl_remotenetwork.nim


Imports
strutils, winlean, dynlib, strutils
Types
BIO = SslPtr
Source   Edit  
DES_cblock = array[0 .. 7, int8]
Source   Edit  
des_key_schedule = array[1 .. 16, des_ks_struct]
Source   Edit  
des_ks_struct {.final.} = object
  ks*: DES_cblock
  weak_key*: cint
Source   Edit  
ENGINE = SslPtr
Source   Edit  
EVP_MD = SslPtr
Source   Edit  
EVP_MD_CTX = SslPtr
Source   Edit  
EVP_PKEY = SslPtr
Source   Edit  
EVP_PKEY_CTX = SslPtr
Source   Edit  
MD5_CTX = object
Source   Edit  
MD5_LONG = cuint
Source   Edit  
PaddingType = enum
  RSA_PKCS1_PADDING = 1, RSA_SSLV23_PADDING = 2, RSA_NO_PADDING = 3,
  RSA_PKCS1_OAEP_PADDING = 4, RSA_X931_PADDING = 5, RSA_PKCS1_PSS_PADDING = 6
Source   Edit  
PASN1_cInt = SslPtr
Source   Edit  
PASN1_UTCTIME = SslPtr
Source   Edit  
PBIO_METHOD = SslPtr
Source   Edit  
PDES_cblock = ptr DES_cblock
Source   Edit  
pem_password_cb = proc (buf: cstring; size, rwflag: cint; userdata: pointer): cint {.
    cdecl.}
Source   Edit  
PFunction = proc () {.cdecl.}
Source   Edit  
PPasswdCb = SslPtr
Source   Edit  
PRSA = SslPtr
Source   Edit  
PskClientCallback = proc (ssl: SslPtr; hint: cstring; identity: cstring;
                          max_identity_len: cuint; psk: ptr uint8;
                          max_psk_len: cuint): cuint {.cdecl.}
Source   Edit  
PskServerCallback = proc (ssl: SslPtr; identity: cstring; psk: ptr uint8;
                          max_psk_len: cint): cuint {.cdecl.}
Source   Edit  
PSSL_METHOD = SslPtr
Source   Edit  
PSslPtr = ptr SslPtr
Source   Edit  
PSTACK = SslPtr
Source   Edit  
PX509 = SslPtr
Source   Edit  
PX509_NAME = SslPtr
Source   Edit  
SslCtx = SslPtr
Source   Edit  
SslPtr = ptr SslStruct
Source   Edit  
Consts
DLLSSLName = "(libssl-1_1-x64|ssleay64|libssl64).dll"
Source   Edit  
DLLUtilName = "(libcrypto-1_1-x64|libeay64).dll"
Source   Edit  
EVP_MAX_MD_SIZE = 36
Source   Edit  
EVP_PKEY_RSA = 6
Source   Edit  
MD5_CBLOCK = 64
Source   Edit  
MD5_DIGEST_LENGTH = 16
Source   Edit  
MD5_LBLOCK = 16
Source   Edit  
OPENSSL_DES_DECRYPT = 0
Source   Edit  
OPENSSL_DES_ENCRYPT = 1
Source   Edit  
SSL_CTRL_CLEAR_NUM_RENEGOTIATIONS = 11
Source   Edit  
SSL_CTRL_EXTRA_CHAIN_CERT = 14
Source   Edit  
SSL_CTRL_GET_CLIENT_CERT_REQUEST = 9
Source   Edit  
SSL_CTRL_GET_FLAGS = 13
Source   Edit  
SSL_CTRL_GET_MAX_CERT_LIST = 50
Source   Edit  
SSL_CTRL_GET_NUM_RENEGOTIATIONS = 10
Source   Edit  
SSL_CTRL_GET_READ_AHEAD = 40
Source   Edit  
SSL_CTRL_GET_SESS_CACHE_MODE = 45
Source   Edit  
SSL_CTRL_GET_SESS_CACHE_SIZE = 43
Source   Edit  
SSL_CTRL_GET_SESSION_REUSED = 8
Source   Edit  
SSL_CTRL_GET_TOTAL_RENEGOTIATIONS = 12
Source   Edit  
SSL_CTRL_MODE = 33
Source   Edit  
SSL_CTRL_NEED_TMP_RSA = 1
Source   Edit  
SSL_CTRL_OPTIONS = 32
Source   Edit  
SSL_CTRL_SESS_ACCEPT = 24
Source   Edit  
SSL_CTRL_SESS_ACCEPT_GOOD = 25
Source   Edit  
SSL_CTRL_SESS_ACCEPT_RENEGOTIATE = 26
Source   Edit  
SSL_CTRL_SESS_CACHE_FULL = 31
Source   Edit  
SSL_CTRL_SESS_CB_HIT = 28
Source   Edit  
SSL_CTRL_SESS_CONNECT = 21
Source   Edit  
SSL_CTRL_SESS_CONNECT_GOOD = 22
Source   Edit  
SSL_CTRL_SESS_CONNECT_RENEGOTIATE = 23
Source   Edit  
SSL_CTRL_SESS_HIT = 27
Source   Edit  
SSL_CTRL_SESS_MISSES = 29
Source   Edit  
SSL_CTRL_SESS_NUMBER = 20
Source   Edit  
SSL_CTRL_SESS_TIMEOUTS = 30
Source   Edit  
SSL_CTRL_SET_ECDH_AUTO = 94
Source   Edit  
SSL_CTRL_SET_MAX_CERT_LIST = 51
Source   Edit  
SSL_CTRL_SET_MSG_CALLBACK = 15
Source   Edit  
SSL_CTRL_SET_MSG_CALLBACK_ARG = 16
Source   Edit  
SSL_CTRL_SET_MTU = 17
Source   Edit  
SSL_CTRL_SET_READ_AHEAD = 41
Source   Edit  
SSL_CTRL_SET_SESS_CACHE_MODE = 44
Source   Edit  
SSL_CTRL_SET_SESS_CACHE_SIZE = 42
Source   Edit  
SSL_CTRL_SET_TMP_DH = 3
Source   Edit  
SSL_CTRL_SET_TMP_DH_CB = 6
Source   Edit  
SSL_CTRL_SET_TMP_ECDH = 4
Source   Edit  
SSL_CTRL_SET_TMP_ECDH_CB = 7
Source   Edit  
SSL_CTRL_SET_TMP_RSA = 2
Source   Edit  
SSL_CTRL_SET_TMP_RSA_CB = 5
Source   Edit  
SSL_ERROR_NONE = 0
Source   Edit  
SSL_ERROR_SSL = 1
Source   Edit  
SSL_ERROR_SYSCALL = 5
Source   Edit  
SSL_ERROR_WANT_ACCEPT = 8
Source   Edit  
SSL_ERROR_WANT_CONNECT = 7
Source   Edit  
SSL_ERROR_WANT_READ = 2
Source   Edit  
SSL_ERROR_WANT_WRITE = 3
Source   Edit  
SSL_ERROR_WANT_X509_LOOKUP = 4
Source   Edit  
SSL_ERROR_ZERO_RETURN = 6
Source   Edit  
SSL_FILETYPE_ASN1 = 2
Source   Edit  
SSL_FILETYPE_PEM = 1
Source   Edit  
SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER = 2
Source   Edit  
SSL_MODE_AUTO_RETRY = 4
Source   Edit  
SSL_MODE_ENABLE_PARTIAL_WRITE = 1
Source   Edit  
SSL_MODE_NO_AUTO_CHAIN = 8
Source   Edit  
SSL_OP_ALL = 0x000FFFFF
Source   Edit  
SSL_OP_NO_SSLv2 = 0x01000000
Source   Edit  
SSL_OP_NO_SSLv3 = 0x02000000
Source   Edit  
SSL_OP_NO_TLSv1 = 0x04000000
Source   Edit  
SSL_OP_NO_TLSv1_1 = 0x08000000
Source   Edit  
SSL_RECEIVED_SHUTDOWN = 2
Source   Edit  
SSL_SENT_SHUTDOWN = 1
Source   Edit  
SSL_ST_ACCEPT = 0x00002000
Source   Edit  
SSL_ST_CONNECT = 0x00001000
Source   Edit  
SSL_ST_INIT = 12288
Source   Edit  
SSL_TLSEXT_ERR_ALERT_FATAL = 2
Source   Edit  
SSL_TLSEXT_ERR_ALERT_WARNING = 1
Source   Edit  
SSL_TLSEXT_ERR_NOACK = 3
Source   Edit  
SSL_TLSEXT_ERR_OK = 0
Source   Edit  
SSL_VERIFY_NONE = 0x00000000
Source   Edit  
SSL_VERIFY_PEER = 0x00000001
Source   Edit  
TLSEXT_NAMETYPE_host_name = 0
Source   Edit  
useOpenssl3 {.booldefine.} = false
Source   Edit  
X509_V_ERR_AKID_ISSUER_SERIAL_MISMATCH = 31
Source   Edit  
X509_V_ERR_AKID_SKID_MISMATCH = 30
Source   Edit  
X509_V_ERR_APPLICATION_VERIFICATION = 50
Source   Edit  
X509_V_ERR_CERT_CHAIN_TOO_LONG = 22
Source   Edit  
X509_V_ERR_CERT_HAS_EXPIRED = 10
Source   Edit  
X509_V_ERR_CERT_NOT_YET_VALID = 9
Source   Edit  
X509_V_ERR_CERT_REJECTED = 28
Source   Edit  
X509_V_ERR_CERT_REVOKED = 23
Source   Edit  
X509_V_ERR_CERT_SIGNATURE_FAILURE = 7
Source   Edit  
X509_V_ERR_CERT_UNTRUSTED = 27
Source   Edit  
X509_V_ERR_CRL_HAS_EXPIRED = 12
Source   Edit  
X509_V_ERR_CRL_NOT_YET_VALID = 11
Source   Edit  
X509_V_ERR_CRL_SIGNATURE_FAILURE = 8
Source   Edit  
X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT = 18
Source   Edit  
X509_V_ERR_ERROR_IN_CERT_NOT_AFTER_FIELD = 14
Source   Edit  
X509_V_ERR_ERROR_IN_CERT_NOT_BEFORE_FIELD = 13
Source   Edit  
X509_V_ERR_ERROR_IN_CRL_LAST_UPDATE_FIELD = 15
Source   Edit  
X509_V_ERR_ERROR_IN_CRL_NEXT_UPDATE_FIELD = 16
Source   Edit  
X509_V_ERR_INVALID_CA = 24
Source   Edit  
X509_V_ERR_INVALID_PURPOSE = 26
Source   Edit  
X509_V_ERR_KEYUSAGE_NO_CERTSIGN = 32
Source   Edit  
X509_V_ERR_OUT_OF_MEM = 17
Source   Edit  
X509_V_ERR_PATH_LENGTH_EXCEEDED = 25
Source   Edit  
X509_V_ERR_SELF_SIGNED_CERT_IN_CHAIN = 19
Source   Edit  
X509_V_ERR_SUBJECT_ISSUER_MISMATCH = 29
Source   Edit  
X509_V_ERR_UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY = 6
Source   Edit  
X509_V_ERR_UNABLE_TO_DECRYPT_CERT_SIGNATURE = 4
Source   Edit  
X509_V_ERR_UNABLE_TO_DECRYPT_CRL_SIGNATURE = 5
Source   Edit  
X509_V_ERR_UNABLE_TO_GET_CRL = 3
Source   Edit  
X509_V_ERR_UNABLE_TO_GET_CRL_ISSUER = 33
Source   Edit  
X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT = 2
Source   Edit  
X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY = 20
Source   Edit  
X509_V_ERR_UNABLE_TO_VERIFY_LEAF_SIGNATURE = 21
Source   Edit  
X509_V_ERR_UNHANDLED_CRITICAL_EXTENSION = 34
Source   Edit  
X509_V_ILLEGAL = 1
Source   Edit  
X509_V_OK = 0
Source   Edit  
Procs
proc BIO_ctrl(bio: BIO; cmd: cint; larg: int; arg: cstring): int {.cdecl,
    dynlib: DLLUtilName, importc, ....}
Source   Edit  
proc BIO_do_connect(bio: BIO): int {.....}
Source   Edit  
proc BIO_do_handshake(bio: BIO): int {.....}
Source   Edit  
proc BIO_free(b: BIO): cint {.cdecl, dynlib: DLLUtilName, importc, ....}
Source   Edit  
proc BIO_get_ssl(bio: BIO; ssl: ptr SslPtr): int {.....}
Source   Edit  
proc BIO_new_mem_buf(data: pointer; len: cint): BIO {.cdecl,
    dynlib: DLLUtilName, importc, ....}
Source   Edit  
proc BIO_new_ssl_connect(ctx: SslCtx): BIO {.cdecl, dynlib: DLLSSLName, importc,
    ....}
Source   Edit  
proc BIO_read(b: BIO; data: cstring; length: cint): cint {.cdecl,
    dynlib: DLLUtilName, importc, ....}
Source   Edit  
proc BIO_set_conn_hostname(bio: BIO; name: cstring): int {.....}
Source   Edit  
proc BIO_write(b: BIO; data: cstring; length: cint): cint {.cdecl,
    dynlib: DLLUtilName, importc, ....}
Source   Edit  
proc bioCtrlPending(b: BIO): cint {.cdecl, dynlib: DLLUtilName,
                                    importc: "BIO_ctrl_pending", ....}
Source   Edit  
proc bioFreeAll(b: BIO) {.cdecl, dynlib: DLLUtilName, importc: "BIO_free_all",
                          ....}
Source   Edit  
proc bioNew(b: PBIO_METHOD): BIO {.cdecl, dynlib: DLLUtilName,
                                   importc: "BIO_new", ....}
Source   Edit  
proc bioRead(b: BIO; Buf: cstring; length: cint): cint {.cdecl,
    dynlib: DLLUtilName, importc: "BIO_read", ....}
Source   Edit  
proc bioSMem(): PBIO_METHOD {.cdecl, dynlib: DLLUtilName, importc: "BIO_s_mem",
                              ....}
Source   Edit  
proc bioWrite(b: BIO; Buf: cstring; length: cint): cint {.cdecl,
    dynlib: DLLUtilName, importc: "BIO_write", ....}
Source   Edit  
proc CRYPTO_malloc_init() {.....}
Source   Edit  
proc d2i_X509(b: string): PX509 {.....}
decode DER/BER bytestring into X.509 certificate struct Source   Edit  
proc d2i_X509(px: ptr PX509; i: ptr ptr uint8; len: cint): PX509 {.cdecl,
    dynlib: DLLUtilName, importc, ....}
Source   Edit  
proc ERR_error_string(e: culong; buf: cstring): cstring {.cdecl,
    dynlib: DLLUtilName, importc, ....}
Source   Edit  
proc ERR_get_error(): culong {.cdecl, dynlib: DLLUtilName, importc, ....}
Source   Edit  
proc ERR_load_BIO_strings() {.....}
Source   Edit  
proc ERR_peek_last_error(): culong {.cdecl, dynlib: DLLUtilName, importc,
                                     ....}
Source   Edit  
proc ERR_print_errors_fp(fp: File) {.cdecl, dynlib: DLLUtilName, importc,
                                     ....}
Source   Edit  
proc ErrClearError() {.cdecl, dynlib: DLLUtilName, importc: "ERR_clear_error",
                       ....}
Source   Edit  
proc ErrFreeStrings() {.cdecl, dynlib: DLLUtilName, importc: "ERR_free_strings",
                        ....}
Source   Edit  
proc ErrRemoveState(pid: cint) {.cdecl, dynlib: DLLUtilName,
                                 importc: "ERR_remove_state", ....}
Source   Edit  
proc EVP_DigestFinal_ex(ctx: EVP_MD_CTX; buffer: pointer; size: ptr cuint): cint {.
    cdecl, dynlib: DLLUtilName, importc, ....}
Source   Edit  
proc EVP_DigestInit_ex(ctx: EVP_MD_CTX; typ: EVP_MD; engine: SslPtr = nil): cint {.
    cdecl, dynlib: DLLUtilName, importc, ....}
Source   Edit  
proc EVP_DigestSignFinal(ctx: EVP_MD_CTX; data: pointer; len: ptr csize_t): cint {.
    cdecl, dynlib: DLLUtilName, importc, ....}
Source   Edit  
proc EVP_DigestSignInit(ctx: EVP_MD_CTX; pctx: ptr EVP_PKEY_CTX; typ: EVP_MD;
                        e: ENGINE; pkey: EVP_PKEY): cint {.cdecl,
    dynlib: DLLUtilName, importc, ....}
Source   Edit  
proc EVP_DigestUpdate(ctx: EVP_MD_CTX; data: pointer; len: cuint): cint {.cdecl,
    dynlib: DLLUtilName, importc, ....}
Source   Edit  
proc EVP_dss(): EVP_MD {.cdecl, dynlib: DLLUtilName, importc, ....}
Source   Edit  
proc EVP_dss1(): EVP_MD {.cdecl, dynlib: DLLUtilName, importc, ....}
Source   Edit  
proc EVP_ecdsa(): EVP_MD {.cdecl, dynlib: DLLUtilName, importc, ....}
Source   Edit  
proc EVP_md2(): EVP_MD {.cdecl, dynlib: DLLUtilName, importc, ....}
Source   Edit  
proc EVP_md4(): EVP_MD {.cdecl, dynlib: DLLUtilName, importc, ....}
Source   Edit  
proc EVP_md5(): EVP_MD {.cdecl, dynlib: DLLUtilName, importc, ....}
Source   Edit  
proc EVP_MD_CTX_cleanup(ctx: EVP_MD_CTX): cint {.cdecl, dynlib: DLLUtilName,
    importc, ....}
Source   Edit  
proc EVP_MD_CTX_create(): EVP_MD_CTX {.cdecl, dynlib: DLLUtilName, importc,
                                       ....}
Source   Edit  
proc EVP_MD_CTX_destroy(ctx: EVP_MD_CTX) {.cdecl, dynlib: DLLUtilName, importc,
    ....}
Source   Edit  
proc EVP_md_null(): EVP_MD {.cdecl, dynlib: DLLUtilName, importc, ....}
Source   Edit  
proc EVP_MD_size(md: EVP_MD): cint {.cdecl, dynlib: DLLUtilName, importc,
                                     ....}
Source   Edit  
proc EVP_mdc2(): EVP_MD {.cdecl, dynlib: DLLUtilName, importc, ....}
Source   Edit  
proc EVP_PKEY_CTX_free(pkeyCtx: EVP_PKEY_CTX) {.cdecl, dynlib: DLLUtilName,
    importc, ....}
Source   Edit  
proc EVP_PKEY_CTX_new(pkey: EVP_PKEY; e: ENGINE): EVP_PKEY_CTX {.cdecl,
    dynlib: DLLUtilName, importc, ....}
Source   Edit  
proc EVP_PKEY_free(p: EVP_PKEY) {.cdecl, dynlib: DLLUtilName, importc,
                                  ....}
Source   Edit  
proc EVP_PKEY_sign_init(c: EVP_PKEY_CTX): cint {.cdecl, dynlib: DLLUtilName,
    importc, ....}
Source   Edit  
proc EVP_ripemd160(): EVP_MD {.cdecl, dynlib: DLLUtilName, importc, ....}
Source   Edit  
proc EVP_sha(): EVP_MD {.cdecl, dynlib: DLLUtilName, importc, ....}
Source   Edit  
proc EVP_sha1(): EVP_MD {.cdecl, dynlib: DLLUtilName, importc, ....}
Source   Edit  
proc EVP_sha224(): EVP_MD {.cdecl, dynlib: DLLUtilName, importc, ....}
Source   Edit  
proc EVP_sha256(): EVP_MD {.cdecl, dynlib: DLLUtilName, importc, ....}
Source   Edit  
proc EVP_sha384(): EVP_MD {.cdecl, dynlib: DLLUtilName, importc, ....}
Source   Edit  
proc EVP_sha512(): EVP_MD {.cdecl, dynlib: DLLUtilName, importc, ....}
Source   Edit  
proc EVP_whirlpool(): EVP_MD {.cdecl, dynlib: DLLUtilName, importc, ....}
Source   Edit  
proc getOpenSSLVersion(): culong {.....}
Return OpenSSL version as unsigned long or 0 if not available Source   Edit  
proc HMAC(evp_md: EVP_MD; key: pointer; key_len: cint; d: cstring; n: csize_t;
          md: cstring; md_len: ptr cuint): cstring {.cdecl, dynlib: DLLUtilName,
    importc, ....}
Source   Edit  
proc i2d_X509(cert: PX509): string {.....}
encode cert to DER string Source   Edit  
proc i2d_X509(cert: PX509; o: ptr ptr uint8): cint {.cdecl, dynlib: DLLUtilName,
    importc, ....}
Source   Edit  
proc md5(d: ptr uint8; n: csize_t; md: ptr uint8): ptr uint8 {.importc: "MD5",
    ....}
Source   Edit  
proc md5_File(file: string): string {.....}
Generate MD5 hash for a file. Result is a 32 character Source   Edit  
proc md5_Final(md: cstring; c: var MD5_CTX): cint {.importc: "MD5_Final",
    ....}
Source   Edit  
proc md5_Init(c: var MD5_CTX): cint {.importc: "MD5_Init", ....}
Source   Edit  
proc md5_Str(str: string): string {.....}
Generate MD5 hash for a string. Result is a 32 character hex string with lowercase characters Source   Edit  
proc md5_Transform(c: var MD5_CTX; b: ptr uint8) {.importc: "MD5_Transform",
    ....}
Source   Edit  
proc md5_Update(c: var MD5_CTX; data: pointer; len: csize_t): cint {.
    importc: "MD5_Update", ....}
Source   Edit  
proc OpenSSL_add_all_algorithms() {.....}
Source   Edit  
proc OPENSSL_config(configName: cstring) {.cdecl, dynlib: DLLUtilName, importc,
    ....}
Source   Edit  
proc OPENSSL_sk_num(stack: PSTACK): int {.cdecl, dynlib: DLLSSLName, importc,
    ....}
Source   Edit  
proc OPENSSL_sk_value(stack: PSTACK; index: int): pointer {.cdecl,
    dynlib: DLLSSLName, importc, ....}
Source   Edit  
proc PEM_read_bio_PrivateKey(bp: BIO; x: ptr EVP_PKEY; cb: pointer; u: pointer): EVP_PKEY {.
    cdecl, dynlib: DLLUtilName, importc, ....}
Source   Edit  
proc PEM_read_bio_RSA_PUBKEY(bp: BIO; x: ptr PRSA; pw: pem_password_cb;
                             u: pointer): PRSA {.cdecl, dynlib: DLLUtilName,
    importc, ....}
Source   Edit  
proc PEM_read_bio_RSAPrivateKey(bp: BIO; x: ptr PRSA; cb: pem_password_cb;
                                u: pointer): PRSA {.cdecl, dynlib: DLLUtilName,
    importc, ....}
Source   Edit  
proc PEM_read_bio_RSAPublicKey(bp: BIO; x: ptr PRSA; cb: pem_password_cb;
                               u: pointer): PRSA {.cdecl, dynlib: DLLUtilName,
    importc, ....}
Source   Edit  
proc PEM_read_RSA_PUBKEY(fp: pointer; x: ptr PRSA; cb: pem_password_cb;
                         u: pointer): PRSA {.cdecl, dynlib: DLLUtilName,
    importc, ....}
Source   Edit  
proc PEM_read_RSAPrivateKey(fp: pointer; x: ptr PRSA; cb: pem_password_cb;
                            u: pointer): PRSA {.cdecl, dynlib: DLLUtilName,
    importc, ....}
Source   Edit  
proc PEM_read_RSAPublicKey(fp: pointer; x: ptr PRSA; cb: pem_password_cb;
                           u: pointer): PRSA {.cdecl, dynlib: DLLUtilName,
    importc, ....}
Source   Edit  
proc RSA_free(rsa: PRSA) {.cdecl, dynlib: DLLUtilName, importc, ....}
Source   Edit  
proc RSA_private_decrypt(flen: cint; fr: ptr uint8; to: ptr uint8; rsa: PRSA;
                         padding: PaddingType): cint {.cdecl,
    dynlib: DLLUtilName, importc, ....}
Source   Edit  
proc RSA_private_encrypt(flen: cint; fr: ptr uint8; to: ptr uint8; rsa: PRSA;
                         padding: PaddingType): cint {.cdecl,
    dynlib: DLLUtilName, importc, ....}
Source   Edit  
proc RSA_public_decrypt(flen: cint; fr: ptr uint8; to: ptr uint8; rsa: PRSA;
                        padding: PaddingType): cint {.cdecl,
    dynlib: DLLUtilName, importc, ....}
Source   Edit  
proc RSA_public_encrypt(flen: cint; fr: ptr uint8; to: ptr uint8; rsa: PRSA;
                        padding: PaddingType): cint {.cdecl,
    dynlib: DLLUtilName, importc, ....}
Source   Edit  
proc RSA_size(rsa: PRSA): cint {.cdecl, dynlib: DLLUtilName, importc,
                                 ....}
Source   Edit  
proc RSA_verify(kind: cint; origMsg: pointer; origMsgLen: cuint;
                signature: pointer; signatureLen: cuint; rsa: PRSA): cint {.
    cdecl, dynlib: DLLUtilName, importc, ....}
Source   Edit  
proc SSL_accept(ssl: SslPtr): cint {.cdecl, dynlib: DLLSSLName, importc,
                                     ....}
Source   Edit  
proc SSL_connect(ssl: SslPtr): cint {.cdecl, dynlib: DLLSSLName, importc,
                                      ....}
Source   Edit  
proc SSL_ctrl(ssl: SslPtr; cmd: cint; larg: int; parg: pointer): int {.cdecl,
    dynlib: DLLSSLName, importc, ....}
Source   Edit  
proc SSL_CTX_check_private_key(ctx: SslCtx): cint {.cdecl, dynlib: DLLSSLName,
    importc, ....}
Source   Edit  
proc SSL_CTX_ctrl(ctx: SslCtx; cmd: cint; larg: clong; parg: pointer): clong {.
    cdecl, dynlib: DLLSSLName, importc, ....}
Source   Edit  
proc SSL_CTX_free(arg0: SslCtx) {.cdecl, dynlib: DLLSSLName, importc,
                                  ....}
Source   Edit  
proc SSL_CTX_get_ex_data(ssl: SslCtx; idx: cint): pointer {.cdecl,
    dynlib: DLLSSLName, importc, ....}
Source   Edit  
proc SSL_CTX_get_ex_new_index(argl: clong; argp: pointer; new_func: pointer;
                              dup_func: pointer; free_func: pointer): cint {.
    cdecl, dynlib: DLLSSLName, importc, ....}
Source   Edit  
proc SSL_CTX_load_verify_locations(ctx: SslCtx; CAfile: cstring; CApath: cstring): cint {.
    cdecl, dynlib: DLLSSLName, importc, ....}
Source   Edit  
proc SSL_CTX_new(meth: PSSL_METHOD): SslCtx {.cdecl, dynlib: DLLSSLName,
    importc, ....}
Source   Edit  
proc SSL_CTX_set_alpn_protos(ctx: SslCtx; protos: cstring; protos_len: cuint): cint {.
    cdecl, dynlib: DLLSSLName, importc, ....}
Source   Edit  
proc SSL_CTX_set_alpn_select_cb(ctx: SslCtx; cb: proc (ssl: SslPtr;
    out_proto: ptr cstring; outlen: cstring; in_proto: cstring; inlen: cuint;
    arg: pointer): cint {.cdecl.}; arg: pointer): cint {.cdecl,
    dynlib: DLLSSLName, importc, ....}
Source   Edit  
proc SSL_CTX_set_cipher_list(s: SslCtx; ciphers: cstring): cint {.cdecl,
    dynlib: DLLSSLName, importc, ....}
Source   Edit  
proc SSL_CTX_set_ciphersuites(ctx: SslCtx; str: cstring): cint {.
    ....}
Source   Edit  
proc SSL_CTX_set_ecdh_auto(ctx: SslCtx; onoff: cint): cint {.inline,
    ....}
Set automatic curve selection.
On OpenSSL >= 1.1.0 this is on by default and cannot be disabled.
Source   Edit  
proc SSL_CTX_set_ex_data(ssl: SslCtx; idx: cint; arg: pointer): cint {.cdecl,
    dynlib: DLLSSLName, importc, ....}
Source   Edit  
proc SSL_CTX_set_next_proto_select_cb(ctx: SslCtx; cb: proc (s: SslPtr;
    out_proto: cstring; outlen: cstring; in_proto: cstring; inlen: cuint;
    arg: pointer): cint {.cdecl.}; arg: pointer) {.cdecl, dynlib: DLLSSLName,
    importc, ....}
Source   Edit  
proc SSL_CTX_set_next_protos_advertised_cb(ctx: SslCtx; cb: proc (ssl: SslPtr;
    out_proto: ptr cstring; outlen: ptr cuint; arg: pointer): cint {.cdecl.};
    arg: pointer) {.cdecl, dynlib: DLLSSLName, importc, ....}
Source   Edit  
proc SSL_CTX_set_psk_client_callback(ctx: SslCtx; callback: PskClientCallback) {.
    cdecl, dynlib: DLLSSLName, importc, ....}
Set callback called when OpenSSL needs PSK (for client). Source   Edit  
proc SSL_CTX_set_psk_server_callback(ctx: SslCtx; callback: PskServerCallback) {.
    cdecl, dynlib: DLLSSLName, importc, ....}
Set callback called when OpenSSL needs PSK (for server). Source   Edit  
proc SSL_CTX_set_session_id_context(context: SslCtx; sid_ctx: string;
                                    sid_ctx_len: int) {.cdecl,
    dynlib: DLLSSLName, importc, ....}
Source   Edit  
proc SSL_CTX_set_tlsext_servername_arg(ctx: SslCtx; arg: pointer): int {.
    ....}
Set the pointer to be used in the callback registered to SSL_CTX_set_tlsext_servername_callback. Source   Edit  
proc SSL_CTX_set_tlsext_servername_callback(ctx: SslCtx;
    cb: proc (ssl: SslPtr; cb_id: int; arg: pointer): int {.cdecl.}): int {.
    ....}
Set the callback to be used on listening SSL connections when the client hello is received.
The callback should return one of:
SSL_TLSEXT_ERR_OK
SSL_TLSEXT_ERR_ALERT_WARNING
SSL_TLSEXT_ERR_ALERT_FATAL
SSL_TLSEXT_ERR_NOACK
Source   Edit  
proc SSL_CTX_set_verify(s: SslCtx; mode: int;
                        cb: proc (a: int; b: pointer): int {.cdecl.}) {.cdecl,
    dynlib: DLLSSLName, importc, ....}
Source   Edit  
proc SSL_CTX_use_certificate_chain_file(ctx: SslCtx; filename: cstring): cint {.
    stdcall, dynlib: DLLSSLName, importc, ....}
Source   Edit  
proc SSL_CTX_use_certificate_file(ctx: SslCtx; filename: cstring; typ: cint): cint {.
    stdcall, dynlib: DLLSSLName, importc, ....}
Source   Edit  
proc SSL_CTX_use_PrivateKey_file(ctx: SslCtx; filename: cstring; typ: cint): cint {.
    cdecl, dynlib: DLLSSLName, importc, ....}
Source   Edit  
proc SSL_CTX_use_psk_identity_hint(ctx: SslCtx; hint: cstring): cint {.cdecl,
    dynlib: DLLSSLName, importc, ....}
Set PSK identity hint to use. Source   Edit  
proc SSL_free(ssl: SslPtr) {.cdecl, dynlib: DLLSSLName, importc, ....}
Source   Edit  
proc SSL_get0_alpn_selected(ssl: SslPtr; data: ptr cstring; len: ptr cuint) {.
    cdecl, dynlib: DLLSSLName, importc, ....}
Source   Edit  
proc SSL_get0_next_proto_negotiated(s: SslPtr; data: ptr cstring; len: ptr cuint) {.
    cdecl, dynlib: DLLSSLName, importc, ....}
Source   Edit  
proc SSL_get0_verified_chain(ssl: SslPtr): PSTACK {.cdecl, dynlib: DLLSSLName,
    importc, ....}
Source   Edit  
proc SSL_get_error(s: SslPtr; ret_code: cint): cint {.cdecl, dynlib: DLLSSLName,
    importc, ....}
Source   Edit  
proc SSL_get_psk_identity(ssl: SslPtr): cstring {.cdecl, dynlib: DLLSSLName,
    importc, ....}
Get PSK identity. Source   Edit  
proc SSL_get_servername(ssl: SslPtr; typ: cint = TLSEXT_NAMETYPE_host_name): cstring {.
    cdecl, dynlib: DLLSSLName, importc, ....}
Retrieve the server name requested in the client hello. This can be used in the callback set in SSL_CTX_set_tlsext_servername_callback to implement virtual hosting. May return nil. Source   Edit  
proc SSL_get_shutdown(ssl: SslPtr): cint {.cdecl, dynlib: DLLSSLName,
    importc: "SSL_get_shutdown", ....}
Source   Edit  
proc SSL_get_SSL_CTX(ssl: SslPtr): SslCtx {.cdecl, dynlib: DLLSSLName, importc,
    ....}
Source   Edit  
proc SSL_get_verify_result(ssl: SslPtr): int {.cdecl, dynlib: DLLSSLName,
    importc, ....}
Source   Edit  
proc SSL_in_init(ssl: SslPtr): cint {.....}
Source   Edit  
proc SSL_library_init(): cint {.discardable, ....}
Initialize SSL using OPENSSL_init_ssl for OpenSSL >= 1.1.0 otherwise SSL_library_init Source   Edit  
proc SSL_load_error_strings() {.....}
Source   Edit  
proc SSL_new(context: SslCtx): SslPtr {.cdecl, dynlib: DLLSSLName, importc,
                                        ....}
Source   Edit  
proc SSL_pending(ssl: SslPtr): cint {.cdecl, dynlib: DLLSSLName, importc,
                                      ....}
Source   Edit  
proc SSL_read(ssl: SslPtr; buf: pointer; num: int): cint {.cdecl,
    dynlib: DLLSSLName, importc, ....}
Source   Edit  
proc SSL_select_next_proto(out_proto: ptr cstring; outlen: cstring;
                           server: cstring; server_len: cuint; client: cstring;
                           client_len: cuint): cint {.cdecl, dynlib: DLLSSLName,
    importc, ....}
Source   Edit  
proc SSL_set_alpn_protos(ssl: SslPtr; protos: cstring; protos_len: cuint): cint {.
    cdecl, dynlib: DLLSSLName, importc, ....}
Source   Edit  
proc SSL_set_fd(ssl: SslPtr; fd: SocketHandle): cint {.cdecl,
    dynlib: DLLSSLName, importc, ....}
Source   Edit  
proc SSL_set_shutdown(ssl: SslPtr; mode: cint) {.cdecl, dynlib: DLLSSLName,
    importc: "SSL_set_shutdown", ....}
Source   Edit  
proc SSL_set_SSL_CTX(ssl: SslPtr; ctx: SslCtx): SslCtx {.cdecl,
    dynlib: DLLSSLName, importc, ....}
Source   Edit  
proc SSL_set_tlsext_host_name(ssl: SslPtr; name: cstring): int {.....}
Set the SNI server name extension to be used in a client hello. Returns 1 if SNI was set, 0 if current SSL configuration doesn't support SNI. Source   Edit  
proc SSL_shutdown(ssl: SslPtr): cint {.cdecl, dynlib: DLLSSLName, importc,
                                       ....}
Source   Edit  
proc SSL_write(ssl: SslPtr; buf: cstring; num: int): cint {.cdecl,
    dynlib: DLLSSLName, importc, ....}
Source   Edit  
proc SSLCTXSetMode(ctx: SslCtx; mode: int): int {.....}
Source   Edit  
proc sslDoHandshake(ssl: SslPtr): cint {.cdecl, dynlib: DLLSSLName,
    importc: "SSL_do_handshake", ....}
Source   Edit  
proc sslPeek(ssl: SslPtr; buf: cstring; num: cint): cint {.cdecl,
    dynlib: DLLSSLName, importc: "SSL_peek", ....}
Source   Edit  
proc sslRead(ssl: SslPtr; buf: cstring; num: cint): cint {.cdecl,
    dynlib: DLLSSLName, importc: "SSL_read", ....}
Source   Edit  
proc sslSetAcceptState(s: SslPtr) {.cdecl, dynlib: DLLSSLName,
                                    importc: "SSL_set_accept_state", ....}
Source   Edit  
proc sslSetBio(ssl: SslPtr; rbio, wbio: BIO) {.cdecl, dynlib: DLLSSLName,
    importc: "SSL_set_bio", ....}
Source   Edit  
proc sslSetConnectState(s: SslPtr) {.cdecl, dynlib: DLLSSLName,
                                     importc: "SSL_set_connect_state",
                                     ....}
Source   Edit  
proc SSLv2_method(): PSSL_METHOD {.....}
Source   Edit  
proc SSLv3_method(): PSSL_METHOD {.....}
Source   Edit  
proc SSLv23_client_method(): PSSL_METHOD {.....}
Source   Edit  
proc SSLv23_method(): PSSL_METHOD {.....}
Source   Edit  
proc sslWrite(ssl: SslPtr; buf: cstring; num: cint): cint {.cdecl,
    dynlib: DLLSSLName, importc: "SSL_write", ....}
Source   Edit  
proc TLS_client_method(): PSSL_METHOD {.....}
Source   Edit  
proc TLS_method(): PSSL_METHOD {.....}
Source   Edit  
proc TLS_server_method(): PSSL_METHOD {.....}
Source   Edit  
proc TLSv1_method(): PSSL_METHOD {.cdecl, dynlib: DLLSSLName, importc,
                                   ....}
















































































































